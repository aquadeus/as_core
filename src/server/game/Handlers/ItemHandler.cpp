////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include "Common.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "Opcodes.h"
#include "Log.h"
#include "ObjectMgr.h"
#include "Player.h"
#include "Item.h"
#include "UpdateData.h"
#include "ObjectAccessor.h"
#include "SpellInfo.h"
#include "GuildMgr.h"
#include "Spell.h"
#include "ScriptMgr.h"
#include "CollectionMgr.hpp"
#include "ItemPackets.h"
#include "../Garrison/BrokenIsles/GarrisonBrokenIslesConstants.hpp"
#include "HelperDefines.h"

void WorldSession::SendItemPageInfo(ItemTemplate * itemProto)
{
}

void WorldSession::HandleSplitItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    uint8 l_SrcBag, l_SrcSlot, l_DestBag, l_DestSlot;
    uint32 l_Count;

    p_RecvData >> l_SrcBag >> l_SrcSlot >> l_DestBag >> l_DestSlot >> l_Count;

    uint16 l_Src = ((l_SrcBag << 8) | l_SrcSlot);
    uint16 l_Dest = ((l_DestBag << 8) | l_DestSlot);

    if (l_Src == l_Dest)
        return;

    // Check count - if zero it's fake packet
    if (l_Count == 0)
        return;

    if (!m_Player->IsValidPos(l_SrcBag, l_SrcSlot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    // Can be auto store pos
    if (!m_Player->IsValidPos(l_DestBag, l_DestSlot, false))
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    for (uint32 l_I = CURRENT_MELEE_SPELL; l_I < CURRENT_AUTOREPEAT_SPELL; ++l_I)
    {
        if (Spell* l_Spell = m_Player->GetCurrentSpell(l_I))
        {
            if (l_Spell->m_castItemGUID)
            {
                m_Player->SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, NULL, NULL);
                return;
            }
        }
    }

    m_Player->SplitItem(l_Src, l_Dest, l_Count);
}

void WorldSession::HandleSwapInvItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_Slot1;
    uint8 l_Slot2;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_Slot2 >> l_Slot1;

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (l_Slot1 == l_Slot2)
        return;

    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot1, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot2, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    for (uint32 l_I = CURRENT_MELEE_SPELL; l_I < CURRENT_AUTOREPEAT_SPELL; ++l_I)
    {
        if (Spell* l_Spell = m_Player->GetCurrentSpell(l_I))
        {
            if (l_Spell->m_castItemGUID)
            {
                m_Player->SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, NULL, NULL);
                return;
            }
        }
    }

    /// Fury artifact should always be main-hand, otherwise the whole system goes apeshit, because weapons are same type, not main - off hand
    Item* l_Item1 = m_Player->GetItemByPos(INVENTORY_SLOT_BAG_0, l_Slot1);
    Item* l_Item2 = m_Player->GetItemByPos(INVENTORY_SLOT_BAG_0, l_Slot2);

    if (l_Item1 && l_Item1->GetEntry() == 128908)
    {
        if (l_Slot2 == EQUIPMENT_SLOT_OFFHAND)
        {
            l_Slot2 = EQUIPMENT_SLOT_MAINHAND;
        }
    }
    if (l_Item2 && l_Item2->GetEntry() == 128908)
    {
        if (l_Slot1 == EQUIPMENT_SLOT_OFFHAND)
        {
            l_Slot1 = EQUIPMENT_SLOT_MAINHAND;
        }
    }

    if (l_Slot1 == l_Slot2)
        return;

    uint16 l_Src    = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot1);
    uint16 l_Dest   = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot2);

    m_Player->SwapItem(l_Src, l_Dest);
}

void WorldSession::HandleSwapItem(WorldPacket& p_RecvData)
{
    uint8 l_DestBag, l_DestSlot, l_SourceBag, l_SourceSlot, l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    std::vector<uint8> l_InventoryBags(l_ItemCount, 0);
    std::vector<uint8> l_InventorySlots(l_ItemCount, 0);
    for (uint8 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData >> l_InventoryBags[l_I];
        p_RecvData >> l_InventorySlots[l_I];
    }

    p_RecvData >> l_DestBag >> l_SourceBag >> l_DestSlot >> l_SourceSlot;

    uint16 l_Source = ((l_SourceBag << 8) | l_SourceSlot);
    uint16 l_Dest = ((l_DestBag << 8) | l_DestSlot);

    /// Fury artifact should always be main-hand, otherwise the whole system goes apeshit, because weapons are same type, not main - off hand
    Item* l_Item1 = m_Player->GetItemByPos(l_SourceBag, l_SourceSlot);
    Item* l_Item2 = m_Player->GetItemByPos(l_DestBag, l_DestSlot);

    if (l_Item1 && l_Item1->GetEntry() == 128908)
    {
        if (l_DestBag == INVENTORY_SLOT_BAG_0 || l_DestSlot == EQUIPMENT_SLOT_OFFHAND)
        {
            l_DestSlot = EQUIPMENT_SLOT_MAINHAND;
            l_Dest = ((l_DestBag << 8) | l_DestSlot);
        }
    }
    if (l_Item2 && l_Item2->GetEntry() == 128908)
    {
        if (l_SourceBag == INVENTORY_SLOT_BAG_0 || l_SourceSlot == EQUIPMENT_SLOT_OFFHAND)
        {
            l_SourceSlot = EQUIPMENT_SLOT_MAINHAND;
            l_Source = ((l_SourceBag << 8) | l_SourceSlot);
        }
    }

    // prevent attempt swap same item to current position generated by client at special checking sequence
    if (l_Source == l_Dest)
        return;

    if (!m_Player->IsValidPos(l_SourceBag, l_SourceSlot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!m_Player->IsValidPos(l_DestBag, l_DestSlot, true))
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    for (uint32 l_I = CURRENT_MELEE_SPELL; l_I < CURRENT_AUTOREPEAT_SPELL; ++l_I)
    {
        if (Spell* l_Spell = m_Player->GetCurrentSpell(l_I))
        {
            if (l_Spell->m_castItemGUID)
            {
                m_Player->SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, NULL, NULL);
                return;
            }
        }
    }

    m_Player->SwapItem(l_Source, l_Dest);
}

void WorldSession::HandleAutoEquipItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_PackSlot;
    p_RecvData >> l_Slot;

    Item* l_SrcItem  = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_SrcItem)
        return;                                             // only at cheat

    uint16 l_Dest;

    InventoryResult l_Msg = m_Player->CanEquipItem(NULL_SLOT, l_Dest, l_SrcItem, !l_SrcItem->IsBag());

    if (l_Msg != EQUIP_ERR_OK)
    {
        m_Player->SendEquipError(l_Msg, l_SrcItem, NULL);
        return;
    }

    uint16 l_Src = l_SrcItem->GetPos();

    // prevent equip in same slot, only at cheat
    if (l_Dest == l_Src)
        return;

    Item* l_DestItem = m_Player->GetItemByPos(l_Dest);

    // empty slot, simple case
    if (!l_DestItem)
    {
        if (l_SrcItem->GetChildItem())
        {
            InventoryResult l_ChildEquipResult = GetPlayer()->CanEquipChildItem(l_SrcItem);
            if (l_ChildEquipResult != EQUIP_ERR_OK)
            {
                GetPlayer()->SendEquipError(l_ChildEquipResult, l_SrcItem);
                return;
            }
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->EquipItem(l_Dest, l_SrcItem, true);

        if (l_SrcItem->GetChildItem())
            GetPlayer()->EquipChildItem(l_PackSlot, l_Slot, l_SrcItem);

        m_Player->AutoUnequipOffhandIfNeed();
    }
    // have currently equipped item, not simple case
    else
    {
        uint8 l_DestBag = l_DestItem->GetBagSlot();
        uint8 l_DestSlot = l_DestItem->GetSlot();

        l_Msg = m_Player->CanUnequipItem(l_Dest, !l_SrcItem->IsBag());

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_DestItem, NULL);
            return;
        }

        if (!l_DestItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
        {
            // check dest->src move possibility
            ItemPosCountVec l_SSrc;
            uint16 l_ESrc = 0;

            if (GetPlayer()->IsInventoryPos(l_Src))
            {
                l_Msg = GetPlayer()->CanStoreItem(l_PackSlot, l_Slot, l_SSrc, l_DestItem, true);
                if (l_Msg != EQUIP_ERR_OK)
                    l_Msg = GetPlayer()->CanStoreItem(l_PackSlot, NULL_SLOT, l_SSrc, l_DestItem, true);
                if (l_Msg != EQUIP_ERR_OK)
                    l_Msg = GetPlayer()->CanStoreItem(NULL_BAG, NULL_SLOT, l_SSrc, l_DestItem, true);
            }
            else if (GetPlayer()->IsBankPos(l_Src))
            {
                l_Msg = GetPlayer()->CanBankItem(l_PackSlot, l_Slot, l_SSrc, l_DestItem, true);
                if (l_Msg != EQUIP_ERR_OK)
                    l_Msg = GetPlayer()->CanBankItem(l_PackSlot, NULL_SLOT, l_SSrc, l_DestItem, true);
                if (l_Msg != EQUIP_ERR_OK)
                    l_Msg = GetPlayer()->CanBankItem(NULL_BAG, NULL_SLOT, l_SSrc, l_DestItem, true);
            }
            else if (GetPlayer()->IsEquipmentPos(l_Src))
            {
                l_Msg = GetPlayer()->CanEquipItem(l_Slot, l_ESrc, l_DestItem, true);
                if (l_Msg == EQUIP_ERR_OK)
                    l_Msg = GetPlayer()->CanUnequipItem(l_ESrc, true);
            }

            if (l_Msg == EQUIP_ERR_OK && Player::IsEquipmentPos(l_Dest) && l_SrcItem->GetChildItem())
                l_Msg = GetPlayer()->CanEquipChildItem(l_SrcItem);

            if (l_Msg != EQUIP_ERR_OK)
            {
                GetPlayer()->SendEquipError(l_Msg, l_DestItem, l_SrcItem);
                return;
            }

            // now do moves, remove...
            GetPlayer()->RemoveItem(l_DestBag, l_DestSlot, false);
            GetPlayer()->RemoveItem(l_PackSlot, l_Slot, false);

            // add to dest
            GetPlayer()->EquipItem(l_Dest, l_SrcItem, true);

            // add to src
            if (GetPlayer()->IsInventoryPos(l_Src))
                GetPlayer()->StoreItem(l_SSrc, l_DestItem, true);
            else if (GetPlayer()->IsBankPos(l_Src))
                GetPlayer()->BankItem(l_SSrc, l_DestItem, true);
            else if (GetPlayer()->IsEquipmentPos(l_Src))
                GetPlayer()->EquipItem(l_ESrc, l_DestItem, true);

            if (Player::IsEquipmentPos(l_Dest) && l_SrcItem->GetChildItem())
                GetPlayer()->EquipChildItem(l_PackSlot, l_Slot, l_SrcItem);
        }
        else
        {
            if (Item* parentItem = GetPlayer()->GetItemByGuid(l_DestItem->GetGuidValue(ITEM_FIELD_CREATOR)))
            {
                if (Player::IsEquipmentPos(l_Dest))
                {
                    GetPlayer()->AutoUnequipChildItem(parentItem);
                    // dest is now empty
                    GetPlayer()->SwapItem(l_Src, l_Dest);
                    // src is now empty
                    GetPlayer()->SwapItem(parentItem->GetPos(), l_Src);
                }
            }
        }

        m_Player->AutoUnequipOffhandIfNeed();
    }
}

void WorldSession::HandleDestroyItemOpcode(WorldPacket& p_Packet)
{
    uint32 l_Count          = 0;
    uint8  l_ContainerId    = 0;
    uint8  l_SlotNum        = 0;

    p_Packet >> l_Count;
    p_Packet >> l_ContainerId;
    p_Packet >> l_SlotNum;

    uint16 l_ItemPosition = (l_ContainerId << 8) | l_SlotNum;

    /// prevent drop unequipable items (in combat, for example) and non-empty bags
    if (m_Player->IsEquipmentPos(l_ItemPosition) || m_Player->IsBagPos(l_ItemPosition))
    {
        InventoryResult msg = m_Player->CanUnequipItem(l_ItemPosition, false);
        if (msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(msg, m_Player->GetItemByPos(l_ItemPosition), NULL);
            return;
        }
    }

    Item* l_Item  = m_Player->GetItemByPos(l_ContainerId, l_SlotNum);

    if (!l_Item)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (l_Item->GetTemplate()->Flags & int32(ItemFlags::NO_USER_DESTROY))
    {
        m_Player->SendEquipError(EQUIP_ERR_DROP_BOUND_ITEM, NULL, NULL);
        return;
    }

    /// If trading
    if (TradeData* l_TradeData = m_Player->GetTradeData())
    {
        /// If current item is in trade window (only possible with packet spoofing - silent return)
        if (l_TradeData->GetTradeSlotForItem(l_Item->GetGUID()) != TRADE_SLOT_INVALID)
        {
            m_Player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, NULL, NULL);
            return;
        }
    }

    if (l_Count)
    {
        uint32 i_count = l_Count;
        m_Player->DestroyItemCount(l_Item, i_count, true);
    }
    else
        m_Player->DestroyItem(l_ContainerId, l_SlotNum, true);
}

/// 7.0.3 22293
enum READ_ITEM_FAILURE
{
    READ_LANGUAGE_DELAY         = 1,
    READ_LANGUAGE_CANCELLED     = 2,
    READ_LANGUAGE_FAILED        = 3,
    READ_LANGUAGE_TOO_DIFFICULT = 4
};

void WorldSession::HandleReadItem(WorldPacket& p_Packet)
{
    uint8 l_PackSlot = 0;
    uint8 l_Slot = 0;

    p_Packet >> l_PackSlot;
    p_Packet >> l_Slot;

    Item * l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (l_Item && l_Item->GetTemplate()->PageText)
    {
        WorldPacket l_Data;

        InventoryResult l_Message = m_Player->CanUseItem(l_Item);

        if (l_Message == EQUIP_ERR_OK)
        {
            l_Data.Initialize(SMSG_READ_ITEM_OK, 2 + 16);
            l_Data.appendPackGUID(l_Item->GetGUID());       ///< Item
        }
        else
        {
            l_Data.Initialize(SMSG_READ_ITEM_FAILED, 2 + 16 + 4 + 1);
            l_Data.appendPackGUID(l_Item->GetGUID());       ///< Item
            l_Data << uint32(1);                            ///< Delay
            l_Data.WriteBits(READ_LANGUAGE_FAILED, 2);      ///< Subcode
            l_Data.FlushBits();

            m_Player->SendEquipError(l_Message, l_Item, NULL);
        }

        SendPacket(&l_Data);
    }
    else
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
}

void WorldSession::HandleSellItemOpcode(WorldPacket& p_RecvPacket)
{
    uint64 l_VendorGUID = 0;
    uint64 l_ItemGUID   = 0;

    uint32 l_Amount = 0;

    p_RecvPacket.readPackGUID(l_VendorGUID);
    p_RecvPacket.readPackGUID(l_ItemGUID);

    p_RecvPacket >> l_Amount;

    if (!l_ItemGUID)
        return;

    Creature* l_Creature = GetPlayer()->GetNPCIfCanInteractWith(l_VendorGUID, UNIT_NPC_FLAG_VENDOR);

    if (!l_Creature)
    {
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, l_ItemGUID);
        return;
    }

    /// remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* l_PlayerItem = m_Player->GetItemByGuid(l_ItemGUID);

    if (l_PlayerItem)
    {
        // prevent sell not owner item
        if (m_Player->GetGUID() != l_PlayerItem->GetOwnerGUID())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent sell non empty bag by drag-and-drop at vendor's item list
        if (l_PlayerItem->IsNotEmptyBag())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent sell currently looted item
        if (m_Player->GetLootGUID() == l_PlayerItem->GetGUID())
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        /// Prevent sell of store items
        if (l_PlayerItem->HasCustomFlags(ItemCustomFlags::FromStore))
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // prevent selling item for sellprice when the item is still refundable
        // this probably happens when right clicking a refundable item, the client sends both
        // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
        if (l_PlayerItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return; // Therefore, no feedback to client
        }

        // pervent sell item with expiration
        if (l_PlayerItem->GetUInt32Value(ITEM_FIELD_EXPIRATION))
        {
            m_Player->SendSellError(SELL_ERR_ONLY_EMPTY_BAG, l_Creature, l_ItemGUID);
            return;
        }

        if (l_PlayerItem->GetTemplate()->Quality == ITEM_QUALITY_ARTIFACT || l_PlayerItem->GetTemplate()->Quality == ITEM_QUALITY_LEGENDARY)
        {
            m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
            return;
        }

        // special case at auto sell (sell all)
        if (l_Amount == 0)
            l_Amount = l_PlayerItem->GetCount();
        else
        {
            // prevent sell more items that exist in stack (possible only not from client)
            if (l_Amount > l_PlayerItem->GetCount())
            {
                m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                return;
            }
        }

        /// Fix the hack if player sells the item during casting item's spell
        /// For example, the spell combines 100 items into 1 item, player can use the spell and sell 100 items at the same time with the macro
        if (Spell const* l_Spell = m_Player->GetCurrentSpell(CurrentSpellTypes::CURRENT_GENERIC_SPELL))
        {
            for (auto l_SpellData : l_PlayerItem->GetTemplate()->Spells)
            {
                if (l_SpellData.SpellId == l_Spell->GetSpellInfo()->Id)
                {
                    m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                    return;
                }
            }
        }

        ItemTemplate const* l_PlayerItemTemplate = l_PlayerItem->GetTemplate();

        if (l_PlayerItemTemplate)
        {
            if (l_PlayerItemTemplate->FlagsCu & int32(ItemFlagsCustom::ITEM_FLAGS_CU_CANT_BE_SELL)
                || l_PlayerItemTemplate->Class == ITEM_CLASS_QUESTITEM)
            {
                m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                return;
            }

            if (l_PlayerItemTemplate->SellPrice > 0)
            {
                if (l_Amount < l_PlayerItem->GetCount())               // need split items
                {
                    Item* pNewItem = l_PlayerItem->CloneItem(l_Amount, m_Player);

                    if (!pNewItem)
                    {
                        m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);
                        return;
                    }

                    l_PlayerItem->SetCount(l_PlayerItem->GetCount() - l_Amount);
                    m_Player->ItemRemovedQuestCheck(l_PlayerItem->GetEntry(), l_Amount);

                    if (m_Player->IsInWorld())
                        l_PlayerItem->SendUpdateToPlayer(m_Player);

                    l_PlayerItem->SetState(ITEM_CHANGED, m_Player);

                    m_Player->AddItemToBuyBackSlot(pNewItem);

                    if (m_Player->IsInWorld())
                        pNewItem->SendUpdateToPlayer(m_Player);
                }
                else
                {
                    m_Player->ItemRemovedQuestCheck(l_PlayerItem->GetEntry(), l_PlayerItem->GetCount());
                    m_Player->RemoveItem(l_PlayerItem->GetBagSlot(), l_PlayerItem->GetSlot(), true);

                    l_PlayerItem->RemoveFromUpdateQueueOf(m_Player);

                    m_Player->AddItemToBuyBackSlot(l_PlayerItem);
                }

                int64 l_Money = l_PlayerItemTemplate->SellPrice * l_Amount;
                m_Player->ModifyMoney(l_Money, "HandleSellItemOpcode " + std::to_string(l_PlayerItemTemplate->ItemId) + " x" + std::to_string(l_Amount));
                m_Player->UpdateCriteria(CRITERIA_TYPE_MONEY_FROM_VENDORS, l_Money);
            }
            else
                m_Player->SendSellError(SELL_ERR_CANT_SELL_ITEM, l_Creature, l_ItemGUID);

            return;
        }
    }

    m_Player->SendSellError(SELL_ERR_CANT_FIND_ITEM, l_Creature, l_ItemGUID);

    return;
}

void WorldSession::HandleBuybackItem(WorldPacket& recvData)
{
    uint64 vendorguid;
    uint32 slot;

    recvData.readPackGUID(vendorguid);
    recvData >> slot;

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = m_Player->GetItemFromBuyBackSlot(slot);
    if (pItem)
    {
        uint64 price = m_Player->GetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + slot - BUYBACK_SLOT_START);
        if (!m_Player->HasEnoughMoney(uint64(price)))
        {
            m_Player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, pItem->GetEntry(), 0);
            return;
        }

        ItemPosCountVec dest;
        InventoryResult msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg == EQUIP_ERR_OK)
        {
            m_Player->ModifyMoney(-(int64)price, "HandleBuybackItem " + std::to_string(pItem->GetEntry()) + " x" + std::to_string(pItem->GetCount()));
            m_Player->RemoveItemFromBuyBackSlot(slot, false);
            m_Player->ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
            m_Player->UpdateCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());
            m_Player->StoreItem(dest, pItem, true);
        }
        else
            m_Player->SendEquipError(msg, pItem, NULL);
        return;
    }
    else
        m_Player->SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, 0, 0);
}

void WorldSession::HandleBuyItemOpcode(WorldPacket& p_RecvPacket)
{
    uint64 l_VendorGUID = 0;
    uint64 l_BagGUID    = 0;

    uint32 l_Muid       = 0;
    uint32 l_Slot       = 0;
    uint32 l_Quantity   = 0;
    uint32 l_ItemID     = 0;

    uint8 l_ItemType = ITEM_VENDOR_TYPE_NONE;

    p_RecvPacket.readPackGUID(l_VendorGUID);
    p_RecvPacket.readPackGUID(l_BagGUID);

    p_RecvPacket >> l_Quantity;
    p_RecvPacket >> l_Muid;
    p_RecvPacket >> l_Slot;

    p_RecvPacket >> l_ItemID;
    p_RecvPacket.read_skip<uint32>();           ///< RandomPropertiesSeed
    p_RecvPacket.read_skip<uint32>();           ///< RandomPropertiesID

    bool l_HasItemBonus     = p_RecvPacket.ReadBit();
    bool l_HasModifications = p_RecvPacket.ReadBit();

    if (l_HasItemBonus)
    {
        p_RecvPacket.read_skip<uint8>();        ///< Context
        uint32 l_Count = p_RecvPacket.read<uint32>();

        for (uint32 l_I = 0; l_I < l_Count;  l_I++)
            p_RecvPacket.read_skip<uint32>();   ///< Bonus ID
    }

    if (l_HasModifications)
        p_RecvPacket.read_skip<uint32>();       ///< Modifications

    p_RecvPacket.ResetBitReading();
    l_ItemType = p_RecvPacket.ReadBits(2);

    /// Client expects count starting at 1, and we send vendorslot+1 to client already
    if (l_Muid > 0)
        --l_Muid;
    else
        return; // cheating

    switch (l_ItemType)
    {
        case ITEM_VENDOR_TYPE_ITEM:
            m_Player->BuyItemFromVendorSlot(l_VendorGUID, l_Muid, l_ItemID, l_Quantity, NULL_BAG, NULL_SLOT);
            break;
        case ITEM_VENDOR_TYPE_CURRENCY:
            m_Player->BuyCurrencyFromVendorSlot(l_VendorGUID, l_Muid, l_ItemID, l_Quantity);
            break;
        default:
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: received wrong itemType (%u) in HandleBuyItemOpcode", l_ItemType);
            break;
    }
}

void WorldSession::HandleListInventoryOpcode(WorldPacket& recvData)
{
    uint64 l_GUID;

    recvData.readPackGUID(l_GUID);

    if (!GetPlayer()->isAlive())
        return;

    SendListInventory(l_GUID);
}

void WorldSession::SendListInventory(uint64 p_VendorGUID, bool p_FunCustomPlayerConditionFilter, bool p_NoFilters)
{
    Creature* l_Vendor = GetPlayer()->GetNPCIfCanInteractWith(p_VendorGUID, UNIT_NPC_FLAG_VENDOR);

    if (!l_Vendor)
    {
        m_Player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    /// remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    /// Stop the npc if moving
    if (l_Vendor->HasUnitState(UNIT_STATE_MOVING))
        l_Vendor->StopMoving();

    int32 l_PriceMod = m_Player->GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES);

    VendorItemData const* vendorItems = l_Vendor->GetVendorItems();
    uint32 rawItemCount = vendorItems ? vendorItems->GetItemCount() : 0;

    ByteBuffer l_ItemDataBuffer(10 * 1024);

    const float l_DiscountMod = m_Player->GetReputationPriceDiscount(l_Vendor);
    uint32 l_Muid = 0;
    uint32 l_ItemCount = 0;

    for (uint32 slot = 0; slot < rawItemCount; ++slot)
    {
        l_Muid++;

        VendorItem const* l_VendorItem = vendorItems->GetItem(slot);
        if (!l_VendorItem)
            continue;

        if (p_FunCustomPlayerConditionFilter && l_VendorItem->PlayerConditionID < 0xFFFFFF)
            continue;

        if (!p_FunCustomPlayerConditionFilter && l_VendorItem->PlayerConditionID >= 0xFFFFFF)
            continue;

        if (l_VendorItem->Type == ITEM_VENDOR_TYPE_ITEM)
        {
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_VendorItem->item);
            if (!l_ItemTemplate)
                continue;

            uint32 l_Quantity = !l_VendorItem->maxcount ? 0xFFFFFFFF : l_Vendor->GetVendorItemCurrentCount(l_VendorItem);
            if (!m_Player->isGameMaster()) ///< Ignore conditions if GM on
            {
                if (!sConditionMgr->IsObjectMeetingVendorItemConditions(l_Vendor->GetEntry(), l_VendorItem->item, m_Player, l_Vendor))
                {
                    sLog->outDebug(LOG_FILTER_CONDITIONSYS, "SendListInventory: conditions not met for creature entry %u item %u", l_Vendor->GetEntry(), l_VendorItem->item);
                    continue;
                }

                /// Respect allowed class
                if (!(l_ItemTemplate->AllowableClass & m_Player->getClassMask()) && l_ItemTemplate->Bonding == BIND_WHEN_PICKED_UP)
                    continue;

                /// Custom MoP Script for Pandaren's Mounts (Alliance)
                if (l_ItemTemplate->Class == 15 && l_ItemTemplate->SubClass == 5 && m_Player->getRace() != RACE_PANDAREN_ALLIANCE
                    && m_Player->getRace() != RACE_PANDAREN_HORDE && m_Player->getRace() != RACE_PANDAREN_NEUTRAL
                    && l_Vendor->GetEntry() == 65068 && m_Player->GetReputationRank(1353) != REP_EXALTED)
                    continue;

                /// Custom MoP Script for Pandaren's Mounts (Horde)
                if (l_ItemTemplate->Class == 15 && l_ItemTemplate->SubClass == 5 && m_Player->getRace() != RACE_PANDAREN_ALLIANCE
                    && m_Player->getRace() != RACE_PANDAREN_HORDE && m_Player->getRace() != RACE_PANDAREN_NEUTRAL
                    && l_Vendor->GetEntry() == 66022 && m_Player->GetReputationRank(1352) != REP_EXALTED)
                    continue;

                /// Only display items in vendor lists for the team the player is on
                if ((l_ItemTemplate->Flags2 & int32(ItemFlagsEX::HORDE) && m_Player->GetTeam() == ALLIANCE) ||
                    (l_ItemTemplate->Flags2 & int32(ItemFlagsEX::ALLIANCE) && m_Player->GetTeam() == HORDE))
                    continue;
#ifndef CROSS
                if (Guild* guild = sGuildMgr->GetGuildById(m_Player->GetGuildId()))
                {
                    if (GuildReward const* l_Reward = sGuildMgr->GetGuildReward(l_ItemTemplate->ItemId))
                    {
                        if (l_Reward->Standing)
                        {
                            if (m_Player->GetReputationRank(REP_GUILD) < l_Reward->Standing)
                                continue;
                        }

                        if (l_Reward->AchievementId)
                        {
                            if (!guild->HasAchieved(l_Reward->AchievementId))
                            {
                                if (!(l_Reward->AchievementId == 5492 && guild->HasAchieved(4912)) && !(l_Reward->AchievementId == 4912 && guild->HasAchieved(5492)))
                                    continue;
                            }
                        }

                        if (l_Reward->Racemask)
                        {
                            if (!(m_Player->getRaceMask() & l_Reward->Racemask))
                                continue;
                        }
                    }
                }
                else if (sGuildMgr->IsGuildReward(l_ItemTemplate->ItemId))
                    continue;
#endif /* not CROSS */

                /// Items sold out are not displayed in list
                if (l_Quantity == 0)
                    continue;

                if (l_Vendor->GetEntry() == MS::Garrison::GBrokenIsles::eWorkOrderNPC::NPCNomi)
                {
                    std::set<uint64> const& l_AvailableRecipes = GetPlayer()->m_SpellHelper.GetUint64Set()[eSpellHelpers::NomiRecipes];
                    if (l_AvailableRecipes.find(l_VendorItem->item) == l_AvailableRecipes.end())
                        continue;
                }
            }

            uint64 l_OverridePrice = 0;

            if (l_VendorItem->ExtendedCost)
            {
                ItemExtendedCostEntry const* l_Entry = sItemExtendedCostStore.LookupEntry(l_VendorItem->ExtendedCost);
                if (!l_Entry)
                    break;

                ItemExtendedCostAddon const* l_ExtendedCostAddon = sObjectMgr->GetItemExtendedCostAddon(l_VendorItem->ExtendedCost);
                if (l_ExtendedCostAddon && l_ExtendedCostAddon->OverrideBuyPrice)
                    l_OverridePrice = l_ExtendedCostAddon->OverrideBuyPrice;
            }

            uint64 l_Price = l_OverridePrice || l_VendorItem->IsGoldRequired(l_ItemTemplate) ? uint64(floor((l_OverridePrice ? l_OverridePrice : l_ItemTemplate->BuyPrice) * l_DiscountMod)) : 0;

            /// Reputation discount
            if (l_PriceMod)
                l_Price -= CalculatePct(l_Price, l_PriceMod);

            bool l_BypassFilter = p_NoFilters ? true : ((l_ItemTemplate->FlagsCu & int32(ItemFlagsCustom::ITEM_FLAGS_CU_BYPASS_VENDOR_FILTER)) || (!l_ItemTemplate->HasSpec()));

            l_ItemDataBuffer << uint32(l_Muid);
            l_ItemDataBuffer << uint32(ITEM_VENDOR_TYPE_ITEM);              ///< Item type

            uint32 l_PlayerCondition = (l_VendorItem->PlayerConditionID >= 0xFFFFFF) ? 0 : l_VendorItem->PlayerConditionID;

            l_ItemDataBuffer << int32(l_Quantity);                          ///< Quantity
            l_ItemDataBuffer << uint64(l_Price);                            ///< Price
            l_ItemDataBuffer << uint32(l_ItemTemplate->MaxDurability);      ///< Durability
            l_ItemDataBuffer << uint32(l_ItemTemplate->BuyCount);           ///< StackCount
            l_ItemDataBuffer << uint32(l_VendorItem->ExtendedCost);         ///< Extended cost ID
            l_ItemDataBuffer << uint32(l_PlayerCondition);                  ///< Player condition failed

            Item::BuildDynamicItemDatas(l_ItemDataBuffer, l_VendorItem->item, l_VendorItem->BonusList);

            l_ItemDataBuffer.FlushBits();
            l_ItemDataBuffer.WriteBit(l_BypassFilter);                      ///< Do not filter on vendor
            l_ItemDataBuffer.FlushBits();

            l_ItemCount++;
        }
        else if (l_VendorItem->Type == ITEM_VENDOR_TYPE_CURRENCY)
        {
            CurrencyTypesEntry const* currencyTemplate = sCurrencyTypesStore.LookupEntry(l_VendorItem->item);

            if (!currencyTemplate)
                continue;

            if (l_VendorItem->ExtendedCost == 0)
                continue; // there's no price defined for currencies, only extended cost is used

            uint32 l_Precision  = (currencyTemplate->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
            uint32 l_Price      = l_VendorItem->maxcount * l_Precision;

            l_ItemDataBuffer << uint32(l_Muid);
            l_ItemDataBuffer << uint32(ITEM_VENDOR_TYPE_CURRENCY);          ///< Item type
            l_ItemDataBuffer << int32(-1);                                  ///< Available In Stock
            l_ItemDataBuffer << uint64(l_Price);                            ///< Price
            l_ItemDataBuffer << uint32(0);                                  ///< Max durability
            l_ItemDataBuffer << uint32(0);                                  ///< Stack count
            l_ItemDataBuffer << uint32(0);                                  ///< Extended cost ID
            l_ItemDataBuffer << uint32(0);                                  ///< Player condition failed

            Item::BuildDynamicItemDatas(l_ItemDataBuffer, l_VendorItem->item, l_VendorItem->BonusList);

            l_ItemDataBuffer.FlushBits();
            l_ItemDataBuffer.WriteBit(false);                               ///< Do not filter on vendor
            l_ItemDataBuffer.FlushBits();

            l_ItemCount++;
        }
        /// else error
    }

    WorldPacket l_Response(SMSG_LIST_INVENTORY, 16 + 2 + 1 + 4 + l_ItemDataBuffer.size());
    l_Response.appendPackGUID(p_VendorGUID);

    if (l_ItemCount)
        l_Response << uint8(l_ItemCount);                   ///< Reason
    else
        l_Response << uint8(l_Vendor->isArmorer());         ///< Reason

    l_Response << uint32(l_ItemCount);
    l_Response.append(l_ItemDataBuffer);

    m_Player->SetInteractionStatus(p_VendorGUID, InteractionStatus::Vendor);
    SendPacket(&l_Response);
}

void WorldSession::HandleAutoStoreBagItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_UnkInvCount, l_SrcBag, l_SrcSlot, l_DestBag;

    p_RecvData >> l_UnkInvCount >> l_SrcBag >> l_DestBag >> l_SrcSlot;

    for (uint8 i = 0; i < l_UnkInvCount; i++)
    {
        p_RecvData.ReadBit();
        p_RecvData.ReadBit();
    }

    p_RecvData.FlushBits();

    for (uint8 i = 0; i < l_UnkInvCount; i++)
    {
        p_RecvData.read_skip<uint8>();
        p_RecvData.read_skip<uint8>();
    }

    Item* l_Item = m_Player->GetItemByPos(l_SrcBag, l_SrcSlot);
    if (!l_Item)
        return;

    if (!m_Player->IsValidPos(l_DestBag, NULL_SLOT, false))      // can be autostore pos
    {
        m_Player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }


    if (l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
    {
        if (Item* l_ParentItem = GetPlayer()->GetItemByGuid(l_Item->GetGuidValue(ITEM_FIELD_CREATOR)))
        {
            l_Item = l_ParentItem;
            l_SrcBag = l_Item->GetBagSlot();
            l_SrcSlot = l_Item->GetSlot();
        }
    }

    uint16 l_Src = l_Item->GetPos();

    // check unequip potability for equipped items and bank bags
    if (m_Player->IsEquipmentPos (l_Src) || m_Player->IsBagPos (l_Src))
    {
        InventoryResult l_Result = m_Player->CanUnequipItem(l_Src, !m_Player->IsBagPos (l_Src));
        if (l_Result != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Result, l_Item, NULL);
            return;
        }
    }

    ItemPosCountVec l_Dest;
    InventoryResult l_Result = m_Player->CanStoreItem(l_DestBag, NULL_SLOT, l_Dest, l_Item, false);
    if (l_Result != EQUIP_ERR_OK)
    {
        m_Player->SendEquipError(l_Result, l_Item, NULL);
        return;
    }

    // no-op: placed in same slot
    if (l_Dest.size() == 1 && l_Dest[0].pos == l_Src)
    {
        // just remove grey item state
        m_Player->SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, l_Item, NULL);
        return;
    }

    m_Player->RemoveItem(l_SrcBag, l_SrcSlot, true);
    m_Player->StoreItem(l_Dest, l_Item, true);
}

void WorldSession::HandleBuyBankSlotOpcode(WorldPacket& p_RecvData)
{
    uint64 l_BankerGUID;

    p_RecvData.readPackGUID(l_BankerGUID);

    uint32 l_Slot = m_Player->GetBankBagSlotCount();

    // next slot
    ++l_Slot;

    BankBagSlotPricesEntry const* l_SlotEntry = sBankBagSlotPricesStore.LookupEntry(l_Slot);

    if (!l_SlotEntry)
        return;

    uint32 l_Price = l_SlotEntry->price;

    if (!m_Player->HasEnoughMoney(uint64(l_Price)))
        return;

    m_Player->SetBankBagSlotCount(l_Slot);
    m_Player->ModifyMoney(-int64(l_Price), "HandleBuyBankSlotOpcode");

    m_Player->UpdateCriteria(CRITERIA_TYPE_BUY_BANK_SLOT);
}

void WorldSession::HandleBuyReagentBankOpcode(WorldPacket& p_RecvData)
{
    uint64 l_BankerGUID;

    p_RecvData.readPackGUID(l_BankerGUID);

    if (m_Player->HasUnlockedReagentBank())
        return;

    Creature * l_Banker = m_Player->GetNPCIfCanInteractWith(l_BankerGUID, UNIT_NPC_FLAG_BANKER);

    if (!l_Banker)
        return;

    uint64 l_RegentBankPrice = 1000000;

    if (!m_Player->HasEnoughMoney(uint64(l_RegentBankPrice)))
        return;

    m_Player->ModifyMoney(-int64(l_RegentBankPrice), "HandleBuyReagentBankOpcode");
    m_Player->UnlockReagentBank();
}

void WorldSession::HandleDepositAllReagentsOpcode(WorldPacket& p_RecvData)
{
    uint64 l_BankerGUID = 0;
    p_RecvData.readPackGUID(l_BankerGUID);

    if (!m_Player->HasUnlockedReagentBank())
        return;

    Creature* l_Banker = m_Player->GetNPCIfCanInteractWith(l_BankerGUID, UNIT_NPC_FLAG_BANKER);
    if (!l_Banker)
        return;

    for (uint32 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Bag* l_Bag = (Bag*)m_Player->GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            for (uint32 l_J = 0; l_J < l_Bag->GetBagSize(); ++l_J)
            {
                if (Item* l_Item = m_Player->GetItemByPos(l_I, l_J))
                {
                    if (l_Item->GetTemplate()->Class != ITEM_CLASS_TRADE_GOODS)
                        continue;

                    if (!(l_Item->GetTemplate()->Flags2 & int32(ItemFlagsEX::USED_IN_A_TRADESKILL)))
                        continue;

                    uint8 l_Slot2 = m_Player->GetFreeReagentBankSlot();

                    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_J, true))
                        continue;

                    if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot2, true))
                        continue;

                    uint16 l_Src = ((l_I << 8) | l_J);
                    uint16 l_Dest = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot2);

                    m_Player->SwapItem(l_Src, l_Dest);
                }
            }
        }
    }

    for (uint8 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (Item* l_Item = m_Player->GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (l_Item->GetTemplate()->Class != ITEM_CLASS_TRADE_GOODS)
                continue;

            if (!(l_Item->GetTemplate()->Flags2 & int32(ItemFlagsEX::USED_IN_A_TRADESKILL)))
                continue;

            uint8 l_Slot2 = m_Player->GetFreeReagentBankSlot();

            if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_I, true))
                continue;

            if (!m_Player->IsValidPos(INVENTORY_SLOT_BAG_0, l_Slot2, true))
                continue;

            uint16 l_Src = ((INVENTORY_SLOT_BAG_0 << 8) | l_I);
            uint16 l_Dest = ((INVENTORY_SLOT_BAG_0 << 8) | l_Slot2);

            m_Player->SwapItem(l_Src, l_Dest);
        }
    }
}

void WorldSession::HandleAutoBankItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_PackSlot;
    p_RecvData >> l_Slot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_Item)
        return;

    ItemPosCountVec l_Dest;

    if (m_Player->IsBankPos(l_PackSlot, l_Slot))
    {
        InventoryResult msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);
        if (msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(msg, l_Item);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->StoreItem(l_Dest, l_Item, true);
        m_Player->ItemAddedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    }
    else
    {
        InventoryResult l_Msg = m_Player->CanBankItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);
        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, NULL);
            return;
        }

        if (l_Dest.size() == 1 && l_Dest[0].pos == l_Item->GetPos())
        {
            m_Player->SendEquipError(EQUIP_ERR_CANT_SWAP, l_Item, NULL);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->ItemRemovedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
        m_Player->BankItem(l_Dest, l_Item, true);
    }

}

void WorldSession::HandleAutoBankReagentOpcode(WorldPacket& p_RecvPacket)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvPacket.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvPacket.read_skip<uint8>();    ///< ContainerSlot
        p_RecvPacket.read_skip<uint8>();    ///< Slot
    }

    p_RecvPacket >> l_PackSlot;
    p_RecvPacket >> l_Slot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);
    if (!l_Item)
    {
        m_Player->SendEquipError(InventoryResult::EQUIP_ERR_ITEM_NOT_FOUND, l_Item, nullptr);
        return;
    }

    if (l_Item->GetTemplate()->Class != ItemClass::ITEM_CLASS_TRADE_GOODS)
    {
        m_Player->SendEquipError(InventoryResult::EQUIP_ERR_CANT_SWAP, l_Item, nullptr);
        return;
    }

    if (!(l_Item->GetTemplate()->Flags2 & int32(ItemFlagsEX::USED_IN_A_TRADESKILL)))
    {
        m_Player->SendEquipError(InventoryResult::EQUIP_ERR_CANT_SWAP, l_Item, nullptr);
        return;
    }

    ItemPosCountVec l_Dest;
    if (m_Player->IsReagentBankPos(l_PackSlot, l_Slot))
    {
        InventoryResult msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);
        if (msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(msg, l_Item);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->StoreItem(l_Dest, l_Item, true);
        m_Player->ItemAddedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    }
    else
    {
        InventoryResult l_Msg = m_Player->CanReagentBankItem(InventorySlot::NULL_BAG, InventorySlot::NULL_SLOT, l_Dest, l_Item, false);
        if (l_Msg != InventoryResult::EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, nullptr);
            return;
        }

        if (l_Dest.size() == 1 && l_Dest[0].pos == l_Item->GetPos())
        {
            m_Player->SendEquipError(InventoryResult::EQUIP_ERR_CANT_SWAP, l_Item, nullptr);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->ItemRemovedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
        m_Player->BankItem(l_Dest, l_Item, true);
    }

}

void WorldSession::HandleAutoStoreBankItemOpcode(WorldPacket& p_RecvData)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvData.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvData.read_skip<uint8>();    ///< ContainerSlot
        p_RecvData.read_skip<uint8>();    ///< Slot
    }

    p_RecvData >> l_PackSlot;
    p_RecvData >> l_Slot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);

    if (!l_Item)
        return;

    // moving from bank to inventory
    if (m_Player->IsBankPos(l_PackSlot, l_Slot))
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanStoreItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, NULL);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        l_Item = m_Player->StoreItem(l_Dest, l_Item, true);
        m_Player->ItemAddedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    }
    // moving from inventory to bank
    else
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanBankItem(NULL_BAG, NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, NULL);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->BankItem(l_Dest, l_Item, true);
    }
}

void WorldSession::HandleAutoStoreBankReagentOpcode(WorldPacket& p_RecvPacket)
{
    uint8 l_PackSlot;
    uint8 l_Slot;
    uint8 l_ItemCount;

    l_ItemCount = p_RecvPacket.ReadBits(2);

    for (uint32 l_I = 0; l_I < l_ItemCount; ++l_I)
    {
        p_RecvPacket.read_skip<uint8>();    ///< ContainerSlot
        p_RecvPacket.read_skip<uint8>();    ///< Slot
    }

    p_RecvPacket >> l_PackSlot;
    p_RecvPacket >> l_Slot;

    Item* l_Item = m_Player->GetItemByPos(l_PackSlot, l_Slot);
    if (!l_Item)
        return;

    /// Moving from bank to inventory
    if (m_Player->IsReagentBankPos(l_PackSlot, l_Slot))
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanStoreItem(InventorySlot::NULL_BAG, InventorySlot::NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != InventoryResult::EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, nullptr);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        l_Item = m_Player->StoreItem(l_Dest, l_Item, true);

        if (l_Item != nullptr)
            m_Player->ItemAddedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
    }
    /// Moving from inventory to bank
    else
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = m_Player->CanReagentBankItem(InventorySlot::NULL_BAG, InventorySlot::NULL_SLOT, l_Dest, l_Item, false);

        if (l_Msg != InventoryResult::EQUIP_ERR_OK)
        {
            m_Player->SendEquipError(l_Msg, l_Item, nullptr);
            return;
        }

        m_Player->RemoveItem(l_PackSlot, l_Slot, true);
        m_Player->ItemRemovedQuestCheck(l_Item->GetEntry(), l_Item->GetCount());
        m_Player->BankItem(l_Dest, l_Item, true);
    }
}

void WorldSession::SendEnchantmentLog(uint64 p_ItemGUID, uint64 p_CasterGUID, uint32 p_ItemID, uint32 p_Enchantment, uint8 p_EnchantSlot)
{
    WorldPacket l_Data(SMSG_ENCHANTMENT_LOG);

    l_Data.appendPackGUID(p_CasterGUID);
    l_Data.appendPackGUID(GetPlayer()->GetGUID());
    l_Data.appendPackGUID(p_ItemGUID);

    l_Data << uint32(p_ItemID);
    l_Data << uint32(p_Enchantment);
    l_Data << uint32(p_EnchantSlot);

    SendPacket(&l_Data);
}

void WorldSession::SendItemEnchantTimeUpdate(uint64 p_PlayerGuid, uint64 p_ItemGuid, uint32 p_Slot, uint32 p_Duration)
{
    WorldPacket l_Data(SMSG_ITEM_ENCHANT_TIME_UPDATE);

    l_Data.appendPackGUID(p_ItemGuid);
    l_Data << uint32(p_Duration);
    l_Data << uint32(p_Slot);
    l_Data.appendPackGUID(p_PlayerGuid);

    SendPacket(&l_Data);
}

void WorldSession::HandleWrapItemOpcode(WorldPacket& recvData)
{
    bool hasGiftBag, hasGiftSlot, hasItemBag, hasItemSlot;
    uint8 gift_bag = 0;
    uint8 gift_slot = 0;
    uint8 item_bag = 0;
    uint8 item_slot = 0;

    uint8 itemCount = recvData.ReadBits(2);

    for (uint8 i = 0; i < itemCount; ++i)
    {
        if (i == 0)
        {
            hasGiftBag = !recvData.ReadBit();
            hasGiftSlot = !recvData.ReadBit();
        }
        else
        {
            hasItemBag = !recvData.ReadBit();
            hasItemSlot = !recvData.ReadBit();
        }
    }

    recvData.FlushBits();

    for (uint8 i = 0; i < itemCount; ++i)
    {
        if (i == 0)
        {
            if (hasGiftSlot)
                recvData >> gift_slot;

            if (hasGiftBag)
                recvData >> gift_bag;
        }
        else
        {
            if (hasItemSlot)
                recvData >> item_slot;

            if (hasItemBag)
                recvData >> item_bag;
        }
    }

    Item* gift = m_Player->GetItemByPos(gift_bag, gift_slot);
    if (!gift)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    if (!(gift->GetTemplate()->Flags & int32(ItemFlags::WRAPPER))) // cheating: non-wrapper wrapper
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    Item* item = m_Player->GetItemByPos(item_bag, item_slot);

    if (!item)
    {
        m_Player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, item, NULL);
        return;
    }

    if (item == gift)                                          // not possable with pacjket from real client
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsEquipped())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_EQUIPPED, item, NULL);
        return;
    }

    if (item->GetGuidValue(ITEM_FIELD_GIFT_CREATOR))        // HasFlag(ITEM_FIELD_FLAGS, ItemFlags::WRAPPER);
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsBag())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_BAGS, item, NULL);
        return;
    }

    if (item->IsSoulBound())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_BOUND, item, NULL);
        return;
    }

    if (item->GetMaxStackCount() != 1)
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_STACKABLE, item, NULL);
        return;
    }

    // maybe not correct check  (it is better than nothing)
    if (item->GetTemplate()->MaxCount > 0 || item->IsConjuredConsumable())
    {
        m_Player->SendEquipError(EQUIP_ERR_CANT_WRAP_UNIQUE, item, NULL);
        return;
    }

    SQLTransaction trans = SessionRealmDatabase.BeginTransaction();

    PreparedStatement* stmt = SessionRealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_GIFT);
    stmt->setUInt32(0, GUID_LOPART(item->GetRealOwnerGUID()));
    stmt->setUInt32(1, item->GetRealGUIDLow());
    stmt->setUInt32(2, item->GetEntry());
    stmt->setUInt32(3, item->GetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS));
    trans->Append(stmt);

    item->SetEntry(gift->GetEntry());

    switch (item->GetEntry())
    {
        case 5042:
            item->SetEntry(5043);
            break;
        case 5048:
            item->SetEntry(5044);
            break;
        case 17303:
            item->SetEntry(17302);
            break;
        case 17304:
            item->SetEntry(17305);
            break;
        case 17307:
            item->SetEntry(17308);
            break;
        case 21830:
            item->SetEntry(21831);
            break;
    }

    item->SetGuidValue(ITEM_FIELD_GIFT_CREATOR, m_Player->GetGUID());
    item->SetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_WRAPPED);
    item->SetState(ITEM_CHANGED, m_Player);

    if (item->GetState() == ITEM_NEW)                          // save new item, to have alway for `character_gifts` record in `item_instance`
    {
        // after save it will be impossible to remove the item from the queue
        item->RemoveFromUpdateQueueOf(m_Player);
        item->SaveToDB(trans);                                   // item gave inventory record unchanged and can be save standalone
    }

    SessionRealmDatabase.CommitTransaction(trans);

    uint32 count = 1;
    m_Player->DestroyItemCount(gift, count, true);
}

void WorldSession::HandleSocketOpcode(WorldPacket& p_Data)
{
    WorldPackets::WPItem::SocketGems packet(p_Data);
    packet.Read();

    Player* player = GetPlayer();

    sLog->outAshran("WorldSession::HandleSocketOpcode player guid %u", player->GetGUIDLow());

    if (!packet.ItemGuid)
        return;

    if ((packet.GemItem[0] && (packet.GemItem[0] == packet.GemItem[1] || packet.GemItem[0] == packet.GemItem[2])) ||
        (packet.GemItem[1] && (packet.GemItem[1] == packet.GemItem[2])))
        return;

    Item* itemTarget = player->GetItemByGuid(packet.ItemGuid);
    if (!itemTarget || !itemTarget->IsInWorld() || !player->IsInWorld())
        return;

    ItemTemplate const* itemProto = itemTarget->GetTemplate();
    if (!itemProto)
        return;

    uint8 slot = itemTarget->IsEquipped() ? itemTarget->GetSlot() : uint8(NULL_SLOT);

    Item* gems[MAX_GEM_SOCKETS];
    memset(gems, 0, sizeof(gems));

    ItemDynamicFieldGems gemData[MAX_GEM_SOCKETS];
    memset(gemData, 0, sizeof(gemData));

    GemPropertiesEntry const* gemProperties[MAX_GEM_SOCKETS];
    memset(gemProperties, 0, sizeof(gemProperties));

    ItemDynamicFieldGems const* oldGemData[MAX_GEM_SOCKETS];
    memset(oldGemData, 0, sizeof(oldGemData));

    for (uint32 i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (Item* gem = player->GetItemByGuid(packet.GemItem[i]))
        {
            gems[i] = gem;
            gemData[i].ItemId = gem->GetEntry();
            gemData[i].Context = gem->GetUInt32Value(ITEM_FIELD_CONTEXT);
            for (std::size_t b = 0; b < gem->GetDynamicValues(ITEM_DYNAMIC_FIELD_BONUS_LIST_IDS).size() && b < 16; ++b)
                gemData[i].BonusListIDs[b] = gem->GetDynamicValue(ITEM_DYNAMIC_FIELD_BONUS_LIST_IDS, b);

            gemProperties[i] = sGemPropertiesStore.LookupEntry(gem->GetTemplate()->GetGemProperties());
        }

        oldGemData[i] = itemTarget->GetGem(i);
    }

    uint32 firstPrismatic = 0;
    while (firstPrismatic < MAX_GEM_SOCKETS && itemTarget->GetSocketColor(firstPrismatic))
        ++firstPrismatic;

    for (uint32 i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!gemProperties[i])
            continue;

        if (!itemTarget->GetSocketColor(i))
        {
            if (!itemTarget->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
                return;

            if (i != firstPrismatic)
                return;
        }

        if (SocketColorToGemTypeMask[itemTarget->GetSocketColor(i)] != gemProperties[i]->Type)
            if (!(SocketColorToGemTypeMask[itemTarget->GetSocketColor(i)] & SOCKET_COLOR_PRISMATIC) || !(gemProperties[i]->Type & SOCKET_COLOR_PRISMATIC))
                return;
    }

    for (uint32 i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!gems[i])
            continue;

        ItemTemplate const* iGemProto = gems[i]->GetTemplate();
        if (iGemProto->Flags & (uint32)ItemFlags::UNIQUE_EQUIPPABLE)
        {
            for (uint32 j = 0; j < MAX_GEM_SOCKETS; ++j)
            {
                if (i == j)                                    // skip self
                    continue;

                if (gems[j])
                {
                    if (iGemProto->ItemId == gems[j]->GetEntry())
                    {
                        player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget);
                        return;
                    }
                }
                else if (oldGemData[j])
                {
                    if (iGemProto->ItemId == oldGemData[j]->ItemId)
                    {
                        player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget);
                        return;
                    }
                }
            }
        }

        int32 limit_newcount = 0;
        if (iGemProto->ItemLimitCategory)
        {
            if (ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(iGemProto->ItemLimitCategory))
            {
                for (int l_Slot = EQUIPMENT_SLOT_START; l_Slot < INVENTORY_SLOT_ITEM_END; ++l_Slot)
                {
                    if (Item* l_Item = m_Player->GetItemByPos(INVENTORY_SLOT_BAG_0, l_Slot))
                    {
                        for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
                        {
                            if (ItemDynamicFieldGems const* l_GemData = l_Item->GetGem(j))
                            {
                                ItemTemplate const* l_OtherGemTpl = sObjectMgr->GetItemTemplate(l_GemData->ItemId);
                                if (!l_OtherGemTpl)
                                    continue;

                                if (iGemProto->ItemLimitCategory == l_OtherGemTpl->ItemLimitCategory)
                                    ++limit_newcount;
                            }
                            else if (oldGemData[j])
                            {
                                if (ItemTemplate const* jProto = sObjectMgr->GetItemTemplate(oldGemData[j]->ItemId))
                                    if (iGemProto->ItemLimitCategory == jProto->ItemLimitCategory)
                                        ++limit_newcount;
                            }
                        }
                    }
                }

                if (limit_newcount > 0 && uint32(limit_newcount) > limitEntry->GetMaxCount(m_Player))
                {
                    player->SendEquipError(InventoryResult::EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED, itemTarget);
                    return;
                }
            }
        }

        if (itemTarget->IsEquipped())
            if (InventoryResult res = player->CanEquipUniqueItem(gems[i], slot, std::max(limit_newcount, 0)))
            {
                player->SendEquipError(res, itemTarget);
                return;
            }
    }

    bool SocketBonusActivated = itemTarget->GemsFitSockets();
    player->ToggleMetaGemsActive(slot, false);

    if (itemTarget->IsEquipped())
        m_Player->_ApplyItemMods(itemTarget, itemTarget->GetSlot(), false);

    if (Item* childItem = m_Player->GetChildItemByGuid(itemTarget->GetChildItem()))
    {
        if (childItem->IsEquipped())
            m_Player->_ApplyItemMods(childItem, childItem->GetSlot(), false);
        childItem->CopyArtifactDataFromParent(itemTarget);
        if (childItem->IsEquipped())
            m_Player->_ApplyItemMods(childItem, childItem->GetSlot(), true);
    }

    for (uint16 i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (gems[i])
        {
            uint32 gemScalingLevel = m_Player->getLevel();
            if (uint32 fixedLevel = gems[i]->GetModifier(ITEM_MODIFIER_SCALING_STAT_DISTRIBUTION_FIXED_LEVEL))
                gemScalingLevel = fixedLevel;

            itemTarget->SetGem(i, &gemData[i], gemScalingLevel);

            if (gemProperties[i] && gemProperties[i]->EnchantID)
                itemTarget->SetEnchantment(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT + i), gemProperties[i]->EnchantID, 0, 0);

            MS::Artifact::Manager* l_Artifact = itemTarget->GetArtifactManager();
            if (l_Artifact)
            {
                RelicTalentData* l_OldRelicTalentData = itemTarget->GetRelicTalentData();
                for (uint8 l_TalentSlot = 0; l_TalentSlot < MAX_RELIC_TALENT; l_TalentSlot++)
                {
                    if (l_OldRelicTalentData->PathMask[i] & 1 << l_TalentSlot)
                    {
                        if (RelicTalentEntry const* l_RelicTalentEntry = sRelicTalentStore.LookupEntry(l_OldRelicTalentData->RelicTalent[i][l_TalentSlot]))
                        {
                            if (l_RelicTalentEntry->ArtifactPowerLabel && l_Artifact)
                                l_Artifact->UpdatePowerBonusRankByType(l_RelicTalentEntry->ArtifactPowerLabel, 1, false);

                            if (l_RelicTalentEntry->ArtifactPowerID)
                                l_Artifact->UpdatePowerBonusRankById(l_RelicTalentEntry->ArtifactPowerID, 1, false);
                        }
                    }
                }
                itemTarget->GetRelicTalentData()->EquipNewRelic(gems[i], i);
                auto l_DynamicFields = itemTarget->GetRelicTalentData()->GetDynamicFieldStruct(i);
                itemTarget->SetDynamicStructuredValue(ITEM_DYNAMIC_FIELD_RELIC_TALENT_DATA, sizeof(ItemDynamicFieldRelicTalentData) * i, &l_DynamicFields);
            }

            uint32 gemCount = 1;
            player->DestroyItemCount(gems[i], gemCount, true);
        }
    }

    if (itemTarget->IsEquipped())
        m_Player->_ApplyItemMods(itemTarget, itemTarget->GetSlot(), true);

    if (Item* childItem = m_Player->GetChildItemByGuid(itemTarget->GetChildItem()))
    {
        if (childItem->IsEquipped())
            m_Player->_ApplyItemMods(childItem, childItem->GetSlot(), false);
        childItem->CopyArtifactDataFromParent(itemTarget);
        if (childItem->IsEquipped())
            m_Player->_ApplyItemMods(childItem, childItem->GetSlot(), true);
    }

    itemTarget = player->GetItemByGuid(packet.ItemGuid);
    if (!itemTarget || !itemTarget->IsInWorld() || !player->IsInWorld())
    {
        sLog->outAshran("WorldSession::HandleSocketOpcode: Somehow the itemTarget is corrupt (player guid %u)", player->GetGUIDLow());
        return;
    }

    bool SocketBonusToBeActivated = itemTarget->GemsFitSockets();
    if (SocketBonusActivated ^ SocketBonusToBeActivated)
    {
        player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, false);
        itemTarget->SetEnchantment(BONUS_ENCHANTMENT_SLOT, (SocketBonusToBeActivated ? itemTarget->GetTemplate()->GetSocketBonus() : 0), 0, 0);
        player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, true);
    }

    player->ToggleMetaGemsActive(slot, true);

    player->RemoveTradeableItem(itemTarget);
    itemTarget->ClearSoulboundTradeable(player);

    itemTarget->SetState(ItemUpdateState::ITEM_CHANGED, player);

    SendPacket(WorldPackets::WPItem::SocketGemsResult(itemTarget->GetGUID()).Write());
}

void WorldSession::HandleCancelTempEnchantmentOpcode(WorldPacket& recvData)
{
    uint32 slot;

    recvData >> slot;

    // apply only to equipped item
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
        return;

    Item* item = GetPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

    if (!item)
        return;

    if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
        return;

    GetPlayer()->ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
    item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
}

void WorldSession::HandleItemRefundInfoRequest(WorldPacket& p_Packet)
{
    uint64 l_Guid = 0;
    p_Packet.readPackGUID(l_Guid);

    Item* l_Item = m_Player->GetItemByGuid(l_Guid);
    if (!l_Item)
        return;

    m_Player->SendRefundInfo(l_Item);
}

void WorldSession::HandleItemRefund(WorldPacket& p_Packet)
{
    uint64 l_Guid = 0;
    p_Packet.readPackGUID(l_Guid);

    Item* l_Item = m_Player->GetItemByGuid(l_Guid);
    if (!l_Item)
        return;

    m_Player->RefundItem(l_Item);
}

void WorldSession::HandleItemTextQuery(WorldPacket& p_RecvData)
{
    uint64 l_ItemGuid = 0;
    p_RecvData.readPackGUID(l_ItemGuid);

    WorldPacket l_Data(SMSG_QUERY_ITEM_TEXT_RESPONSE, 2048);

    if (Item* l_Item = m_Player->GetItemByGuid(l_ItemGuid))
    {
        l_Data.WriteBit(true);  ///< HasText
        l_Data.FlushBits();
        l_Data.WriteBits(l_Item->GetText().size(), 13);
        l_Data.FlushBits();
        l_Data.WriteString(l_Item->GetText());
        l_Data.appendPackGUID(l_ItemGuid);
    }
    else
    {
        l_Data.WriteBit(false);  ///< HasText
        l_Data.FlushBits();
        l_Data.WriteBits(0, 13);
        l_Data.FlushBits();
        l_Data.appendPackGUID(l_ItemGuid);
    }

    SendPacket(&l_Data);
}

void WorldSession::HandleChangeCurrencyFlags(WorldPacket& recvPacket)
{
    uint32 currencyId, flags;

    recvPacket >> flags >> currencyId;

    if (GetPlayer())
        GetPlayer()->ModifyCurrencyFlags(currencyId, uint8(flags));
}

void WorldSession::SendItemUpgradeResult(bool /*success*/)
{
}

void WorldSession::HandleUpgradeItemOpcode(WorldPacket& /*recvData*/)
{
    /// Upgrade system will be implemented back because of WoD 6.1.2
    /*sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_UPGRADE_ITEM");

    ObjectGuid npcGuid;
    ObjectGuid itemGuid;
    Player* player = GetPlayer();

    uint32 item_slot = 0;
    uint32 upgradeEntry = 0;
    uint32 item_bag = 0;
    recvData >> item_slot >> upgradeEntry >> item_bag;

    npcGuid[6] = recvData.ReadBit();
    itemGuid[4] = recvData.ReadBit();
    itemGuid[3] = recvData.ReadBit();
    itemGuid[5] = recvData.ReadBit();
    npcGuid[5] = recvData.ReadBit();
    itemGuid[1] = recvData.ReadBit();
    npcGuid[7] = recvData.ReadBit();
    npcGuid[3] = recvData.ReadBit();
    itemGuid[6] = recvData.ReadBit();
    itemGuid[2] = recvData.ReadBit();
    npcGuid[2] = recvData.ReadBit();
    npcGuid[4] = recvData.ReadBit();
    itemGuid[7] = recvData.ReadBit();
    npcGuid[1] = recvData.ReadBit();
    npcGuid[0] = recvData.ReadBit();
    itemGuid[0] = recvData.ReadBit();

    recvData.FlushBits();

    recvData.ReadByteSeq(itemGuid[4]);
    recvData.ReadByteSeq(itemGuid[5]);
    recvData.ReadByteSeq(npcGuid[3]);
    recvData.ReadByteSeq(npcGuid[0]);
    recvData.ReadByteSeq(itemGuid[1]);
    recvData.ReadByteSeq(itemGuid[3]);
    recvData.ReadByteSeq(itemGuid[7]);
    recvData.ReadByteSeq(npcGuid[7]);
    recvData.ReadByteSeq(npcGuid[6]);
    recvData.ReadByteSeq(itemGuid[2]);
    recvData.ReadByteSeq(npcGuid[1]);
    recvData.ReadByteSeq(npcGuid[4]);
    recvData.ReadByteSeq(npcGuid[5]);
    recvData.ReadByteSeq(itemGuid[0]);
    recvData.ReadByteSeq(itemGuid[6]);
    recvData.ReadByteSeq(npcGuid[2]);

    if (!player->GetNPCIfCanInteractWithFlag2(npcGuid, UNIT_NPC_FLAG2_ITEM_UPGRADE))
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(npcGuid));
        SendItemUpgradeResult(false);
        return;
    }

    Item* item = player->GetItemByGuid(itemGuid);
    if (!item)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    // Check if item guid is the same as item related to bag and slot
    if (Item* tempItem = player->GetItemByPos(item_bag, item_slot))
    {
        if (item != tempItem)
        {
            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
            SendItemUpgradeResult(false);
            return;
        }
    }
    else
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    ItemUpgradeEntry const* itemUpEntry = sItemUpgradeStore.LookupEntry(upgradeEntry);
    if (!itemUpEntry)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) not found.", upgradeEntry);
        SendItemUpgradeResult(false);
        return;
    }

    // Check if player has enough currency
    if (player->GetCurrency(itemUpEntry->currencyId, false) < itemUpEntry->currencyCost)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - Player has not enougth currency (ID: %u, Cost: %u) not found.", itemUpEntry->currencyId, itemUpEntry->currencyCost);
        SendItemUpgradeResult(false);
        return;
    }

    uint32 actualUpgrade = item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 2);
    if (actualUpgrade != itemUpEntry->precItemUpgradeId)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) is not related to this ItemUpgradePath (%u).", itemUpEntry->Id, actualUpgrade);
        SendItemUpgradeResult(false);
        return;
    }

    item->SetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, 2, itemUpEntry->Id);
    item->SetFlag(ITEM_FIELD_MODIFIERS_MASK, 0x1 | ITEM_TRANSMOGRIFIED | 0x4);
    item->SetState(ITEM_CHANGED, player);

    // Don't forget to remove currency cost
    SendItemUpgradeResult(true);

    //if (item->IsEquipped())
    //    player->ApplyItemUpgrade(item, true);

    player->ModifyCurrency(itemUpEntry->currencyId, -int32(itemUpEntry->currencyCost), false, true, true);*/
}

void WorldSession::HandleSetLootSpecialization(WorldPacket& p_RecvData)
{
    uint32 l_SpecID = p_RecvData.read<uint32>();
    GetPlayer()->SetLootSpecId(l_SpecID);
    GetPlayer()->SetUInt32Value(PLAYER_FIELD_LOOT_SPEC_ID, l_SpecID);
}

/// This anonymous namespace contains utility functions for handling BagAutoSort.
namespace
{
    /// Look in the bag if the item can be store or stacked.
    bool StoreItemAndStack(Player* p_Player, Item* p_Item, uint8 p_BagSlot)
    {
        uint16 l_Src = p_Item->GetPos();

        ItemPosCountVec l_Dest;
        InventoryResult l_Result = p_Player->CanStoreItem(p_BagSlot, NULL_SLOT, l_Dest, p_Item, false);
        if (l_Result == EQUIP_ERR_OK && !(l_Dest.size() == 1 && l_Dest[0].pos == l_Src))
        {
            p_Player->RemoveItem(p_Item->GetBagSlot(), p_Item->GetSlot(), true);
            p_Player->StoreItem(l_Dest, p_Item, true);

            return true;
        }

        return false;
    }

    bool BankItemAndStack(Player* p_Player, Item* p_Item, uint8 p_BagSlot)
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = p_Player->CanBankItem(p_BagSlot, NULL_SLOT, l_Dest, p_Item, false);

        if (l_Msg != EQUIP_ERR_OK)
            return false;

        p_Player->RemoveItem(p_Item->GetBagSlot(), p_Item->GetSlot(), true);
        p_Player->BankItem(l_Dest, p_Item, true);

        return true;
    }

    bool ReagentBankItemAndStack(Player* p_Player, Item* p_Item)
    {
        ItemPosCountVec l_Dest;
        InventoryResult l_Msg = p_Player->CanReagentBankItem(InventorySlot::NULL_BAG, InventorySlot::NULL_SLOT, l_Dest, p_Item, false);

        if (l_Msg != InventoryResult::EQUIP_ERR_OK)
            return false;

        p_Player->RemoveItem(p_Item->GetBagSlot(), p_Item->GetSlot(), true);
        p_Player->BankItem(l_Dest, p_Item, true);
        return true;
    }

    /// Loop through all the bags to see if it can be stack or not.
    void StoreItemInBags(Player* p_Player, Item* p_Item)
    {
        if (StoreItemAndStack(p_Player, p_Item, INVENTORY_SLOT_BAG_0))
            return;

        for (uint32 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
        {
            if (StoreItemAndStack(p_Player, p_Item, l_I))
                break;
        }
    }

    /// Loop through all the bags to see if it can be stack or not.
    void StoreItemInBanks(Player* p_Player, Item* p_Item)
    {
        if (BankItemAndStack(p_Player, p_Item, NULL_SLOT))
            return;

        for (uint32 l_I = BANK_SLOT_BAG_START; l_I < BANK_SLOT_BAG_END; l_I++)
        {
            if (BankItemAndStack(p_Player, p_Item, l_I))
                break;
        }
    }
}

void WorldSession::HandleSortBags(WorldPacket& /*p_RecvData*/)
{
    WorldPacket data(SMSG_SORT_BAGS_RESULT);
    SendPacket(&data);

    Player* l_Player = this->m_Player;

    if (!l_Player)
        return;

    /// First pass to stack items.
    l_Player->ApplyOnBagsItems([](Player* p_Player, Item* p_Item, uint8 /*p_BagSlot*/, uint8)
    {
        StoreItemInBags(p_Player, p_Item);
        return true;
    });

    using t_uint32Pair = std::pair<uint32, Item*>;
    std::unordered_map<uint32, uint32> l_ItemsQuality;
    std::multimap<uint32, Item*> l_Items;

    /// Second pass, we collect the informations for sorting.
    l_Player->ApplyOnBagsItems([&l_Items, &l_ItemsQuality](Player* p_Player, Item* p_Item, uint8 /*p_BagSlot*/, uint8)
    {
        ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(p_Item->GetEntry());
        if (!l_Proto)
            return true;

        /// We get the number of non-distinct items and item level for sorting.
        l_Items.insert(std::make_pair(p_Item->GetEntry(), p_Item));
        l_ItemsQuality[p_Item->GetEntry()] = p_Item->GetItemLevel(p_Player);

        return true;
    });

    /// We get advantage of the multimap properties to sort our items.
    std::multimap<uint32, t_uint32Pair> l_ResultMap;
    for (auto const& l_Pair : l_Items)
        l_ResultMap.insert(std::make_pair(l_ItemsQuality[l_Pair.first], l_Pair));

    /// Third pass to swap all the items correctly.
    auto l_Itr = std::begin(l_ResultMap);
    l_Player->ApplyOnBagsItems([&l_ResultMap, &l_Itr](Player* p_Player, Item* /*p_Item*/, uint8 p_BagSlot, uint8 p_ItemSlot)
    {
        if (l_Itr == std::end(l_ResultMap))
            return false;

        uint16 l_Pos = l_Itr->second.second->GetPos();
        p_Player->SwapItem(l_Pos, (p_BagSlot << 8) | p_ItemSlot);
        l_Itr++;

        return true;
    });
}

void WorldSession::HandleSortReagentBankBagsOpcode(WorldPacket& p_RecvData)
{
    bool l_IsReagentBank = p_RecvData.GetOpcode() == Opcodes::CMSG_SORT_REAGENT_BANK_BAGS;

    WorldPacket l_Data(SMSG_SORT_BAGS_RESULT);
    SendPacket(&l_Data);

    Player* l_Player = m_Player;
    if (!l_Player)
        return;

    /// First pass to stack items.
    if (l_IsReagentBank)
    {
        l_Player->ApplyOnReagentBankItems([](Player* p_Player, Item* p_Item, uint8 /*p_BagSlot*/, uint8)
        {
            return ReagentBankItemAndStack(p_Player, p_Item);
        });
    }
    else
    {
        l_Player->ApplyOnBankItems([](Player* p_Player, Item* p_Item, uint8 /*p_BagSlot*/, uint8)
        {
            StoreItemInBanks(p_Player, p_Item);
            return true;
        });
    }

    using t_uint32Pair = std::pair<uint32, Item*>;
    std::unordered_map<uint32, uint32> l_BankItemsQuality;
    std::multimap<uint32, Item*> l_BankItems;

    /// Second pass, we collect the informations for sorting.
    {
        auto l_CollectInfos = ([&l_BankItems, &l_BankItemsQuality](Player* p_Player, Item* p_Item, uint8 /*p_BagSlot*/, uint8)
        {
            ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(p_Item->GetEntry());
            if (!l_Proto)
                return true;

            /// We get the number of non-distinct items and item level for sorting.
            l_BankItems.insert(std::make_pair(p_Item->GetEntry(), p_Item));
            l_BankItemsQuality[p_Item->GetEntry()] = p_Item->GetItemLevel(p_Player);

            return true;
        });

        if (l_IsReagentBank)
            l_Player->ApplyOnReagentBankItems(l_CollectInfos);
        else
            l_Player->ApplyOnBankItems(l_CollectInfos);
    }

    /// We get advantage of the multimap properties to sort our items.
    std::multimap<uint32, t_uint32Pair> l_BankResultMap; ///< Bank items.
    for (auto const& l_Pair : l_BankItems)
        l_BankResultMap.insert(std::make_pair(l_BankItemsQuality[l_Pair.first], l_Pair));

    /// Third pass to swap all the items correctly.
    {
        auto l_BankItr = std::begin(l_BankResultMap);
        auto l_SwapFunction = ([&l_BankResultMap, &l_BankItr](Player* p_Player, Item* /*p_Item*/, uint8 p_BagSlot, uint8 p_ItemSlot)
        {
            if (l_BankItr == std::end(l_BankResultMap))
                return false;

            uint16 l_Pos = l_BankItr->second.second->GetPos();
            p_Player->SwapItem(l_Pos, (p_BagSlot << 8) | p_ItemSlot);
            l_BankItr++;

            return true;
        });

        if (l_IsReagentBank)
            l_Player->ApplyOnReagentBankItems(l_SwapFunction);
        else
            l_Player->ApplyOnBankItems(l_SwapFunction);
    }
}

void WorldSession::HandleUseCritterItemOpcode(WorldPacket& p_RecvData)
{
    uint64 l_ItemGuid = 0;

    p_RecvData.readPackGUID(l_ItemGuid);

    if (Item* l_Item = m_Player->GetItemByGuid(l_ItemGuid))
    {
        SpellCastTargets l_Targets;
        l_Targets.SetCaster(m_Player);

        l_Targets.Initialize(0, 0, 0, 0, WorldLocation(), 0, WorldLocation());
        l_Targets.SetElevation(0.0f);
        l_Targets.SetSpeed(0.0f);
        l_Targets.Update(m_Player);

        if (!sScriptMgr->OnItemUse(m_Player, l_Item, l_Targets))
            m_Player->CastItemUseSpell(l_Item, l_Targets, Guid128(GUID_TYPE_CAST, 0, 0, 0), 0, 0);
    }
}

void WorldSession::HandleChangeBagSlotFlagOpcode(WorldPacket& p_RecvPacket)
{
    uint32 l_BagSlot    = p_RecvPacket.read<uint32>();
    uint32 l_BagFlags   = p_RecvPacket.read<uint32>();
    bool   l_On         = p_RecvPacket.ReadBit();

    Bag* l_Bag = m_Player->GetBagByPos(InventorySlots::INVENTORY_SLOT_BAG_START + l_BagSlot);
    if (l_Bag == nullptr)
        return;

    l_Bag->ApplyModBagFlag(l_BagFlags, l_On);
    l_Bag->SetState(ItemUpdateState::ITEM_CHANGED, m_Player);

    m_Player->SetUInt32Value(EPlayerFields::PLAYER_FIELD_BAG_SLOT_FLAGS + l_BagSlot, l_Bag->GetBagFlags());
}

void WorldSession::HandleChangeBankBagSlotFlagOpcode(WorldPacket& p_RecvPacket)
{
    uint32 l_BagSlot    = p_RecvPacket.read<uint32>();
    uint32 l_BagFlags   = p_RecvPacket.read<uint32>();
    bool   l_On         = p_RecvPacket.ReadBit();

    Bag* l_Bag = m_Player->GetBagByPos(BankBagSlots::BANK_SLOT_BAG_START + l_BagSlot);
    if (l_Bag == nullptr)
        return;

    l_Bag->ApplyModBagFlag(l_BagFlags, l_On);
    l_Bag->SetState(ItemUpdateState::ITEM_CHANGED, m_Player);

    m_Player->SetUInt32Value(EPlayerFields::PLAYER_FIELD_BANK_BAG_SLOT_FLAGS + l_BagSlot, l_Bag->GetBagFlags());
}

void WorldSession::HandleSetBackpackAutoSortDisable(WorldPacket& p_RecvPacket)
{
    m_Player->SetBackPackAutoSortDisabled(p_RecvPacket.ReadBit());
}
