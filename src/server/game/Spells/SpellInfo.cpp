////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include "SpellAuraDefines.h"
#include "SpellInfo.h"
#include "SpellMgr.h"
#include "Spell.h"
#include "DB2Stores.h"
#include "ConditionMgr.h"
#include "Vehicle.h"
#include "Group.h"
#include "CreatureAI.h"
#include "GameTables.h"
#include "Formulas.h"
#include "LFGMgr.h"

uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
{
    switch (objType)
    {
        case TARGET_OBJECT_TYPE_DEST:
            return TARGET_FLAG_DEST_LOCATION;
        case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
            return TARGET_FLAG_DEST_LOCATION | TARGET_FLAG_UNIT;
        case TARGET_OBJECT_TYPE_CORPSE_ALLY:
            return TARGET_FLAG_CORPSE_ALLY;
        case TARGET_OBJECT_TYPE_CORPSE_ENEMY:
            return TARGET_FLAG_CORPSE_ENEMY;
        case TARGET_OBJECT_TYPE_CORPSE:
            return TARGET_FLAG_CORPSE_ALLY | TARGET_FLAG_CORPSE_ENEMY;
        case TARGET_OBJECT_TYPE_UNIT:
            return TARGET_FLAG_UNIT;
        case TARGET_OBJECT_TYPE_GOBJ:
            return TARGET_FLAG_GAMEOBJECT;
        case TARGET_OBJECT_TYPE_GOBJ_ITEM:
            return TARGET_FLAG_GAMEOBJECT_ITEM;
        case TARGET_OBJECT_TYPE_ITEM:
            return TARGET_FLAG_ITEM;
        case TARGET_OBJECT_TYPE_SRC:
            return TARGET_FLAG_SOURCE_LOCATION;
        default:
            return TARGET_FLAG_NONE;
    }
}

uint8 GetClassBySpec(uint32 spec)
{
    ChrSpecializationsEntry const* l_Entry = sChrSpecializationsStore.LookupEntry(spec);

    if (l_Entry)
        return l_Entry->ClassID;

    return CLASS_NONE;
}

SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
{
    _target = Targets(target);
}

bool SpellImplicitTargetInfo::IsArea() const
{
    switch (GetSelectionCategory())
    {
        case SpellTargetSelectionCategories::TARGET_SELECT_CATEGORY_AREA:
        case SpellTargetSelectionCategories::TARGET_SELECT_CATEGORY_CONE:
        case SpellTargetSelectionCategories::TARGET_SELECT_CATEGORY_CYLINDER:
            return true;
        default:
            return false;
    }
}

SpellTargetSelectionCategories SpellImplicitTargetInfo::GetSelectionCategory() const
{
    return _data[_target].SelectionCategory;
}

SpellTargetReferenceTypes SpellImplicitTargetInfo::GetReferenceType() const
{
    return _data[_target].ReferenceType;
}

SpellTargetObjectTypes SpellImplicitTargetInfo::GetObjectType() const
{
    return _data[_target].ObjectType;
}

SpellTargetCheckTypes SpellImplicitTargetInfo::GetCheckType() const
{
    return _data[_target].SelectionCheckType;
}

SpellTargetDirectionTypes SpellImplicitTargetInfo::GetDirectionType() const
{
    return _data[_target].DirectionType;
}

float SpellImplicitTargetInfo::CalcDirectionAngle() const
{
    switch (GetDirectionType())
    {
        case TARGET_DIR_FRONT:
            return 0.0f;
        case TARGET_DIR_BACK:
            return static_cast<float>(M_PI);
        case TARGET_DIR_RIGHT:
            return static_cast<float>(-M_PI/2);
        case TARGET_DIR_LEFT:
            return static_cast<float>(M_PI/2);
        case TARGET_DIR_FRONT_RIGHT:
            return static_cast<float>(-M_PI/4);
        case TARGET_DIR_BACK_RIGHT:
            return static_cast<float>(-3*M_PI/4);
        case TARGET_DIR_BACK_LEFT:
            return static_cast<float>(3*M_PI/4);
        case TARGET_DIR_FRONT_LEFT:
            return static_cast<float>(M_PI/4);
        case TARGET_DIR_RANDOM:
            return float(rand_norm())*static_cast<float>(2*M_PI);
        default:
            return 0.0f;
    }
}

Targets SpellImplicitTargetInfo::GetTarget() const
{
    return _target;
}

uint32 SpellImplicitTargetInfo::GetExplicitTargetMask(bool& srcSet, bool& dstSet) const
{
    if (_target >= TOTAL_SPELL_TARGETS)
    {
        printf("SPELL_TARGET overflow!! %d\r\n", _target); ///< Bad sprintf :'(
        return 0;
    }

    uint32 targetMask = 0;
    if (GetTarget() == TARGET_DEST_TRAJ)
    {
        if (!srcSet)
            targetMask = TARGET_FLAG_SOURCE_LOCATION;
        if (!dstSet)
            targetMask |= TARGET_FLAG_DEST_LOCATION;
    }
    else
    {
        switch (GetReferenceType())
        {
            case TARGET_REFERENCE_TYPE_SRC:
                if (srcSet)
                    break;
                targetMask = TARGET_FLAG_SOURCE_LOCATION;
                break;
            case TARGET_REFERENCE_TYPE_DEST:
                if (dstSet)
                    break;
                targetMask = TARGET_FLAG_DEST_LOCATION;
                break;
            case TARGET_REFERENCE_TYPE_TARGET:
                switch (GetObjectType())
                {
                    case TARGET_OBJECT_TYPE_GOBJ:
                        targetMask = TARGET_FLAG_GAMEOBJECT;
                        break;
                    case TARGET_OBJECT_TYPE_GOBJ_ITEM:
                        targetMask = TARGET_FLAG_GAMEOBJECT_ITEM;
                        break;
                    case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
                    case TARGET_OBJECT_TYPE_UNIT:
                    case TARGET_OBJECT_TYPE_DEST:
                        switch (GetCheckType())
                        {
                            case TARGET_CHECK_ENEMY:
                                targetMask = TARGET_FLAG_UNIT_ENEMY;
                                break;
                            case TARGET_CHECK_ALLY:
                            case TARGET_CHECK_ALLY_OR_RAID:
                                targetMask = TARGET_FLAG_UNIT_ALLY;
                                break;
                            case TARGET_CHECK_PARTY:
                                targetMask = TARGET_FLAG_UNIT_PARTY;
                                break;
                            case TARGET_CHECK_RAID:
                                targetMask = TARGET_FLAG_UNIT_RAID;
                                break;
                            case TARGET_CHECK_PASSENGER:
                                targetMask = TARGET_FLAG_UNIT_PASSENGER;
                                break;
                            case TARGET_CHECK_RAID_CLASS:
                            default:
                                targetMask = TARGET_FLAG_UNIT;
                                break;
                        }
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    }

    switch (GetObjectType())
    {
        case TARGET_OBJECT_TYPE_SRC:
            srcSet = true;
            break;
        case TARGET_OBJECT_TYPE_DEST:
        case TARGET_OBJECT_TYPE_UNIT_AND_DEST:
            dstSet = true;
            break;
        default:
            break;
    }
    return targetMask;
}

SpellImplicitTargetInfo::StaticData  SpellImplicitTargetInfo::_data[TOTAL_SPELL_TARGETS] =
{
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 0
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 1 TARGET_UNIT_CASTER
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 2 TARGET_UNIT_NEARBY_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 3 TARGET_UNIT_NEARBY_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 4 TARGET_UNIT_NEARBY_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 5 TARGET_UNIT_PET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 6 TARGET_UNIT_TARGET_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 7 TARGET_UNIT_SRC_AREA_ENTRY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 8 TARGET_UNIT_DEST_AREA_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 9 TARGET_DEST_HOME
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 10
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 11 TARGET_UNIT_SRC_AREA_UNK_11
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 12
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 13
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 14
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 15 TARGET_UNIT_SRC_AREA_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 16 TARGET_UNIT_DEST_AREA_ENEMY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 17 TARGET_DEST_DB
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 18 TARGET_DEST_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 19
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 20 TARGET_UNIT_CASTER_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 21 TARGET_UNIT_TARGET_ALLY
    { TARGET_OBJECT_TYPE_SRC,       TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 22 TARGET_SRC_CASTER
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 23 TARGET_GAMEOBJECT_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 24 TARGET_UNIT_CONE_ENEMY_24
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 25 TARGET_UNIT_TARGET_ANY
    { TARGET_OBJECT_TYPE_GOBJ_ITEM, TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 26 TARGET_GAMEOBJECT_ITEM_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 27 TARGET_UNIT_MASTER
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 28 TARGET_DEST_DYNOBJ_ENEMY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 29 TARGET_DEST_DYNOBJ_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 30 TARGET_UNIT_SRC_AREA_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 31 TARGET_UNIT_DEST_AREA_ALLY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 32 TARGET_DEST_CASTER_SUMMON
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 33 TARGET_UNIT_SRC_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 34 TARGET_UNIT_DEST_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 35 TARGET_UNIT_TARGET_PARTY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 36 TARGET_DEST_CASTER_UNK_36
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_LAST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_PARTY,         TARGET_DIR_NONE         },  ///< 37 TARGET_UNIT_LASTTARGET_AREA_PARTY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 38 TARGET_UNIT_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 39 TARGET_DEST_CASTER_FISHING
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 40 TARGET_GAMEOBJECT_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 41 TARGET_DEST_CASTER_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 42 TARGET_DEST_CASTER_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 43 TARGET_DEST_CASTER_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 44 TARGET_DEST_CASTER_FRONT_LEFT
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 45 TARGET_UNIT_TARGET_CHAINHEAL_ALLY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_ENTRY,         TARGET_DIR_NONE         },  ///< 46 TARGET_DEST_NEARBY_ENTRY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 47 TARGET_DEST_CASTER_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 48 TARGET_DEST_CASTER_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 49 TARGET_DEST_CASTER_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 50 TARGET_DEST_CASTER_LEFT
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 51 TARGET_GAMEOBJECT_SRC_AREA
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 52 TARGET_GAMEOBJECT_DEST_AREA
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 53 TARGET_DEST_TARGET_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 54 TARGET_UNIT_CONE_ENEMY_54
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 55 TARGET_DEST_CASTER_FRONT_LEAP
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 56 TARGET_UNIT_CASTER_AREA_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 57 TARGET_UNIT_TARGET_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_NEARBY,      TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 58 TARGET_UNIT_NEARBY_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ALLY,          TARGET_DIR_FRONT        },  ///< 59 TARGET_UNIT_CONE_ALLY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENTRY,         TARGET_DIR_FRONT        },  ///< 60 TARGET_UNIT_CONE_ENTRY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_RAID_CLASS,    TARGET_DIR_NONE         },  ///< 61 TARGET_UNIT_TARGET_AREA_RAID_CLASS
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 62 TARGET_DEST_DEST_UNK_62
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 63 TARGET_DEST_TARGET_ANY
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 64 TARGET_DEST_TARGET_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 65 TARGET_DEST_TARGET_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 66 TARGET_DEST_TARGET_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 67 TARGET_DEST_TARGET_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 68 TARGET_DEST_TARGET_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 69 TARGET_DEST_TARGET_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 70 TARGET_DEST_TARGET_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 71 TARGET_DEST_TARGET_FRONT_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 72 TARGET_DEST_CASTER_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 73 TARGET_DEST_CASTER_RADIUS
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 74 TARGET_DEST_TARGET_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 75 TARGET_DEST_TARGET_RADIUS
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 76 TARGET_DEST_CHANNEL_TARGET
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 77 TARGET_UNIT_CHANNEL_TARGET
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 78 TARGET_DEST_DEST_FRONT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK         },  ///< 79 TARGET_DEST_DEST_BACK
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RIGHT        },  ///< 80 TARGET_DEST_DEST_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_LEFT         },  ///< 81 TARGET_DEST_DEST_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_RIGHT  },  ///< 82 TARGET_DEST_DEST_FRONT_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_RIGHT   },  ///< 83 TARGET_DEST_DEST_BACK_RIGHT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_BACK_LEFT    },  ///< 84 TARGET_DEST_DEST_BACK_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT_LEFT   },  ///< 85 TARGET_DEST_DEST_FRONT_LEFT
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 86 TARGET_DEST_DEST_RANDOM
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 87 TARGET_DEST_DEST
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 88 TARGET_DEST_DYNOBJ_NONE
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 89 TARGET_DEST_TRAJ
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 90 TARGET_UNIT_TARGET_MINIPET
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 91 TARGET_DEST_DEST_RADIUS
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 92 TARGET_UNIT_SUMMONER
    { TARGET_OBJECT_TYPE_CORPSE,    TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 93 TARGET_CORPSE_SRC_AREA_ENEMY
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 94 TARGET_UNIT_VEHICLE
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_PASSENGER,     TARGET_DIR_NONE         },  ///< 95 TARGET_UNIT_TARGET_PASSENGER
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 96 TARGET_UNIT_PASSENGER_0
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 97 TARGET_UNIT_PASSENGER_1
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 98 TARGET_UNIT_PASSENGER_2
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 99 TARGET_UNIT_PASSENGER_3
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 100 TARGET_UNIT_PASSENGER_4
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 101 TARGET_UNIT_PASSENGER_5
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 102 TARGET_UNIT_PASSENGER_6
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 103 TARGET_UNIT_PASSENGER_7
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 104 TARGET_UNIT_CONE_ENEMY_104
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 105 TARGET_UNIT_UNK_105
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CHANNEL,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 106 TARGET_DEST_CHANNEL_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 107 TARGET_DEST_EXTRA_TARGETS
    { TARGET_OBJECT_TYPE_GOBJ,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_DEFAULT,       TARGET_DIR_FRONT        },  ///< 108 TARGET_GAMEOBJECT_CONE
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 109
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 110 TARGET_UNIT_CONE_ENEMY_110
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 111
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 112
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 113
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 114
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 115
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 116
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 117
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ALLY_OR_RAID,  TARGET_DIR_NONE         },  ///< 118 TARGET_UNIT_ALLY_OR_RAID
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_RAID,          TARGET_DIR_NONE         },  ///< 119
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_SUMMON,        TARGET_DIR_NONE         },  ///< 120 TARGET_UNIT_CASTER_AREA_SUMMON
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 121 TARGET_UNIT_RESURRECT
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 122 TARGET_UNIT_TARGET_SELECT2
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 123
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 124
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 125 TARGET_DEST_CASTER_2
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 126
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 127
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 128
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 129 TARGET_UNIT_ENEMY_BETWEEN_DEST
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 130 TARGET_UNIT_ENEMY_BETWEEN_DEST_2
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 131
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_ALLY,          TARGET_DIR_NONE         },  ///< 132 TARGET_DEST_TARGET_FRIEND
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 133
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_TARGET,   TARGET_SELECT_CATEGORY_CYLINDER,    TARGET_CHECK_ENEMY,         TARGET_DIR_FRONT        },  ///< 134 TARGET_ENNEMIES_IN_CYLINDER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 135
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_CONE,        TARGET_CHECK_ALLY,          TARGET_DIR_FRONT        },  ///< 136 TARGET_UNIT_ALLY_CONE_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 137
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_DEST,     TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 138 TARGET_DEST_TARGET_SELECT
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 139
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 140
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 141
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 142
    { TARGET_OBJECT_TYPE_UNIT,      TARGET_REFERENCE_TYPE_SRC,      TARGET_SELECT_CATEGORY_AREA,        TARGET_CHECK_ENEMY,         TARGET_DIR_NONE         },  ///< 143 TARGET_ENNEMIES_AROUND_CASTER
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 144
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 145
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 146
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 147
    { TARGET_OBJECT_TYPE_NONE,      TARGET_REFERENCE_TYPE_NONE,     TARGET_SELECT_CATEGORY_NYI,         TARGET_CHECK_DEFAULT,       TARGET_DIR_NONE         },  ///< 148
    { TARGET_OBJECT_TYPE_DEST,      TARGET_REFERENCE_TYPE_CASTER,   TARGET_SELECT_CATEGORY_DEFAULT,     TARGET_CHECK_DEFAULT,       TARGET_DIR_RANDOM       },  ///< 149
};

SpellEffectInfo::SpellEffectInfo(SpellEntry const* spellEntry, SpellInfo const* spellInfo, uint8 effIndex, uint32 difficulty)
{
    auto l_Effect    = spellEntry->GetSpellEffect(effIndex, difficulty);

    _spellInfo = spellInfo;
    _effIndex = effIndex;
    Effect = l_Effect ? l_Effect->Effect : 0;
    ApplyAuraName = l_Effect ? l_Effect->EffectApplyAuraName : 0;
    Amplitude = l_Effect ? l_Effect->EffectAmplitude : 0;
    DieSides = l_Effect ? l_Effect->EffectDieSides : 0;
    RealPointsPerLevel = l_Effect ? l_Effect->EffectRealPointsPerLevel : 0.0f;
    BasePoints = l_Effect ? l_Effect->EffectBasePoints : 0;

    /// This aura is handled only with negatives values
    if (ApplyAuraName == AuraType::SPELL_AURA_MOD_DECREASE_SPEED && BasePoints > 0)
        BasePoints = -BasePoints;

    PointsPerComboPoint = l_Effect ? l_Effect->EffectPointsPerComboPoint : 0.0f;
    ValueMultiplier = l_Effect ? l_Effect->EffectValueMultiplier : 0.0f;
    DamageMultiplier = l_Effect ? l_Effect->EffectDamageMultiplier : 0.0f;
    BonusMultiplier = l_Effect ? l_Effect->EffectBonusMultiplier : 0.0f;
    MiscValue = l_Effect ? l_Effect->EffectMiscValue : 0;
    MiscValueB = l_Effect ? l_Effect->EffectMiscValueB : 0;
    Mechanic = Mechanics(l_Effect ? l_Effect->EffectMechanic : 0);
    TargetA = SpellImplicitTargetInfo(l_Effect ? l_Effect->EffectImplicitTargetA : 0);
    TargetB = SpellImplicitTargetInfo(l_Effect ? l_Effect->EffectImplicitTargetB : 0);
    RadiusEntry = l_Effect && l_Effect->EffectRadiusIndex ? sSpellRadiusStore.LookupEntry(l_Effect->EffectRadiusIndex) : nullptr;
    MaxRadiusEntry = l_Effect && l_Effect->EffectRadiusMaxIndex ? sSpellRadiusStore.LookupEntry(l_Effect->EffectRadiusMaxIndex) : nullptr;
    if (!RadiusEntry)
    {
        RadiusEntry = MaxRadiusEntry;
        MaxRadiusEntry = nullptr;
    }

    ChainTarget = l_Effect ? l_Effect->EffectChainTarget : 0;
    ItemType = l_Effect ? l_Effect->EffectItemType : 0;
    TriggerSpell = l_Effect ? l_Effect->EffectTriggerSpell : 0;
    SpellClassMask = l_Effect ? l_Effect->EffectSpellClassMask : flag128(0);
    ImplicitTargetConditions = nullptr;
    ScalingMultiplier = l_Effect ? l_Effect->Coefficient : 0.0f;
    DeltaScalingMultiplier = l_Effect ? l_Effect->Variance : 0.0f;
    ComboScalingMultiplier = l_Effect ? l_Effect->ResourceCoefficient : 0.0f;
    AttackPowerMultiplier = l_Effect ? l_Effect->BonusCoefficientFromAP : 0.0f;
    GroupSizeCoefficient = l_Effect ? l_Effect->GroupSizeCoefficient : 0.0f;
    m_CanBeStacked = true;
    m_AmountNotAlterByStacks = false;
}

SpellEffectInfo::SpellEffectInfo()
{
    _spellInfo = nullptr;
    _effIndex = 0;
    Effect = 0;
    ApplyAuraName = 0;
    Amplitude =  0;
    DieSides = 0;
    RealPointsPerLevel = 0.0f;
    BasePoints = 0;
    PointsPerComboPoint = 0.0f;
    ValueMultiplier = 0.0f;
    DamageMultiplier = 0.0f;
    BonusMultiplier =  0.0f;
    MiscValue = 0;
    MiscValueB =  0;
    Mechanic = Mechanics(0);
    TargetA = SpellImplicitTargetInfo(0);
    TargetB = SpellImplicitTargetInfo(0);
    RadiusEntry = nullptr;
    MaxRadiusEntry = nullptr;
    ChainTarget = 0;
    ItemType = 0;
    TriggerSpell = 0;
    SpellClassMask = flag128(0);
    ImplicitTargetConditions = nullptr;
    ScalingMultiplier = 0.0f;
    DeltaScalingMultiplier = 0.0f;
    ComboScalingMultiplier = 0.0f;
    AttackPowerMultiplier = 0.0f;
    GroupSizeCoefficient = 0.0f;
    m_CanBeStacked = true;
    m_AmountNotAlterByStacks = false;
}

bool SpellEffectInfo::IsEffect() const
{
    return Effect != 0;
}

bool SpellEffectInfo::IsEffect(SpellEffects effectName) const
{
    return Effect == uint32(effectName);
}

bool SpellEffectInfo::IsAura() const
{
    return (IsUnitOwnedAuraEffect() || Effect == SPELL_EFFECT_PERSISTENT_AREA_AURA) && ApplyAuraName != 0;
}

bool SpellEffectInfo::IsPersistenAura() const
{
    return Effect == SPELL_EFFECT_PERSISTENT_AREA_AURA && ApplyAuraName != 0;
}

bool SpellEffectInfo::IsAura(AuraType aura) const
{
    return IsAura() && AuraType(ApplyAuraName) == uint32(aura);
}

bool SpellEffectInfo::IsTargetingArea() const
{
    if (_spellInfo)
    {
        switch (_spellInfo->Id)
        {
            case 198641: ///< Whirling Blade (BRH: Kur'talos Ravencrest)
            case 193513: ///< Bane (MoS: Ymiron)
            case 194232: ///< Nether Rip (Mos: Harbaron)
            case 194235: ///< Nether Rip DoT (MoS: Harbaron)
            case 197262: ///< Taint of the Sea (MoS: Helya)
            case 202098: ///< Brackwater Barrage (MoS: Helya)
            case 195309: ///< Swirling Water (MoS: Helya)
            case 192053: ///< Quicksand(EoA: Warlord Parjesh)
            case 192135: ///< Bellowing Roar (EoA: Hatecoil Shellbreaker)
            case 192801: ///< Tidal Wave (EoA: Wrath of Azshara)
            case 192675: ///< Mystic Tornado (EoA: Wrath of Azshara)
            case 192800: ///< Chocking Dust (Neltharions's Lair: Rokmora)
            case 193267: ///< Falling Debris (Neltharion's Lair: Ularog Cragshaper)
            case 216407: ///< Lava Geyser (Neltharion's Lair: Dargrul the Underking)
            case 198408: ///< NightFall (DHT: Archdruid Glaidalis)
            case 198376: ///< Primal Rampage (DHT: Archdruid Glaidalis)
            case 220855: ///< Down Draft (DHT: Dresaron)
            case 199460: ///< Falling Rocks (DHT: Dresaron)
            case 194945: ///< Lingering Gaze (VoW: Glazer)
            case 118459: ///< Beast Cleave (Hunter BM)
                return true;
            default:
                break;
        }
    }

    return TargetA.IsArea() || TargetB.IsArea();
}

bool SpellEffectInfo::IsAreaAuraEffect() const
{
    if (Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY    ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID     ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_FRIEND   ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_ENEMY    ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_PET      ||
        Effect == SPELL_EFFECT_APPLY_AREA_AURA_OWNER)
        return true;
    return false;
}

bool SpellEffectInfo::IsFarUnitTargetEffect() const
{
    return (Effect == SPELL_EFFECT_SUMMON_PLAYER)
        || (Effect == SPELL_EFFECT_RAF_TELEPORT)
        || (Effect == SPELL_EFFECT_SUMMON_RAF_FRIEND)
        || (Effect == SPELL_EFFECT_RESURRECT)
        || (Effect == SPELL_EFFECT_SKIN_PLAYER_CORPSE);
}

bool SpellEffectInfo::IsFarDestTargetEffect() const
{
    return Effect == SPELL_EFFECT_TELEPORT_UNITS;
}

bool SpellEffectInfo::IsUnitOwnedAuraEffect() const
{
    return IsAreaAuraEffect() || IsApplyingAura();
}

bool SpellEffectInfo::IsApplyingAura() const
{
    return Effect == SPELL_EFFECT_APPLY_AURA || Effect == SPELL_EFFECT_APPLY_AURA_ON_PET || Effect == SPELL_EFFECT_APPLY_AURA_2;
}

bool SpellEffectInfo::IsDamagingEffect() const
{
    switch (Effect)
    {
        case SpellEffects::SPELL_EFFECT_SCHOOL_DAMAGE:
        case SpellEffects::SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SpellEffects::SPELL_EFFECT_HEALTH_LEECH:
        case SpellEffects::SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SpellEffects::SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SpellEffects::SPELL_EFFECT_WEAPON_DAMAGE:
        case SpellEffects::SPELL_EFFECT_POWER_BURN:
        case SpellEffects::SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT:
            return true;
        default:
            break;
    }

    return false;
}

int32 SpellEffectInfo::CalcValue(Unit const* p_Caster, int32 const* p_Bp, Unit const* p_Target, Item const* p_CastItem /*= nullptr*/, bool p_Log /*= false*/, std::ostringstream* p_DamageLogStream /*= nullptr*/) const
{
    float l_BasePointsPerLevel = RealPointsPerLevel;
    int32 l_BasePoints = p_Bp ? *p_Bp : BasePoints;
    float l_ComboDamage = PointsPerComboPoint;
    int32 l_ItemLevel = -1;
    if (p_CastItem && p_Caster->IsPlayer())
        l_ItemLevel = p_CastItem->GetItemLevel(p_Caster->ToPlayer());


    if (p_Caster && p_Caster->IsDealingFixedDamage())
        return l_BasePoints;

    /// Tmp fix for old trinkets
    /// @TODO: Handle it properly (see sub_6B2375 in 7.0.3 x86 client)
    if (_spellInfo->HasAttribute(SPELL_ATTR12_UNK21) && p_Caster && p_Caster->getLevel() == MAX_LEVEL && l_ItemLevel < 780)
        return 0;

    if (_spellInfo->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS))
        return l_BasePoints;

    float l_Value = static_cast<float>(l_BasePoints);

    // base amount modification based on spell lvl vs caster lvl
    if (!G3D::fuzzyEq(ScalingMultiplier, 0.0f))
    {
        SpellScalingEntry const* l_SpellScaling = _spellInfo->GetSpellScaling();

        if (p_Caster && l_SpellScaling != nullptr)
        {
            int32 l_Level = p_Caster->getLevelForTarget(p_Target);
            if (p_Target && _spellInfo->IsPositiveEffect(_effIndex) && IsApplyingAura())
                l_Level = p_Target->getLevelForTarget(p_Caster);

            if (!_spellInfo->HasAttribute(SPELL_ATTR11_SCALES_WITH_ITEM_LEVEL) && _spellInfo->HasAttribute(SPELL_ATTR10_USE_SPELL_BASE_LEVEL_FOR_SCALING))
                l_Level = _spellInfo->BaseLevel;

            float l_Multiplier = 0.0f;

            // Level scaling cap
            if (l_SpellScaling->MaxScalingLevel && uint32(l_Level) > l_SpellScaling->MaxScalingLevel)
                l_Level = l_SpellScaling->MaxScalingLevel;

            // Level scaling cap
            if (l_SpellScaling->MinScalingLevel && uint32(l_Level) < l_SpellScaling->MinScalingLevel)
                l_Level = l_SpellScaling->MinScalingLevel;

            if (l_SpellScaling->ScalesFromItemLevel == 0)
            {
                if ((_spellInfo->AttributesEx11 & SPELL_ATTR11_SCALES_WITH_ITEM_LEVEL) == 0)
                {
                    int8 l_ScalingClassIndex = _spellInfo->ScalingClass;

                    if (l_ScalingClassIndex < 0)
                        l_ScalingClassIndex = (MAX_CLASSES - 1) - l_ScalingClassIndex;


                    SpellScalingTableEntry const* l_Scaling = g_SpellScalingTable.LookupEntry(l_Level);

                    if (l_Scaling)
                        l_Multiplier = GetSpellScalingColumnForClass(l_Scaling, l_ScalingClassIndex);
                }
                else
                {
                    RandomPropertiesPointsEntry const* l_RandomPropertiesPoints = sRandomPropertiesPointsStore.LookupEntry(l_ItemLevel);
                    if (l_RandomPropertiesPoints)
                        l_Multiplier = l_RandomPropertiesPoints->RarePropertiesPoints[0];

                    if (IsAura() && ApplyAuraName == SPELL_AURA_MOD_RATING)
                        if (CombatRatingsMultByILvl const* l_IlvlRating = g_CombatRatingMultByIlvl.LookupEntry(l_ItemLevel))
                        {
                            float l_typeMultiplier = l_IlvlRating->ArmorMultiplier;
                            if (p_CastItem)
                            {
                                if (ItemTemplate const* proto = p_CastItem->GetTemplate())
                                {
                                    switch (proto->GetInventoryType())
                                    {
                                        case INVTYPE_WEAPON:
                                        case INVTYPE_SHIELD:
                                        case INVTYPE_RANGED:
                                        case INVTYPE_2HWEAPON:
                                        case INVTYPE_WEAPONMAINHAND:
                                        case INVTYPE_WEAPONOFFHAND:
                                        case INVTYPE_HOLDABLE:
                                        case INVTYPE_RANGEDRIGHT:
                                            l_typeMultiplier = l_IlvlRating->WeaponMultiplier;
                                            break;
                                        case INVTYPE_TRINKET:
                                            l_typeMultiplier = l_IlvlRating->TrinketMultiplier;
                                            break;
                                        case INVTYPE_NECK:
                                        case INVTYPE_FINGER:
                                            l_typeMultiplier = l_IlvlRating->JewelryMultiplier;
                                            break;
                                        default:
                                            l_typeMultiplier = l_IlvlRating->ArmorMultiplier;
                                            break;
                                    }
                                }
                            }
                            l_Multiplier *= l_typeMultiplier;
                        }
                }
            }
            else
            {
                RandomPropertiesPointsEntry const* l_RandomPropertiesPoints = sRandomPropertiesPointsStore.LookupEntry(l_SpellScaling->ScalesFromItemLevel);
                if (l_RandomPropertiesPoints)
                    l_Multiplier = l_RandomPropertiesPoints->RarePropertiesPoints[0];
            }

            float l_PreciseBasePoints = ScalingMultiplier * l_Multiplier;

            if (p_CastItem && p_CastItem->GetTemplate()->GetInventoryType() == InventoryType::INVTYPE_TRINKET && (ApplyAuraName == SPELL_AURA_MOD_BONUS_ARMOR || ApplyAuraName == SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK))
                if (CombatRatingsMultByILvl const* l_IlvlRating = g_CombatRatingMultByIlvl.LookupEntry(l_ItemLevel))
                    l_PreciseBasePoints *= l_IlvlRating->TrinketMultiplier;

            if (DeltaScalingMultiplier)
            {
                float l_Delta = DeltaScalingMultiplier * ScalingMultiplier * l_Multiplier * 0.5f;
                l_PreciseBasePoints += frand(-l_Delta, l_Delta);
            }

            l_Value = l_PreciseBasePoints;

            if (ComboScalingMultiplier)
                l_ComboDamage = ComboScalingMultiplier * l_Multiplier;
        }
    }
    else
    {
        if (p_Caster)
        {
            int32 l_Level = static_cast<int32>(p_Caster->getLevelForTarget(p_Target));
            if (l_Level > static_cast<int32>(_spellInfo->MaxLevel) && _spellInfo->MaxLevel > 0)
                l_Level = static_cast<int32>(_spellInfo->MaxLevel);
            else if (l_Level < static_cast<int32>(_spellInfo->BaseLevel))
                l_Level = static_cast<int32>(_spellInfo->BaseLevel);
            l_Level -= static_cast<int32>(_spellInfo->SpellLevel);
            l_Value += static_cast<float>(l_Level * l_BasePointsPerLevel);

            if (l_BasePointsPerLevel && l_BasePoints >= 100 && (Effect == SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT || ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE_PERCENT))  // Temporary
                l_Value /= 10.0f;
        }

        // roll in a range <1;EffectDieSides> as of patch 3.3.3
        int32 l_RandomPoints = int32(DieSides);
        switch (l_RandomPoints)
        {
            case 0: break;
            case 1: l_BasePoints += 1; break;                     // range 1..1
            default:
            {
                // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
                int32 randvalue = (l_RandomPoints >= 1)
                    ? irand(1, l_RandomPoints)
                    : irand(l_RandomPoints, 1);

                l_BasePoints += randvalue;
                break;
            }
        }
    }

    if (_spellInfo->IsPassive() && p_Caster)
    {
        if (Player const* l_Player = p_Caster->ToPlayer())
        {
            if (ArtifactPowerRankEntry const* l_RankEntryForSpellId = GetArtifactPowerRankBySpellID(_spellInfo->Id, l_Player))
            {
                if (uint32 l_ArtifactPowerID = l_RankEntryForSpellId->ArtifactPowerID)
                {
                    uint8 l_RankOfArtifactPowerID = p_Caster->ToPlayer()->GetRankOfArtifactPowerId(l_ArtifactPowerID);
                    if (l_RankOfArtifactPowerID > 1 || GetArtifactPowerRank(l_ArtifactPowerID, l_RankOfArtifactPowerID))
                    {
                        if (ArtifactPowerRankEntry const* l_RankEntry = GetArtifactPowerRank(l_ArtifactPowerID, l_RankOfArtifactPowerID - 1))
                        {
                            if (G3D::fuzzyEq(l_RankEntry->AuraPointsOverride, 0.00f) && BasePoints != 0)
                                l_Value = static_cast<float>(BasePoints);
                            else
                                l_Value = static_cast<float>(l_RankEntry->AuraPointsOverride);
                        }
                    }
                }
            }
        }
    }

    /// Apply group size scaling (since MoP 5.4 - SoO)
    if (GroupSizeCoefficient > 1.0f && p_Caster && p_Caster->GetMap()->IsRaid() && !p_Caster->GetMap()->IsMythic())
    {
        /// Get the group size
        int32 l_GroupSize = p_Caster->GetMap()->GetPlayersCountExceptGMs();

        /// Apply group size limit (min size is 10, max 30)
        l_GroupSize = std::min((int32)GroupScalingRange::Max, std::max(l_GroupSize, (int32)GroupScalingRange::Min));

        /// Compute the group size scaling value
        float l_GroupSizeCoefficient = (GroupSizeCoefficient - 1.0f) / ((int32)GroupScalingRange::Max - (int32)GroupScalingRange::Min);
        float l_GroupScalingValue    = l_GroupSizeCoefficient * (l_GroupSize - (int32)GroupScalingRange::Min) * l_Value;

        /// Add the group scaling bonus to the value
        l_Value += l_GroupScalingValue;
    }

    // random damage
    if (p_Caster)
    {
        /// Bonus amount from combo points
        if (p_Caster && l_ComboDamage)
            l_Value += l_ComboDamage * p_Caster->GetPower(Powers::POWER_COMBO_POINT);

        l_Value = p_Caster->ApplyEffectModifiers(_spellInfo, _effIndex, l_Value);

        // amount multiplication based on caster's level
        if (!_spellInfo->GetSpellScaling() && !l_BasePointsPerLevel && (_spellInfo->Attributes & SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION) &&
                Effect != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
                Effect != SPELL_EFFECT_KNOCK_BACK &&
                Effect != SPELL_EFFECT_KNOCK_BACK_DEST &&
                Effect != SPELL_EFFECT_ADD_EXTRA_ATTACKS &&
                Effect != SPELL_EFFECT_GAMEOBJECT_DAMAGE &&
                Effect != SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT &&
                ApplyAuraName != SPELL_AURA_MOD_SPEED_ALWAYS &&
                ApplyAuraName != SPELL_AURA_MOD_SPEED_NOT_STACK &&
                ApplyAuraName != SPELL_AURA_MOD_INCREASE_SPEED &&
                ApplyAuraName != SPELL_AURA_MOD_DECREASE_SPEED &&
                ApplyAuraName != SPELL_AURA_MELEE_SLOW &&
                ApplyAuraName != SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT &&
                ApplyAuraName != SPELL_AURA_MOD_SCALE &&
                ApplyAuraName != SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT)
        {
            uint32 l_Level = p_Caster->getLevelForTarget(p_Target);

            if (NpcDamageByClassEntry const* l_NpcDamage = g_NpcDamageByClassGameTable[JadeCore::GetExpansionForLevel(l_Level)].LookupEntry(l_Level))
            {
                float l_Damage = l_NpcDamage->m_ClassScaling.GetScalingForClassID(p_Caster->getClass());
                ApplyPct(l_Damage, l_BasePoints);
                l_Value = l_Damage;
            }
        }

        if (CanScale())
        {
            bool l_RangedClass = _spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && _spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MAGIC && p_Caster->getClass() == CLASS_HUNTER;
            WeaponAttackType l_AttType = (_spellInfo->IsRangedWeaponSpell() && l_RangedClass) ? WeaponAttackType::RangedAttack : WeaponAttackType::BaseAttack;
            float l_AttackPower = p_Caster->GetTotalAttackPowerValue(l_AttType);
            float l_SpellPower = p_Caster->SpellBaseDamageBonusDone(_spellInfo->GetSchoolMask());

            {
                if (l_AttackPower == 0.0f)
                    l_AttackPower = p_Caster->GetTotalAttackPowerValue(WeaponAttackType::BaseAttack);
                if (l_AttackPower == 0.0f && p_Caster->GetOwner() && p_Caster->GetOwner()->ToPlayer())
                    l_AttackPower = p_Caster->GetOwner()->GetTotalAttackPowerValue(l_AttType);
            }

            {
                if (l_SpellPower == 0.0f)
                    l_SpellPower = p_Caster->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);
                if (l_SpellPower == 0.0f && p_Caster->GetOwner() && p_Caster->GetOwner()->ToPlayer())
                    l_SpellPower = p_Caster->GetOwner()->SpellBaseDamageBonusDone(_spellInfo->GetSchoolMask());
            }

            /// TempFix for Mangle because it uses SP instead of Weapon Damage
            if (_spellInfo->Id == 33917)
                l_SpellPower = 0;

            float l_APBonusDamage = l_AttackPower * AttackPowerMultiplier;
            float l_SPBonusDamage = l_SpellPower * BonusMultiplier;

            if (p_DamageLogStream)
            {
                *p_DamageLogStream << " CalcValue : AttackPowerMultiplier " << AttackPowerMultiplier << " AttackPower " << l_AttackPower << " APBonusDamage " << l_APBonusDamage << " Value " << l_Value << std::endl;
                *p_DamageLogStream << " BonusMultiplier " << BonusMultiplier << " SpellPower " << l_SpellPower << " SPBonusDamage " << l_SPBonusDamage << " Value " << l_Value << std::endl;
            }

            if (p_Log && AttackPowerMultiplier)
                LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(CanScale): Spell %s: EffIndex %i: AttackPowerMultiplier %f * AttackPower %f = %f, Base %f", _spellInfo->GetNameForLogging().c_str(), _effIndex, AttackPowerMultiplier, l_AttackPower, l_APBonusDamage, l_Value);

            if (p_Log && BonusMultiplier)
                LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(CanScale): Spell %s: EffIndex %i: BonusMultiplier %f * SpellPower %f = %f, Base %f", _spellInfo->GetNameForLogging().c_str(), _effIndex, BonusMultiplier, l_SpellPower, l_SPBonusDamage, l_Value);

            l_Value += l_APBonusDamage + l_SPBonusDamage;
        }
    }

    /// Don't need to change our value for Arcane Barrage triggered spell and Mind Control, it's already calculated
    if (_spellInfo->Id == 50273)
        l_Value = float(l_BasePoints);

    /// TempFix waiting for floatamount calculation
    if (_spellInfo->Id == 222209)
        l_Value *= 100.0f;

    int32 l_RetValue = roundf(l_Value);

    if (p_Log)
        LOG_SPELL(p_Caster, _spellInfo->Id, "CalcValue(): Spell %s: EffIndex %i: Final Amount %i", _spellInfo->GetNameForLogging().c_str(), _effIndex, l_RetValue);

    return l_RetValue;
}

int32 SpellEffectInfo::CalcBaseValue(int32 value) const
{
    if (DieSides == 0)
        return value;
    else
        return value - 1;
}

float SpellEffectInfo::CalcValueMultiplier(Unit* caster, Spell* spell) const
{
    float multiplier = ValueMultiplier;
    if (Player* modOwner = (caster ? caster->GetSpellModOwner() : NULL))
        modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
    return multiplier;
}

float SpellEffectInfo::CalcDamageMultiplier(Unit* p_Caster, Spell* p_Spell) const
{
    float l_Multiplier = DamageMultiplier * 100.0f;

    if (Player* l_ModOwner = (p_Caster ? p_Caster->GetSpellModOwner() : nullptr))
        l_ModOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_DAMAGE_MULTIPLIER, l_Multiplier, p_Spell);

    return l_Multiplier / 100.0f;
}

bool SpellEffectInfo::HasRadius() const
{
    return RadiusEntry != nullptr;
}

float SpellEffectInfo::CalcRadius(Unit* caster, Spell* spell, bool Area /*= false*/) const
{
    if (!HasRadius())
        return 0.0f;

    float radius = 0.0f;
    if (MaxRadiusEntry && MaxRadiusEntry->radiusHostile && Area)
        radius = MaxRadiusEntry->RadiusMax;
    else if (RadiusEntry)
        radius = RadiusEntry->radiusHostile;

    if (Player* modOwner = (caster ? caster->GetSpellModOwner() : nullptr))
        modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_RADIUS, radius, spell);

    return radius;
}

uint32 SpellEffectInfo::GetProvidedTargetMask() const
{
    return GetTargetFlagMask(TargetA.GetObjectType()) | GetTargetFlagMask(TargetB.GetObjectType());
}

void SpellEffectInfo::SetRadiusIndex(uint32 index)
{
    SpellRadiusEntry const* radiusIndex = sSpellRadiusStore.LookupEntry(index);
    if (!radiusIndex)
        return;

    RadiusEntry = radiusIndex;
}

uint32 SpellEffectInfo::GetMissingTargetMask(bool srcSet /*= false*/, bool dstSet /*= false*/, uint32 mask /*=0*/) const
{
    uint32 effImplicitTargetMask = GetTargetFlagMask(GetUsedTargetObjectType());
    uint32 providedTargetMask = GetTargetFlagMask(TargetA.GetObjectType()) | GetTargetFlagMask(TargetB.GetObjectType()) | mask;

    // remove all flags covered by effect target mask
    if (providedTargetMask & TARGET_FLAG_UNIT_MASK)
        effImplicitTargetMask &= ~(TARGET_FLAG_UNIT_MASK);
    if (providedTargetMask & TARGET_FLAG_CORPSE_MASK)
        effImplicitTargetMask &= ~(TARGET_FLAG_UNIT_MASK | TARGET_FLAG_CORPSE_MASK);
    if (providedTargetMask & TARGET_FLAG_GAMEOBJECT_ITEM)
        effImplicitTargetMask &= ~(TARGET_FLAG_GAMEOBJECT_ITEM | TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_ITEM);
    if (providedTargetMask & TARGET_FLAG_GAMEOBJECT)
        effImplicitTargetMask &= ~(TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_GAMEOBJECT_ITEM);
    if (providedTargetMask & TARGET_FLAG_ITEM)
        effImplicitTargetMask &= ~(TARGET_FLAG_ITEM | TARGET_FLAG_GAMEOBJECT_ITEM);
    if (dstSet || providedTargetMask & TARGET_FLAG_DEST_LOCATION)
        effImplicitTargetMask &= ~(TARGET_FLAG_DEST_LOCATION);
    if (srcSet || providedTargetMask & TARGET_FLAG_SOURCE_LOCATION)
        effImplicitTargetMask &= ~(TARGET_FLAG_SOURCE_LOCATION);

    return effImplicitTargetMask;
}

SpellEffectImplicitTargetTypes SpellEffectInfo::GetImplicitTargetType() const
{
    return _data[Effect].ImplicitTargetType;
}

SpellTargetObjectTypes SpellEffectInfo::GetUsedTargetObjectType() const
{
    return _data[Effect].UsedTargetObjectType;
}

SpellEffectInfo::StaticData  SpellEffectInfo::_data[TOTAL_SPELL_EFFECTS] =
{
    // implicit target type           used target object type
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 0
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 1 SPELL_EFFECT_INSTAKILL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 2 SPELL_EFFECT_SCHOOL_DAMAGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 3 SPELL_EFFECT_DUMMY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 4 SPELL_EFFECT_PORTAL_TELEPORT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 5 SPELL_EFFECT_TELEPORT_UNITS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 6 SPELL_EFFECT_APPLY_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 8 SPELL_EFFECT_POWER_DRAIN
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 9 SPELL_EFFECT_HEALTH_LEECH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 10 SPELL_EFFECT_HEAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 11 SPELL_EFFECT_BIND
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 12 SPELL_EFFECT_PORTAL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 13 SPELL_EFFECT_RITUAL_BASE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 14 SPELL_EFFECT_RITUAL_SPECIALIZE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST },//< 15 SPELL_EFFECT_TELEPORT_FROM_PORTAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 16 SPELL_EFFECT_QUEST_COMPLETE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ALLY},   //< 18 SPELL_EFFECT_RESURRECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 20 SPELL_EFFECT_DODGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 21 SPELL_EFFECT_EVADE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 22 SPELL_EFFECT_PARRY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 23 SPELL_EFFECT_BLOCK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 24 SPELL_EFFECT_CREATE_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 25 SPELL_EFFECT_WEAPON
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 26 SPELL_EFFECT_DEFENSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 28 SPELL_EFFECT_SUMMON
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 29 SPELL_EFFECT_LEAP
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 30 SPELL_EFFECT_ENERGIZE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 32 SPELL_EFFECT_TRIGGER_MISSILE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ_ITEM},     //< 33 SPELL_EFFECT_OPEN_LOCK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 36 SPELL_EFFECT_LEARN_SPELL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 37 SPELL_EFFECT_SPELL_DEFENSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 38 SPELL_EFFECT_DISPEL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 39 SPELL_EFFECT_LANGUAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 40 SPELL_EFFECT_DUAL_WIELD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 41 SPELL_EFFECT_JUMP
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_DEST},          //< 42 SPELL_EFFECT_JUMP_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 44 SPELL_EFFECT_SKILL_STEP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 45 SPELL_EFFECT_PLAY_MOVIE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 46 SPELL_EFFECT_SPAWN
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 47 SPELL_EFFECT_TRADE_SKILL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 48 SPELL_EFFECT_STEALTH
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 49 SPELL_EFFECT_DETECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 50 SPELL_EFFECT_TRANS_DOOR
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 51 SPELL_EFFECT_FORCE_CRITICAL_HIT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 52 SPELL_EFFECT_GUARANTEE_HIT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 53 SPELL_EFFECT_ENCHANT_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 55 SPELL_EFFECT_TAMECREATURE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 56 SPELL_EFFECT_SUMMON_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 57 SPELL_EFFECT_LEARN_PET_SPELL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 58 SPELL_EFFECT_WEAPON_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 59 SPELL_EFFECT_CREATE_RANDOM_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 60 SPELL_EFFECT_PROFICIENCY
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 61 SPELL_EFFECT_SEND_EVENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 62 SPELL_EFFECT_POWER_BURN
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 63 SPELL_EFFECT_THREAT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 64 SPELL_EFFECT_TRIGGER_SPELL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 66 SPELL_EFFECT_CREATE_OR_RECHARGE_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 67 SPELL_EFFECT_HEAL_MAX_HEALTH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 68 SPELL_EFFECT_INTERRUPT_CAST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 69 SPELL_EFFECT_DISTRACT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 70 SPELL_EFFECT_PULL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 71 SPELL_EFFECT_PICKPOCKET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 72 SPELL_EFFECT_ADD_FARSIGHT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 73 SPELL_EFFECT_UNTRAIN_TALENTS
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 74 SPELL_EFFECT_APPLY_GLYPH
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 75 SPELL_EFFECT_HEAL_MECHANICAL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 77 SPELL_EFFECT_SCRIPT_EFFECT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 78 SPELL_EFFECT_ATTACK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 79 SPELL_EFFECT_SANCTUARY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 80 SPELL_EFFECT_INCREASE_FOLLOWER_ITEM_LEVEL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 81 SPELL_EFFECT_CREATE_HOUSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 82 SPELL_EFFECT_BIND_SIGHT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 83 SPELL_EFFECT_DUEL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 84 SPELL_EFFECT_STUCK
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 85 SPELL_EFFECT_SUMMON_PLAYER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 86 SPELL_EFFECT_ACTIVATE_OBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 87 SPELL_EFFECT_GAMEOBJECT_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 88 SPELL_EFFECT_GAMEOBJECT_REPAIR
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_GOBJ},          //< 89 SPELL_EFFECT_GAMEOBJECT_SET_DESTRUCTION_STATE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 90 SPELL_EFFECT_KILL_CREDIT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 91 SPELL_EFFECT_THREAT_ALL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 93 SPELL_EFFECT_FORCE_DESELECT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 94 SPELL_EFFECT_SELF_RESURRECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 95 SPELL_EFFECT_SKINNING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 96 SPELL_EFFECT_CHARGE
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 97 SPELL_EFFECT_CAST_BUTTON
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 98 SPELL_EFFECT_KNOCK_BACK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 99 SPELL_EFFECT_DISENCHANT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 100 SPELL_EFFECT_INEBRIATE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 101 SPELL_EFFECT_FEED_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 102 SPELL_EFFECT_DISMISS_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 103 SPELL_EFFECT_REPUTATION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 108 SPELL_EFFECT_DISPEL_MECHANIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 109 SPELL_EFFECT_SUMMON_DEAD_PET
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 111 SPELL_EFFECT_DURABILITY_DAMAGE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 112 SPELL_EFFECT_112
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ALLY},   //< 113 SPELL_EFFECT_RESURRECT_NEW
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 114 SPELL_EFFECT_ATTACK_ME
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_CORPSE_ENEMY},  //< 116 SPELL_EFFECT_SKIN_PLAYER_CORPSE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 117 SPELL_EFFECT_SPIRIT_HEAL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 118 SPELL_EFFECT_SKILL
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 119 SPELL_EFFECT_APPLY_AREA_AURA_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 120 SPELL_EFFECT_TELEPORT_GRAVEYARD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 122 SPELL_EFFECT_122
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 123 SPELL_EFFECT_SEND_TAXI
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 124 SPELL_EFFECT_PULL_TOWARDS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 127 SPELL_EFFECT_PROSPECTING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 130 SPELL_EFFECT_REDIRECT_THREAT
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 131 SPELL_EFFECT_PLAY_SOUND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 132 SPELL_EFFECT_PLAY_MUSIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 133 SPELL_EFFECT_UNLEARN_SPECIALIZATION
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 134 SPELL_EFFECT_KILL_CREDIT2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 135 SPELL_EFFECT_CALL_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 136 SPELL_EFFECT_HEAL_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 137 SPELL_EFFECT_ENERGIZE_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 138 SPELL_EFFECT_LEAP_BACK
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 139 SPELL_EFFECT_CLEAR_QUEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 140 SPELL_EFFECT_FORCE_CAST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 144 SPELL_EFFECT_KNOCK_BACK_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 145 SPELL_EFFECT_PULL_TOWARDS_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 146 SPELL_EFFECT_ACTIVATE_RUNE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 147 SPELL_EFFECT_QUEST_FAIL
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 148 SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_DEST},          //< 149 SPELL_EFFECT_CHARGE_DEST
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 150 SPELL_EFFECT_QUEST_START
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 151 SPELL_EFFECT_TRIGGER_SPELL_2
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 152 SPELL_EFFECT_SUMMON_RAF_FRIEND
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 153 SPELL_EFFECT_CREATE_TAMED_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 154 SPELL_EFFECT_DISCOVER_TAXI
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_UNIT},          //< 155 SPELL_EFFECT_TITAN_GRIP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 157 SPELL_EFFECT_CREATE_LOOT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 158 SPELL_EFFECT_MILLING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 159 SPELL_EFFECT_ALLOW_RENAME_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 160 SPELL_EFFECT_160
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 161 SPELL_EFFECT_TALENT_SPEC_COUNT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 162 SPELL_EFFECT_TALENT_SPEC_SELECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 163 SPELL_EFFECT_163
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 164 SPELL_EFFECT_REMOVE_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 165 SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 166 SPELL_EFFECT_GIVE_CURRENCY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 167 SPELL_EFFECT_UPDATE_PLAYER_PHASE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 168 SPELL_EFFECT_ALLOW_CONTROL_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 169 SPELL_EFFECT_DESTROY_ITEM
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 170 SPELL_EFFECT_UPDATE_ZONE_AURAS_AND_PHASES
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 171 SPELL_EFFECT_SUMMON_OBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 172 SPELL_EFFECT_RESURRECT_WITH_AURA
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 173 SPELL_EFFECT_UNLOCK_GUILD_VAULT_TAB
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 174 SPELL_EFFECT_APPLY_AURA_ON_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 175 SPELL_EFFECT_175
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 176 SPELL_EFFECT_BECOME_UNTARGETTABLE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_AREATRIGGER},   //< 177 SPELL_EFFECT_DESPAWN_AREA_TRIGGER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 178 SPELL_EFFECT_178
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 179 SPELL_EFFECT_CREATE_AREATRIGGER
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 180 SPELL_EFFECT_180
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 181 SPELL_EFFECT_UNLEARN_TALENT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_AREATRIGGER},   //< 182 SPELL_EFFECT_DESPAWN_AREA_TRIGGER_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 183 SPELL_EFFECT_183
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 184 SPELL_EFFECT_REPUTATION_REWARD
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 185 SPELL_EFFECT_PLAY_SCENEOBJECT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 186 SPELL_EFFECT_PLAY_SCENEOBJECT_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 187 SPELL_EFFECT_187
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 188 SPELL_EFFECT_188
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 189 SPELL_EFFECT_LOOT_BONUS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 190 SPELL_EFFECT_JOIN_LEAVE_PLAYER_PARTY
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 191 SPELL_EFFECT_TELEPORT_TO_DIGSITE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 192 SPELL_EFFECT_UNCAGE_BATTLE_PET
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 193 SPELL_EFFECT_193
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 194 SPELL_EFFECT_194
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 195 SPELL_EFFECT_195
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 196 SPELL_EFFECT_196
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 197 SPELL_EFFECT_197
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 198 SPELL_EFFECT_PLAY_CINEMATIC
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 199 SPELL_EFFECT_199
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 200 SPELL_EFFECT_RESURECT_BATTLE_PETS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 201 SPELL_EFFECT_CAN_PETBATTLE
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 202 SPELL_EFFECT_202
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 203 SPELL_EFFECT_REMOVE_AURA_2
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 204 SPELL_EFFECT_204
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 205 SPELL_EFFECT_205
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 206 SPELL_EFFECT_206
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 207 SPELL_EFFECT_207
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 208 SPELL_EFFECT_208
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 209 SPELL_EFFECT_209
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 210 SPELL_EFFECT_LEARN_BLUE_PRINT
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 211 SPELL_EFFECT_211
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 212 SPELL_EFFECT_212
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 213 SPELL_EFFECT_DEATH_GRIP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 214 SPELL_EFFECT_214
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 215 SPELL_EFFECT_UPGRADE_CHARACTER_SPELLS
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 216 SPELL_EFFECT_216
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 217 SPELL_EFFECT_217
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 218 SPELL_EFFECT_218
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 219 SPELL_EFFECT_START_CONVERSATION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 220 SPELL_EFFECT_220
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 221 SPELL_EFFECT_ADD_GARRISON_MISSION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 222 SPELL_EFFECT_222
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 223 SPELL_EFFECT_223
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 224 SPELL_EFFECT_GARRISON_FINALIZE_BUILDING
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 225 SPELL_EFFECT_225
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 226 SPELL_EFFECT_226
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 227 SPELL_EFFECT_227
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 228 SPELL_EFFECT_228
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 229 SPELL_EFFECT_229
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 230 SPELL_EFFECT_230
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 231 SPELL_EFFECT_231
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 232 SPELL_EFFECT_232
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 233 SPELL_EFFECT_233
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 234 SPELL_EFFECT_234
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 235 SPELL_EFFECT_AK_CATCHUP
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 236 SPELL_EFFECT_236
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 237 SPELL_EFFECT_237
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 238 SPELL_EFFECT_238
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 239 SPELL_EFFECT_239
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 240 SPELL_EFFECT_240
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 241 SPELL_EFFECT_241
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 242 SPELL_EFFECT_242
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_ITEM},          //< 243 SPELL_EFFECT_APPLY_ENCHANT_ILLUSION
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 244 SPELL_EFFECT_244
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 245 SPELL_EFFECT_245
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT},          //< 246 SPELL_EFFECT_246
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 247
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 248
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 249
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 250
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 251
    {EFFECT_IMPLICIT_TARGET_EXPLICIT, TARGET_OBJECT_TYPE_UNIT_AND_DEST}, //< 252
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 253
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 254
    {EFFECT_IMPLICIT_TARGET_NONE,     TARGET_OBJECT_TYPE_NONE},          //< 255
};

SpellInfo::SpellInfo(SpellEntry const* p_SpellEntry, uint32 p_Difficulty, SpellVisualMap const& p_Visuals)
{
    Id = p_SpellEntry->Id;
    DifficultyID = p_Difficulty;
    AttributesCu = 0;

    m_SpellVisuals = p_Visuals;

    SpellName = p_SpellEntry->SpellName;
    Rank = p_SpellEntry->Rank;
    SpellDifficultyId = 0;
    SpellTargetRestrictionsId = 0;

    SpellMiscId = sSpellMgr->GetBaseSpellDBCID(sSpellMiscStore.GetDbcFileName(), Id);
    SpellAuraOptionsID = sSpellMgr->GetBaseSpellDBCID(sSpellAuraOptionsStore.GetDbcFileName(), Id);
    SpellCategoriesID = sSpellMgr->GetBaseSpellDBCID(sSpellCategoriesStore.GetDbcFileName(), Id);
    SpellCooldownsID = sSpellMgr->GetBaseSpellDBCID(sSpellCooldownsStore.GetDbcFileName(), Id);
    SpellInteruptsID = sSpellMgr->GetBaseSpellDBCID(sSpellInterruptsStore.GetDbcFileName(), Id);
    SpellLevelsID = sSpellMgr->GetBaseSpellDBCID(sSpellLevelsStore.GetDbcFileName(), Id);
    SpellTargetRestrictionsId = sSpellMgr->GetBaseSpellDBCID(sSpellTargetRestrictionsStore.GetDbcFileName(), Id);

    uint32 l_MaxEffect = 0;
    EffectCount = 0;

    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (p_SpellEntry->GetSpellEffect(i, p_Difficulty))
            l_MaxEffect = i + 1;
    }

    // SpellDifficultyEntry
    for (uint8 i = 0; i < l_MaxEffect; ++i)
    {
        Effects._effects.push_back(SpellEffectInfo(p_SpellEntry, this, i, p_Difficulty));
        EffectCount++;
    }

    UpdateSpellEffectCount();

    // SpellScalingEntry
    SpellScalingEntry const* _scaling = GetSpellScaling();
    ScalesFromItemLevel = _scaling ? _scaling->ScalesFromItemLevel : 0;
    ScalingClass = _scaling ?_scaling->ScalingClass : 0;
    MinScalingLevel = _scaling ? _scaling->MinScalingLevel : 0;
    MaxScalingLevel = _scaling ? _scaling->MaxScalingLevel : 0;

    // SpellAuraOptionsEntry
    SpellAuraOptionsEntry const* _options = GetSpellAuraOptions();
    SpellProcsPerMinuteEntry const* _ppm = _options ? sSpellProcsPerMinuteStore.LookupEntry(_options->ProcsPerMinuteEntry) : nullptr;
    ProcFlags = _options ? _options->ProcTypeMask : 0;
    ProcChance = _options ? _options->procChance : 0;
    ProcCharges = _options ? _options->ProcCharges : 0;
    InternalCooldown = _options ? _options->InternalCooldown : 0;
    ProcBasePPM = _ppm ? _ppm->BaseProcRate : 0.0f;
    if (_options)
        ProcPPMMods = GetSpellProcsPerMinuteMods(_options->ProcsPerMinuteEntry);
    StackAmount = _options ? _options->StackAmount : 0;

    // SpellAuraRestrictionsEntry
    SpellAuraRestrictionsEntry const* _aura = GetSpellAuraRestrictions();
    CasterAuraState = _aura ? _aura->CasterAuraState : 0;
    TargetAuraState = _aura ? _aura->TargetAuraState : 0;
    ExcludeCasterAuraState = _aura ? _aura->ExcludeCasterAuraState : 0;
    ExcludeTargetAuraState = _aura ? _aura->ExcludeTargetAuraState : 0;
    CasterAuraSpell = _aura ? _aura->casterAuraSpell : 0;
    TargetAuraSpell = _aura ? _aura->targetAuraSpell : 0;
    ExcludeCasterAuraSpell = _aura ? _aura->excludeCasterAuraSpell : 0;
    ExcludeTargetAuraSpell = _aura ? _aura->excludeTargetAuraSpell : 0;

    // SpellCastingRequirementsEntry
    SpellCastingRequirementsEntry const* _castreq = GetSpellCastingRequirements();
    RequiresSpellFocus = _castreq ? _castreq->RequiresSpellFocus : 0;
    FacingCasterFlags = _castreq ? _castreq->FacingCasterFlags : 0;
    AreaGroupId = _castreq ? _castreq->AreaGroupId : 0;

    // SpellCategoriesEntry
    SpellCategoriesEntry const* _categorie = GetSpellCategories();
    CategoryEntry = _categorie ? sSpellCategoryStore.LookupEntry(_categorie->Category) : NULL;
    Dispel = _categorie ? _categorie->Dispel : 0;
    Mechanic = _categorie ? _categorie->Mechanic : 0;
    StartRecoveryCategory = _categorie ? _categorie->StartRecoveryCategory : 0;
    DmgClass = _categorie ? _categorie->DmgClass : 0;
    PreventionType = _categorie ? _categorie->PreventionType : 0;
    ChargeCategoryEntry = _categorie ? sSpellCategoryStore.LookupEntry(_categorie->ChargeCategory ? _categorie->ChargeCategory : _categorie->Category) : 0;

    // SpellClassOptionsEntry
    SpellClassOptionsEntry const* _class = GetSpellClassOptions();
    SpellFamilyName = _class ? _class->SpellFamilyName : 0;
    SpellFamilyFlags = _class ? _class->SpellFamilyFlags : flag128(0);

    // SpellCooldownsEntry
    SpellCooldownsEntry const* _cooldowns = GetSpellCooldowns();
    RecoveryTime = _cooldowns ? _cooldowns->RecoveryTime : 0;
    CategoryRecoveryTime = _cooldowns ? _cooldowns->CategoryRecoveryTime : 0;
    StartRecoveryTime = _cooldowns ? _cooldowns->StartRecoveryTime : 0;

    // SpellEquippedItemsEntry
    SpellEquippedItemsEntry const* _equipped = GetSpellEquippedItems();
    EquippedItemClass = _equipped ? _equipped->EquippedItemClass : -1;
    EquippedItemSubClassMask = _equipped ?_equipped->EquippedItemSubClassMask : -1;
    EquippedItemInventoryTypeMask = _equipped ? _equipped->EquippedItemInventoryTypeMask : -1;

    // SpellInterruptsEntry
    SpellInterruptsEntry const* _interrupt = GetSpellInterrupts();
    InterruptFlags = _interrupt ? _interrupt->InterruptFlags : 0;
    AuraInterruptFlags = _interrupt ? _interrupt->AuraInterruptFlags[0] : 0;
    AuraInterruptFlags2 = _interrupt ? _interrupt->AuraInterruptFlags[1] : 0;
    ChannelInterruptFlags = _interrupt ? _interrupt->ChannelInterruptFlags[0] : 0;
    ChannelInterruptFlags2 = _interrupt ? _interrupt->ChannelInterruptFlags[1] : 0;

    // SpellLevelsEntry
    SpellLevelsEntry const* _levels = GetSpellLevels();
    MaxLevel = _levels ? _levels->maxLevel : 0;
    BaseLevel = _levels ? _levels->baseLevel : 0;
    SpellLevel = _levels ? _levels->spellLevel : 0;

    SpellPowers.clear();

    // SpellMiscEntry
    SpellMiscEntry const* _misc = GetSpellMisc();
    Attributes = _misc ? _misc->Attributes : 0;
    AttributesEx = _misc ? _misc->AttributesEx : 0;
    AttributesEx2 = _misc ? _misc->AttributesEx2 : 0;
    AttributesEx3 = _misc ? _misc->AttributesEx3 : 0;
    AttributesEx4 = _misc ? _misc->AttributesEx4 : 0;
    AttributesEx5 = _misc ? _misc->AttributesEx5 : 0;
    AttributesEx6 = _misc ? _misc->AttributesEx6 : 0;
    AttributesEx7 = _misc ? _misc->AttributesEx7 : 0;
    AttributesEx8 = _misc ? _misc->AttributesEx8 : 0;
    AttributesEx9 = _misc ? _misc->AttributesEx9 : 0;
    AttributesEx10 = _misc ? _misc->AttributesEx10 : 0;
    AttributesEx11 = _misc ? _misc->AttributesEx11 : 0;
    AttributesEx12 = _misc ? _misc->AttributesEx12 : 0;
    AttributesEx13 = _misc ? _misc->AttributesEx13 : 0;
    CastTimeEntry = _misc ? (_misc->CastingTimeIndex ? sSpellCastTimesStore.LookupEntry(_misc->CastingTimeIndex) : NULL) : NULL;
    DurationEntry = _misc ? (_misc->DurationIndex ? sSpellDurationStore.LookupEntry(_misc->DurationIndex) : NULL) : NULL;
    RangeEntry = _misc ? (_misc->RangeIndex ? sSpellRangeStore.LookupEntry(_misc->RangeIndex) : NULL) : NULL;
    Speed = _misc ? _misc->speed : 1.00f;
    LaunchDelay = _misc ? _misc->LaunchDelay : 0.0f;

    IconFileDataId = _misc ? _misc->SpellIconFileDataId : 0;
    ActiveIconFileDataId = 0;//_misc ? _misc->ActiveIconFileDataID : 0;
    SchoolMask = _misc ? _misc->SchoolMask : 0;

    // SpellReagentsEntry
    SpellReagentsEntry const* _reagents = GetSpellReagents();
    for (uint8 i = 0; i < MAX_SPELL_REAGENTS; ++i)
        Reagent[i] = _reagents ? _reagents->Reagent[i] : 0;
    for (uint8 i = 0; i < MAX_SPELL_REAGENTS; ++i)
        ReagentCount[i] = _reagents ? _reagents->ReagentCount[i] : 0;


    auto l_SpellReagentCurrencyItr = sSpellReagentsCurrencyMap.find(p_SpellEntry->Id);
    SpellReagentsCurrencyEntry const* l_CurrencyReagents = l_SpellReagentCurrencyItr != sSpellReagentsCurrencyMap.end() ? l_SpellReagentCurrencyItr->second : nullptr;
    CurrencyID = l_CurrencyReagents ? l_CurrencyReagents->CurrencyID : 0;
    CurrencyCount = l_CurrencyReagents ? l_CurrencyReagents->CurrencyCount : 0;

    // SpellShapeshiftEntry
    SpellShapeshiftEntry const* _shapeshift = GetSpellShapeshift();
    Stances = _shapeshift ? MAKE_PAIR64(_shapeshift->ShapeshiftMask[0], _shapeshift->ShapeshiftMask[1]) : 0;
    StancesNot = _shapeshift ? MAKE_PAIR64(_shapeshift->ShapeshiftExclude[0], _shapeshift->ShapeshiftExclude[1]) : 0;

    // SpellTargetRestrictionsEntry
    SpellTargetRestrictionsEntry const* _target = GetSpellTargetRestrictions();
    Targets = _target ? _target->Targets : 0;
    TargetCreatureType = _target ? _target->TargetCreatureType : 0;
    MaxAffectedTargets = _target ? _target->MaxAffectedTargets : 0;
    MaxTargetLevel = _target ? _target->MaxTargetLevel : 0;

    // SpellTotemsEntry
    SpellTotemsEntry const* _totem = GetSpellTotems();
    for (uint8 i = 0; i < 2; ++i)
        TotemCategory[i] = _totem ? _totem->TotemCategory[i] : 0;
    for (uint8 i = 0; i < 2; ++i)
        Totem[i] = _totem ? _totem->Totem[i] : 0;

    // SpecializationSpellsEntry
    SpecializationSpellEntry const* specializationInfo = nullptr;
    for (uint32 i = 0; i < sSpecializationSpellStore.GetNumRows(); i++)
    {
        specializationInfo = sSpecializationSpellStore.LookupEntry(i);
        if (!specializationInfo)
            continue;

        if (specializationInfo->SpellID == Id)
            SpecializationIdList.push_back(specializationInfo->SpecializationEntry);

        if (specializationInfo->OverridesSpellID == Id)
            OverrideSpellList.push_back(specializationInfo->SpellID);
    }

    m_TalentIDs.clear();

    ExplicitTargetMask = _GetExplicitTargetMask();
    ChainEntry = NULL;

    auto l_ResearchProject = sResearchProjectPerSpell.find(Id);

    ResearchProject = l_ResearchProject == sResearchProjectPerSpell.end() ? 0 : l_ResearchProject->second->ID;
    m_IsPVPTalent = false;

    CanUpdateCriteriaBeSpellTarget    = false;
    CanUpdateCriteriaBeSpellTarget2   = false;
    CanUpdateCriteriaCastSpell        = false;
    CanUpdateCriteriaCastSpell2       = false;
    CanUpdateCriteriaTimedSpellTarget = false;
    CanUpdateCriteriaTimedSpellCaster = false;
}

SpellInfo::~SpellInfo()
{
    _UnloadImplicitTargetConditionLists();
}

uint32 SpellInfo::GetCategory() const
{
    return CategoryEntry ? CategoryEntry->Id : 0;
}

bool SpellInfo::HasEffect(SpellEffects effect) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect(effect))
            return true;

    return false;
}

SpellEffectInfo const* SpellInfo::GetEffectByType(SpellEffects p_Effect) const
{
    for (uint8 l_I = 0; l_I < EffectCount; ++l_I)
        if (Effects[l_I].IsEffect(p_Effect))
            return &Effects[l_I];

    return nullptr;
}

int8 SpellInfo::GetEffectIndex(SpellEffects effect) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect(effect))
            return i;

    return -1;
}

bool SpellInfo::HasAura(AuraType aura) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsAura(aura))
            return true;

    return false;
}

bool SpellInfo::HasAuraPositive(AuraType aura) const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsAura(aura) && IsPositiveEffect(i))
            return true;
    }

    return false;
}

bool SpellInfo::HasAreaAuraEffect() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsAreaAuraEffect())
            return true;

    return false;
}

bool SpellInfo::HasPersistenAura() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsPersistenAura())
            return true;

    return false;
}

bool SpellInfo::IsExplicitDiscovery() const
{

    return (EffectCount > 1 && (Effects[0].Effect == SPELL_EFFECT_CREATE_RANDOM_ITEM
        || Effects[0].Effect == SPELL_EFFECT_CREATE_LOOT)
        && Effects[1].Effect == SPELL_EFFECT_SCRIPT_EFFECT)
        || Id == 64323 || Id == 112996 || Id == 101805;
}

bool SpellInfo::IsLootCrafting() const
{
    return HasEffect(SPELL_EFFECT_CREATE_RANDOM_ITEM) ||
    HasEffect(SPELL_EFFECT_CREATE_ITEM) ||
    HasEffect(SPELL_EFFECT_CREATE_LOOT);
}

bool SpellInfo::IsQuestTame() const
{
    return EffectCount > 1 && Effects[0].Effect == SPELL_EFFECT_THREAT && Effects[1].Effect == SPELL_EFFECT_APPLY_AURA && Effects[1].ApplyAuraName == SPELL_AURA_DUMMY;
}

bool SpellInfo::IsProfession() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsProfessionSkill(skill))
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPrimaryProfession() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsPrimaryProfessionSkill(skill))
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPrimaryProfessionFirstRank() const
{
    return IsPrimaryProfession() && GetRank() == 1;
}

uint16 SpellInfo::GetPrimaryProfessionSkill() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].Effect == SPELL_EFFECT_SKILL)
        {
            uint32 skill = Effects[i].MiscValue;

            if (IsPrimaryProfessionSkill(skill))
                return skill;
        }
    }

    return 0;
}

bool SpellInfo::IsAbilityOfSkillType(uint32 skillType) const
{
    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(Id);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
        if (_spell_idx->second->SkillLine == skillType)
            return true;

    return false;
}

bool SpellInfo::IsAffectingArea() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect() && ((Effects[i].IsTargetingArea() && Effects[i].Effect != SPELL_EFFECT_DUMMY) || Effects[i].IsEffect(SPELL_EFFECT_PERSISTENT_AREA_AURA) || Effects[i].IsAreaAuraEffect()))
            return true;

    if (!IsPositive() && HasCustomAttribute(SpellCustomAttributes::SPELL_ATTR0_CU_IS_CUSTOM_AOE_SPELL))
        return true;

    return false;
}

// checks if spell targets are selected from area, doesn't include spell effects in check (like area wide auras for example)
bool SpellInfo::IsTargetingArea() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].IsEffect() && Effects[i].IsTargetingArea())
            return true;

    if (!IsPositive() && HasCustomAttribute(SpellCustomAttributes::SPELL_ATTR0_CU_IS_CUSTOM_AOE_SPELL))
        return true;

    return false;
}

bool SpellInfo::NeedsExplicitUnitTarget() const
{
    return GetExplicitTargetMask() & TARGET_FLAG_UNIT_MASK;
}

bool SpellInfo::NeedsToBeTriggeredByCaster() const
{
    if (NeedsExplicitUnitTarget())
        return true;
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsEffect())
        {
            if (Effects[i].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_CHANNEL
                || Effects[i].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_CHANNEL)
                return true;
        }
    }
    return false;
}

bool SpellInfo::IsPassive() const
{
    return Attributes & SPELL_ATTR0_PASSIVE;
}

bool SpellInfo::IsRaidMarker() const
{
    return AttributesEx8 & SPELL_ATTR8_RAID_MARKER;
}

bool SpellInfo::IsAutocastable() const
{
    if (Attributes & SPELL_ATTR0_PASSIVE)
        return false;
    if (AttributesEx & SPELL_ATTR1_UNAUTOCASTABLE_BY_PET)
        return false;
    return true;
}

bool SpellInfo::IsStackableWithRanks() const
{
    if (IsPassive())
        return false;

    if (PowerType != POWER_MANA && PowerType != POWER_HEALTH)
        return false;

    // All stance spells. if any better way, change it.
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        switch (SpellFamilyName)
        {
            case SPELLFAMILY_PALADIN:
                // Paladin aura Spell
                if (Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
                    return false;
                break;
            case SPELLFAMILY_DRUID:
                // Druid form Spell
                if (Effects[i].Effect == SPELL_EFFECT_APPLY_AURA &&
                    Effects[i].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
                    return false;
                break;
        }
    }
    return true;
}

bool SpellInfo::IsPassiveStackableWithRanks() const
{
    return IsPassive() && !HasEffect(SPELL_EFFECT_APPLY_AURA) && !HasEffect(SPELL_EFFECT_APPLY_AURA_2);
}

bool SpellInfo::IsMultiSlotAura() const
{
    return (IsPassive() || Id == 55849 || Id == 40075) && Id != 76856;
}

bool SpellInfo::IsCooldownStartedOnEvent() const
{
    return Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE || (CategoryEntry && (CategoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_STARTS_ON_EVENT));
}

bool SpellInfo::IsDeathPersistent() const
{
    return AttributesEx3 & SPELL_ATTR3_DEATH_PERSISTENT;
}

bool SpellInfo::IsRequiringDeadTarget() const
{
    return AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS;
}

bool SpellInfo::IsAllowingDeadTarget() const
{
    return AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD || Targets & (TARGET_FLAG_CORPSE_ALLY | TARGET_FLAG_CORPSE_ENEMY | TARGET_FLAG_UNIT_DEAD);
}

bool SpellInfo::CanBeUsedInCombat() const
{
    return !(Attributes & SPELL_ATTR0_CANT_USED_IN_COMBAT);
}

bool SpellInfo::IsPositive() const
{
    return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE);
}

bool SpellInfo::IsHealingSpell() const
{
    return (HasEffect(SPELL_EFFECT_HEALTH_LEECH)
        || HasEffect(SPELL_EFFECT_HEAL_MAX_HEALTH)
        || HasEffect(SPELL_EFFECT_HEAL_MECHANICAL)
        || HasEffect(SPELL_EFFECT_HEAL_PCT)
        || HasEffect(SPELL_EFFECT_HEAL)
        || HasAuraPositive(SPELL_AURA_OBS_MOD_HEALTH)
        || HasAuraPositive(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_PCT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_DONE)
        || HasAuraPositive(SPELL_AURA_MOD_HEALING_DONE_PERCENT)
        || HasAuraPositive(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT)
        || HasAuraPositive(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER)
        || HasAuraPositive(SPELL_AURA_MOD_BASE_HEALTH_PCT)
        || HasAuraPositive(SPELL_AURA_PERIODIC_HEAL));
}

bool SpellEffectInfo::IsHealingEffect() const
{
    switch (Effect)
    {
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL_MAX_HEALTH:
        case SPELL_EFFECT_HEAL_MECHANICAL:
        case SPELL_EFFECT_HEAL_PCT:
        case SPELL_EFFECT_HEAL:
            return true;
        case SPELL_EFFECT_APPLY_AURA:
        case SPELL_EFFECT_APPLY_AURA_2:
        {
            switch (ApplyAuraName)
            {
                case SPELL_AURA_OBS_MOD_HEALTH:
                case SPELL_AURA_MOD_HEALTH_REGEN_PERCENT:
                case SPELL_AURA_MOD_HEALING:
                case SPELL_AURA_MOD_HEALING_PCT:
                case SPELL_AURA_MOD_HEALING_DONE:
                case SPELL_AURA_MOD_HEALING_DONE_PERCENT:
                case SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT:
                case SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER:
                case SPELL_AURA_MOD_BASE_HEALTH_PCT:
                case SPELL_AURA_PERIODIC_HEAL:
                    return true;
                default:
                    break;
            }

            break;
        }
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsShieldingSpell() const
{
    return (HasAura(SPELL_AURA_SCHOOL_ABSORB)
        || HasAura(SPELL_AURA_SCHOOL_HEAL_ABSORB));
}

bool SpellEffectInfo::IsShieldingEffect() const
{
    switch (ApplyAuraName)
    {
        case SPELL_AURA_SCHOOL_ABSORB:
        case SPELL_AURA_SCHOOL_HEAL_ABSORB:
            return true;
        default:
            break;
    }

    return false;
}

bool SpellEffectInfo::IsHealingOrShieldingEffect() const
{
    return (IsHealingEffect() || IsShieldingEffect());
}

bool SpellInfo::IsPositiveEffect(uint8 effIndex) const
{
    switch (effIndex)
    {
        default:
        case 0:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF0);
        case 1:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF1);
        case 2:
            return !(AttributesCu & SPELL_ATTR0_CU_NEGATIVE_EFF2);
    }
}

bool SpellInfo::IsChanneled() const
{
    return (AttributesEx & (SPELL_ATTR1_CHANNELED_1 | SPELL_ATTR1_CHANNELED_2));
}

bool SpellInfo::NeedsComboPoints() const
{
    return (AttributesEx & (SPELL_ATTR1_REQ_COMBO_POINTS1 | SPELL_ATTR1_REQ_COMBO_POINTS2));
}

bool SpellInfo::IsRangedWeaponSpell() const
{
    return (SpellFamilyName == SPELLFAMILY_HUNTER && !(SpellFamilyFlags[1] & 0x10000000)) // for 53352, cannot find better way
        || (EquippedItemSubClassMask & ITEM_SUBCLASS_MASK_WEAPON_RANGED);
}

bool SpellInfo::IsAutoRepeatRangedSpell() const
{
    return AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG;
}

bool SpellInfo::CanTriggerPoisonAdditional() const
{
    if (SpellFamilyName == SPELLFAMILY_ROGUE)
    {
        switch (Id)
        {
            case 1766:  ///< Kick
            case 1943:  ///< Rupture
            case 703:   ///< Garrote
                return true;
            default:
                break;
        }
    }
    return false;
}

bool SpellInfo::IsAffectedBySpellMods() const
{
    return !(AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS);
}

bool SpellInfo::IsAffectedBySpellMod(SpellModifier* mod) const
{
    if (mod->op != SPELLMOD_CRIT_DAMAGE_BONUS && !IsAffectedBySpellMods())
        return false;

    SpellInfo const* affectSpell = sSpellMgr->GetSpellInfo(mod->spellId);
    // False if affect_spell == NULL or spellFamily not equal
    /// if One has spellfaimily_warlock_pet and the other spell_family_warlock, this should be affected.
    if (!affectSpell || (affectSpell->SpellFamilyName != SpellFamilyName && !(((affectSpell->SpellFamilyName == SpellFamilyNames::SPELLFAMILY_WARLOCK) && (SpellFamilyName == SpellFamilyNames::SPELLFAMILY_WARLOCK_PET))
        || ((affectSpell->SpellFamilyName == SpellFamilyNames::SPELLFAMILY_WARLOCK_PET) && (SpellFamilyName == SpellFamilyNames::SPELLFAMILY_WARLOCK)))))
        return false;

    // true
    if (mod->mask & SpellFamilyFlags)
        return true;

    return false;
}

bool SpellInfo::CanPierceImmuneAura(SpellInfo const* aura) const
{
    // these spells pierce all avalible spells (Resurrection Sickness for example)
    if (Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return true;

    /// Hackfix for Imonar the Soulhunter - Pulse grenade, immunities shouldn't prevent knock back
    if (Id == 247388)
        return true;

    // these spells (Cyclone for example) can pierce all...         // ...but not these (Divine shield, Ice block, Cyclone and Banish for example)
    if ((AttributesEx & SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE) && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY || aura->Mechanic == MECHANIC_BANISH || aura->Id == 48707 || aura->Id == 157913))) ///< ...nor Anti-Magic Shell nor Evanesce
        return true;

    return false;
}

bool SpellInfo::CanDispelAura(SpellInfo const* aura) const
{
    /// Challenger's Burden / Necrotic Embrace / Misery
    if (aura->Id == 206151 || aura->Id == 244094 || aura->Id == 243961)
        return false;

    // Touch of Karma
    if (aura && (aura->Id == 125174 || aura->Id == 124280))
        return true;

    // These spells (like Mass Dispel) can dispell all auras
    if (Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return true;

    // These auras (like Divine Shield) can't be dispelled
    if (aura->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return false;

    // These auras (Cyclone for example) are not dispelable
    if (aura->AttributesEx & SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE)
        return false;

    return true;
}

bool SpellInfo::CanPierceCloakOfShadows(Unit* p_Caster, Unit* p_Target, bool p_Triggered /*= false*/) const
{
    if (IsPositive() || !(GetSchoolMask() & SPELL_SCHOOL_MASK_MAGIC) || GetSchoolMask() == SPELL_SCHOOL_MASK_ALL)
        return true;

    switch (Id)
    {
        case 245388: ///< Toxic Blade
            // the energize effect
            if (p_Caster == p_Target)
                return true;
            break;
        case 202665: ///< Curse of the Dreadblades
        case 202668: ///< Curse of the Dreadblades (energize)
        case 157695: ///< Demonbolt
        case 192759: ///< Kingsbane
        case 3409:   ///< Crippling Poison
        case 2818:   ///< Deadly Poison (DoT)
        case 8680:   ///< Wound Poison
        case 197051: ///< Mind-Numbing Poison
        case 210279: ///< Creeping Nightmares
        case 212997: ///< Carrion Plague
        case 223021: ///< Carrion Plague
        case 206480: ///< Carrion Plague
        case 206223: ///< Bonds of Fel
        case 200227: ///< Tangled Web
        case 200284: ///< Tangled Web
        case 204316: ///< Shockwave
        case 244094: ///< Necrotic Embrace
        case 243961: ///< Misery
        case 142895: ///< Ring of Peace
        case 237371: ///< Ring of Peace
        case 249016: ///< Antorus Eonar - Debuffs
        case 249015: ///< Antorus Eonar - Debuffs
        case 249014: ///< Antorus Eonar - Debuffs
        case 249017: ///< Antorus Eonar - Debuffs
            return true;
    }

    return false;
}

bool SpellInfo::CanCritDamageClassNone() const
{
    switch (Id)
    {
        case 73685: ///< Shaman - Unleash Elements - Unleash Life

        case 33778: ///< Druid - Lifebloom Final Bloom

        case 64844: ///< Priest - Divine Hymn

        case 85222: ///< Paladin - Light of Dawn
        case 94289: ///< Paladin - Protector of the Innocent

        case 119611: ///< Monk - Renewing Mist

        case 71607:  ///< Item - Bauble of True Blood 10m
        case 71646:  ///< Item - Bauble of True Blood 25m
        case 109825: ///< Item - Windward Heart heroic
        case 108000: ///< Item - Windward Heart lfr
        case 109822: ///< Item - Windward Heart normal
            return true;
    }
    return false;
}

bool SpellInfo::IsSingleTarget() const
{
    // all other single target spells have if it has AttributesEx5
    if (AttributesEx5 & SPELL_ATTR5_SINGLE_TARGET_SPELL)
        return true;

    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificJudgement:
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsSingleTargetWith(SpellInfo const* spellInfo) const
{
    // TODO - need better check
    // Equal icon and spellfamily
    if (SpellFamilyName == spellInfo->SpellFamilyName &&
        IconFileDataId == spellInfo->IconFileDataId)
        return true;

    SpellSpecificType spec = GetSpellSpecific();
    // spell with single target specific types
    switch (spec)
    {
        case SpellSpecificType::SpellSpecificJudgement:
        case SpellSpecificType::SpellSpecificMagePolymorph:
            if (spellInfo->GetSpellSpecific() == spec)
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsAuraExclusiveBySpecificWith(SpellInfo const* spellInfo) const
{
    SpellSpecificType spellSpec1 = GetSpellSpecific();
    SpellSpecificType spellSpec2 = spellInfo->GetSpellSpecific();
    switch (spellSpec1)
    {
        case SpellSpecificType::SpellSpecificWarlockArmor:
        case SpellSpecificType::SpellSpecificMageArmor:
        case SpellSpecificType::SpellSpecificElementalShield:
        case SpellSpecificType::SpellSpecificMagePolymorph:
        case SpellSpecificType::SpellSpecificPresence:
        case SpellSpecificType::SpellSpecificCharm:
        case SpellSpecificType::SpellSpecificScroll:
        case SpellSpecificType::SpellSpecificWarriorEnrage:
        case SpellSpecificType::SpellSpecificMageArcaneBrillance:
        case SpellSpecificType::SpellSpecificPriestDivineSpirit:
        case SpellSpecificType::SpellSpecificExocitMunition:
        case SpellSpecificType::SpellSpecificLethalPoison:
        case SpellSpecificType::SpellSpecificNonLethalPoison:
        case SpellSpecificType::SpellSpecificCrowdFavorite:
        case SpellSpecificType::SpellSpecificTarrenMillTitle:
        case SpellSpecificType::SpellSpecificDisposition:
        case SpellSpecificType::SpellSpecificTowerBuffs:
        case SpellSpecificType::SpellSpecificWeeklyEventBuffs:
        case SpellSpecificType::SpellSpecificAncestralVigor:
            return spellSpec1 == spellSpec2;
        case SpellSpecificType::SpellSpecificFood:
            return spellSpec2 == SpellSpecificType::SpellSpecificFood
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        case SpellSpecificType::SpellSpecificDrink:
            return spellSpec2 == SpellSpecificType::SpellSpecificDrink
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        case SpellSpecificType::SpellSpecificFoodAndDrink:
            return spellSpec2 == SpellSpecificType::SpellSpecificFood
                || spellSpec2 == SpellSpecificType::SpellSpecificDrink
                || spellSpec2 == SpellSpecificType::SpellSpecificFoodAndDrink;
        default:
            return false;
    }
}

bool SpellInfo::IsAuraExclusiveBySpecificPerCasterWith(SpellInfo const* spellInfo) const
{
    SpellSpecificType spellSpec = GetSpellSpecific();
    switch (spellSpec)
    {
        case SpellSpecificType::SpellSpecificHand:
        case SpellSpecificType::SpellSpecificAura:
        case SpellSpecificType::SpellSpecificSting:
        case SpellSpecificType::SpellSpecificCurse:
        case SpellSpecificType::SpellSpecificBane:
        case SpellSpecificType::SpellSpecificAspect:
        case SpellSpecificType::SpellSpecificJudgement:
        case SpellSpecificType::SpellSpecificWarlockCorruption:
        case SpellSpecificType::SpellSpecificGreaterBlessing:
            return spellSpec == spellInfo->GetSpellSpecific();
        default:
            return false;
    }
}

SpellCastResult SpellInfo::CheckShapeshift(uint32 p_Shapeshift) const
{
    // talents that learn spells can have stance requirements that need ignore
    // (this requirement only for client-side stance show in talent description)
    if (/*GetTalentSpellCost(Id) > 0 &&*/
        ((EffectCount > 0 &&  Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL) || (EffectCount > 1 && Effects[1].Effect == SPELL_EFFECT_LEARN_SPELL) || (EffectCount > 2 && Effects[2].Effect == SPELL_EFFECT_LEARN_SPELL)))
        return SPELL_CAST_OK;

    if (HasAttribute(SPELL_ATTR13_ACTIVATES_REQUIRED_SHAPESHIFT))
        return SPELL_CAST_OK;

    uint64 stanceMask = (p_Shapeshift ? UI64LIT(1) << (p_Shapeshift - 1) : 0);

    // can explicitly not be casted in this stance
    if (stanceMask & StancesNot)
        return SPELL_FAILED_NOT_SHAPESHIFT;

    // can explicitly be casted in this stance
    if (stanceMask & Stances)
        return SPELL_CAST_OK;

    bool actAsShifted = false;
    SpellShapeshiftFormEntry const* shapeInfo = NULL;
    if (p_Shapeshift > 0)
    {
        shapeInfo = sSpellShapeshiftFormStore.LookupEntry(p_Shapeshift);
        if (!shapeInfo)
        {
            sLog->outError(LOG_FILTER_SPELLS_AURAS, "GetErrorAtShapeshiftedCast: unknown shapeshift %u", p_Shapeshift);
            return SPELL_CAST_OK;
        }
        actAsShifted = !(shapeInfo->Flags & SHAPESHIFT_FORM_IS_NOT_A_SHAPESHIFT);
    }

    if (actAsShifted)
    {
        if (Attributes & SPELL_ATTR0_NOT_SHAPESHIFT || (shapeInfo && shapeInfo->Flags & SHAPESHIFT_FORM_PREVENT_USING_OWN_SKILLS)) // not while shapeshifted
            return SPELL_FAILED_NOT_SHAPESHIFT;
        else if (Stances != 0)                   // needs other shapeshift
            return SPELL_FAILED_ONLY_SHAPESHIFT;
    }
    else
    {
        // needs shapeshift
        if (!(AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT) && Stances != 0)
            return SPELL_FAILED_ONLY_SHAPESHIFT;
    }

    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player) const
{
    // normal case
    if (AreaGroupId > 0)
    {
        bool l_Found = false;
        std::vector<uint32> l_AreaGroups = GetAreasForGroup(AreaGroupId);
        for (uint32 areaId : l_AreaGroups)
        {
            if (areaId == zone_id || areaId == area_id)
            {
                l_Found = true;
                break;
            }
        }

        if (!l_Found)
            return SPELL_FAILED_INCORRECT_AREA;
    }

    // continent limitation (virtual continent)
    if (AttributesEx4 & SPELL_ATTR4_CAST_ONLY_IN_OUTLAND)
    {
        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
        MapEntry const* mapEntry = sMapStore.LookupEntry(v_map);
        if (!mapEntry || mapEntry->ExpansionID < 1 || !mapEntry->IsContinent())
            return SPELL_FAILED_INCORRECT_AREA;
    }

    // raid instance limitation
    if (AttributesEx6 & SPELL_ATTR6_NOT_IN_RAID_INSTANCE)
    {
        MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
        if (!mapEntry || mapEntry->IsRaid())
            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
    }

    // DB base check (if non empty then must fit at least single for allow)
    SpellAreaMapBounds saBounds = sSpellMgr->GetSpellAreaMapBounds(Id);
    if (saBounds.first != saBounds.second)
    {
        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (itr->second.IsFitToRequirements(player, zone_id, area_id))
                return SPELL_CAST_OK;
        }
        return SPELL_FAILED_INCORRECT_AREA;
    }

    // spell checks
    switch (Id)
    {
        case 105896: ///< Gift of Life
        case 105900: ///< Essence of Dreams
        case 105903: ///< Source of Magic
        case 105984: ///< Timeloop
        case 106224: ///< Last Defender of Azeroth
        case 106226: ///< Last Defender of Azeroth
        case 106227: ///< Last Defender of Azeroth
        case 106080: ///< Last Defender of Azeroth
        case 106108: ///< Heroic Will
        case 105925: ///< Fading Light
        case 109075: ///< Fading Light
        case 106498: ///< Looming Darkness
        case 106368: ///< Twilight Shift
        case 133755: ///< Flight
        case 140013: ///< Flight
            if (!player)
                return SPELL_CAST_OK;
            return (area_id == 5928 || area_id == 6622) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 103755: ///< Twilight Epiphany, Archbishop Benedictus, Hour of Twilight
            return ((map_id == 940 && area_id == 5845) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA);
        case 105009: ///< Gift of Sargeras, Well of Eternity
            return (map_id == 939)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 100713: ///< Deluge, Ragnaros, Firelands
        case 101110: ///< Rage of Ragnaros, Ragnaros, Firelands
            return (area_id == 5770)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 98226: ///< Balance Bar, Lord Rhyolith, Firelands
            return (area_id == 5763)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 102668: ///< Sands of the Hourglass, Murozond, End Time
            return (area_id == 5795)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 98229: ///< Concentration, Majordomo Staghelm, Firelands
        case 98245: ///< Legendary Concentration
        case 98252: ///< Epic Concentration
        case 98253: ///< Rare Concentration
        case 98254: ///< Uncommon Concentration
            return (area_id == 5769)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99252: ///< Blaze of Glory, Baleroc
            return (area_id == 5767)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99837: ///< Crystal Prison, Shannox
            return (map_id == 720)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 45614: ///< Shroud of the Scourge
            return (area_id == 4125)? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 43820: ///< Charm of the Witch Doctor
        case 43822: ///< Charm of the Raging Defender
        case 43816: ///< Charm of the Bloodletter
        case 43818: ///< Charm of Mighty Mojo
            return map_id == 568? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 99659: ///< Mushroom Chair
        case 62857: ///< Sandbox Tiger
        case 107926: ///< Sandbox Tiger
            return ((player && player->InBattleground()) ? SPELL_FAILED_NOT_IN_BATTLEGROUND : SPELL_CAST_OK);
        case 29534: ///< Traces of Silithyst
            return zone_id == 1377 ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 23333: ///< Warsong Flag
        case 23335: ///< Silverwing Flag
            return (map_id == 489 || map_id == 726) && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 34976: ///< Netherstorm Flag
            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        case 2584:  ///< Waiting to Resurrect
        case 22011: ///< Spirit Heal Channel
        case 22012: ///< Spirit Heal
        case 24171: ///< Resurrection Impact Visual
        case 42792: ///< Recently Dropped Flag
        case 43681: ///< Inactive
        case 44535: ///< Spirit Heal (mana)
        {
            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            return map_id == 1191 || zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 44521: ///< Preparation
        {
            if (!player)
                return SPELL_FAILED_REQUIRES_AREA;

            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            if (!mapEntry->IsBattleground())
                return SPELL_FAILED_REQUIRES_AREA;

            Battleground* bg = player->GetBattleground();
            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 32724: ///< Gold Team (Alliance)
        case 32725: ///< Green Team (Alliance)
        case 35774: ///< Gold Team (Horde)
        case 35775: ///< Green Team (Horde)
        {
            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 32727:///< Arena Preparation
        {
            if (!player)
                return SPELL_FAILED_REQUIRES_AREA;

            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
            if (!mapEntry)
                return SPELL_FAILED_INCORRECT_AREA;

            if (!mapEntry->IsBattleArena())
                return SPELL_FAILED_REQUIRES_AREA;

            Battleground* bg = player->GetBattleground();
            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
        }
        case 161862:///< Ascension
        {
            if (!player)
                return SPELL_FAILED_DONT_REPORT;

            return map_id == 1116 ? SPELL_CAST_OK : SPELL_FAILED_INCORRECT_AREA;
        }
        case 183213: ///< Barrel Ride (Neltharion's Lair)
            return map_id == 1458 ? SpellCastResult::SPELL_CAST_OK : SpellCastResult::SPELL_FAILED_INCORRECT_AREA;
        case 233652: ///< Confess (TOS)
        {
            if (!player)
                return SPELL_FAILED_DONT_REPORT;

            return map_id == 1676 ? SpellCastResult::SPELL_CAST_OK : SpellCastResult::SPELL_FAILED_INCORRECT_AREA;
        }
        case 252776: ///< Essence Transfer (To Xoroth)
        case 252777: ///< Essence Transfer (To Rancora)
        case 244494: ///< Essence Transfer (To Nathreza)
            return map_id == 1712 ? SpellCastResult::SPELL_CAST_OK : SpellCastResult::SPELL_FAILED_INCORRECT_AREA;
        default:
            break;
    }

    /// aura limitations
    if (player)
    {
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (!Effects[i].IsAura())
                continue;

            switch (Effects[i].ApplyAuraName)
            {
                case SPELL_AURA_FLY:
                case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
                {
                    if (!player->IsKnowHowFlyIn(map_id, zone_id, Id))
                        return SPELL_FAILED_INCORRECT_AREA;
                    break;
                }
                case SPELL_AURA_MOUNTED:
                {
                    uint32 l_MountType = Effects[i].MiscValueB;

                    if (MountEntry const* l_MountEntry = GetMountBySpell(Id))
                        l_MountType = l_MountEntry->MountType;

                    if (l_MountType && !player->GetMountCapability(l_MountType))
                        return SPELL_FAILED_NOT_HERE;
                    break;
                }
            }
        }
    }
    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckTarget(Unit const* caster, WorldObject const* target, bool implicit) const
{
    if (AttributesEx & SPELL_ATTR1_CANT_TARGET_SELF && caster == target)
        return SPELL_FAILED_BAD_TARGETS;

    /// Check for some spells that are only usable during quests or by npcs
    if (AttributesEx5 & SPELL_ATTR5_UNK7 && caster->IsPlayer() && target->IsPlayer())
        return SPELL_FAILED_BAD_TARGETS;

    /// HACK: It's very ugly hack for Living Bomb
    /// The spell is used on a dead target and the check is failed in 'IsInvisibleDueToDespawn()'
    /// Cannot fix that in the correct way :(
    bool l_SkipVisibilityCheck = Id == 44461 && target->ToUnit() && !target->ToUnit()->isAlive();

    // check visibility - ignore stealth for implicit (area) targets
    if (!l_SkipVisibilityCheck && !(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE) && (!caster->canSeeOrDetect(target, implicit, false, implicit)))
        return SPELL_FAILED_BAD_TARGETS;

    Unit const* unitTarget = target->ToUnit();

    // Custom MoP Script - Hack fix for Piercing Howl, Multi-Shot, Earthgrab Totem - it doesn't break stealth.
    if ((Id == 12323 || Id == 2643 || Id == 3600 || Id == 64695) && (unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) || HasAura(SPELL_AURA_MOD_INVISIBILITY)) && unitTarget)
        return SPELL_FAILED_BAD_TARGETS;

    // creature/player specific target checks
    if (unitTarget)
    {
        if (AttributesEx & SPELL_ATTR1_CANT_TARGET_IN_COMBAT && unitTarget->isInCombat())
            return SPELL_FAILED_TARGET_AFFECTING_COMBAT;

        // only spells with SPELL_ATTR3_ONLY_TARGET_GHOSTS can target ghosts
        if (((AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS) != 0) != unitTarget->HasAuraType(SPELL_AURA_GHOST))
        {
            if (AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_GHOSTS)
                return SPELL_FAILED_TARGET_NOT_GHOST;
            else
                return SPELL_FAILED_BAD_TARGETS;
        }

        if (caster != unitTarget)
        {
            if (caster->IsPlayer())
            {
                // Do not allow these spells to target creatures not tapped by us (Banish, Polymorph, many quest spells)
                // @TODO : rewrite tapped system with personal loot system
                /* if (AttributesEx2 & SPELL_ATTR2_CANT_TARGET_TAPPED)
                    if (Creature const* targetCreature = unitTarget->ToCreature())
                        if (!targetCreature->isTappedBy(caster->ToPlayer()))
                            return SPELL_FAILED_CANT_CAST_ON_TAPPED; */

                if (AttributesCu & SPELL_ATTR0_CU_PICKPOCKET)
                {
                     if (unitTarget->IsPlayer())
                         return SPELL_FAILED_BAD_TARGETS;
                     else if ((unitTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) == 0)
                         return SPELL_FAILED_TARGET_NO_POCKETS;
                }

                // Not allow disarm unarmed player
                if (Mechanic == MECHANIC_DISARM)
                {
                    if (unitTarget->IsPlayer())
                    {
                        Player const* player = unitTarget->ToPlayer();
                        if (!player->GetWeaponForAttack(WeaponAttackType::BaseAttack) || !player->IsUseEquipedWeapon(true))
                            return SPELL_FAILED_TARGET_NO_WEAPONS;
                    }
                }
            }
        }
    }
    // corpse specific target checks
    else if (Corpse const* corpseTarget = target->ToCorpse())
    {
        // cannot target bare bones
        if (corpseTarget->GetType() == CORPSE_BONES)
            return SPELL_FAILED_BAD_TARGETS;
        // we have to use owner for some checks (aura preventing resurrection for example)
        if (Player* owner = ObjectAccessor::FindPlayer(corpseTarget->GetOwnerGUID()))
            unitTarget = owner;
        // we're not interested in corpses without owner
        else
            return SPELL_FAILED_BAD_TARGETS;
    }
    // other types of objects - always valid
    else return SPELL_CAST_OK;

    // corpseOwner and unit specific target checks
    if (AttributesEx3 & SPELL_ATTR3_ONLY_TARGET_PLAYERS && !unitTarget->ToPlayer())
       return SPELL_FAILED_TARGET_NOT_PLAYER;

    if (!IsAllowingDeadTarget() && !unitTarget->isAlive())
       return SPELL_FAILED_TARGETS_DEAD;

    // check this flag only for implicit targets (chain and area), allow to explicitly target units for spells like Shield of Righteousness
    if (implicit && AttributesEx6 & SPELL_ATTR6_CANT_TARGET_CROWD_CONTROLLED && !unitTarget->CanFreeMove())
       return SPELL_FAILED_BAD_TARGETS;

    // Do not allow pet or guardian targets if the spell is a raid buff or may not target pets at all
    if ((HasAttribute(SPELL_ATTR7_CONSOLIDATED_RAID_BUFF) || HasAttribute(SPELL_ATTR5_DONT_ALLOW_PET_TARGET)) && (!caster->isPet() || !caster->isGuardian()))
        if ((unitTarget->isPet() || unitTarget->isGuardian()))
            return SPELL_FAILED_BAD_TARGETS;

    // checked in Unit::IsValidAttack/AssistTarget, shouldn't be checked for ENTRY targets
    //if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
    //    return SPELL_FAILED_BAD_TARGETS;

    //if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS)

    if (!CheckTargetCreatureType(unitTarget))
    {
        if (target->IsPlayer())
            return SPELL_FAILED_TARGET_IS_PLAYER;
        else
            return SPELL_FAILED_BAD_TARGETS;
    }

    // check GM mode and GM invisibility - only for player casts (npc casts are controlled by AI) and negative spells
    if (unitTarget != caster && (caster->IsControlledByPlayer() || !IsPositive()) && unitTarget->IsPlayer())
    {
        if (!unitTarget->ToPlayer()->IsVisible())
            return SPELL_FAILED_BM_OR_INVISGOD;

        if (unitTarget->ToPlayer()->isGameMaster())
            return SPELL_FAILED_BM_OR_INVISGOD;
    }

    // not allow casting on flying player
    if (unitTarget->HasUnitState(UNIT_STATE_IN_FLIGHT) && !(AttributesCu & SPELL_ATTR0_CU_ALLOW_INFLIGHT_TARGET))
        return SPELL_FAILED_BAD_TARGETS;

    // TARGET_UNIT_MASTER gets blocked here for passengers, because the whole idea of this check is to
    // not allow passengers to be implicitly hit by spells, however this target type should be an exception,
    // if this is left it kills spells that award kill credit from vehicle to master and some or all* spells,
    // the use of these 2 covers passenger target check

    if (!(Targets & TARGET_UNIT_MASTER) && !caster->IsVehicle())
    {
        if (TargetAuraState && !unitTarget->HasAuraState(AuraStateType(TargetAuraState), this, caster))
            return SPELL_FAILED_TARGET_AURASTATE;

        if (ExcludeTargetAuraState && unitTarget->HasAuraState(AuraStateType(ExcludeTargetAuraState), this, caster))
            return SPELL_FAILED_TARGET_AURASTATE;
    }

    if (TargetAuraSpell && !unitTarget->HasAura(TargetAuraSpell))
        return SPELL_FAILED_TARGET_AURASTATE;

    if (ExcludeTargetAuraSpell && unitTarget->HasAura(ExcludeTargetAuraSpell))
        return SPELL_FAILED_TARGET_AURASTATE;

    if (unitTarget->HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
        if (HasEffect(SPELL_EFFECT_SELF_RESURRECT) || HasEffect(SPELL_EFFECT_RESURRECT))
            return SPELL_FAILED_TARGET_CANNOT_BE_RESURRECTED;

    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckExplicitTarget(Unit const* caster, WorldObject const* target, Item const* itemTarget) const
{
    uint32 neededTargets = GetExplicitTargetMask();
    if (!target)
    {
        if (neededTargets & (TARGET_FLAG_UNIT_MASK | TARGET_FLAG_GAMEOBJECT_MASK | TARGET_FLAG_CORPSE_MASK))
            if (!(neededTargets & TARGET_FLAG_GAMEOBJECT_ITEM) || !itemTarget)
                return SPELL_FAILED_BAD_TARGETS;
        return SPELL_CAST_OK;
    }

    if (Unit const* unitTarget = target->ToUnit())
    {
        if (neededTargets & (TARGET_FLAG_UNIT_ENEMY | TARGET_FLAG_UNIT_ALLY | TARGET_FLAG_UNIT_RAID | TARGET_FLAG_UNIT_PARTY | TARGET_FLAG_UNIT_MINIPET | TARGET_FLAG_UNIT_PASSENGER))
        {
            if (neededTargets & TARGET_FLAG_UNIT_ENEMY)
                if (caster->_IsValidAttackTarget(unitTarget, this))
                    return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_ALLY
                || (neededTargets & TARGET_FLAG_UNIT_PARTY && caster->IsInPartyWith(unitTarget))
                || (neededTargets & TARGET_FLAG_UNIT_RAID && caster->IsInRaidWith(unitTarget)))
                    if (caster->_IsValidAssistTarget(unitTarget, this))
                        return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_MINIPET)
                if (unitTarget->GetGUID() == caster->GetCritterGUID())
                    return SPELL_CAST_OK;
            if (neededTargets & TARGET_FLAG_UNIT_PASSENGER)
                if (unitTarget->IsOnVehicle(caster))
                    return SPELL_CAST_OK;
            return SPELL_FAILED_BAD_TARGETS;
        }
    }
    return SPELL_CAST_OK;
}

SpellCastResult SpellInfo::CheckVehicle(Unit const* caster) const
{
    // All creatures should be able to cast as passengers freely, restriction and attribute are only for players
    if (caster->GetTypeId() != TYPEID_PLAYER)
        return SPELL_CAST_OK;

    Vehicle* vehicle = caster->GetVehicle();
    if (vehicle)
    {
        uint16 checkMask = 0;
        for (uint8 effIndex = EFFECT_0; effIndex < EffectCount; ++effIndex)
        {
            if (Effects[effIndex].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
            {
                SpellShapeshiftFormEntry const* shapeShiftEntry = sSpellShapeshiftFormStore.LookupEntry(Effects[effIndex].MiscValue);
                if (shapeShiftEntry && (shapeShiftEntry->Flags & 1) == 0)  // unk flag
                    checkMask |= VEHICLE_SEAT_FLAG_UNCONTROLLED;
                break;
            }
        }

        if (HasAura(SPELL_AURA_MOUNTED))
            checkMask |= VEHICLE_SEAT_FLAG_CAN_CAST_MOUNT_SPELL;

        if (!checkMask)
            checkMask = VEHICLE_SEAT_FLAG_CAN_ATTACK;

        VehicleSeatEntry const* vehicleSeat = vehicle->GetSeatForPassenger(caster);
        if (!(AttributesEx6 & SPELL_ATTR6_CASTABLE_WHILE_ON_VEHICLE) && !(Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED)
            && (vehicleSeat->m_flags & checkMask) != checkMask)
            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;

        // Can only summon uncontrolled minions/guardians when on controlled vehicle
        if (vehicleSeat->m_flags & (VEHICLE_SEAT_FLAG_CAN_CONTROL | VEHICLE_SEAT_FLAG_UNK2))
        {
            for (uint8 i = EFFECT_0; i < EffectCount; ++i)
            {
                if (Effects[i].Effect != SPELL_EFFECT_SUMMON)
                    continue;

                SummonPropertiesEntry const* props = sSummonPropertiesStore.LookupEntry(Effects[i].MiscValueB);
                if (props && props->Category != SUMMON_CATEGORY_WILD)
                    return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
            }
        }
    }

    return SPELL_CAST_OK;
}

bool SpellInfo::CheckTargetCreatureType(Unit const* target) const
{
    // Curse of Doom & Exorcism: not find another way to fix spell target check :/
    if (SpellFamilyName == SPELLFAMILY_WARLOCK && GetCategory() == 1179)
    {
        // not allow cast at player
        if (target->IsPlayer())
            return false;
        else
            return true;
    }

    uint32 creatureType = target->GetCreatureTypeMask();
    return !TargetCreatureType || !creatureType || (creatureType & TargetCreatureType);
}

SpellSchoolMask SpellInfo::GetSchoolMask() const
{
    return SpellSchoolMask(SchoolMask);
}

uint64 SpellInfo::GetAllEffectsMechanicMask() const
{
    uint64 l_Mask = 0;
    if (Mechanic)
        l_Mask |= 1LL << Mechanic;

    for (int l_I = 0; l_I < EffectCount; ++l_I)
    {
        if (Effects[l_I].IsEffect() && Effects[l_I].Mechanic)
            l_Mask |= 1LL << Effects[l_I].Mechanic;
    }

    return l_Mask;
}

uint64 SpellInfo::GetEffectMechanicMask(uint8 p_EffIndex) const
{
    uint64 l_Mask = 0;
    if (Mechanic)
        l_Mask |= 1LL << Mechanic;

    if (p_EffIndex >= SpellEffIndex::MAX_EFFECTS || p_EffIndex >= EffectCount)
        return 0;

    if (Effects[p_EffIndex].IsEffect() && Effects[p_EffIndex].Mechanic)
        l_Mask |= 1LL << Effects[p_EffIndex].Mechanic;

    return l_Mask;
}

uint64 SpellInfo::GetSpellMechanicMaskByEffectMask(uint32 p_EffectMask) const
{
    uint64 l_Mask = 0;
    if (Mechanic)
        l_Mask |= 1LL << Mechanic;

    for (int l_I = 0; l_I < EffectCount; ++l_I)
    {
        if ((p_EffectMask & (1 << l_I)) && Effects[l_I].Mechanic)
            l_Mask |= 1LL << Effects[l_I].Mechanic;
    }

    return l_Mask;
}

Mechanics SpellInfo::GetEffectMechanic(uint8 effIndex) const
{
    if (Effects[effIndex].IsEffect() && Effects[effIndex].Mechanic)
        return Mechanics(Effects[effIndex].Mechanic);
    if (Mechanic)
        return Mechanics(Mechanic);
    return MECHANIC_NONE;
}

bool SpellInfo::HasAnyEffectMechanic() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
        if (Effects[i].Mechanic)
            return true;

    return false;
}

uint32 SpellInfo::GetDispelMask() const
{
    return GetDispelMask(static_cast<DispelType>(Dispel));
}

uint32 SpellInfo::GetDispelMask(DispelType type)
{
    // If dispel all
    if (type == DISPEL_ALL)
        return DISPEL_ALL_MASK;
    else
        return uint32(1 << type);
}

uint32 SpellInfo::GetExplicitTargetMask() const
{
    return ExplicitTargetMask;
}

AuraStateType SpellInfo::GetAuraState() const
{
    // Conflagrate aura state on Immolate and Shadowflame
    if (SpellFamilyName == SPELLFAMILY_WARLOCK &&
        // Immolate
        ((SpellFamilyFlags[0] & 4) ||
        // Shadowflame
        (SpellFamilyFlags[2] & 2)))
        return AURA_STATE_CONFLAGRATE;

    // Sting (hunter's pet ability)
    if (GetCategory() == 1133)
        return AURA_STATE_FAERIE_FIRE;

    // Victorious
    if (SpellFamilyName == SPELLFAMILY_WARRIOR &&  SpellFamilyFlags[1] & 0x00040000)
        return AURA_STATE_WARRIOR_VICTORY_RUSH;

    // Swiftmend state on Regrowth & Rejuvenation
    if (SpellFamilyName == SPELLFAMILY_DRUID && SpellFamilyFlags[0] & 0x50)
        return AURA_STATE_SWIFTMEND;

    // Deadly poison aura state
    if (SpellFamilyName == SPELLFAMILY_ROGUE && SpellFamilyFlags[0] & 0x10000)
        return AURA_STATE_DEADLY_POISON;

    // Enrage aura state
    if (Dispel == DISPEL_ENRAGE)
        return AURA_STATE_ENRAGE;

    // Bleeding aura state
    if (GetAllEffectsMechanicMask() & (1LL << MECHANIC_BLEED))
        return AURA_STATE_BLEEDING;

    if ((GetSchoolMask() & SPELL_SCHOOL_MASK_FROST) && (GetSchoolMask() & SPELL_SCHOOL_MASK_SPELL) != SPELL_SCHOOL_MASK_SPELL) ///< Magic stunning should not be considered a AURA_STATE_FROZEN
    {
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (Effects[i].IsAura() && (Effects[i].ApplyAuraName == SPELL_AURA_MOD_STUN
                || Effects[i].ApplyAuraName == SPELL_AURA_MOD_ROOT
                || Effects[i].ApplyAuraName == SPELL_AURA_MOD_ROOT_2))
                return AURA_STATE_FROZEN;
        }
    }

    switch (Id)
    {
        case 71465: // Divine Surge
        case 50241: // Evasive Charges
            return AURA_STATE_UNKNOWN22;
        default:
            break;
    }

    return AURA_STATE_NONE;
}

SpellSpecificType SpellInfo::GetSpellSpecific() const
{
    switch (SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
        {
            // Food / Drinks (mostly)
            if (AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
            {
                bool food = false;
                bool drink = false;
                for (uint8 i = 0; i < EffectCount; ++i)
                {
                    if (!Effects[i].IsAura())
                        continue;

                    switch (Effects[i].ApplyAuraName)
                    {
                        // Food
                        case SPELL_AURA_MOD_REGEN:
                        case SPELL_AURA_OBS_MOD_HEALTH:
                            food = true;
                            break;
                        // Drink
                        case SPELL_AURA_MOD_POWER_REGEN:
                        case SPELL_AURA_OBS_MOD_POWER:
                            drink = true;
                            break;
                        default:
                            break;
                    }
                }

                if (food && drink)
                    return SpellSpecificType::SpellSpecificFoodAndDrink;
                else if (food)
                    return SpellSpecificType::SpellSpecificFood;
                else if (drink)
                    return SpellSpecificType::SpellSpecificDrink;
            }
            else if ((AttributesEx2 & SPELL_ATTR2_FOOD_BUFF) || IconFileDataId == 133943)
                return SpellSpecificType::SpellSpecificWellFed;
            // scrolls effects
            else
            {
                SpellInfo const* firstRankSpellInfo = GetFirstRankSpell();
                switch (firstRankSpellInfo->Id)
                {
                    case 8118: ///< Strength
                    case 8099: ///< Stamina
                    case 8112: ///< Versatility
                    case 8096: ///< Intellect
                    case 8115: ///< Agility
                    case 8091: ///< Armor
                        return SpellSpecificType::SpellSpecificScroll;
                }
            }

            switch (Id)
            {
                case 163366:    ///< Crowd Favorite - 25%
                case 163368:    ///< Crowd Favorite - 50%
                case 163369:    ///< Crowd Favorite - 75%
                case 163370:    ///< Crowd Favorite - 100%
                    return SpellSpecificType::SpellSpecificCrowdFavorite;
                case 157951:    ///< Aggressive Disposition
                case 158016:    ///< Fierce Disposition
                case 158017:    ///< Savage Disposition
                    return SpellSpecificType::SpellSpecificDisposition;
                case 173534:    ///< Hold your ground
                case 173541:    ///< Tower Defense
                case 173549:    ///< Stand Fast
                    return SpellSpecificType::SpellSpecificTowerBuffs;
                case 186400:    ///< Sign of Apexis
                case 186401:    ///< Sign of the Skirmisher
                case 186403:    ///< Sign of Battle
                case 186404:    ///< Sign of the Emissary
                case 186406:    ///< Sign of the Critter
                    return SpellSpecificType::SpellSpecificWeeklyEventBuffs;
                default:
                    break;
            }

            /// Tarren Mill titles
            if (Id >= 168412 && Id <= 168444)
                return SpellSpecificType::SpellSpecificTarrenMillTitle;

            break;
        }
        case SPELLFAMILY_MAGE:
        {
            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
            if (SpellFamilyFlags[0] & 0x12040000)
                return SpellSpecificType::SpellSpecificMageArmor;

            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
            if (SpellFamilyFlags[0] & 0x400)
                return SpellSpecificType::SpellSpecificMageArcaneBrillance;

            if ((SpellFamilyFlags[0] & 0x1000000) && Effects[0].ApplyAuraName == SPELL_AURA_MOD_CONFUSE)
                return SpellSpecificType::SpellSpecificMagePolymorph;

            switch (Id)
            {
                case 118:
                case 28272:
                case 28271:
                case 61780:
                case 61305:
                case 161372:
                case 61721:
                case 161354:
                case 126819:
                case 161355:
                case 161353:
                    return SpellSpecificType::SpellSpecificMagePolymorph;
                default:
                    break;
            }

            break;
        }
        case SPELLFAMILY_WARLOCK:
        {
            // Agony, Doom (Metamorphosis) and Havoc are no longer curses
            if (Id == 980 || Id == 603 || Id == 80240)
                return SpellSpecificType::SpellSpecificBane;

            // only warlock curses have this
            if (Dispel == DISPEL_CURSE)
                return SpellSpecificType::SpellSpecificCurse;

            break;
        }
        case SPELLFAMILY_PRIEST:
        {
            // "Well Fed" buff from Blessed Sunfruit, Blessed Sunfruit Juice, Alterac Spring Water
            if ((Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING) &&
                (InterruptFlags & AURA_INTERRUPT_FLAG_MOVE) &&
                (IconFileDataId == 135892 || IconFileDataId == 135928))
                return SpellSpecificType::SpellSpecificWellFed;

            // Divine Spirit and Prayer of Spirit
            if (SpellFamilyFlags[0] & 0x20)
                return SpellSpecificType::SpellSpecificPriestDivineSpirit;

            break;
        }
        case SPELLFAMILY_HUNTER:
        {
            // only hunter stings have this
            if (Dispel == DISPEL_POISON)
                return SpellSpecificType::SpellSpecificSting;

            // only hunter aspects have this (but not all aspects in hunter family) and Hack fix for Deterrence - Is not an aspect !
            if (SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010) && Id != 67801)
                return SpellSpecificType::SpellSpecificAspect;

            switch (Id)
            {
                case 162536:///< Incendiary Ammo
                case 162537:///< Poisoned Ammo
                case 162539:///< Frozen Ammo
                    return SpellSpecificType::SpellSpecificExocitMunition;
            }

            break;
        }
        case SPELLFAMILY_PALADIN:
        {
            if (SpellFamilyFlags[0] & 0x01000002)
                return SpellSpecificType::SpellSpecificBlessing;

            if (SpellFamilyFlags[0] & 0x00002190)
                return SpellSpecificType::SpellSpecificHand;

            // Judgement, Judgement of Truth
            if (Id == 20271 || Id == 31804)
                return SpellSpecificType::SpellSpecificJudgement;

            // Greater Blessing of Kings and Greater Blessing of Wisdom
            if (Id == 203539 || Id == 203538)
                return SpellSpecificType::SpellSpecificGreaterBlessing;

            // only paladin auras have this (for palaldin class family)
            if (SpellFamilyFlags[2] & 0x00000020)
                return SpellSpecificType::SpellSpecificAura;

            break;
        }
        case SPELLFAMILY_SHAMAN:
        {
            // family flags 10 (Lightning), 42 (Earth), 37 (Water), proc shield from T2 8 pieces bonus
            if (SpellFamilyFlags[1] & 0x420
                || SpellFamilyFlags[0] & 0x00000400
                || Id == 23552)
                return SpellSpecificType::SpellSpecificElementalShield;
            if (Id == 207400)
                return SpellSpecificType::SpellSpecificAncestralVigor;
            break;
        }
        case SPELLFAMILY_ROGUE:
        {
            switch (Id)
            {
                case 200802:  ///< Agonizing Poison
                case 2823:    ///< Deadly Poison
                case 8679:    ///< Wound Poison
                    return SpellSpecificType::SpellSpecificLethalPoison;
                case 3408:    ///< Crippling Poison
                case 108211:  ///< Leech Poison
                    return SpellSpecificType::SpellSpecificNonLethalPoison;
                default:
                    break;
            }

            break;
        }
    }

    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsApplyingAura())
        {
            switch (Effects[i].ApplyAuraName)
            {
                case SPELL_AURA_MOD_CHARM:
                case SPELL_AURA_MOD_POSSESS:
                case SPELL_AURA_AOE_CHARM:
                    return SpellSpecificType::SpellSpecificCharm;
                case SPELL_AURA_TRACK_CREATURES:
                case SPELL_AURA_TRACK_RESOURCES:
                case SPELL_AURA_TRACK_STEALTHED:
                    return SpellSpecificType::SpellSpecificTracker;
            }
        }
    }

    return SpellSpecificType::SpellSpecificNormal;
}

float SpellInfo::GetMinRange(bool positive) const
{
    if (!RangeEntry)
        return 0.0f;
    if (positive)
        return RangeEntry->minRangeFriend;
    return RangeEntry->minRangeHostile;
}

float SpellInfo::GetMaxRange(bool positive, Unit* caster, Spell* spell) const
{
    if (!RangeEntry)
        return 0.0f;
    float range;
    if (positive)
        range = RangeEntry->maxRangeFriend;
    else
        range = RangeEntry->maxRangeHostile;
    if (caster)
        if (Player* modOwner = caster->GetSpellModOwner())
            modOwner->ApplySpellMod(Id, SPELLMOD_RANGE, range, spell);
    return range;
}

int32 SpellInfo::GetDuration() const
{
    if (!DurationEntry)
        return 0;
    return (DurationEntry->Duration == -1) ? -1 : abs(DurationEntry->Duration);
}

int32 SpellInfo::GetMaxDuration() const
{
    if (!DurationEntry)
        return 0;
    return (DurationEntry->MaxDuration == -1) ? -1 : abs(DurationEntry->MaxDuration);
}

uint32 SpellInfo::CalcCastTime(Unit* p_Caster, Spell* p_Spell) const
{
    int32 l_CastTime = 0;

    // not all spells have cast time index and this is all is pasiive abilities
    if (CastTimeEntry)
        l_CastTime = CastTimeEntry->CastTime;

    if (!l_CastTime)
        return 0;

    /// Swift Riding Crop
    if (p_Caster && p_Caster->HasAura(170495))
    {
        if (SpellCategoriesEntry const* l_Cat = GetSpellCategories())
        {
            if (l_Cat->Mechanic == MECHANIC_MOUNT) ///< Mount
                return 0;
        }
    }

    /// 227252 - Quick mount
    if (p_Caster && p_Caster->HasAura(227252))
    {
        if (SpellCategoriesEntry const* l_Cat = GetSpellCategories())
        {
            if (l_Cat->Mechanic == MECHANIC_MOUNT) ///< Mount
                l_CastTime /= 2;

            return l_CastTime;
        }
    }

    if (p_Caster)
        p_Caster->ModSpellCastTime(this, l_CastTime, p_Spell);

    /// Glyph of the Righteous Retreat
    if (p_Caster && Id == 8690)
    {
        if (p_Caster->HasAura(115933) && (p_Caster->HasAura(642)))
            l_CastTime /= 2;
    }

    /// Flayer
    if (HasEffect(SPELL_EFFECT_SKINNING) && p_Caster->HasAura(68978))
        l_CastTime = CalculatePct(l_CastTime, 66);

    /// Cultivation
    if (HasEffect(SPELL_EFFECT_SKILL) && p_Caster->HasAura(20552) && AttributesEx10 & SPELL_ATTR10_HERB_GATHERING_MINING)
    {
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (Effects[i].Effect == SPELL_EFFECT_SKILL && Effects[i].MiscValue == SKILL_HERBALISM)
            {
                l_CastTime = CalculatePct(l_CastTime, 66);
                break;
            }
        }
    }

    /// Loot bonus animation
    if (HasEffect(SpellEffects::SPELL_EFFECT_LOOT_BONUS))
        l_CastTime = 0;

    /// Elegon - Overloaded
    if (p_Caster && p_Caster->HasAura(117204))
    {
        if (Aura* overloaded = p_Caster->GetAura(117204))
            l_CastTime -= CalculatePct(l_CastTime, (20 * overloaded->GetStackAmount()));
    }

    if (p_Caster && p_Caster->GetTypeId() == TypeID::TYPEID_UNIT)
    {
        if (p_Caster->ToCreature()->IsAIEnabled)
            p_Caster->ToCreature()->AI()->OnCalculateCastingTime(this, l_CastTime);
    }

    return (l_CastTime > 0) ? uint32(l_CastTime) : 0;
}

uint32 SpellInfo::GetMaxTicks() const
{
    int32 DotDuration = GetDuration();
    if (DotDuration == 0)
        return 1;

    // 200% limit
    if (DotDuration > 30000)
        DotDuration = 30000;

    for (uint8 x = 0; x < EffectCount; x++)
    {
        if (Effects[x].IsApplyingAura())
        {
            switch (Effects[x].ApplyAuraName)
            {
                case SPELL_AURA_PERIODIC_DAMAGE:
                case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
                case SPELL_AURA_PERIODIC_HEAL:
                case SPELL_AURA_PERIODIC_LEECH:
                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
                case SPELL_AURA_PERIODIC_DUMMY:
                    if (Effects[x].Amplitude != 0)
                        return DotDuration / Effects[x].Amplitude + static_cast<uint8>(HasAttribute(SpellAttr5::SPELL_ATTR5_START_PERIODIC_AT_APPLY));
                    break;
            }
        }
    }

    return 6;
}

uint32 SpellInfo::GetRecoveryTime() const
{
    return RecoveryTime > CategoryRecoveryTime ? RecoveryTime : CategoryRecoveryTime;
}

SpellPowerEntry const* SpellInfo::GetSpellPower(Powers p_PowerType) const
{
    for (auto l_SpellPowerEntry : SpellPowers)
        if (l_SpellPowerEntry->PowerType == p_PowerType)
            return p_PowerType < Powers::MAX_POWERS_COST ? l_SpellPowerEntry : nullptr;
    return nullptr;
}

void SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask, int32* m_powerCost) const
{
    if (SpellPowers.empty())
        return;

    // Spell drain all exist power on cast (Only paladin lay of Hands)
    if (AttributesEx & SPELL_ATTR1_DRAIN_ALL_POWER)
    {
        for (auto itr : SpellPowers)
        {
            Powers PowerType = Powers(itr->PowerType);

            if (PowerType == POWER_HEALTH) // If power type - health drain all
                m_powerCost[POWER_TO_INDEX(PowerType)] = int32(caster->GetHealth());
            else if (PowerType < MAX_POWERS) // Else drain all power
                m_powerCost[POWER_TO_INDEX(PowerType)] = caster->GetPower(Powers(PowerType));
            else
                sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
        }
    }

    int32 powerCost = 0;
    bool l_RemoveMod = true;
    for (auto itr : SpellPowers)
    {
        if (itr->RequiredAuraSpellId && !caster->HasAura(itr->RequiredAuraSpellId))
            continue;

        Powers PowerType = Powers(itr->PowerType);

        // Base powerCost
        powerCost = itr->Cost;

        // PCT cost from total amount
        if (itr->CostBasePercentage)
        {
            switch (PowerType)
            {
                // health as power used
                case POWER_HEALTH:
                    powerCost += int32(CalculatePct(caster->GetMaxHealth(), itr->CostBasePercentage));
                    break;
                case POWER_MANA:
                    powerCost += int32(CalculatePct(caster->GetCreateMana(), itr->CostBasePercentage));
                    break;
                case POWER_RAGE:
                case POWER_PAIN:
                case POWER_FOCUS:
                case POWER_ENERGY:
                case POWER_CHI:
                    powerCost += int32(CalculatePct(caster->GetMaxPower(Powers(PowerType)), itr->CostBasePercentage));
                    break;
                case POWER_RUNES:
                case POWER_RUNIC_POWER:
                    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "CalculateManaCost: Not implemented yet!");
                    break;
                default:
                    sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
                    break;
            }
        }

        // PCT cost from max amount
        if (itr->CostMaxPercentage)
        {
            switch (PowerType)
            {
                // health as power used
                case POWER_HEALTH:
                    powerCost += int32(CalculatePct(caster->GetMaxHealth(), itr->CostMaxPercentage));
                    break;
                case POWER_MANA:
                case POWER_RAGE:
                case POWER_PAIN:
                case POWER_FOCUS:
                case POWER_ENERGY:
                case POWER_CHI:
                    powerCost += int32(CalculatePct(caster->GetMaxPower(PowerType), itr->CostMaxPercentage));
                    break;
                case POWER_RUNES:
                case POWER_RUNIC_POWER:
                    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "CalculateManaCost: Not implemented yet!");
                    break;
                default:
                    sLog->outAshran("SpellInfo::CalcPowerCost: Unknown power type [%u] with spell [%u]", PowerType, Id);
                    break;
            }
        }

        // Flat mod from caster auras by spell school and power type
        Unit::AuraEffectList const& auras = caster->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_COST_SCHOOL);
        for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
        {
            if (!((*i)->GetMiscValue() & schoolMask))
                continue;

            if (!((*i)->GetMiscValueB() & (1 << PowerType)))
                continue;

            powerCost += (*i)->GetAmount();
        }

        // Apply cost mod by spell
        if (Player* modOwner = caster->GetSpellModOwner())
            modOwner->ApplySpellMod(Id, powerCost < 0 ? SPELLMOD_SPELL_COST2 : SPELLMOD_COST, powerCost, nullptr, l_RemoveMod);

        /// If the player has SPELLMOD_COST with 2+ charges and the spell has more than one PowerCost then it drops more than one mod charges, but it should drop one charge only
        /// Example: Eviscerate and Feeding Frenzy
        l_RemoveMod = false;

        // PCT mod from user auras by spell school and power type
        Unit::AuraEffectList const& aurasPct = caster->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT);
        for (Unit::AuraEffectList::const_iterator i = aurasPct.begin(); i != aurasPct.end(); ++i)
        {
            if (!((*i)->GetMiscValue() & schoolMask))
                continue;

            if (!((*i)->GetMiscValueB() & (1 << PowerType)))
                continue;

            powerCost += CalculatePct(powerCost, (*i)->GetAmount());
        }


        /// Lock and Load should avoid focus consumption of Aimed Shot
        if (Id == 19434 && PowerType == POWER_FOCUS && caster->HasAura(194594))
            powerCost = 0;

        /// Hack fix: Soul Swap Exhale shouldn't take any mana
        if (Id == 86213 && PowerType == POWER_MANA)
            powerCost = 0;

        if (Id == 190456 && PowerType == POWER_RAGE)
            powerCost = 200;

        ///< Vengeance: Ignore Pain power cost calc
        if (caster->HasAura(202574) && Id == 190456 && PowerType == POWER_RAGE)
            powerCost = 130;

        ///< Mortal Strike Power cost with Dauntless + Archavon's Heavy Hand auras
        if (caster->HasAura(205144) && caster->HasAura(202297) && (Id == 12294 || Id == 246820) && PowerType == POWER_RAGE)
            powerCost = 100;

        m_powerCost[POWER_TO_INDEX(PowerType)] += powerCost;
    }
}

inline float CalcPPMHasteMod(SpellProcsPerMinuteModEntry const* mod, Unit* caster)
{
    float haste = caster->GetFloatValue(UNIT_FIELD_MOD_HASTE);
    float rangedHaste = caster->GetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE);
    float spellHaste = caster->GetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE);
    float regenHaste = caster->GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);

    switch (mod->Param)
    {
        case 1:
            return (1.0f / haste - 1.0f) * mod->Coeff;
        case 2:
            return (1.0f / rangedHaste - 1.0f) * mod->Coeff;
        case 3:
            return (1.0f / spellHaste - 1.0f) * mod->Coeff;
        case 4:
            return (1.0f / regenHaste - 1.0f) * mod->Coeff;
        case 5:
            return (1.0f / std::min(std::min(std::min(haste, rangedHaste), spellHaste), regenHaste) - 1.0f) * mod->Coeff;
        default:
            break;
    }

    return 0.0f;
}

inline float CalcPPMCritMod(SpellProcsPerMinuteModEntry const* mod, Unit* caster)
{
    if (caster->GetTypeId() != TYPEID_PLAYER)
        return 0.0f;

    float crit = caster->GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE);
    float rangedCrit = caster->GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE);
    float spellCrit = caster->GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);

    switch (mod->Param)
    {
        case 1:
            return crit * mod->Coeff * 0.01f;
        case 2:
            return rangedCrit * mod->Coeff * 0.01f;
        case 3:
            return spellCrit * mod->Coeff * 0.01f;
        case 4:
            return std::min(std::min(crit, rangedCrit), spellCrit) * mod->Coeff * 0.01f;
        default:
            break;
    }

    return 0.0f;
}

inline float CalcPPMItemLevelMod(SpellProcsPerMinuteModEntry const* mod, int32 itemLevel)
{
    if (uint32(itemLevel) == mod->Param)
        return 0.0f;

    float itemLevelPoints = GetRandomPropertyPoints(itemLevel, ITEM_QUALITY_RARE, INVTYPE_CHEST, 0);
    float basePoints = GetRandomPropertyPoints(mod->Param, ITEM_QUALITY_RARE, INVTYPE_CHEST, 0);
    if (itemLevelPoints == basePoints)
        return 0.0f;

    return ((itemLevelPoints / basePoints) - 1.0f) * mod->Coeff;
}

float SpellInfo::CalcProcPPM(float ppm, Unit* caster, int32 itemLevel) const
{
    for (SpellProcsPerMinuteModEntry const* mod : ProcPPMMods)
    {
        switch (mod->Type)
        {
            case SPELL_PPM_MOD_HASTE:
            {
                ppm *= 1.0f + CalcPPMHasteMod(mod, caster);
                break;
            }
            case SPELL_PPM_MOD_CRIT:
            {
                ppm *= 1.0f + CalcPPMCritMod(mod, caster);
                break;
            }
            case SPELL_PPM_MOD_CLASS:
            {
                if (caster->getClassMask() & mod->Param)
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_SPEC:
            {
                if (Player* plrCaster = caster->ToPlayer())
                    if (plrCaster->GetActiveSpecializationID() == mod->Param)
                        ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_RACE:
            {
                if (caster->getRaceMask() & mod->Param)
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            case SPELL_PPM_MOD_ITEM_LEVEL:
            {
                ppm *= 1.0f + CalcPPMItemLevelMod(mod, itemLevel);
                break;
            }
            case SPELL_PPM_MOD_BATTLEGROUND:
            {
                if (caster->GetMap()->IsBattlegroundOrArena())
                    ppm *= 1.0f + mod->Coeff;
                break;
            }
            default:
                break;
        }
    }

    /// Sudden Doom
    if (Id == 49530)
    {
        if (SpellInfo const* l_DoubleDoom = sSpellMgr->GetSpellInfo(191741))
            AddPct(ppm, l_DoubleDoom->Effects[EFFECT_1].BasePoints);
    }

    return ppm;
}

bool SpellInfo::IsRanked() const
{
    return ChainEntry != NULL;
}

uint8 SpellInfo::GetRank() const
{
    if (!ChainEntry)
        return 1;
    return ChainEntry->rank;
}

SpellInfo const* SpellInfo::GetFirstRankSpell() const
{
    if (!ChainEntry)
        return this;
    return ChainEntry->first;
}
SpellInfo const* SpellInfo::GetLastRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->last;
}
SpellInfo const* SpellInfo::GetNextRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->next;
}
SpellInfo const* SpellInfo::GetPrevRankSpell() const
{
    if (!ChainEntry)
        return NULL;
    return ChainEntry->prev;
}

SpellInfo const* SpellInfo::GetAuraRankForLevel(uint8 level) const
{
    // ignore passive spells
    if (IsPassive())
        return this;

    bool needRankSelection = false;
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (IsPositiveEffect(i) &&
            (Effects[i].IsApplyingAura() ||
            Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
            Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID) &&
            !Effects[i].ScalingMultiplier)
        {
            needRankSelection = true;
            break;
        }
    }

    // not required
    if (!needRankSelection)
        return this;

    for (SpellInfo const* nextSpellInfo = this; nextSpellInfo != NULL; nextSpellInfo = nextSpellInfo->GetPrevRankSpell())
    {
        // if found appropriate level
        if (uint32(level + 10) >= nextSpellInfo->SpellLevel)
            return nextSpellInfo;

        // one rank less then
    }

    // not found
    return NULL;
}

bool SpellInfo::IsRankOf(SpellInfo const* spellInfo) const
{
    return spellInfo && GetFirstRankSpell() == spellInfo->GetFirstRankSpell();
}

bool SpellInfo::IsDifferentRankOf(SpellInfo const* spellInfo) const
{
    if (Id == spellInfo->Id)
        return false;
    return IsRankOf(spellInfo);
}

bool SpellInfo::IsHighRankOf(SpellInfo const* spellInfo) const
{
    if (ChainEntry && spellInfo->ChainEntry)
    {
        if (ChainEntry->first == spellInfo->ChainEntry->first)
            if (ChainEntry->rank > spellInfo->ChainEntry->rank)
                return true;
    }
    return false;
}

uint32 SpellInfo::_GetExplicitTargetMask() const
{
    bool srcSet = false;
    bool dstSet = false;
    uint32 targetMask = Targets;
    // prepare target mask using effect target entries
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (!Effects[i].IsEffect())
            continue;

        if (Effects[i].TargetA.GetTarget() >= TOTAL_SPELL_TARGETS)
        {
            printf("%u SPELL_TARGET overflow!! %d\r\n", Id, Effects[i].TargetA.GetTarget());
            continue;
        }

        targetMask |= Effects[i].TargetA.GetExplicitTargetMask(srcSet, dstSet);
        targetMask |= Effects[i].TargetB.GetExplicitTargetMask(srcSet, dstSet);

        // add explicit target flags based on spell effects which have EFFECT_IMPLICIT_TARGET_EXPLICIT and no valid target provided
        if (Effects[i].GetImplicitTargetType() != EFFECT_IMPLICIT_TARGET_EXPLICIT)
            continue;

        // extend explicit target mask only if valid targets for effect could not be provided by target types
        uint32 effectTargetMask = Effects[i].GetMissingTargetMask(srcSet, dstSet, targetMask);

        // don't add explicit object/dest flags when spell has no max range
        if (GetMaxRange(true) == 0.0f && GetMaxRange(false) == 0.0f)
            effectTargetMask &= ~(TARGET_FLAG_UNIT_MASK | TARGET_FLAG_GAMEOBJECT | TARGET_FLAG_CORPSE_MASK | TARGET_FLAG_DEST_LOCATION);
        targetMask |= effectTargetMask;
    }
    return targetMask;
}

bool SpellInfo::IsAllwaysStackModifers() const
{
    if (IsPassive())
        return true;

    if (SpellFamilyName == SPELLFAMILY_POTION)
        return true;

    switch (Id)
    {
        // warsong flags
        case 23333:
        case 23335:
            return true;
       default:
            break;
    }
    return false;
}

bool SpellInfo::_IsPositiveEffect(uint8 effIndex, bool deep) const
{
    // not found a single positive spell with this attribute
    if (Attributes & SPELL_ATTR0_DEBUFF)
        return false;

    switch (SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
            switch (Id)
            {
                case 29214: // Wrath of the Plaguebringer
                case 34700: // Allergic Reaction
                case 54836: // Wrath of the Plaguebringer
                case 61987: // Avenging Wrath Marker
                case 61988: // Divine Shield exclude aura
                case 69708: // Ice Prison (HoR)
                case 70194: // Dark Arrow (HoR)
                case 70070: // Harvest Soul (HoR)
                case 47310: // Direbrew's Disarm
                    return false;
                case 30877: // Tag Murloc
                case 61716: // Rabbit Costume
                case 61734: // Noblegarden Bunny
                case 62344: // Fists of Stone
                case 62478: // Frozen Blows (Hodir)
                case 63512: // Frozen Blows (Hodir)
                case 73523: // Rigor Mortis
                case 24732: // Nananananana... Bat Costume!
                case 24740: // Wisp Costume
                case 233679: ///< Confess
                case 235293: ///< Remnant of Hope
                case 233104: /// Torment
                case 234364: /// Confess
                    return true;
                case 242570: ///< Spectral Owl
                    if (effIndex != SpellEffIndex::EFFECT_0)
                        return true;
                    break;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_MAGE:
            // Dampen Magic
            if (SpellFamilyFlags[0] == 0x00002000)
                return true;
            break;
        case SPELLFAMILY_WARLOCK:
            switch (Id)
            {
                case 111400: ///< Burning Rush
                    return true;
                default:
                    break;
            }
        case SPELLFAMILY_PRIEST:
            switch (Id)
            {
                case 64844: ///< Divine Hymn
                case 47585: ///< Dispersion
                    return true;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_WARRIOR:
            switch (Id)
            {
                case 197690: ///< Defensive Stance
                    return true;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_PALADIN:
            switch (Id)
            {
                case 217020 : /// Zeal
                    return true;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_DEATHKNIGHT:
            switch (Id)
            {
                case 194844 : ///< BoneStorm
                    return true;
                default:
                    break;
            }
            break;
        case SPELLFAMILY_DEMONHUNTER:
            switch (Id)
            {
            case 188499: ///< Blade Dance
                return true;
            default:
                break;
            }
            break;
        case SPELLFAMILY_DRUID:
            switch (Id)
            {
            case 210664: ///< Scent of Blood
                return true;
            default:
                break;
            }
            break;
        default:
            break;
    }

    switch (Mechanic)
    {
        case MECHANIC_IMMUNE_SHIELD:
            return true;
        default:
            break;
    }

    // Special case: effects which determine positivity of whole spell
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].IsAura() && Effects[i].ApplyAuraName == SPELL_AURA_MOD_STEALTH)
            return true;
    }

    if (effIndex >= EffectCount)
        return true;

    switch (Effects[effIndex].Effect)
    {
        case SPELL_EFFECT_DUMMY:
            // some explicitly required dummy effect sets
            switch (Id)
            {
                case 28441:
                    return false; // AB Effect 000
                default:
                    break;
            }
            break;
        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_LEARN_SPELL:
        case SPELL_EFFECT_SKILL_STEP:
        case SPELL_EFFECT_HEAL_PCT:
        case SPELL_EFFECT_ENERGIZE_PCT:
            return true;
        case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
            return false;

            // non-positive aura use
        case SPELL_EFFECT_APPLY_AURA:
        case SPELL_EFFECT_APPLY_AURA_2:
        case SPELL_EFFECT_APPLY_AURA_ON_PET:
        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
        {
            switch (Effects[effIndex].ApplyAuraName)
            {
                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
                case SPELL_AURA_MOD_STAT:
                case SPELL_AURA_MOD_SKILL:
                case SPELL_AURA_MOD_DODGE_PERCENT:
                case SPELL_AURA_MOD_HEALING_PCT:
                case SPELL_AURA_MOD_HEALING_DONE:
                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
                    if (Effects[effIndex].CalcValue() < 0)
                        return false;
                    break;
                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
                    if (Effects[effIndex].CalcValue() > 0)
                        return false;
                    break;
                case SPELL_AURA_MOD_CRIT_PCT:
                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
                    if (Effects[effIndex].CalcValue() > 0)
                        return true;                        // some expected positive spells have SPELL_ATTR1_NEGATIVE
                    break;
                case SPELL_AURA_ADD_TARGET_TRIGGER:
                    return true;
                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
                    if (!deep)
                    {
                        if (SpellInfo const* spellTriggeredProto = sSpellMgr->GetSpellInfo(Effects[effIndex].TriggerSpell))
                        {
                            // negative targets of main spell return early
                            for (uint8 i = 0; i < EffectCount; ++i)
                            {
                                if (!spellTriggeredProto->Effects[i].Effect)
                                    continue;
                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
                                // this will place this spell auras as debuffs
                                if (_IsPositiveTarget(spellTriggeredProto->Effects[i].TargetA.GetTarget(), spellTriggeredProto->Effects[effIndex].TargetB.GetTarget()) && !spellTriggeredProto->_IsPositiveEffect(i, true))
                                    return false;
                            }
                        }
                    }
                case SPELL_AURA_PROC_TRIGGER_SPELL:
                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
                    break;
                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
                    if (effIndex == 0 && Effects[1].Effect == 0 && Effects[2].Effect == 0)
                        return false;                       // but all single stun aura spells is negative
                    break;
                case SPELL_AURA_MOD_PACIFY_SILENCE:
                    if (Id == 24740)             // Wisp Costume
                        return true;
                    return false;
                case SPELL_AURA_MOD_ROOT:
                case SPELL_AURA_MOD_ROOT_2:
                case SPELL_AURA_MOD_SILENCE:
                case SPELL_AURA_GHOST:
                case SPELL_AURA_PERIODIC_LEECH:
                case SPELL_AURA_MOD_STALKED:
                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
                case SPELL_AURA_PREVENT_RESURRECTION:
                    return false;
                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
                case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
                    // part of negative spell if casted at self (prevent cancel)
                    if (Effects[effIndex].TargetA.GetTarget() == TARGET_UNIT_CASTER)
                        return false;
                    break;
                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
                    // part of positive spell if casted at self
                    if (Effects[effIndex].TargetA.GetTarget() != TARGET_UNIT_CASTER)
                        return false;
                    // but not this if this first effect (didn't find better check)
                    if (Attributes & SPELL_ATTR0_DEBUFF && effIndex == 0)
                        return false;
                    break;
                case SPELL_AURA_MECHANIC_IMMUNITY:
                {
                    // non-positive immunities
                    switch (Effects[effIndex].MiscValue)
                    {
                        case MECHANIC_BANDAGE:
                        case MECHANIC_SHIELD:
                        case MECHANIC_MOUNT:
                        case MECHANIC_INVULNERABILITY:
                            return false;
                        default:
                            break;
                    }
                    break;
                }
                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
                case SPELL_AURA_ADD_PCT_MODIFIER:
                {
                    // non-positive mods
                    switch (Effects[effIndex].MiscValue)
                    {
                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
                            if (Effects[effIndex].CalcValue() > 0)
                            {
                                if (!deep)
                                {
                                    bool negative = true;
                                    for (uint8 i = 0; i < EffectCount; ++i)
                                    {
                                        if (i != effIndex)
                                            if (_IsPositiveEffect(i, true))
                                            {
                                                negative = false;
                                                break;
                                            }
                                    }
                                    if (negative)
                                        return false;
                                }
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:
            break;
    }

    // non-positive targets
    if (!_IsPositiveTarget(Effects[effIndex].TargetA.GetTarget(), Effects[effIndex].TargetB.GetTarget()))
        return false;

    // negative spell if triggered spell is negative
    if (!deep && !Effects[effIndex].ApplyAuraName && Effects[effIndex].TriggerSpell)
    {
        if (SpellInfo const* spellTriggeredProto = sSpellMgr->GetSpellInfo(Effects[effIndex].TriggerSpell))
            if (!spellTriggeredProto->_IsPositiveSpell())
                return false;
    }

    // ok, positive
    return true;
}

bool SpellInfo::_IsPositiveSpell() const
{
    // spells with at least one negative effect are considered negative
    // some self-applied spells have negative effects but in self casting case negative check ignored.
    for (uint8 i = 0; i < EffectCount; ++i)
        if (!_IsPositiveEffect(i, true))
            return false;

    return true;
}

bool SpellInfo::_IsPositiveTarget(uint32 p_TargetA, uint32 p_TargetB)
{
    /// Non-positive targets
    switch (p_TargetA)
    {
        case Targets::TARGET_UNIT_NEARBY_ENEMY:
        case Targets::TARGET_UNIT_TARGET_ENEMY:
        case Targets::TARGET_UNIT_SRC_AREA_ENEMY:
        case Targets::TARGET_UNIT_DEST_AREA_ENEMY:
        case Targets::TARGET_UNIT_CONE_ENEMY_24:
        case Targets::TARGET_UNIT_CONE_ENEMY_104:
        case Targets::TARGET_UNIT_CONE_ENEMY_110:
        case Targets::TARGET_UNIT_ENEMY_BETWEEN_DEST:
        case Targets::TARGET_UNIT_ENEMY_BETWEEN_DEST_2:
        case Targets::TARGET_DEST_DYNOBJ_ENEMY:
        case Targets::TARGET_DEST_TARGET_ENEMY:
        case Targets::TARGET_ENNEMIES_AROUND_CASTER:
            return false;
        default:
            break;
    }

    if (p_TargetB)
        return _IsPositiveTarget(p_TargetB, 0);

    return true;
}

SpellTargetRestrictionsEntry const* SpellInfo::GetSpellTargetRestrictions() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellTargetRestrictionsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellTargetRestrictionsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellTargetRestrictionsId ? sSpellTargetRestrictionsStore.LookupEntry(SpellTargetRestrictionsId) : nullptr;
}

SpellEquippedItemsEntry const* SpellInfo::GetSpellEquippedItems() const
{
    auto l_Itr = sSpellEquippedItemsMap.find(Id);
    if (l_Itr == sSpellEquippedItemsMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellInterruptsEntry const* SpellInfo::GetSpellInterrupts() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellInterruptsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellInterruptsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellInteruptsID ? sSpellInterruptsStore.LookupEntry(SpellInteruptsID) : nullptr;
}

SpellLevelsEntry const* SpellInfo::GetSpellLevels() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellLevelsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellLevelsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellLevelsID ? sSpellLevelsStore.LookupEntry(SpellLevelsID) : nullptr;
}

SpellMiscEntry const* SpellInfo::GetSpellMisc() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellMiscStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellMiscStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellMiscId ? sSpellMiscStore.LookupEntry(SpellMiscId) : nullptr;
}

SpellReagentsEntry const* SpellInfo::GetSpellReagents() const
{
    auto l_Itr = sSpellReagentMap.find(Id);
    if (l_Itr == sSpellReagentMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellScalingEntry const* SpellInfo::GetSpellScaling() const
{
    auto l_Itr = sSpellScalingMap.find(Id);
    if (l_Itr == sSpellScalingMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellShapeshiftEntry const* SpellInfo::GetSpellShapeshift() const
{
    auto l_Itr = sSpellShapeshiftMap.find(Id);
    if (l_Itr == sSpellShapeshiftMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellTotemsEntry const* SpellInfo::GetSpellTotems() const
{
    auto l_Itr = sSpellTotemsMap.find(Id);
    if (l_Itr == sSpellTotemsMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellAuraOptionsEntry const* SpellInfo::GetSpellAuraOptions() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_Difficulty = GetMaxDifficultyOptionBelowCurrentDifficulty(Id, DifficultyID);

        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellAuraOptionsStore.GetDbcFileName(), Id, l_Difficulty);
        if (l_EntryByDifficulty != 0)
            return sSpellAuraOptionsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellAuraOptionsID ? sSpellAuraOptionsStore.LookupEntry(SpellAuraOptionsID) : nullptr;
}

SpellAuraRestrictionsEntry const* SpellInfo::GetSpellAuraRestrictions() const
{
    auto l_Itr = sSpellAuraRestrictionMap.find(Id);
    if (l_Itr == sSpellAuraRestrictionMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellCastingRequirementsEntry const* SpellInfo::GetSpellCastingRequirements() const
{
    auto l_Itr = sSpellCastingRequirementsMap.find(Id);
    if (l_Itr == sSpellCastingRequirementsMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellCategoriesEntry const* SpellInfo::GetSpellCategories() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellCategoriesStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellCategoriesStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellCategoriesID ? sSpellCategoriesStore.LookupEntry(SpellCategoriesID) : nullptr;
}

SpellClassOptionsEntry const* SpellInfo::GetSpellClassOptions() const
{
    auto l_Itr = sSpellClassOptionsMap.find(Id);
    if (l_Itr == sSpellClassOptionsMap.end())
        return nullptr;

    return l_Itr->second;
}

SpellCooldownsEntry const* SpellInfo::GetSpellCooldowns() const
{
    if (DifficultyID != Difficulty::DifficultyNone)
    {
        uint32 l_EntryByDifficulty = sSpellMgr->GetDifficultyEntryForDataStore(sSpellCooldownsStore.GetDbcFileName(), Id, DifficultyID);
        if (l_EntryByDifficulty != 0)
            return sSpellCooldownsStore.LookupEntry(l_EntryByDifficulty);
    }

    return SpellCooldownsID ? sSpellCooldownsStore.LookupEntry(SpellCooldownsID) : nullptr;
}

SpellEffectEntry const* SpellEntry::GetSpellEffect(uint32 eff, uint32 difficulty) const
{
    return GetSpellEffectEntry(Id, eff, difficulty);
}

void SpellInfo::SetDurationIndex(uint32 index)
{
    SpellDurationEntry const* durationIndex = sSpellDurationStore.LookupEntry(index);
    if (!durationIndex)
        return;

    DurationEntry = durationIndex;
}

void SpellInfo::SetRangeIndex(uint32 index)
{
    SpellRangeEntry const* rangeIndex = sSpellRangeStore.LookupEntry(index);
    if (!rangeIndex)
        return;

    RangeEntry = rangeIndex;
}

void SpellInfo::SetCastTimeIndex(uint32 index)
{
    SpellCastTimesEntry const* castTimeIndex = sSpellCastTimesStore.LookupEntry(index);
    if (!castTimeIndex)
        return;

    CastTimeEntry = castTimeIndex;
}

void SpellInfo::_UnloadImplicitTargetConditionLists()
{
    // find the same instances of ConditionContainer and delete them.
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        ConditionContainer* cur = Effects[i].ImplicitTargetConditions;
        if (!cur)
            continue;

        for (uint8 j = i; j < EffectCount; ++j)
        {
            if (Effects[j].ImplicitTargetConditions == cur)
                Effects[j].ImplicitTargetConditions = NULL;
        }
        delete cur;
    }
}

bool SpellInfo::_IsCrowdControl(uint32 p_EffMask /*= 0*/, bool p_NoDamage /*= false*/) const
{
    for (uint32 l_EffIndex = 0; l_EffIndex < EffectCount; ++l_EffIndex)
    {
        if (p_EffMask && !(p_EffMask & (1 << l_EffIndex)))
            continue;

        if (p_NoDamage)
        {
            switch (Effects[l_EffIndex].Effect)
            {
                case SPELL_EFFECT_HEALTH_LEECH:
                case SPELL_EFFECT_SCHOOL_DAMAGE:
                    return false;
            }
        }

        switch (Effects[l_EffIndex].ApplyAuraName)
        {
            case SPELL_AURA_MOD_STUN:
            case SPELL_AURA_MOD_CONFUSE:
            case SPELL_AURA_MOD_FEAR:
            case SPELL_AURA_MOD_FEAR_2:
            case SPELL_AURA_MOD_ROOT:
            case SPELL_AURA_MOD_ROOT_2:
            case SPELL_AURA_TRANSFORM:
            {
                if (!IsPositive())
                    return true;
                break;
            }
            case SPELL_AURA_STRANGULATE:
                /// Don't know why it's here but it's taken from HandleAuraStrangulate where the check is
                if (Id == 108194 || Id == 221562) /// Asphyxiate
                    return true;
                break;
            default:
                break;
        }
    }

    return false;
}

bool SpellInfo::_IsLossOfControl() const
{
    for (uint8 l_I = 0; l_I < EffectCount; ++l_I)
    {
        switch (Effects[l_I].Mechanic)
        {
            case Mechanics::MECHANIC_SAPPED:
            case Mechanics::MECHANIC_CHARM:
            case Mechanics::MECHANIC_DISORIENTED:
            case Mechanics::MECHANIC_FEAR:
            case Mechanics::MECHANIC_SILENCE:
            case Mechanics::MECHANIC_POLYMORPH:
            case Mechanics::MECHANIC_BANISH:
            case Mechanics::MECHANIC_SLEEP:
            case Mechanics::MECHANIC_STUN:
            case Mechanics::MECHANIC_HORROR:
            case Mechanics::MECHANIC_FREEZE:
                return true;
            default:
                break;
            }
    }

    ///< If nothing found, we must find default values depending on AuraType
    for (uint8 l_I = 0; l_I < EffectCount; ++l_I)
    {
        switch (Effects[l_I].ApplyAuraName)
        {
        case SPELL_AURA_MOD_FEAR:
        case SPELL_AURA_MOD_FEAR_2:
        case SPELL_AURA_MOD_STUN:
        case SPELL_AURA_MOD_SILENCE:
        case SPELL_AURA_MOD_PACIFY_SILENCE:
        case SPELL_AURA_MOD_POSSESS:
        case SPELL_AURA_MOD_CHARM:
        case SPELL_AURA_MOD_CONFUSE:
            return true;
        case SPELL_AURA_STRANGULATE:
            /// Don't know why it's here but it's taken from HandleAuraStrangulate where the check is
            if (Id == 108194 || Id == 221562) /// Asphyxiate
                return true;
            break;
        default:
            break;
        }
    }

    return false;
}

bool SpellInfo::_IsNeedDelay() const
{
    switch (Id)
    {
        case 379:   // Earth Shield (Shaman)
        case 14161: // Ruthlessness (Rogue)
        case 33110: // Prayer of Mending (Priest)
        case 48503: // Living Seed (Druid)
        case 52752: // Ancestral Awakening (Shaman)
        case 62836: // Slag Imbued (Ignis, Ulduar)
        case 63536: // Slag Imbued (Ignis, Ulduar)
        case 70802: // Mayhem (Rogue)
        case 70157: // Ice Tomb (Sindragosa, ICC)
        case 79128: // Improved Expose Armor
        case 36032: // Arcane Blast
        case 109950: // Fury of Destroyer
        case 139546: // Add combo point (for Ruthlessness)
            return true;
    }

    return false;
}

bool SpellInfo::IsBreakingCamouflageAfterHit() const
{
    // Traps
    if (SpellFamilyFlags[1] & 0x8002000 ||
        SpellFamilyFlags[2] & 0x20000)
        return true;

    // Damage casts
    switch (Id)
    {
        case 19434: // Aimed Shot
        case 82928: // Aimed Shot
        case 77767: // Cobra Shot
            return true;
    }

    return false;
}

bool SpellInfo::IsBreakingCamouflage() const
{
    // This is bad but I dont't see another way
    // I cannot check spells using any mask
    // Use it only for hunter camouflage
    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificFood:
        case SpellSpecificType::SpellSpecificFoodAndDrink:
        case SpellSpecificType::SpellSpecificWellFed:
        case SpellSpecificType::SpellSpecificAspect:
            return false;
        default:
            break;
    }

    switch (Id)
    {
        case 136:   // Mend Pet
        case 982:   // Revive Pet
        case 1130:  // Hunter's Mark
        case 1462:  // Beast Lore
        case 1499:  // Frost Trap
        case 1543:  // Flare
        case 3045:  // Rapid Fire
        case 5384:  // Feign Death
        case 6197:  // Eagle Eye
        case 6991:  // Feed Pet
        case 13795: // Immolation Trap
        case 13809: // Ice Trap
        case 13813: // Explosive Trap
        case 19263: // Deterence
        case 19434: // Aimed Shot
        case 23989: // Readiness
        case 26297: // Berserking (Troll Racial)
        case 34477: // Misdirection
        case 34600: // Snake Trap
        case 42292: // PvP Trinket
        case 53271: // Master's Call
        case 60192: // Frost Trap launcher
        case 77767: // Cobra Shot
        case 82935: // Immplation Trap launcher
        case 82939: // Explosive Trap launcher
        case 82941: // Ice Trap launcher
        case 82945: // Immolation Trap Launcher
        case 82948: // Snake Trap launcher
        case 93435: // Roar of Courage (Special Ability)
            return false;
    }

    return true;
}

bool SpellInfo::IsIgnoringCombat() const
{
    if (HasAttribute(SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS))
        return true;

    if (HasAura(AuraType::SPELL_AURA_TRIGGER_BONUS_LOOT) || HasAura(AuraType::SPELL_AURA_TRIGGER_BONUS_LOOT_2))
        return true;

    /// Polymorph spells shouldn't give combat
    if (Mechanic == MECHANIC_POLYMORPH)
        return true;

    switch (Id)
    {
        /// Meteor
        case 153561:
        /// Marked for Death
        case 137619:
        /// Slice and Dice
        case 5171:
        case 6434:
        case 6774:
        /// Honor Among Thieves
        case 51698:
        case 51699:
        case 51700:
        case 51701:
        case 52916:
        /// Divine Hymn
        case 64843:
        case 64844:
        case 70619:
        /// Shadowmeld
        case 58984:
        /// Blackjack
        case 79124:
        case 79126:
        /// Venomous Wounds
        case 79136:
        /// Master Poisoner
        case 93068:
        /// Blind
        case 2094:
        /// Ignite
        case 12654:
        /// Resistance is Futile
        case 83676:
        /// Vendeta
        case 79140:
        /// Earth Shield
        case 379:
        /// Earthliving Weapon proc
        case 51730:
        /// Ancestral Vigor
        case 105284:
        /// Ancestral Fortitude
        case 16177:
        case 16236:
        /// Ysera's Gift
        case 145110:
        /// Eradication (Cosmetic)
        case 249114:
        /// Beaming Gaze
        case 253990:
        /// Obliteration Beam
        case 250249:
            return true;
        default: break;
    }

    // Dark Intent
    if (SpellFamilyName == SPELLFAMILY_WARLOCK && (SpellFamilyFlags[2] & 0x00800000))
        return true;

    return false;
}

bool SpellInfo::IsFeralDruidPeriodicDamage() const
{
    switch (Id)
    {
        case 155722: ///< Rake
        case 1079: ///< Rip
        case 106830: ///< Thrash
        case 210723: ///< Ashamane's Frenzy
            return true;
        default:
            return false;
    }
}

bool SpellInfo::IsUnstableAffliction() const
{
    switch (Id) ///< the 5 DOTS of Unstable Affliction
    {
    case 233490:
    case 233496:
    case 233497:
    case 233498:
    case 233499:
        return true;
    default:
        return false;
    }
}

bool SpellInfo::IsNonSnapshottingAura() const
{
    switch (Id)
    {
        case 210649: ///< Feral Instinct
        case 247891: ///< Dance of Mists
        case 235966: ///< Velen's Future Sight
        case 197030: ///< Divinity
        case 62071:  ///< Savage Roar
        case 202797: ///< Viper Sting
            return true;
        default:
            return false;
    }
}

float SpellInfo::GetGiftOfTheSerpentScaling(Unit* caster) const
{
    float scale = 1.0f;

    switch (Id)
    {
        case 130654:// Chi Burst (Heal)
            scale = 0.15f;
            break;
        case 132120:// Enveloping Mist
            scale = 0.2f;
            break;
        case 115151:// Renewing Mist
        case 119611:// Renewing Mist (HoT)
        case 116670:// Uplift
        case 124081:// Zen Sphere (HoT)
        case 132463:// Chi Wave (Heal)
            scale = 0.25f;
            break;
        case 115175:// Soothing Mist
            scale = 0.3f;
            break;
        default:
            break;
    }

    // Serpent Statue has different scaling
    if (caster->GetTypeId() == TYPEID_UNIT && caster->ToUnit()->GetEntry() == 60849)
    {
        switch (Id)
        {
            case 115175:// Soothing Mist
                scale = 0.5f;
                break;
            default:
                break;
        }
    }

    return scale;
}

float SpellInfo::GetCastTimeReduction() const
{
    return 1.0f;
}

bool SpellInfo::CanTriggerBladeFlurry() const
{
    /// https://www.askmrrobot.com/wow/theory/mechanic/spell/masterymaingauche?spec=RogueOutlaw&version=7_3_5_25864
    switch (Id)
    {
        case 2098:      ///< Run Through
        case 193315:    ///< Saber Lash
        case 197834:    ///< Saber Lash
        case 196937:    ///< Ghostly Strike
        case 57841:     ///< Killing Spree
        case 57842:     ///< Killing Spree Off-Hand
        case 8676:      ///< Ambush
        case 86392:     ///< Main Gauche
            return true;
    }

    return false;
}

bool SpellInfo::IsTargetingFollower() const
{
    for (uint8 l_Index = 0; l_Index < EffectCount; ++l_Index)
    {
        switch (Effects[l_Index].Effect)
        {
            case SPELL_EFFECT_INCREASE_FOLLOWER_ITEM_LEVEL:
            case SPELL_EFFECT_INCREASE_FOLLOWER_EXPERIENCE:
            case SPELL_EFFECT_TEACH_FOLLOWER_ABILITY:
                return true;
            default:
                break;
        }
    }

    return false;
}

bool SpellInfo::IsCustomCharged(SpellInfo const* procSpell, Unit* caster) const
{
    switch (Id)
    {
        case 16246: // Clearcasting (Shaman)
            if (procSpell && procSpell->Id == 8004)
                return true;
            break;
        case 36032: // Arcane Charge
        case 79683: // Arcane Missiles !
        case 114637:// Bastion of Glory
        case 60503: // Overpower !
        case 121153:// Blindside
        case 131116:// Raging Blow !
        case 204288: ///< Earth Shield
            return true;
        case 115191:// Stealth (Subterfuge)
            if (caster->HasAura(115192)) // Subterfuge buff - 3s
                return true;
            break;
        case 165442:///< Crusader's Fury
            if (procSpell && procSpell->Id == 157048) ///< Final Verdict
                return true;
            break;
        case 145152: ///< Bloodtalons
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsCustomCastCanceled(Unit* caster) const
{
    switch (Id)
    {
        case 22778:  ///< Hamstring Rage Reduction
        case 32973:  ///< Gloves S12 - Shaman
        case 33830:  ///< Gloves S12 - Druid
        case 44297:  ///< Gloves S12 - Priest
        case 131562: ///< Item Monk - 2P S12 Windwalker
        {
            if (caster->HasAura(Id))
                return true;
            break;
        }
        case 127249: ///< Flesh to Stone
        {
            /// Disable Flesh to Stone toy
            /// @TODO: Sniff & Fix me
            return true;
        }
        case 200749: ///< Activating Specialization - Disabled during Artifact Challenges
        {
            /// Can't switch spec in those maps, or during LFG handling for those maps
            std::set<uint32> l_Maps =
            {
                1616, ///< An Impossible Foe
                1673, ///< Closing the Eye
                1684, ///< Thwarting the Twins
                1698, ///< The Highlord's Return
                1702, ///< Feltotem's Fall
                1703, ///< The God-Queen's Fury
                1710  ///< End of the Risen Threat
            };

            LfgUpdateData l_UpdateData = sLFGMgr->GetLfgStatus(caster->GetGUID());
            for (auto const& l_Iter : l_UpdateData.dungeons)
            {
                if (LFGDungeonEntry const* l_Entry = sLFGDungeonStore.LookupEntry(l_Iter))
                {
                    if (l_Maps.find(l_Entry->map) != l_Maps.end())
                        return true;
                }
            }

            if (l_Maps.find(caster->GetMapId()) != l_Maps.end())
                return true;

            break;
        }
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsWrongPrecastSpell(SpellInfo const* m_preCastSpell) const
{
    switch (Id)
    {
        case 51723: // Fan of Knives
            if (m_preCastSpell->Id == 51690)
                return true;
            break;
        case 115072:// Expel Harm
            if (m_preCastSpell->Id == 101545)
                return true;
            break;
        case 46584:// Raise dead
            if (m_preCastSpell->Id == 212756)
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsPoisonOrBleedSpell() const
{
    switch (Id)
    {
        case 703:   ///< Garrote
        case 1943:  ///< Rupture
        case 2818:  ///< Deadly Poison (DoT)
        case 3409:  ///< Crippling Poison
        case 8680:  ///< Wound Poison
        case 16511: ///< Hemorrhage (DoT)
        case 79136: ///< Venomous Wound (damage)
        case 112961:///< Leeching Poison
        case 113780:///< Deadly Poison (direct damage)
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsCustomChecked() const
{
    switch (Id)
    {
        case 136955:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136956:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136957:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136958:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136959:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 136960:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138671:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138672:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138673:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138674:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138675:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
        case 138676:///< Anima Ring (Triggered) (Dark Animus - Throne of Thunder)
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsBattleResurrection() const
{
    return AttributesEx8 & SpellAttr8::SPELL_ATTR8_BATTLE_RESURRECTION;
}

bool SpellInfo::IsNonPvP(Unit* p_Caster/* = nullptr*/, Unit* p_Target/* = nullptr*/) const
{
    switch (Id)
    {
        case 1719: ///< Battle Cry
            if (p_Caster != nullptr && p_Caster != p_Target && !p_Caster->HasAura(198765)) /// without Pain Train
                return true;
            break;
        case 80396: ///< 7.1.5 - Build 23420: casting Illusion (Mage) was activating victim's pvp if Mage pvp was on (because target_unit_target_any, spell_aura_clone_caster)
        case 7353:  ///< Cozy Fire (Cooking, Campfire)
        case 7358:  ///< Cozy Fire (Cooking, Campfire)
        case 223298: ///< Cozy Fire (Cooking, Campfire)
            return true;
        case 53563: ///< Beacon of Light
        case 53651: ///< Beacon of Light (Proc)
        case 156910: ///< Beacon of Faith
        case 177173: ///< Beacon of Faith (Proc)
        case 200025: ///< Beacon of Virtue
            return true;
        case 229385: ///< Ban-Lu, Grandmaster's Companion
            return true;

    };

    return false;
}

bool SpellInfo::IsFinishingMove() const
{
    switch (Id)
    {
        case 5171: ///< slice  and dice
        case 193316: ///< Roll the bones

        case 52610: ///< Savage Roar
            return true;
        default:
            break;
    }

    return IsOffensiveFinishingMove();
}

bool SpellInfo::IsOffensiveFinishingMove() const
{
    switch (Id)
    {
        case 408: ///< kidney shot
        case 1943: ///< rupture
        case 2098: ///< run through
        case 26679: ///< deadly throw
        case 32645: ///< envenom
        case 152150: ///< death from above
        case 195452: ///< Nightblade
        case 197395: ///< NightBlade Finality
        case 197393: ///< NightBlade Eviscerate
        case 196819: ///< Eviscerate
        case 199804: ///< Between the eyes
        case 206237: ///< Empowering shadow
        case 22570: ///< Maim
        case 22568: ///< Ferocious bite
        case 1079: ///< Rip
            return true;
        default:
            return false;
    }
}

bool SpellInfo::IsArcaneTorrent() const
{
    switch (Id)
    {
        case 25046: ///< Energy
        case 28730: ///< Mana
        case 50613: ///< Runic Power
        case 69179: ///< Rage
        case 80483: ///< Focus
        case 129597: ///< Chi / Mana / Energy
        case 155145: ///< Holy Power / Mana
        case 202719: ///< Pain / Fury
        case 232633: ///< Mana / Insanity
            return true;
        default:
            return false;
    }
}

bool SpellInfo::IsCanBeStolen() const
{
    /// Special rules, some aren't using mana but can be stolen
    switch (Id)
    {
        case 633:   ///< Lay on Hands
        case 22812: ///< Barkskin
        case 24275: ///< Hammer of Wrath
        case 158392: ///< Hammer of Wrath
        case 31935: ///< Avenger's Shield
        case 53563: ///< Beacon of Light
            return false;
        case 642:   ///< Divine Shield
        case 5484:  ///< Howl of Terror
        case 12472: ///< Icy Veins
        case 51490: ///< Thunderstorm
        case 64044: ///< Psychic Horror
            return true;
        default:
            break;
    }

    /// Some of the rules for those spells that can be stolen by Dark Simulacrum
    /// Spells should use mana
    bool l_UseMana = false;
    for (auto l_Iter : SpellPowers)
    {
        if (l_Iter->PowerType != POWER_MANA)
            return false;

        /// And should have mana cost
        if (!l_Iter->Cost && !l_Iter->CostBasePercentage)
            return false;

        l_UseMana = true;
        break;
    }

    if (!l_UseMana)
        return false;

    for (uint8 l_I = 0; l_I < EffectCount; ++l_I)
    {
        switch (Effects[l_I].Effect)
        {
            case SPELL_EFFECT_SUMMON:
            case SPELL_EFFECT_SUMMON_PET:
            case SPELL_EFFECT_CAST_BUTTON:
            case SPELL_EFFECT_TAMECREATURE:
            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
                return false;
            case SPELL_EFFECT_SCHOOL_DAMAGE:
                if (DmgClass == SPELL_DAMAGE_CLASS_MELEE)
                    return false;
                break;
            case SPELL_EFFECT_APPLY_AURA:
            case SPELL_EFFECT_APPLY_AURA_2:
                if (Effects[l_I].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
                    return false;
                break;
            default:
                break;
        }
    }

    return true;
}

bool SpellInfo::IsNeedAdditionalLosChecks() const
{
    switch (Id)
    {
        case 3600:  // Earthbind Totem
        case 50622:
        case 44949: // Whirlwind from bladestorm
        case 87204: // Sin and Punishment proc
        case 117418: // Fists of Fury
        case 120086: // Fists of Fury (Stun)
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsRequireAdditionalTargetCheck() const
{
    switch (Id)
    {
        case 103327: // Hour of Twilight dmg, Ultraxion, Dragon Soul
            return false;
        default:
            break;
    }

    return true;
}

bool SpellInfo::IsBreakingStealth(Unit* m_caster) const
{
    if (!m_caster)
        return false;

    if (m_caster->HasAura(115192))
        return false;

    /// Hearthstone shouldn't call subterfuge effect
    if ((IconFileDataId == 134414 || SpellFamilyName == SPELLFAMILY_POTION) && m_caster->HasAura(115191))
    {
        m_caster->RemoveAura(115191);
        return true;
    }

    switch (GetSpellSpecific())
    {
        case SpellSpecificType::SpellSpecificFood:
        case SpellSpecificType::SpellSpecificFoodAndDrink:
        case SpellSpecificType::SpellSpecificWellFed:
            return true;
        default:
            break;
    }

    bool callSubterfuge = true;
    if (m_caster->HasAura(108208) && m_caster->HasAura(115191) && !m_caster->HasAura(115192) &&
        !HasAttribute(SPELL_ATTR1_NOT_BREAK_STEALTH) && Id != 127802)
    {
        /// Mounts shouldn't call subterfuge effect
        for (uint8 i = 0; i < EffectCount; ++i)
        {
            if (Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
            {
                callSubterfuge = false;
                break;
            }
        }

        if (callSubterfuge)
        {
            m_caster->CastSpell(m_caster, 115192, true);
            return true;
        }
    }

    if (m_caster->HasAura(115191) && callSubterfuge)
        return false;

    switch (Id)
    {
        case 99:    ///< Incapaciting Roar
        case 2643:  ///< Multi-shot
        case 3600:  ///< Earthbind
        case 12323: ///< Piercing Howl
        case 64695: ///< Earthgrab
            return false;
        default:
            break;
    }

    if (IsTargetingArea())
    {
        /// Dispel etc spells
        switch (Effects[EFFECT_0].Effect)
        {
            case SPELL_EFFECT_DISPEL:
            case SPELL_EFFECT_DISPEL_MECHANIC:
            case SPELL_EFFECT_THREAT:
            case SPELL_EFFECT_MODIFY_THREAT_PERCENT:
            case SPELL_EFFECT_DISTRACT:
                return false;
            default:
                break;
        }
    }

    if (HasAttribute(SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS) || HasAttribute(SPELL_ATTR1_NOT_BREAK_STEALTH))
        return false;

    return true;
}

bool SpellInfo::IsPeriodicHeal() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
        if (Effects[i].ApplyAuraName == SPELL_AURA_PERIODIC_HEAL)
            return true;
    }

    return false;
}

bool SpellInfo::HasExpireTick() const
{
    switch (Id)
    {
        case 233490: /// Unstable Affliction 1
        case 233496: /// Unstable Affliction 2
        case 233497: /// Unstable Affliction 3
        case 233498: /// Unstable Affliction 4
        case 233499: /// Unstable Affliction 5
            return false;
        default:
            return true;
    }
}

bool SpellInfo::IsPeriodic() const
{
    for (uint8 i = 0; i < EffectCount; ++i)
    {
       if (Effects[i].IsPeriodicEffect())
           return true;
    }
    return false;
}

bool SpellEffectInfo::IsPeriodicEffect() const
{
    if (!ApplyAuraName)
        return false;

    switch (ApplyAuraName)
    {
        case SPELL_AURA_PERIODIC_DUMMY:
        case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
        case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
        case SPELL_AURA_PERIODIC_DAMAGE:
        case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
        case SPELL_AURA_PERIODIC_LEECH:
        case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
        case SPELL_AURA_PERIODIC_HEAL:
        case SPELL_AURA_OBS_MOD_HEALTH:
        case SPELL_AURA_PERIODIC_MANA_LEECH:
        case SPELL_AURA_OBS_MOD_POWER:
        case SPELL_AURA_PERIODIC_ENERGIZE:
        case SPELL_AURA_POWER_BURN:
            return true;
    }

    return false;
}

bool SpellEffectInfo::CanScale() const
{
    switch (Effect)
    {
        case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
        case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
        case SPELL_EFFECT_APPLY_AREA_AURA_PET:
        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
        case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
        case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
        case SPELL_EFFECT_APPLY_AURA:
        case SPELL_EFFECT_APPLY_AURA_2:
        case SPELL_EFFECT_APPLY_AURA_ON_PET:
        {
            switch (ApplyAuraName)
            {
                case SPELL_AURA_PERIODIC_LEECH:
                case SPELL_AURA_PERIODIC_DAMAGE:
                case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
                case SPELL_AURA_PERIODIC_HEAL:
                case SPELL_AURA_DAMAGE_SHIELD:
                case SPELL_AURA_SCHOOL_ABSORB:
                case SPELL_AURA_SCHOOL_HEAL_ABSORB:
                {
                    switch (_spellInfo->Id)
                    {
                        case 162184: ///< Expel Magic: Shadow - Highmaul (Ko'ragh)
                            return false;
                        default:
                            break;
                    }

                    return true;
                }
                case SPELL_AURA_DUMMY:
                {
                    switch (_spellInfo->Id)
                    {
                        // Earthquake
                        case 61882:
                            return true;
                        default:
                            break;
                    }
                }
                default:
                    break;
            }

            break;
        }
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        {
            switch (_spellInfo->Id)
            {
                case 132566:    ///< Seed of Corruption (Drain Soul triggered)
                case 131737:    ///< Agony (Drain Soul triggered)
                case 131736:    ///< Unstable Affliction (Drain Soul triggered)
                case 131740:    ///< Corruption (Drain Soul triggered)
                    return false;
                default:
                    break;
            }

            return true;
        }
        case SPELL_EFFECT_POWER_DRAIN:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_WEAPON_DAMAGE:
        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
        case SPELL_EFFECT_PERSISTENT_AREA_AURA:
            return true;
    }

    return false;
}

bool SpellInfo::IsInterruptSpell() const
{
    switch (Id)
    {
        case 78675: // Solar Beam
        case 93985: ///< Skull bash
        case 97547: // Solar Beam
        case 106839: // Skull Bash
        case 147362: // Counter Shot
            return true;
    default:
        break;
    }
    if (HasEffect(SPELL_EFFECT_INTERRUPT_CAST) || HasAura(SPELL_AURA_MOD_SILENCE))
        return true;
    return false;
}

bool SpellInfo::IsNeedToCheckSchoolImmune() const
{
    // there are a problem with some of spells that does holypower or break cc kinda pvp trinket
    // so we need hack-handle for em

    switch (Id)
    {
        case 25914: ///< Holy Shock heal
        case 42292: ///< Pvp Trinket
        case 59752: ///< Every Man for Himself (racical)
            return false;
        default:
            break;
    }

    return true;
}

bool SpellInfo::IsRemoveLossControlEffects() const
{
    switch (Id)
    {
        case 42292: // Pvp Trinket
        case 59752: // Every Man for Himself (racical)
        case 108201:// Desecrated Ground
        case 232043: ///< Ethereal Urn
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsRemoveFear() const
{
    if (HasAttribute(SPELL_ATTR5_USABLE_WHILE_FEARED))
        return true;

    switch (Id)
    {
        case 108201:  ///< Desecrated Ground
        case 118009:  ///< Desecrated Ground
        case 642:     ///< Divine Shield
        case 45438:   ///< Ice Block
        case 18499:   ///< Berserker Rage
        case 7744:    ///< Will of the Forsaken
        case 49039:   ///< Lichborne
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::DoesIgnoreGlobalCooldown(Unit* caster) const
{
    switch (Id)
    {
        case 5019:
            return true;
        break;
        case 114163:// Eternal Flame
            if (caster->HasAura(53592)) // Guarded by the Light
                return true;
            break;
        default:
            break;
    }

    return false;
}

bool SpellInfo::IsAffectedByResilience() const
{
    return !HasCustomAttribute(SPELL_ATTR0_CU_TRIGGERED_IGNORE_RESILENCE);
}

bool SpellInfo::IsLethalPoison() const
{
    switch (Id)
    {
        case 8680:      ///< Wound Poison
        case 2818:      ///< Deadly Poison DOT
        case 113780:    ///< Deadly Poison Initial Damage (usefull for Kingsbane (Artifact Spell)
        case 200803:    ///< Agonizing Poison
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::CanTriggerHotStreak() const
{
    switch (Id)
    {
        case 133:       ///< Fireball
        case 2136:      ///< Fire Blast
        case 2948:      ///< Scorch
        case 11366:     ///< Pyroblast
        case 30455:     ///< Ice Lance
        case 108853:    ///< Fire Blast
        case 194466:    ///< Pheonix's Flames
            return true;
        default:
            break;
    }

    return false;
}

bool SpellInfo::CannotBeAddedToCharm() const
{
    switch (Id)
    {
        case 121087: ///< Ground Slam
        case 121224: ///< Spirit Bolt
        case 123996: ///< Crackling Tiger Lightning
        case 123999: ///< Crackling Tiger Lightning Driver
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsCustomArchaeologySpell() const
{
    switch (Id)
    {
        case 139776: // Banner of the Mantid Empire
        case 139779: // Ancient Sap Feeder
        case 139780: // The Praying Mantid
        case 139781: // Inert Sound Beacon
        case 139782: // Remains of a Paragon
        case 139783: // Mantid Lamp
        case 139784: // Pollen Collector
        case 139785: // Kypari Sap Container
        case 139786: // Mantid Sky Reaver
        case 139787: // Sonic Pulse Generator
        case 223844:
        case 223846:
        case 223848:
        case 223849:
        case 223850:
        case 223851:
        case 223852:
        case 223853:
        case 223854:
        case 223855:
        case 223856:
        case 223857:
        case 223858:
            return true;
        default:
            return false;
    }

    return false;
}

Classes SpellInfo::GetClassIDBySpellFamilyName() const
{
    switch (SpellFamilyName)
    {
        case SPELLFAMILY_MAGE:
            return CLASS_MAGE;
        case SPELLFAMILY_WARRIOR:
            return CLASS_WARRIOR;
        case SPELLFAMILY_WARLOCK:
            return CLASS_WARLOCK;
        case SPELLFAMILY_PRIEST:
            return CLASS_PRIEST;
        case SPELLFAMILY_DRUID:
            return CLASS_DRUID;
        case SPELLFAMILY_ROGUE:
            return CLASS_ROGUE;
        case SPELLFAMILY_HUNTER:
            return CLASS_HUNTER;
        case SPELLFAMILY_PALADIN:
            return CLASS_PALADIN;
        case SPELLFAMILY_SHAMAN:
            return CLASS_SHAMAN;
        case SPELLFAMILY_DEATHKNIGHT:
            return CLASS_DEATH_KNIGHT;
        case SPELLFAMILY_MONK:
            return CLASS_MONK;
        default:
            return CLASS_NONE;
    }
}

std::string SpellInfo::GetNameForLogging() const
{
    std::ostringstream l_StringStream;

    if (SpellName && strlen(SpellName->Get(sWorld->GetDefaultDb2Locale())))
        l_StringStream << "\"" << SpellName->Get(sWorld->GetDefaultDb2Locale()) << "\"" << "[" << Id << "]";
    else
        l_StringStream << "[" << Id << "]";

    return l_StringStream.str();
}

void SpellInfo::UpdateSpellEffectCount()
{
    /*EffectCount = 0;
    for (uint8 l_I = 0; l_I < SpellEffIndex::MAX_EFFECTS; ++l_I)
    {
        if (Effects[l_I].IsEffect())
            e l_I + 1;
    }*/
}

bool SpellInfo::IsPandemicAffected() const
{
    switch (Id)
    {
        case 124280:    ///< Touch of Karma
        case 213757:    ///< Execution Sentence
        case 187464:    ///< Shadow Mend DoT
        case 193065:    ///< Talent Masochism (shadow mend HoT)
        case 603:       ///< Doom
        case 199450:    ///< Ultimate Sacrifice
        case 233490:    ///< FisrtUnstableAffliction
        case 233496:    ///< SecondUnstableAffliction
        case 233497:    ///< ThirdUnstableAffliction
        case 233498:    ///< FourthUnstableAffliction
        case 233499:    ///< FifthUnstableAffliction
        case 55078:     ///< Blood Plague
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsAuraNeedDynamicCalculation() const
{
    switch (Id)
    {
        case 1079:   ///< Rip
        case 1943:   ///< Rupture
        case 113344: ///< Bloodbath (DOT)
        case 114916: ///< Stay of Execution (damage)
        case 114917: ///< Stay of Execution (heal)
        case 154953: ///< Internal Bleeding
        case 155722: ///< Rake
            return false;
        default:
            return true;
    }

    return true;
}

bool SpellInfo::IsAuraNeedPandemicEffect() const
{
    switch (Id)
    {
        case 5171:   ///< Slice and Dice
        case 125359: ///< Tiger Power
        case 196937: ///< Ghostly Strike
        case 52610: ///< Savage Roar
            return true;
        default:
            return false;
    }

    return false;
}

float SpellInfo::GetFloatAmount(int32 p_Amount, float p_Custom /*= 0.0f*/) const
{
    float l_Amount = (float)p_Amount;
    switch (Id)
    {
        case 205029: ///< Flame On, for the second effect
            if (p_Amount == -17)
                return -16.67f;
            break;
        case 231895: ///< Crusade
        case 240559: ///< Grevious Wound (affix)
            return l_Amount / 10.0f;
        case 205766:
            return l_Amount / 2.0f;
        case 222209: ///< Darkening Soul
        case 211309: ///< Artificial stamina
        case 213428: ///< Artificial damage
        case 219655: ///< Artificial damage
        case 226829: ///< Artificial damage
            return l_Amount / 100.0f;
        case 207995: ///< Fire of the Twisting Nether
        case 207998: ///< Chill of the Twisting Nether
        case 207999: ///< Shock of the Twisting Nether
            return l_Amount / 10.0f;
        /// Amounts of these auras equal artifact power ranks
        case 214904: ///< Soulbiter, DK Frost
        case 214906: ///< Fleshsearer, DK Unholy
        case 214907: ///< Chaos Burn, DH Havoc
        case 214910: ///< Goldrinn's Fury, Druid Balance
        case 214911: ///< Fangs of the First, Druid Feral
        case 214913: ///< G'Hanir's Bloom, Druid Restoration
        case 214914: ///< Spiritbound, Hunter Beastmaster
        case 214915: ///< Windflight Arrows, Hunter Marksman
        case 214916: ///< Voice of the Wild Gogs, Hunter Survival
        case 214917: ///< Ancient Power, Mage Arcane
        case 214918: ///< Empowered Spellblade, Mage Fire
        case 214919: ///< Spellborne, Mage Frost
        case 214921: ///< Mistweaving, Monk Mistweaver
        case 214922: ///< Windborne Blows, Monk Windwalker
        case 214923: ///< Silver Touch, Paladin Holy
        case 207604: ///< Ashbringer's Light, Paladin Retribution
        case 214925: ///< Forbidden Flame, Priest Discipline
        case 214926: ///< Beacon of Light, Priest Holy
        case 214927: ///< Darkening Whispers, Priest Shadow
        case 214928: ///< Slayer's Precision, Rogue Assassination
        case 214929: ///< Cursed Steel, Rogue Combat
        case 214930: ///< Legionblade, Rogue Subtlety
        case 214931: ///< Stormkeeper's Power, Shaman Elemental
        case 214932: ///< Earthshattering Blows, Shaman Enhancement
        case 214933: ///< Flow of the Tides, Shaman Restoration
        case 214934: ///< Soulstealer, Warlock Affliction
        case 214935: ///< Thal'kiel's Lingering Power, Warlock Demonology
        case 214936: ///< Stolen Power, Warlock Destruction
        case 214937: ///< Unbreakable Steel, Warrior Arms
        case 214938: ///< Titanic Power, Warrior Fury
        case 77223: ///< Shaman's Mastery
            return p_Custom;
        default:
            return l_Amount;
    }

    return l_Amount;
}

uint32 SpellInfo::GetSpellXSpellVisualId(Unit const* p_Caster /*= nullptr*/) const
{
    switch (Id)
    {
        case 197703: ///< Eye Beams, original visual doesn't work at all
            return 91433; ///< Dark rush
        case 227566: ///< Salty Spittle (Guarm)
        case 227539: ///< Fiery Phlegm (Guarm)
        case 227570: ///< Dark Discharge (Guarm)
            return 0; ///< Visual is from PTR version of TOV and shouldn't be there.
        case 217830: ///< Scattering Field (Gul'dan)
            return 102751;
        case 179300: ///< REUSE (Gul'dan)
            return 116884;
        case 174556: ///< Meteor (Mage)
            return 0;
        case 2120: ///< Flamestrike
            return 101901;
        default:
            break;
    }

    if (p_Caster)
    {
        ///< Glide visual not send in Metamorphosis aura
        if (Id == 131347 && p_Caster->HasAura(162264))
            return 0;

        ///< Eye Beam vs Metamorphosis
        if (Id == 198013 && p_Caster->HasAura(162264))
            return 101263;

        ///< Fel Devastation vs Metamorphosis
        if (Id == 212084 && p_Caster->HasAura(187827))
            return 108501;

        ///< Burning Armor (Goroth)
        if (Id == 231363 && p_Caster->GetMap() && (p_Caster->GetMap()->GetDifficultyID() == Difficulty::DifficultyRaidHeroic || p_Caster->GetMap()->GetDifficultyID() == Difficulty::DifficultyRaidMythic))
            return 119039; ///< from sniff 25 yard

        ///< Burning Eruption (Goroth)
        if (Id == 231395 && p_Caster->GetMap() && (p_Caster->GetMap()->GetDifficultyID() == Difficulty::DifficultyRaidHeroic || p_Caster->GetMap()->GetDifficultyID() == Difficulty::DifficultyRaidMythic))
            return 119042; ///< from sniff 25 yard

        if (Id == 191034) ///< Starfall
        {
            if (p_Caster->HasAura(171803)) ///< Glyph of the Sun
            {
                if (p_Caster->HasAura(202354)) ///< Stellar Drift
                    return 111919;
                else
                    return 91511;
            }
            else
            {
                if (p_Caster->HasAura(202354)) ///< Stellar Drift
                    return 111918;
                else
                    return 98389;
            }
        }

        if (Id == 191037 && p_Caster->HasAura(171803)) ///< Glyph of the Sun
            return 98394;

        if (Id == 191034 && p_Caster->HasAura(202354))
            return 111919;

        if (Id == 246504) ///< Initializing
        {
            if (Creature const* l_Creature = p_Caster->ToCreature())
            {
                if (l_Creature->GetEntry() == 123906) ///< Garothi Annihilator
                    return 121258;
                else if (l_Creature->GetEntry() == 123921) ///< Garothi Decimator
                    return 126679;
                else if (l_Creature->GetEntry() == 123929) ///< Garothi Demolisher
                    return 126685;
            }
        }

        Difficulty l_Difficulty = p_Caster->GetMap() ? p_Caster->GetMap()->GetDifficultyID() : Difficulty::DifficultyNormal;
        DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(l_Difficulty);
        while (l_DifficultyEntry)
        {
            if (m_SpellVisuals.find(l_Difficulty) != m_SpellVisuals.end())
            {
                auto l_Iter = m_SpellVisuals.find(l_Difficulty);
                if (l_Iter != m_SpellVisuals.end())
                {
                    for (SpellXSpellVisualEntry const* l_Visual : l_Iter->second)
                    {
                        if (!l_Visual->PlayerConditionID || p_Caster->EvalPlayerCondition(l_Visual->PlayerConditionID).first)
                            return l_Visual->Id; ///< return proper visual if no condition or condition met
                        else
                            l_DifficultyEntry = sDifficultyStore.LookupEntry(l_DifficultyEntry->FallbackDifficultyID);
                    }
                }
            }
            else
                l_DifficultyEntry = sDifficultyStore.LookupEntry(l_DifficultyEntry->FallbackDifficultyID);
        }
    }

    auto l_Iter = m_SpellVisuals.find(Difficulty::DifficultyNone);
    if (l_Iter != m_SpellVisuals.end())
    {
        for (SpellXSpellVisualEntry const* l_Visual : l_Iter->second)
        {
            if (!l_Visual->PlayerConditionID || (p_Caster && p_Caster->EvalPlayerCondition(l_Visual->PlayerConditionID).first))
                return l_Visual->Id;
        }
    }

    return 0;
}

uint32 SpellInfo::GetSpellVisualID(Unit const* p_Caster) const
{
    if (SpellXSpellVisualEntry const* visual = sSpellXSpellVisualStore.LookupEntry(GetSpellXSpellVisualId(p_Caster)))
        return visual->VisualID;

    return 0;
}

bool SpellInfo::IsPvPStatTemplate() const
{
    switch (static_cast<PvPStatsSpells>(Id))
    {
        case PvPStatsSpells::SPEC_STAT_TEMPLATE_ALL_SPECS:
            return true;
        default:
            return false;
    }
}

/*
    Those spell entries are spells that are learned upon pet spawn (so far only DK pet spells are like that).
    The issue is that they are in spell book but shouldn't be, and go in action bars and mess up binds.
    I couldn't find any flags or skill attributes that could be used instead of this switch.
*/
bool SpellInfo::IsHiddenForPetEntry(uint32 p_PetEntry) const
{
    switch (p_PetEntry)
    {
        case DeathKnightPet::Ghoul:
        case DeathKnightPet::Abomination:
        {
            switch (Id)
            {
                case 91776: ///< RealClaw
                case 91800: ///< RealGnaw
                case 91838: ///< RealHuddle
                case 91809: ///< RealLeap
                case 91778: ///< SweepingClaws
                case 91797: ///< MonstrousBlow
                case 91378: ///< PutridBulwark
                case 91802: ///< ShamblingRush
                case 212335: ///< RealCleaver
                case 212332: ///< RealSmash
                case 212469: ///< RealHook
                case 212385: ///< RealProtectiveBile
                case 212338: ///< VileGas
                case 212383: ///< GastricBoat
                case 212337: ///< PowerfulSmash
                case 212470: ///< FleshHook
                {
                    return true;
                }
                default:
                    return false;
            }
        }
        default:
            return false;
    }
}

bool SpellInfo::IsDamageSpell() const
{
    for (uint8 l_Idx = 0; l_Idx < EffectCount; ++l_Idx)
    {
        if (Effects[l_Idx].IsDamagingEffect())
            return true;

        uint32 l_AuraType = Effects[l_Idx].ApplyAuraName;

        if (l_AuraType == SPELL_AURA_PERIODIC_DAMAGE_PERCENT ||
            l_AuraType == SPELL_AURA_PERIODIC_DAMAGE)
            return true;
    }

    return false;
}
