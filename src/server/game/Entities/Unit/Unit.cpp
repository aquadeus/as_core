////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include "AnticheatMgr.h"
#include "Common.h"
#include "CreatureAIImpl.h"
#include "Log.h"
#include "Opcodes.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "World.h"
#include "ObjectMgr.h"
#include "SpellMgr.h"
#include "Unit.h"
#include "QuestDef.h"
#include "Player.h"
#include "Creature.h"
#include "Spell.h"
#include "Group.h"
#include "SpellAuras.h"
#include "SpellAuraEffects.h"
#include "MapManager.h"
#include "ObjectAccessor.h"
#include "CreatureAI.h"
#include "Formulas.h"
#include "Pet.h"
#include "Util.h"
#include "Totem.h"
#include "Battleground.h"
#include "OutdoorPvP.h"
#include "OutdoorPvEMgr.h"
#include "InstanceSaveMgr.h"
#include "GridNotifiersImpl.h"
#include "CellImpl.h"
#include "CreatureGroups.h"
#include "PetAI.h"
#include "PassiveAI.h"
#include "TemporarySummon.h"
#include "Vehicle.h"
#include "Transport.h"
#include "InstanceScript.h"
#include "SpellInfo.h"
#include "MoveSplineInit.h"
#include "MoveSpline.h"
#include "ConditionMgr.h"
#include "UpdateFieldFlags.h"
#include "Battlefield.h"
#include "BattlefieldMgr.h"
#include "SpellAuraEffects.h"
#include "BattlegroundKT.h"
#include "BattlegroundWS.h"
#include "BattlegroundTP.h"
#include "BattlegroundDG.h"
#include "BattlegroundEY.h"
#include "GameTables.h"
#include "DB2Stores.h"
#include "SpellAuraDefines.h"
#include "HelperDefines.h"
#include "WeatherMgr.h"
#include "GarbageCollector.h"
#include <chrono>

#ifndef CROSS
# include "Guild.h"
#endif

#ifndef CROSS
# include "../../Garrison/GarrisonMgr.hpp"
# include "../../../scripts/Draenor/Garrison/GarrisonScriptData.hpp"
#endif

//#include "Reporting/Reporter.hpp"

float baseMoveSpeed[MAX_MOVE_TYPE] =
{
    2.5f,                  // MOVE_WALK
    7.0f,                  // MOVE_RUN
    4.5f,                  // MOVE_RUN_BACK
    4.722222f,             // MOVE_SWIM
    2.5f,                  // MOVE_SWIM_BACK
    3.141594f,             // MOVE_TURN_RATE
    7.0f,                  // MOVE_FLIGHT
    4.5f,                  // MOVE_FLIGHT_BACK
    3.14f                  // MOVE_PITCH_RATE
};

float playerBaseMoveSpeed[MAX_MOVE_TYPE] =
{
    2.5f,                  // MOVE_WALK
    7.0f,                  // MOVE_RUN
    4.5f,                  // MOVE_RUN_BACK
    4.722222f,             // MOVE_SWIM
    2.5f,                  // MOVE_SWIM_BACK
    3.141594f,             // MOVE_TURN_RATE
    7.0f,                  // MOVE_FLIGHT
    4.5f,                  // MOVE_FLIGHT_BACK
    3.14f                  // MOVE_PITCH_RATE
};

#define SPELL_PLAYER_LIFE_STEAL 146347

// Used for prepare can/can`t triggr aura
static bool InitTriggerAuraData();
// Define can trigger auras
static bool isTriggerAura[TOTAL_AURAS];
// Define can't trigger auras (need for disable second trigger)
static bool isNonTriggerAura[TOTAL_AURAS];
// Triggered always, even from triggered spells
static bool isAlwaysTriggeredAura[TOTAL_AURAS];
// Prepare lists
static bool procPrepared = InitTriggerAuraData();

thread_local uint32 g_UnsafeSpellOrAuraScriptHook = 0;
static ACE_Based::LockedMap<uint32, bool> g_UnsafeSpellReportedSet;
static ACE_Based::LockedMap<uint32, bool> g_MalformedAreatriggerSearcherSet;

void Unit::IncreaseUnsafeSpellOrAuraHookThreadLocal()
{
    g_UnsafeSpellOrAuraScriptHook++;
}

void Unit::ReduceUnsafeSpellOrAuraHookThreadLocal()
{
    g_UnsafeSpellOrAuraScriptHook--;
}

uint32 Unit::GetUnsafeSpellOrAuraScriptHookThreadLocal()
{
    return g_UnsafeSpellOrAuraScriptHook;
}

bool Unit::IsAlreadyReportedSpell(uint32 p_SpellId)
{
    return (g_UnsafeSpellReportedSet.find(p_SpellId) != g_UnsafeSpellReportedSet.end());
}

void Unit::AddReportedSpell(uint32 p_SpellId)
{
    g_UnsafeSpellReportedSet[p_SpellId] = true;
}

bool Unit::IsAlreadyReportedAreatrigger(uint32 p_Entry)
{
    return (g_MalformedAreatriggerSearcherSet.find(p_Entry) != g_MalformedAreatriggerSearcherSet.end());
}

void Unit::AddReportedAreatrigger(uint32 p_Entry)
{
    g_MalformedAreatriggerSearcherSet[p_Entry] = true;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, SpellSchoolMask p_SchoolMask, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
m_source(p_Actor), m_target(p_Target), m_amount(p_Amount), m_spell(nullptr), m_spellInfo(nullptr), m_schoolMask(p_SchoolMask),
m_damageType(p_DamageType), m_attackType(p_AttackType), m_absorb(0), m_block(0), m_resist(0), m_unmitigatedAmount(p_Amount)
{
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, Spell const* p_Spell, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_Spell->GetSpellInfo(), p_DamageType, p_AttackType)
{
    m_spell = p_Spell;
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, SpellInfo const* p_SpellInfo, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
m_source(p_Actor), m_target(p_Target), m_amount(p_Amount), m_spell(nullptr), m_spellInfo(p_SpellInfo), m_schoolMask((p_SpellInfo) ? p_SpellInfo->GetSchoolMask() : SPELL_SCHOOL_MASK_NONE),
m_damageType(p_DamageType), m_attackType(p_AttackType), m_absorb(0), m_block(0), m_resist(0), m_unmitigatedAmount(p_Amount)
{
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedAmount, SpellSchoolMask p_SchoolMask, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
m_source(p_Actor), m_target(p_Target), m_amount(p_Amount), m_spell(nullptr), m_spellInfo(nullptr), m_schoolMask(p_SchoolMask),
m_damageType(p_DamageType), m_attackType(p_AttackType), m_absorb(0), m_block(0), m_resist(0), m_unmitigatedAmount(p_UnmitigatedAmount)
{
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedAmount, Spell const* p_Spell, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_UnmitigatedAmount, p_Spell->GetSpellInfo(), p_DamageType, p_AttackType)
{
    m_spell = p_Spell;
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedAmount, SpellInfo const* p_SpellInfo, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
m_source(p_Actor), m_target(p_Target), m_amount(p_Amount), m_spell(nullptr), m_spellInfo(p_SpellInfo), m_schoolMask((p_SpellInfo) ? p_SpellInfo->GetSchoolMask() : SPELL_SCHOOL_MASK_NONE),
m_damageType(p_DamageType), m_attackType(p_AttackType), m_absorb(0), m_block(0), m_resist(0), m_unmitigatedAmount(p_UnmitigatedAmount)
{
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(const DamageInfo& p_DamageInfo) :
m_source(p_DamageInfo.m_source),
m_target(p_DamageInfo.m_target),
m_amount(p_DamageInfo.m_amount),
m_spell(p_DamageInfo.m_spell),
m_spellInfo(p_DamageInfo.m_spellInfo),
m_schoolMask(p_DamageInfo.m_schoolMask),
m_damageType(p_DamageInfo.m_damageType),
m_attackType(p_DamageInfo.m_attackType),
m_absorb(p_DamageInfo.m_absorb),
m_block(p_DamageInfo.m_block),
m_resist(p_DamageInfo.m_resist),
m_unmitigatedAmount(p_DamageInfo.m_unmitigatedAmount)
{
    m_addpower = 0;
    m_addptype = -1;
    m_OverHeal = 0;
}

DamageInfo::DamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedDamage, SpellInfo const* p_SpellInfo, SpellSchoolMask p_SchoolMask, DamageEffectType p_DamageType) :
    m_source(p_Actor), m_target(p_Target), m_amount(p_Amount), m_spell(nullptr), m_spellInfo(p_SpellInfo), m_schoolMask(p_SchoolMask), m_damageType(p_DamageType), m_absorb(0), m_block(0),
    m_resist(0), m_unmitigatedAmount(p_UnmitigatedDamage)
{
    m_source = p_Actor;
    m_target = p_Target;
    m_amount = p_Amount;
    m_unmitigatedAmount = p_UnmitigatedDamage;
    m_spellInfo = p_SpellInfo;
    m_schoolMask = p_SchoolMask;
    m_damageType = p_DamageType;
    m_OverHeal = 0;
}

void DamageInfo::Absorb(uint32 p_Amount)
{
    p_Amount = std::min(p_Amount, GetAmount());
    m_absorb += p_Amount;
    m_amount -= p_Amount;
}

void DamageInfo::Block(uint32 p_Amount)
{
    p_Amount = std::min(p_Amount, GetAmount());
    m_block += p_Amount;
    m_amount -= p_Amount;
}

void DamageInfo::CancelDamage()
{
    ResetAmount(0);
}

void DamageInfo::ModifyAmount(int32 p_Amount)
{
    m_amount += (p_Amount > 0) ? p_Amount : std::min<int32>(p_Amount, GetAmount());
}

void DamageInfo::Resist(uint32 p_Amount)
{
    p_Amount = std::min(p_Amount, GetAmount());
    m_resist += p_Amount;
    m_amount -= p_Amount;
}

void DamageInfo::SetAmount(uint32 p_Amount)
{
    m_amount = p_Amount;
}

void DamageInfo::ResetAmount(uint32 p_Amount)
{
    ResetAmount(p_Amount, p_Amount);
}

void DamageInfo::ResetAmount(uint32 p_Amount, uint32 p_UnmitigatedAmount)
{
    m_absorb = 0;
    m_amount = p_Amount;
    m_block = 0;
    m_resist = 0;
    m_unmitigatedAmount = p_UnmitigatedAmount;
}

void DamageInfo::OverrideSpell(Spell const* p_Spell)
{
    m_spell = p_Spell;
    OverrideSpell((p_Spell) ? p_Spell->GetSpellInfo() : nullptr);
}

std::string DamageInfo::ToString()
{
    std::ostringstream l_Output;
    l_Output << "DamageIngo dump :" << std::endl;
    l_Output << "m_absorb " << m_absorb << std::endl;
    l_Output << "m_amount " << m_amount << std::endl;
    l_Output << "m_block " << m_block << std::endl;
    l_Output << "m_resist " << m_resist << std::endl;
    l_Output << "m_unmitigatedAmount " << m_unmitigatedAmount << std::endl;
    l_Output << "m_addpower " << m_addpower << std::endl;
    l_Output << "m_damageType " << m_damageType << std::endl;

    if (m_spellInfo)
        l_Output << "m_spellInfo " << m_spellInfo->Id << std::endl;

    return l_Output.str();
}

ProcEventInfo::ProcEventInfo(Unit* p_Actor, Unit* p_ActionTarget, Unit* p_ProcTarget, uint32 p_TypeMask, uint32 p_SpellTypeMask, uint32 p_SpellPhaseMask, uint32 p_HitMask, DamageInfo* p_DamageInfo)
:m_actor(p_Actor), m_actionTarget(p_ActionTarget), m_procTarget(p_ProcTarget), m_typeMask(p_TypeMask), m_spellTypeMask(p_SpellTypeMask), m_spellPhaseMask(p_SpellPhaseMask),
m_hitMask(p_HitMask),  m_damageInfo(p_DamageInfo)
{
}

CalcDamageInfo::CalcDamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, SpellSchoolMask p_SchoolMask, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_SchoolMask, p_DamageType, p_AttackType),
TargetState(0),
HitInfo(0),
procAttacker(PROC_FLAG_NONE),
procVictim(PROC_FLAG_NONE),
procEx(PROC_EX_NONE),
hitOutCome(MELEE_HIT_EVADE)
{
}

CalcDamageInfo::CalcDamageInfo(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedAmount, SpellSchoolMask p_SchoolMask, DamageEffectType p_DamageType, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_SchoolMask, p_DamageType, p_AttackType),
TargetState(0),
HitInfo(0),
procAttacker(PROC_FLAG_NONE),
procVictim(PROC_FLAG_NONE),
procEx(PROC_EX_NONE),
hitOutCome(MELEE_HIT_EVADE)
{
}

SpellNonMeleeDamage::SpellNonMeleeDamage(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, Spell const* p_Spell, DamageEffectType p_DamageType, uint32 p_SpellXSpellVisualID, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_Spell, p_DamageType, p_AttackType),
physicalLog(false),
HitInfo(0),
m_SpellXSpellVisualID(p_SpellXSpellVisualID)
{
}

SpellNonMeleeDamage::SpellNonMeleeDamage(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, SpellInfo const* p_SpellInfo, DamageEffectType p_DamageType, uint32 p_SpellXSpellVisualID, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_SpellInfo, p_DamageType, p_AttackType),
physicalLog(false),
HitInfo(0),
m_SpellXSpellVisualID(p_SpellXSpellVisualID)
{
}

SpellNonMeleeDamage::SpellNonMeleeDamage(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigatedAmount, Spell const* p_Spell, DamageEffectType p_DamageType, uint32 p_SpellXSpellVisualID, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_Spell, p_DamageType, p_AttackType),
physicalLog(false),
HitInfo(0),
m_SpellXSpellVisualID(p_SpellXSpellVisualID)
{
}

SpellNonMeleeDamage::SpellNonMeleeDamage(Unit* p_Actor, Unit* p_Target, uint32 p_Amount, uint32 p_UnmitigedAmount, SpellInfo const* p_SpellInfo, DamageEffectType p_DamageType, uint32 p_SpellXSpellVisualID, WeaponAttackType p_AttackType) :
DamageInfo(p_Actor, p_Target, p_Amount, p_SpellInfo, p_DamageType, p_AttackType),
physicalLog(false),
HitInfo(0),
m_SpellXSpellVisualID(p_SpellXSpellVisualID)
{
}

SpellNonMeleeDamage::SpellNonMeleeDamage(const DamageInfo& p_DamageInfo) :
DamageInfo(p_DamageInfo),
physicalLog(false),
HitInfo(0),
m_SpellXSpellVisualID(p_DamageInfo.GetSpell() ? p_DamageInfo.GetSpell()->GetSpellXSpellVisualID() : 0)
{
}

// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
Unit::Unit(bool isWorldObject): WorldObject(isWorldObject)
    , m_movedPlayer(NULL)
    , m_lastSanctuaryTime(0)
    , m_TempSpeed(0.0f)
    , IsAIEnabled(false)
    , NeedChangeAI(false)
    , m_ControlledByPlayer(false)
    , movespline(new Movement::MoveSpline())
    , i_AI(NULL)
    , i_disabledAI(NULL)
    , m_AutoRepeatFirstCast(false)
    , m_procDeep(0)
    , m_removedAurasCount(0)
    , i_motionMaster(this)
    , m_ThreatManager(this)
    , m_vehicle(NULL)
    , m_vehicleKit(NULL)
    , m_unitTypeMask(UNIT_MASK_NONE)
    , m_disableHealthRegen(false)
    , m_disableEnterEvadeMode(false)
    , m_HostileRefManager(this)
    , _lastDamagedTime(0)
    , m_movementCounter(0)
    , m_DebugPosition(false)
{
#ifdef _MSC_VER
#pragma warning(default:4355)
#endif
    m_objectType |= TYPEMASK_UNIT;
    m_objectTypeId = TYPEID_UNIT;

    m_updateFlag = UPDATEFLAG_HAS_MOVEMENT_UPDATE;

    m_attackTimer[WeaponAttackType::BaseAttack] = 0;
    m_attackTimer[WeaponAttackType::OffAttack] = 0;
    m_attackTimer[WeaponAttackType::RangedAttack] = 0;
    m_modAttackSpeedPct[WeaponAttackType::BaseAttack] = 1.0f;
    m_modAttackSpeedPct[WeaponAttackType::OffAttack] = 1.0f;
    m_modAttackSpeedPct[WeaponAttackType::RangedAttack] = 1.0f;

    m_extraAttacks = 0;
    m_InsightCount = 0;
    m_canDualWield = false;

    m_rootTimes = 0;

    m_state = 0;
    m_deathState = ALIVE;

    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
        m_currentSpells[i] = NULL;

    m_addDmgOnce = 0;

    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
        m_SummonSlot[i] = 0;

    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)
        m_ObjectSlot[i] = 0;

    m_auraUpdateIterator = m_ownedAuras.end();

    m_interruptMask = 0;
    m_transform = 0;
    m_canModifyStats = false;

    for (uint8 i = 0; i < MAX_SPELL_IMMUNITY; ++i)
        m_spellImmune[i].clear();

    for (uint8 l_I = 0; l_I < UNIT_MOD_END; ++l_I)
    {
        m_auraModifiersGroup[l_I][BASE_VALUE]               = 0.0f;
        m_auraModifiersGroup[l_I][BASE_PCT_EXCLUDE_CREATE]  = 100.0f;
        m_auraModifiersGroup[l_I][BASE_PCT]                 = 1.0f;
        m_auraModifiersGroup[l_I][TOTAL_VALUE]              = 0.0f;
        m_auraModifiersGroup[l_I][TOTAL_PCT]                = 1.0f;
    }
                                                            // implement 50% base damage from offhand
    m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;

    for (uint8 i = 0; i < WeaponAttackType::MaxAttack; ++i)
    {
        m_baseWeaponDamage[i][MINDAMAGE] = 0.0f;
        m_baseWeaponDamage[i][MAXDAMAGE] = 0.0f;

        m_WeaponDamage[i][MINDAMAGE] = 0.0f;
        m_WeaponDamage[i][MAXDAMAGE] = 0.0f;
    }

    for (uint8 i = 0; i < MAX_STATS; ++i)
        m_createStats[i] = 0.0f;

    m_attacking = NULL;
    m_modMeleeHitChance = 0.0f;
    m_modRangedHitChance = 0.0f;
    m_modSpellHitChance = 0.0f;
    m_baseSpellCritChance = 5;
    m_LastAbilityID = 0;

    m_CombatTimer = 0;

    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
        m_threatModifier[i] = 1.0f;

    m_isSorted = true;

    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
        m_speed_rate[i] = 1.0f;

    m_charmInfo = NULL;
    m_reducedThreatPercent = 0;
    m_misdirectionTargetGUID = 0;

    // remove aurastates allowing special moves
    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
        m_reactiveTimer[i] = 0;

    m_cleanupDone = false;
    m_duringRemoveFromWorld = false;

    m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GHOST, GHOST_VISIBILITY_ALIVE);

    _focusSpell = NULL;
    _lastLiquid = NULL;
    _isWalkingBeforeCharm = false;

    // Area Skip Update
    _skipCount = urand(0, 5);
    _skipDiff = 0;

    _petBattleId = 0;

    m_IsInKillingProcess = false;
    m_VisibilityUpdScheduled = false;

    for (int i = 0; i < MAX_POWERS; ++i) ///< Comparison of integers of different signs: 'int' and 'Powers'
        m_lastRegenTime[i] = getMSTime();

    for (int i = 0; i < MAX_POWERS; ++i) ///< Comparison of integers of different signs: 'int' and 'Powers'
        m_powers[i] = 0;

    m_lastVisibilityUpdPos = *this;

    m_HealingRainTrigger = 0;

    m_PersonnalChauffeur = 0;

    m_LastNotifyPosition.Relocate(-5000.0f, -5000.0f, -5000.0f, 0.0f);
    m_LastOutdoorPosition.Relocate(-5000.0f, -5000.0f, -5000.0f, 0.0f);

    m_Events.SetUnit(this);

#ifdef CROSS
    m_MapSwitchDestination = -1;
#endif
}

////////////////////////////////////////////////////////////
// Methods of class GlobalCooldownMgr
bool GlobalCooldownMgr::HasGlobalCooldown(SpellInfo const* spellInfo) const
{
    GlobalCooldownList::const_iterator itr = m_GlobalCooldowns.find(spellInfo->StartRecoveryCategory);
    return itr != m_GlobalCooldowns.end() && itr->second.duration && getMSTimeDiff(itr->second.cast_time, getMSTime() + 120) < itr->second.duration;
}

void GlobalCooldownMgr::AddGlobalCooldown(SpellInfo const* spellInfo, uint32 gcd)
{
    m_GlobalCooldowns[spellInfo->StartRecoveryCategory] = GlobalCooldown(gcd, getMSTime());
}

void GlobalCooldownMgr::CancelGlobalCooldown(SpellInfo const* spellInfo)
{
    m_GlobalCooldowns[spellInfo->StartRecoveryCategory].duration = 0;
}

int32 GlobalCooldownMgr::GetGlobalCooldown(SpellInfo const* p_SpellInfo)
{
    GlobalCooldownList::const_iterator itr = m_GlobalCooldowns.find(p_SpellInfo->StartRecoveryCategory);
    if (itr == m_GlobalCooldowns.end())
        return 0;

    return itr->second.duration - getMSTimeDiff(itr->second.cast_time, getMSTime());
}

////////////////////////////////////////////////////////////
// Methods of class Unit
Unit::~Unit()
{
    // set current spells as deletable
    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (m_currentSpells[i])
        {
            m_currentSpells[i]->SetReferencedFromCurrent(false);
            m_currentSpells[i]->SetExecutedCurrently(false);
            m_currentSpells[i] = NULL;
        }

    _DeleteRemovedAuras();

    for (DmgDoneList::iterator itr = m_dmgDone.begin(); itr != m_dmgDone.end(); itr++)
        delete (*itr);

    m_dmgDone.clear();

    delete m_charmInfo;
    delete movespline;

    if (m_vehicleKit)
    {
        delete m_vehicleKit;
        m_vehicleKit = nullptr;
    }

    // TODO : Find Why it crashes
    //ASSERT(!m_duringRemoveFromWorld);
    //ASSERT(!m_attacking);
    //ASSERT(m_attackers.empty());
    //ASSERT(m_sharedVision.empty());
    //ASSERT(m_Controlled.empty());
    //ASSERT(m_appliedAuras.empty());
    //ASSERT(m_ownedAuras.empty());
    //ASSERT(m_removedAuras.empty());
    //ASSERT(m_gameObj.empty());
    //ASSERT(m_dynObj.empty());
    //ASSERT(m_AreaTrigger.empty());
}

void Unit::Update(uint32 p_time)
{
    if (m_DebugPosition)
        SummonCreature(31146, *this, TEMPSUMMON_TIMED_DESPAWN, 5 * IN_MILLISECONDS);

    bool l_LogDiff = GetMap()->IsRaid();
    uint32 l_Time = l_LogDiff ? getMSTime() : 0;
    std::vector<uint32> l_Times;

    bool l_MapPerfLog = sMapMgr->m_LogMapPerformance || l_LogDiff;

    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::time_point();
    if (l_MapPerfLog)
        start = std::chrono::steady_clock::now();

    // WARNING! Order of execution here is important, do not change.
    // Spells must be processed with event system BEFORE they go to _UpdateSpells.
    // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
    m_Events.Update(p_time);
    m_Functions.Update(p_time);

    if (l_MapPerfLog)
        GetMap()->m_UpdateEventsFunctionsTime += std::chrono::steady_clock::now() - start;

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    if (!IsInWorld())
        return;

    if (l_MapPerfLog)
        start = std::chrono::steady_clock::now();

    _UpdateSpells(p_time);

    if (l_MapPerfLog)
        GetMap()->m_UpdateSpellsTime += std::chrono::steady_clock::now() - start;

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    // If this is set during update SetCantProc(false) call is missing somewhere in the code
    // Having this would prevent spells from being proced, so let's crash
    ASSERT(!m_procDeep);

    if (CanHaveThreatList() && getThreatManager().isNeedUpdateToClient(p_time))
        SendThreatListUpdate();

    // update combat timer only for players and pets (only pets with PetAI)
    if (isInCombat() && (IsPlayer() || (ToCreature()->isPet() && IsControlledByPlayer())))
    {
        // Check UNIT_STATE_MELEE_ATTACKING or UNIT_STATE_CHASE (without UNIT_STATE_FOLLOW in this case) so pets can reach far away
        // targets without stopping half way there and running off.
        // These flags are reset after target dies or another command is given.
        if (m_HostileRefManager.isEmpty())
        {
            // m_CombatTimer set at aura start and it will be freeze until aura removing
            if (m_CombatTimer <= p_time)
                ClearInCombat();
            else
                m_CombatTimer -= p_time;
        }
    }
    else if (!isInCombat())
    {
        m_LongSoulShardTimer += p_time;
    }
    /// Warlock should earn 1 Soul shard each 5 seconds after 30 seconds out of combat if they have less than 3.  As for 7.3.2 - 25549
    if (ToPlayer())
    {
        uint32 l_SecsCount = (ToPlayer()->GetPower(POWER_SOUL_SHARDS) >= 10 ? 5 : 25);
        if (ToPlayer()->getClass() == CLASS_WARLOCK && m_LongSoulShardTimer >= l_SecsCount * IN_MILLISECONDS)
        {
            if (m_ShortSoulShardTimer > 5 * IN_MILLISECONDS)
            {
                m_ShortSoulShardTimer = p_time;

                if ((GetPower(POWER_SOUL_SHARDS) < 30 && GetPower(POWER_SOUL_SHARDS) > 20) || (GetPower(POWER_SOUL_SHARDS) > 30 && GetPower(POWER_SOUL_SHARDS) < 40))
                    SetPower(POWER_SOUL_SHARDS, 30);
                else if (GetPower(POWER_SOUL_SHARDS) < 30)
                    ModifyPower(POWER_SOUL_SHARDS, 10);
                else if (GetPower(POWER_SOUL_SHARDS) > 30)
                    ModifyPower(POWER_SOUL_SHARDS, -10);
            }
            else
                m_ShortSoulShardTimer += p_time;
        }
    }

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    // not implemented before 3.0.2
    if (uint32 base_att = getAttackTimer(WeaponAttackType::BaseAttack))
        setAttackTimer(WeaponAttackType::BaseAttack, (base_att - p_time));
    if (uint32 ranged_att = getAttackTimer(WeaponAttackType::RangedAttack))
        setAttackTimer(WeaponAttackType::RangedAttack, (ranged_att - p_time));
    if (uint32 off_att = getAttackTimer(WeaponAttackType::OffAttack))
        setAttackTimer(WeaponAttackType::OffAttack, (off_att - p_time));

    // update abilities available only for fraction of time
    UpdateReactives(p_time);

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    /// Update all the stack durations
    UpdateStackOnDuration(p_time);

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    if (isAlive())
    {
        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, HealthBelowPct(20));
        ModifyAuraState(AURA_STATE_HEALTHLESS_25_PERCENT, HealthBelowPct(25));
        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, HealthBelowPct(35));
        ModifyAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT, HealthAbovePct(75));
    }

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    UpdateSplineMovement(p_time);

    if (l_LogDiff)
        l_Times.push_back(getMSTime() - l_Time);

    if (l_MapPerfLog)
        start = std::chrono::steady_clock::now();

    i_motionMaster.UpdateMotion(p_time);

    if (l_MapPerfLog)
        GetMap()->m_UpdateMotionMasterTime += std::chrono::steady_clock::now() - start;

    bool l_UpdateVisibility = false;
    for (auto l_Itr = m_HideForGuid.begin(); l_Itr != m_HideForGuid.end();)
    {
        if (l_Itr->second)
        {
            if (l_Itr->second <= p_time)
            {
                l_Itr = m_HideForGuid.erase(l_Itr);
                l_UpdateVisibility = true;
                continue;
            }

            l_Itr->second -= p_time;
        }
        l_Itr++;
    }

    if (l_UpdateVisibility)
        UpdateObjectVisibility(false);

    if (l_LogDiff)
    {
        uint32 l_EndTime = getMSTime() - l_Time;
        l_Times.push_back(getMSTime() - l_Time);

        if (l_EndTime > 10)
        {
            sLog->outAshran("Unit::Update [Entry: %u, Victim: %u] take %u ms", GetEntry(), getVictim() ? getVictim()->GetEntry() : 0, l_EndTime);
            std::ostringstream l_DiffDump;
            for (auto l_Diff : l_Times)
                l_DiffDump << l_Diff << " ";
            sLog->outAshran(l_DiffDump.str().c_str());
        }
    }
}

void Unit::SetObjectScale(float p_Scale)
{
    Object::SetObjectScale(p_Scale);

    if (IsPlayer())
    {
        SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, p_Scale * DEFAULT_WORLD_OBJECT_SIZE);
        SetFloatValue(UNIT_FIELD_COMBAT_REACH, p_Scale * DEFAULT_COMBAT_REACH);
    }
    else
    {
        if (CreatureModelInfo const* l_Model = sObjectMgr->GetCreatureModelInfo(GetDisplayId()))
        {
            SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, p_Scale * l_Model->bounding_radius);
            SetFloatValue(UNIT_FIELD_COMBAT_REACH, p_Scale * l_Model->combat_reach);
        }
    }
}

bool Unit::haveOffhandWeapon() const
{
    if (IsPlayer())
        return ToPlayer()->GetWeaponForAttack(WeaponAttackType::OffAttack, true);
    else
        return m_canDualWield;
}

void Unit::MonsterMoveWithSpeed(float x, float y, float z, float speed, bool generatePath, bool forceDestination)
{
    Movement::MoveSplineInit init(this);
    init.MoveTo(x, y, z, generatePath, forceDestination);
    init.SetVelocity(speed);
    init.Launch();
}

uint32 const positionUpdateDelay = 400;
uint32 const g_FlightSplineSyncDelay = 5 * TimeConstants::IN_MILLISECONDS;

class SplineHandler
{
public:
    SplineHandler(Unit* unit) : _unit(unit) { }

    bool operator()(Movement::MoveSpline::UpdateResult result)
    {
        if ((result & (Movement::MoveSpline::Result_NextSegment | Movement::MoveSpline::Result_JustArrived)) &&
            _unit->IsCreature() && _unit->GetMotionMaster()->GetCurrentMovementGeneratorType() == ESCORT_MOTION_TYPE &&
            _unit->movespline->GetId() == _unit->GetMotionMaster()->GetCurrentSplineId())
        {
            _unit->ToCreature()->AI()->MovementInform(ESCORT_MOTION_TYPE, _unit->movespline->currentPathIdx() - 1);
        }

        return true;
    }

private:
    Unit* _unit;
};

void Unit::UpdateSplineMovement(uint32 p_Diff)
{
    bool l_Arrived = movespline->Finalized(); ///< l_Arrived is never read 01/18/16
    if (movespline->Finalized())
        return;

    SplineHandler handler(this);
    movespline->updateState(p_Diff, handler);
    l_Arrived = movespline->Finalized();

    if (l_Arrived)
        DisableSpline();

    m_movesplineTimer.Update(p_Diff);
    if (m_movesplineTimer.Passed() || l_Arrived)
        UpdateSplinePosition();

    m_FlightSplineSyncTimer.Update(p_Diff);
    if (m_FlightSplineSyncTimer.Passed())
    {
        float l_Percent = 1.0f;
        float l_TotalTime = movespline->spline.length();
        if (l_TotalTime > 0.0f)
            l_Percent = (float)movespline->time_passed / l_TotalTime;

        SendFlightSplineSync(l_Percent);
        m_FlightSplineSyncTimer.Reset(g_FlightSplineSyncDelay);
    }
}

void Unit::UpdateSplinePosition()
{
    m_movesplineTimer.Reset(positionUpdateDelay);

    Movement::Location l_Location = movespline->ComputePosition();
    if (GetTransGUID())
    {
        Position& l_Pos = m_movementInfo.t_pos;
        l_Pos.m_positionX = l_Location.x;
        l_Pos.m_positionY = l_Location.y;
        l_Pos.m_positionZ = l_Location.z;
        l_Pos.SetOrientation(l_Location.orientation);

        if (GetVehicleBase())
        {
            if (TransportBase* l_Transport = GetDirectTransport())
                l_Transport->CalculatePassengerPosition(l_Location.x, l_Location.y, l_Location.z, l_Location.orientation);
        }
    }

    if (HasUnitState(UnitState::UNIT_STATE_CANNOT_TURN))
        l_Location.orientation = GetOrientation();

    UpdatePosition(l_Location.x, l_Location.y, l_Location.z, l_Location.orientation);

    /// Update all passengers after updating vehicle position
    /// This will prevent some base positioning if vehicles are updated in the wrong order
    if (Vehicle* l_Vehicle = GetVehicleKit())
    {
        for (int8 l_I = 0; l_I < MAX_VEHICLE_SEATS; ++l_I)
        {
            if (Unit* l_Passenger = l_Vehicle->GetPassenger(l_I))
            {
                if (l_Passenger->movespline->Initialized())
                    l_Passenger->UpdateSplinePosition();
            }
        }
     }

    if (sObjectMgr->IsInWPDebug() && ToCreature())
    {
        if (Creature* l_Creature = ToCreature()->SummonCreature(31146, *this))
            l_Creature->SetObjectScale(0.5f);
    }
}

void Unit::DisableSpline()
{
    m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FORWARD);
    movespline->_Interrupt();
}

bool Unit::SpellProcTriggered(Unit* p_Victim, DamageInfo* p_DmgInfo, AuraEffect* p_TriggeredByAura, SpellInfo const* p_ProcSpell, uint32 p_ProcFlags, uint32 p_ProcEx, double p_Cooldown)
{
    uint32 damage = p_DmgInfo->GetAmount();
    int32 addpowertype = p_DmgInfo->GetAddPType();
    SpellInfo const* dummySpell = p_TriggeredByAura->GetSpellInfo();
    uint32 effIndex = p_TriggeredByAura->GetEffIndex();
    int32  triggerAmount = p_TriggeredByAura->GetAmount();
    int32 cooldown_spell_id = 0;
    uint32 triggered_spell_id = p_TriggeredByAura->GetTriggerSpell() ? p_TriggeredByAura->GetTriggerSpell() : 0;

    Item* castItem = p_TriggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(p_TriggeredByAura->GetBase()->GetCastItemGUID()) : nullptr;

    Unit* target = p_Victim;
    int32 basepoints0 = 0;
    int32 basepoints1 = 0;
    int32 basepoints2 = 0;
    ObjectGuid originalCaster;
    Unit* procSpellCaster = p_DmgInfo->GetActor();
    uint64 procSpellCasterGUID = procSpellCaster ? procSpellCaster->GetGUID() : 0;
    int32 schoolMask = p_ProcSpell ? p_ProcSpell->GetSchoolMask() : SPELL_SCHOOL_MASK_NORMAL;

    if (std::vector<SpellTriggered> const* spellTrigger = sSpellMgr->GetSpellTriggered(dummySpell->Id))
    {
        bool check = false;
        std::list<int32> groupList;
        for (std::vector<SpellTriggered>::const_iterator itr = spellTrigger->begin(); itr != spellTrigger->end(); ++itr)
        {
            if (itr->DummyID) //take amount from other spell
            {
                if (SpellInfo const* dummySpellInfo = sSpellMgr->GetSpellInfo(abs(itr->DummyID)))
                    triggerAmount = dummySpellInfo->Effects[itr->DummyEffect].BasePoints;
            }
            if (itr->SpellCooldown)
                cooldown_spell_id = abs(itr->SpellCooldown);
            else
                cooldown_spell_id = abs(itr->SpellTrigger);

            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "SpellTriggered target %u, caster %u, spell_trigger %i, chance %i, triggerAmount %i, damage %i, GetAbsorb %i, GetResist %i, GetBlock %i",
                itr->Target, itr->Caster, itr->SpellTrigger, itr->Chance, triggerAmount, damage, p_DmgInfo->GetAbsorb(), p_DmgInfo->GetResist(), p_DmgInfo->GetBlock());
            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, " group %i, effIndex %i, effectmask %i, option %i, (1<<effIndex) %i, procFlag %i addpowertype %i addptype %i procEx %i cooldown %f cooldown_spell_id %i",
                itr->Group, effIndex, itr->EffectMask, itr->Options, (1 << effIndex), p_ProcFlags, addpowertype, itr->AddPType, p_ProcEx, p_Cooldown, cooldown_spell_id);

            if (G3D::fuzzyGt(p_Cooldown, 0.0) && IsPlayer())
            {
                if (itr->Options == SPELL_TRIGGER_COOLDOWN || itr->Options == SPELL_TRIGGER_MODIFY_COOLDOWN)
                {
                    if (!ToPlayer()->HasSpellCooldown(itr->SpellTrigger))
                        continue;
                    cooldown_spell_id = dummySpell->Id;
                    if (ToPlayer()->HasSpellCooldown(cooldown_spell_id))
                        return false;
                }
                else if (ToPlayer()->HasSpellCooldown(cooldown_spell_id))
                    return false;
            }

            if (!(itr->EffectMask & (1 << effIndex)))
                continue;

            if (itr->ProcFlags > 0 && !(itr->ProcFlags & p_ProcFlags))
                continue;
            else if (itr->ProcFlags < 0 && (std::abs(itr->ProcFlags) & p_ProcFlags))
                continue;

            if (itr->ProcEx > 0 && !(itr->ProcEx & p_ProcEx))
                continue;
            else if (itr->ProcEx < 0 && (abs(itr->ProcEx) & p_ProcEx))
                continue;

            if (itr->SchoolMask > 0 && !(itr->SchoolMask & schoolMask))
                continue;
            else if (itr->SchoolMask < 0 && (abs(itr->SchoolMask) & schoolMask))
                continue;

            if (itr->AddPType != -1 && itr->AddPType != addpowertype)
                continue;
            else if (itr->AddPType == -1 && addpowertype != -1)
                continue;

            if (itr->Chance != 0)
            {
                if (itr->Chance > 100) // chance get from amount
                {
                    if (!roll_chance_i(triggerAmount))
                        continue;
                }
                else if (itr->Chance == -1) // chance get from amount / 10
                {
                    int32 rollchance = urand(0, 1000);
                    if (rollchance > triggerAmount)
                        continue;
                }
                else if (itr->Chance == -2) // chance get from amount / 100
                {
                    int32 rollchance = urand(0, 10000);
                    if (rollchance > triggerAmount)
                        continue;
                }
                else if (itr->Chance == -3) // chance get from target health
                {
                    if (!target)
                        continue;
                    if (dummySpell->GetSpellAuraOptions()->procChance < int32(target->GetHealthPct()))
                        continue;
                    int32 rollchance = 100 - int32((target->GetHealthPct() / 100) * dummySpell->GetSpellAuraOptions()->procChance);
                    if (!roll_chance_i(rollchance))
                        continue;
                }
                else if (!roll_chance_i(itr->Chance))
                    continue;
            }
            if (itr->CheckSpellID > 0)
            {
                if (!p_ProcSpell)
                    continue;
                if (p_ProcSpell->Id != itr->CheckSpellID)
                    continue;
            }
            else if (itr->CheckSpellID < 0)
            {
                if (!p_ProcSpell)
                    continue;
                if (p_ProcSpell->Id == abs(itr->CheckSpellID))
                    continue;
            }

            if (itr->Group != 0 && !groupList.empty())
            {
                bool groupFind = false;
                for (std::list<int32>::const_iterator group_itr = groupList.begin(); group_itr != groupList.end(); ++group_itr)
                    if ((*group_itr) == itr->Group)
                        groupFind = true;
                if (groupFind)
                    continue;
            }

            if (itr->Target == 8 && target == this) //not trigger spell for self
                continue;
            if (itr->Target == 1 || itr->Target == 6 || !target) //get target self
                target = this;
            if (itr->Target == 3 && ToPlayer()) //get target owner
                if (Pet* pet = ToPlayer()->GetPet())
                    target = (Unit*)pet;
            if (itr->Target == 4 && target->ToPlayer()) //get target pet
                if (Pet* pet = target->ToPlayer()->GetPet())
                    target = (Unit*)pet;
            if (itr->Target == 5) //get target owner
                if (Unit* owner = GetOwner())
                    target = owner;
            if (itr->Target == 7) //get target self
                target = p_TriggeredByAura->GetCaster();
            if (itr->Target == 10) //get target owner or self
            {
                if (Player* _player = ToPlayer())
                {
                    if (Pet* pet = _player->GetPet())
                        target = (Unit*)pet;
                }
                else if (Unit* owner = GetOwner())
                    target = owner;
            }

            Unit* _caster = this;
            Unit* _targetAura = this;
            Unit* _targetAura2 = this;

            if (itr->Caster == 1) //get caster aura
                _caster = p_TriggeredByAura->GetCaster();
            if (itr->Caster == 3 && ToPlayer()) //get caster owner
                if (Pet* pet = ToPlayer()->GetPet())
                    _caster = (Unit*)pet;
            if (itr->Caster == 4) //get caster owner
                if (Unit* owner = GetOwner())
                    _caster = owner;
            if (itr->Caster == 5) //get caster is target
                _caster = p_Victim;
            if (itr->Caster == 10) //get target owner or self
            {
                if (Player* _player = ToPlayer())
                {
                    if (Pet* pet = _player->GetPet())
                        _caster = (Unit*)pet;
                }
                else if (Unit* owner = GetOwner())
                    _caster = owner;
            }
            if (!_caster)
                _caster = this;

            if (itr->Target == 9) //get target select
                if (Player* _player = _caster->ToPlayer())
                    if (Unit* _select = _player->GetSelectedUnit())
                        target = _select;

            if (itr->TargetAura == 1) //get caster aura
                _targetAura = p_TriggeredByAura->GetCaster();
            if (itr->TargetAura == 2) //get target aura
                _targetAura = p_Victim;
            if (itr->TargetAura == 3) //get target select
                if (Player* _player = ToPlayer())
                    if (Unit* _select = _player->GetSelectedUnit())
                        _targetAura = _select;

            if (itr->TargetAura2 == 1) //get caster aura
                _targetAura2 = p_TriggeredByAura->GetCaster();
            if (itr->TargetAura2 == 2) //get target aura
                _targetAura2 = p_Victim;
            if (itr->TargetAura2 == 3) //get target select
                if (Player* _player = ToPlayer())
                    if (Unit* _select = _player->GetSelectedUnit())
                        _targetAura2 = _select;

            if (_targetAura)
            {
                if (itr->CreatureType > 0 && !(itr->CreatureType & (1 << _targetAura->GetCreatureType())))
                    continue;
                else if (itr->CreatureType < 0 && (itr->CreatureType & (1 << _targetAura->GetCreatureType())))
                    continue;
            }

            if (itr->Aura2 > 0 && !_targetAura2->HasAura(itr->Aura2))
            {
                check = true;
                continue;
            }
            if (itr->Aura2 < 0 && _targetAura2->HasAura(abs(itr->Aura2)))
            {
                check = true;
                continue;
            }

            int32 bp0 = int32(itr->Bp0);
            int32 bp1 = int32(itr->Bp1);
            int32 bp2 = int32(itr->Bp2);
            switch (itr->Options)
            {
                case SPELL_TRIGGER_BP: //0
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->SpellTrigger > 0)
                        basepoints0 = triggerAmount;
                    else
                        basepoints0 = -(triggerAmount);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    if (basepoints0)
                        _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    else
                        _caster->CastSpell(target, triggered_spell_id, true);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                        {
                            if (basepoints0)
                                _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &bp1, &bp2, true);
                            else
                                _caster->CastSpell(pet, triggered_spell_id, true);
                        }
                    }
                    check = true;

                    break;
                }
                case SPELL_TRIGGER_BP_CUSTOM: //1
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &bp0, &bp1, &bp2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &bp1, &bp2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_MANA_COST: //2
                {
                    if (!p_ProcSpell)
                        continue;
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    int32 cost[MAX_POWERS_COST];
                    memset(cost, 0, sizeof(uint32)* MAX_POWERS_COST);
                    cost[MAX_POWERS_COST - 1] = 0;
                    p_ProcSpell->CalcPowerCost(_caster, p_ProcSpell->GetSchoolMask(), cost);
                    basepoints0 = CalculatePct(cost[POWER_MANA], bp0);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &bp1, &bp2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &bp1, &bp2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_DAM_HEALTH: //3
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    float percent = 0.0f;
                    if (Player* plr = ToPlayer())
                    {
                        if (dummySpell->HasAttribute(SPELL_ATTR8_MASTERY_SPECIALIZATION))
                            percent = plr->GetFloatValue(PLAYER_FIELD_MASTERY) * dummySpell->Effects[effIndex].BonusMultiplier;
                    }

                    if (!percent)
                        percent = triggerAmount;

                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;

                    basepoints0 = CalculatePct(int32(p_DmgInfo->GetAmount() + p_DmgInfo->GetAbsorb()), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_COOLDOWN: //4
                {
                    if (Player* player = target->ToPlayer())
                    {
                        uint32 spellid = abs(itr->SpellTrigger);
                        if (itr->Bp0 == 0.0f)
                            player->RemoveSpellCooldown(spellid, true);
                        else
                        {
                            if (itr->Aura && !p_ProcSpell)
                                continue;
                            if (itr->Aura && p_ProcSpell && itr->Aura != p_ProcSpell->Id)
                                continue;

                            int32 delay = itr->Bp0;
                            player->ModifySpellCooldown(spellid, delay);
                        }
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_UPDATE_DUR: //5
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    if (itr->SpellTrigger > 0)
                    {
                        if (Aura* aura = target->GetAura(abs(itr->SpellTrigger), _caster->GetGUID()))
                            aura->RefreshTimers();
                    }
                    else
                    {
                        if (p_ProcSpell->Id == -(itr->SpellTrigger))
                            if (procSpellCasterGUID == p_TriggeredByAura->GetCasterGUID())
                                p_TriggeredByAura->GetBase()->RefreshTimers();
                    }

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_GET_DUR_AURA: //6
                {
                    if (Aura* aura = target->GetAura(itr->Aura, GetGUID()))
                        basepoints0 = int32(aura->GetDuration() / 1000);
                    if (basepoints0)
                    {
                        triggered_spell_id = abs(itr->SpellTrigger);
                        _caster->CastCustomSpell(this, triggered_spell_id, &basepoints0, &bp1, &bp2, true, castItem, p_TriggeredByAura, originalCaster);
                        if (itr->Target == 6)
                        {
                            if (Guardian* pet = GetGuardianPet())
                                _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &bp1, &bp2, true);
                        }
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_UPDATE_DUR_TO_MAX: //8
                {
                    if (Aura* aura = target->GetAura(abs(itr->SpellTrigger), GetGUID()))
                        aura->SetDuration(aura->GetSpellInfo()->GetMaxDuration(), true);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_PERC_FROM_DAMGE: //9
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    float amount = bp0;

                    if (!bp0)
                        amount = triggerAmount / 100.0f;

                    basepoints0 = CalculatePct(damage, amount);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &bp1, &bp2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &bp1, &bp2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_PERC_MAX_MANA: //10
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;
                    basepoints0 = CalculatePct(target->GetMaxPower(POWER_MANA), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    //target->EnergizeBySpell(target, triggered_spell_id, basepoints0, POWER_MANA);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, nullptr, nullptr, true, castItem, p_TriggeredByAura, originalCaster);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_PERC_BASE_MANA: //11
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;
                    basepoints0 = CalculatePct(target->GetCreateMana(), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, nullptr, nullptr, true, castItem, p_TriggeredByAura, originalCaster);
                    //target->EnergizeBySpell(target, triggered_spell_id, basepoints0, POWER_MANA);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_PERC_CUR_MANA: //12
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    basepoints0 = int32((itr->Bp0 / 100.0f) * target->GetPower(POWER_MANA));

                    triggered_spell_id = abs(itr->SpellTrigger);
                    target->EnergizeBySpell(target, triggered_spell_id, basepoints0, POWER_MANA);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_CHECK_PROCK: //13
                {
                    if (!p_ProcSpell)
                    {
                        check = true;
                        continue;
                    }
                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (itr->Aura == p_ProcSpell->Id)
                        _caster->CastSpell(target, triggered_spell_id, true);

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_CHECK_DAMAGE: //16
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (int32(damage) >= triggerAmount)
                    {
                        _caster->CastSpell(target, triggered_spell_id, true);
                        p_TriggeredByAura->GetBase()->Remove(AURA_REMOVE_BY_DEFAULT);
                        check = true;
                        continue;
                    }

                    p_TriggeredByAura->SetAmount(triggerAmount - damage);

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_CAST_OR_REMOVE: // 20
                {
                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    if (itr->SpellTrigger > 0)
                        _caster->CastSpell(target, triggered_spell_id, true);
                    else
                        _caster->RemoveAurasDueToSpell(triggered_spell_id);

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_UPDATE_DUR_TO_IGNORE_MAX: //21
                {
                    if (Aura* aura = target->GetAura(abs(itr->SpellTrigger), GetGUID()))
                    {
                        int32 _duration = int32(aura->GetDuration() + int32(triggerAmount * 1000));
                        if (bp0 && bp0 < _duration)
                            _duration = int32(bp0);

                        aura->SetDuration(_duration, true);
                        if (_duration > aura->GetMaxDuration())
                            aura->SetMaxDuration(_duration);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_DURATION: //22
                {
                    triggered_spell_id = abs(itr->SpellTrigger);
                    if (Aura* aura = target->GetAura(triggered_spell_id))
                    {
                        int32 _duration = int32(aura->GetDuration() + triggerAmount);
                        if (_duration < aura->GetMaxDuration())
                            aura->SetDuration(_duration, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_MODIFY_COOLDOWN: //23
                {
                    if (Player* player = target->ToPlayer())
                    {
                        uint32 triggered_spell_id = abs(itr->SpellTrigger);
                        if (itr->Aura && !p_ProcSpell)
                            continue;
                        if (itr->Aura && p_ProcSpell && itr->Aura != p_ProcSpell->Id)
                            continue;

                        int32 ChangeCooldown = triggerAmount * (target->GetPower(Powers::POWER_COMBO_POINT) ? target->GetPower(Powers::POWER_COMBO_POINT) : 1);

                        if (ChangeCooldown < 100)
                            ChangeCooldown *= IN_MILLISECONDS;
                        player->ModifySpellCooldown(triggered_spell_id, -ChangeCooldown);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_VENGEANCE: // 24
                {
                    if (!target || target->GetCharmerOrOwnerPlayerOrPlayerItself() || (p_ProcSpell && p_ProcSpell->IsAffectingArea()))
                        return false;

                    if (itr->Aura)
                        if (!HasAura(itr->Aura))
                            return false;

                    if (!p_DmgInfo->GetUnmitigatedAmount())
                        return false;

                    Creature* creature = target->ToCreature();

                    if (!creature)
                        return false;

                    ObjectGuid creatureGUID = creature->GetGUID();
                    int32 alldamage = p_DmgInfo->GetUnmitigatedAmount();
                    uint32 count = 1;
                    float creatureThreat = 0.0f;
                    ThreatContainer& _threatContainer = getThreatManager().getOnlineContainer();

                    if (!_threatContainer.empty())
                    {
                        HostileReference* refer = _threatContainer.getReferenceByTarget(creature);

                        if (!refer)
                            getThreatManager().resetAllAggro();
                    }

                    getThreatManager().addThreat(creature, float(alldamage), p_ProcSpell ? p_ProcSpell->GetSchoolMask() : SPELL_SCHOOL_MASK_NORMAL, p_ProcSpell);

                    std::list<HostileReference*>& _threatList = getThreatManager().getThreatList();

                    for (std::list<HostileReference*>::const_iterator _iter = _threatList.begin(); _iter != _threatList.end(); ++_iter)
                        if ((*_iter) && (*_iter)->getUnitGuid() == creatureGUID)
                        {
                            creatureThreat = (*_iter)->getThreat();
                            break;
                        }

                    for (std::list<HostileReference*>::const_iterator _iter = _threatList.begin(); _iter != _threatList.end(); ++_iter)
                    {
                        if ((*_iter)->getUnitGuid() == creatureGUID)
                            continue;

                        if ((*_iter)->getThreat() > creatureThreat)
                            count++;
                    }

                    triggered_spell_id = itr->SpellTrigger;

                    float _percent = (triggerAmount / 100.0f);
                    int32 minBp = CalculatePct(alldamage, _percent * 5.0f);

                    int32 bp = 0;

                    if (Aura* oldAura = GetAura(triggered_spell_id, GetGUID()))
                    {
                        if (AuraEffect* oldEff = oldAura->GetEffect(EFFECT_0))
                        {
                            int32 oldamount = oldEff->GetAmount() * float(oldAura->GetDuration()) / float(oldAura->GetMaxDuration());
                            bp = CalculatePct(alldamage, _percent / count);
                            bp += oldamount;
                        }
                    }

                    if (bp < minBp)
                        bp = minBp;

                    int32 maxVal = int32(GetMaxHealth() * 0.5f);

                    if (bp > maxVal)
                        bp = maxVal;

                    basepoints0 = bp;
                    basepoints1 = bp;

                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_DURATION_OR_CAST: //25
                {
                    if (Aura* aura = target->GetAura(abs(itr->SpellTrigger)))
                    {
                        int32 _duration = int32(aura->GetDuration() + aura->CalcMaxDuration(target));
                        aura->SetDuration(_duration, true);
                        if (_duration > aura->GetMaxDuration())
                            aura->SetMaxDuration(_duration);
                    }
                    else
                        _caster->CastSpell(target, itr->SpellTrigger, true);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_REMOVE_CD_RUNE: //26
                {
                    if (Player* _player = _caster->ToPlayer())
                    {
                        int32 runesRestor = 0;
                        for (int i = 0; i < MAX_RUNES; i++)
                        {
                            if (_player->GetRuneCooldown(i) == RUNE_BASE_COOLDOWN && runesRestor < 1)
                            {
                                runesRestor++;
                                _player->SetRuneCooldown(i, 0);
                            }
                        }
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_BP_SPELLID: //27
                {
                    if (!p_ProcSpell)
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);
                    if (itr->Bp0)
                        basepoints0 = p_ProcSpell->Id;
                    if (itr->Bp1)
                        basepoints1 = p_ProcSpell->Id;
                    if (itr->Bp2)
                        basepoints2 = p_ProcSpell->Id;
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_BP_SPD_AP: //28
                {
                    if (!p_ProcSpell)
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    WeaponAttackType attType = WeaponAttackType::BaseAttack;
                    if (p_ProcSpell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
                        attType = WeaponAttackType::RangedAttack;

                    int32 SPD = SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);
                    int32 SPDH = SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL);
                    int32 AP = GetTotalAttackPowerValue(attType);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    switch (int32(itr->Bp0))
                    {
                        case 1:
                            basepoints0 = SPD;
                            break;
                        case 2:
                            basepoints0 = SPDH;
                            break;
                        case 3:
                            basepoints0 = AP;
                            break;
                    }

                    switch (int32(itr->Bp1))
                    {
                        case 1:
                            basepoints1 = SPD;
                            break;
                        case 2:
                            basepoints1 = SPDH;
                            break;
                        case 3:
                            basepoints1 = AP;
                            break;
                    }

                    switch (int32(itr->Bp2))
                    {
                        case 1:
                            basepoints2 = SPD;
                            break;
                        case 2:
                            basepoints2 = SPDH;
                            break;
                        case 3:
                            basepoints2 = AP;
                            break;
                    }

                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints1, &basepoints2, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_COMBOPOINT_BP: //29
                {
                    if (!GetPower(Powers::POWER_COMBO_POINT))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    triggered_spell_id = abs(itr->SpellTrigger);
                    int32 basepoints0 = triggerAmount * GetPower(Powers::POWER_COMBO_POINT);

                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_DAM_PERC_FROM_MAX_HP: //30
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    basepoints0 = int32(float(p_DmgInfo->GetAmount() * 100.0f) / target->GetMaxHealth(_caster));
                    if (bp0)
                        basepoints0 *= bp0;

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_SUMM_DAMAGE_PROC: //31
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    int32 limited = 0;
                    int32 summ_damage = triggerAmount + p_DmgInfo->GetAmount();
                    triggered_spell_id = abs(itr->SpellTrigger);
                    if (itr->Bp0)
                        limited = int32(SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL) * itr->Bp0);
                    else if (itr->Bp1)
                        limited = int32(SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL) * itr->Bp1);
                    else if (itr->Bp2)
                    {
                        WeaponAttackType attType = WeaponAttackType::BaseAttack;
                        if (p_ProcSpell && p_ProcSpell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
                            attType = WeaponAttackType::RangedAttack;
                        limited = int32(GetTotalAttackPowerValue(attType) * itr->Bp2);
                    }

                    if (summ_damage < limited)
                    {
                        p_TriggeredByAura->SetAmount(summ_damage);
                        check = true;
                        continue;
                    }
                    else
                        p_TriggeredByAura->SetAmount(0);

                    _caster->CastSpell(target, triggered_spell_id, true);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastSpell(pet, triggered_spell_id, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADDPOWER_PCT: //32
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;

                    if (!p_DmgInfo->GetAddPower())
                    {
                        check = true;
                        continue;
                    }

                    basepoints0 = CalculatePct(p_DmgInfo->GetAddPower(), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_ABSORB_PCT: //33
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;

                    if (!p_DmgInfo->GetAbsorb())
                    {
                        check = true;
                        continue;
                    }

                    basepoints0 = CalculatePct(p_DmgInfo->GetAbsorb(), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_BLOCK_PCT: //34
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;

                    if (!p_DmgInfo->GetBlock())
                    {
                        check = true;
                        continue;
                    }

                    basepoints0 = CalculatePct(p_DmgInfo->GetBlock(), percent);

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_NEED_COMBOPOINTS: //35
                {
                    if (!p_ProcSpell || !GetPower(Powers::POWER_COMBO_POINT))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastSpell(target, triggered_spell_id, true);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_STACK: //17
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (Aura* aura = _caster->GetAura(triggered_spell_id))
                        if (aura->GetStackAmount() < (triggerAmount + bp1))
                            aura->ModStackAmount(bp0);

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_CHARGES: //18
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (Aura* aura = _caster->GetAura(triggered_spell_id))
                        if (aura->GetCharges() < (triggerAmount + bp1))
                            aura->ModCharges(bp0);

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_CHARGES_STACK: //19
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (Aura* aura = _caster->GetAura(triggered_spell_id))
                        if (aura->GetCharges() < (triggerAmount + bp1))
                        {
                            aura->ModCharges(bp0);
                            aura->ModStackAmount(bp0);
                        }

                    check = true;
                    break;
                }
                case SPELL_TRIGGER_HOLYPOWER_BONUS: //36
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    int32 percent = triggerAmount;
                    if (bp0)
                        percent += bp0;
                    if (bp1)
                        percent /= bp1;
                    if (bp2)
                        percent *= bp2;

                    basepoints0 = CalculatePct(int32(p_DmgInfo->GetAmount() + p_DmgInfo->GetAbsorb()), percent)/* / GetModForHolyPowerSpell()*/;

                    triggered_spell_id = abs(itr->SpellTrigger);
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    if (itr->Target == 6)
                    {
                        if (Guardian* pet = GetGuardianPet())
                            _caster->CastCustomSpell(pet, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true);
                    }
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_CAST_AFTER_MAX_STACK: // 37
                {
                    if (target->HasAura(itr->SpellTrigger))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = itr->Aura;

                    if (Aura* aura = _targetAura->GetAura(triggered_spell_id))
                    {
                        if ((aura->GetStackAmount() + 1) >(aura->GetSpellInfo()->StackAmount - 1))
                        {
                            RemoveAurasDueToSpell(triggered_spell_id);
                            triggered_spell_id = itr->SpellTrigger;
                        }
                    }
                    _caster->CastSpell(target, triggered_spell_id, true, castItem);
                    break;
                }
                case SPELL_TRIGGER_STACK_AMOUNT: //39
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }
                    p_TriggeredByAura->SetAmount(triggerAmount + damage);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_BP_DURATION: //40
                {
                    basepoints0 = p_TriggeredByAura->GetBase()->GetDuration();
                    _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_STACK_AND_CAST: //41
                {
                    if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                    {
                        check = true;
                        continue;
                    }
                    if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                    {
                        check = true;
                        continue;
                    }

                    triggered_spell_id = abs(itr->SpellTrigger);
                    basepoints0 = p_TriggeredByAura->GetBase()->GetStackAmount() + bp1;

                    if (basepoints0 > 0)
                        _caster->CastCustomSpell(target, triggered_spell_id, &basepoints0, &basepoints0, &basepoints0, true, castItem, p_TriggeredByAura, originalCaster);
                    p_TriggeredByAura->GetBase()->ModStackAmount(bp1);

                    if (itr->SpellTrigger < 0)
                        p_TriggeredByAura->GetBase()->Remove();
                    check = true;
                    break;
                }
                case SPELL_TRIGGER_ADD_SPELL_CHARGES: //42
                {
                    triggered_spell_id = abs(itr->SpellTrigger);

                    if (Player* _player = _caster->ToPlayer())
                        _player->ModSpellCharge(triggered_spell_id, bp0);

                    check = true;
                }
                break;
            }

            if (itr->Group != 0 && check)
                groupList.push_back(itr->Group);
        }

        if (G3D::fuzzyGt(p_Cooldown, 0.0) && IsPlayer())
            ToPlayer()->AddSpellCooldown(cooldown_spell_id, 0, p_Cooldown);
        if (check)
            return true;
    }

    return false;
}

void Unit::resetAttackTimer(WeaponAttackType type)
{
    float attackSpeedPct = m_modAttackSpeedPct[type];
    Creature* creature = ToCreature();
    if (isHunterPet() || (creature && (creature->IsDireBeast() || creature->IsHati())))
    {
        if (Unit* owner = GetOwner())
        {
            attackSpeedPct *= owner->m_modAttackSpeedPct[type];
        }
    }

    if (m_attackTimer[type] < 0 && int32(GetAttackTime(type) * attackSpeedPct) > m_attackTimer[type] * -1)
        m_attackTimer[type] = uint32(GetAttackTime(type) * attackSpeedPct) + m_attackTimer[type];
    else
        m_attackTimer[type] = uint32(GetAttackTime(type) * attackSpeedPct);
}

bool Unit::IsWithinCombatRange(const Unit* obj, float dist2compare) const
{
    if (!obj || !IsInMap(obj) || !InSamePhase(obj))
        return false;

    float dx = GetPositionX() - obj->GetPositionX();
    float dy = GetPositionY() - obj->GetPositionY();
    float dz = GetPositionZH() - obj->GetPositionZH();
    float distsq = dx * dx + dy * dy + dz * dz;

    float sizefactor = GetCombatReach() + obj->GetCombatReach();
    float maxdist = dist2compare + sizefactor;

    return distsq < maxdist * maxdist;
}

inline float Unit::CalcMeleeRange(const Unit* p_Obj) const
{
    float l_MaxDist = GetCombatReach() + p_Obj->GetCombatReach() + 4.0f / 3.0f;

    /// HACK: Find the better way
    /// Calc for druids only now, but there are 5 spells
    if (getClass() == Classes::CLASS_DRUID)
    {
        ///< Astral Influence
        if (AuraEffect const* l_Effect = GetAuraEffect(197524, SpellEffIndex::EFFECT_1))
            l_MaxDist += l_Effect->GetAmount();
    }

    /// HACK: Find the better way
    /// Calc for Rogue
    if (getClass() == Classes::CLASS_ROGUE)
    {
        ///< Acrobatie
        if (AuraEffect const* l_Effect = GetAuraEffect(196924, SpellEffIndex::EFFECT_4))
            l_MaxDist += l_Effect->GetAmount();
    }

    /// - Handle Melee Leeway Mechanic mod
    Player* l_VictimPlayer = p_Obj->GetCharmerOrOwnerPlayerOrPlayerItself();
    if (!p_Obj->IsPlayer() || !l_VictimPlayer)
        return l_MaxDist;

    if (p_Obj->IsMoving() && l_VictimPlayer->IsMoving())
        l_MaxDist += 2.5f;

    return l_MaxDist;
}

bool Unit::IsWithinMeleeRange(const Unit* obj) const
{
    if (!obj || !IsInMap(obj) || !InSamePhase(obj))
        return false;

    float dx = GetPositionX() - obj->GetPositionX();
    float dy = GetPositionY() - obj->GetPositionY();
    float dz = GetPositionZH() - obj->GetPositionZH();
    float distsq = dx*dx + dy*dy + dz*dz;

    float maxdist = CalcMeleeRange(obj);
    return distsq <= maxdist * maxdist;
}

bool Unit::IsWithinBoundaryRadius(const Unit* p_obj) const
{
    if (!p_obj || !IsInMap(p_obj) || !InSamePhase(p_obj))
        return false;

    float objBoundaryRadius = std::max(p_obj->GetFloatValue(UNIT_FIELD_BOUNDING_RADIUS), MIN_MELEE_REACH);

    return IsInDist(p_obj, objBoundaryRadius);
}

void Unit::GetRandomContactPoint(const Unit* obj, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const
{
    float combat_reach = GetCombatReach();
    if (combat_reach < 0.1f) // sometimes bugged for players
        combat_reach = DEFAULT_COMBAT_REACH;

    uint32 attacker_number = getAttackers().size();
    if (attacker_number > 0)
        --attacker_number;
    GetNearPoint(obj, x, y, z, obj->GetCombatReach(), distance2dMin+(distance2dMax-distance2dMin) * (float)rand_norm()
        , GetAngle(obj) + (attacker_number ? (static_cast<float>(M_PI/2) - static_cast<float>(M_PI) * (float)rand_norm()) * float(attacker_number) / combat_reach * 0.3f : 0));
}

void Unit::UpdateInterruptMask()
{
    m_interruptMask = 0;
    for (AuraApplicationList::const_iterator i = m_interruptableAuras.begin(); i != m_interruptableAuras.end(); ++i)
        m_interruptMask |= (*i)->GetBase()->GetSpellInfo()->AuraInterruptFlags;

    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
        if (spell->getState() == SPELL_STATE_CASTING)
            m_interruptMask |= spell->m_spellInfo->ChannelInterruptFlags;
}

bool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const
{
    if (!HasAuraType(auraType))
        return false;
    AuraEffectList const& auras = GetAuraEffectsByType(auraType);
    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
        if (SpellInfo const* iterSpellProto = (*itr)->GetSpellInfo())
            if (iterSpellProto->SpellFamilyName == familyName && iterSpellProto->SpellFamilyFlags[0] & familyFlags)
                return true;
    return false;
}

bool Unit::HasBreakableByDamageAuraType(AuraType p_Type, uint32 p_ExcludeAura) const
{
    AuraEffectList const& l_Auras = GetAuraEffectsByType(p_Type);
    for (AuraEffectList::const_iterator l_Iter = l_Auras.begin(); l_Iter != l_Auras.end(); ++l_Iter)
    {
        if ((!p_ExcludeAura || p_ExcludeAura != (*l_Iter)->GetSpellInfo()->Id) && ///< Avoid self interrupt of channeled Crowd Control spells like Seduction
            ((*l_Iter)->GetSpellInfo()->Attributes & SPELL_ATTR0_BREAKABLE_BY_DAMAGE || (*l_Iter)->GetSpellInfo()->AuraInterruptFlags & (AURA_INTERRUPT_FLAG_TAKE_DAMAGE_AMOUNT | AURA_INTERRUPT_FLAG_TAKE_DAMAGE)))
            return true;
    }
    return false;
}

bool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) const
{
    uint32 excludeAura = 0;
    if (Spell* currentChanneledSpell = excludeCasterChannel ? excludeCasterChannel->GetCurrentSpell(CURRENT_CHANNELED_SPELL) : NULL)
        excludeAura = currentChanneledSpell->GetSpellInfo()->Id; //Avoid self interrupt of channeled Crowd Control spells like Seduction

    return (   HasBreakableByDamageAuraType(SPELL_AURA_MOD_CONFUSE, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_FEAR, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_FEAR_2, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_STUN, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_ROOT, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_ROOT_2, excludeAura)
            || HasBreakableByDamageAuraType(SPELL_AURA_TRANSFORM, excludeAura));
}

bool Unit::HasBreakOnDamageCrowdControlAura() const
{
    AuraApplicationMap appliedAuras = GetAppliedAuras();
    for (AuraApplicationMap::iterator iter = appliedAuras.begin(); iter != appliedAuras.end(); ++iter)
    {
        Aura const* l_Aura = iter->second->GetBase();

        switch (l_Aura->GetId())
        {
            case 217832: ///< Imprison
            case 207167: ///< Blinding Sleet
            case 236026: ///< Enraged Maim
            case 236748: ///< Intimidating Roar
            case 19386:  ///< Wyvern Sting
            case 212638: ///< Tracker's Net
            case 198898: ///< Song of Chi-Ji
            case 2094:   ///< Blind
            case 1776:   ///< Gouge
            case 31661:  ///< Dragon's Breath
            case 118:    ///< Polymorph
            case 6358:   ///< Seduce
            case 186387: ///< Bursting Shot
            case 213691: ///< Scatter Shot
            case 115078: ///< Paralysis
            case 115750: ///< Blinding Light
            case 29511:  ///< Repentance
            case 20066:  ///< Repentance
            case 187650: ///< Freezing Trap
            case 196555: ///< Netherwalk
            case 199448: ///< Blessing of Sacrifice (PvP Talent)
            case 6940:   ///< Blessing of Sacrifice
                return true;
            default:
                break;
        }
    }
    return false;
}

bool Unit::HasAurasPreventCasting() const
{
    uint32 l_UnitFlags = GetUInt32Value(UNIT_FIELD_FLAGS);

    if ((l_UnitFlags & UNIT_FLAG_SILENCED) || (l_UnitFlags & UNIT_FLAG_PACIFIED) || (l_UnitFlags & UNIT_FLAG_STUNNED) ||
        (l_UnitFlags & UNIT_FLAG_CONFUSED))
        return true;

    return false;
}

void Unit::DealDamageMods(DamageInfo& p_DamageInfo)
{
    Unit* l_Victim = p_DamageInfo.GetTarget();
    if (!l_Victim || !l_Victim->isAlive() || l_Victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (l_Victim->GetTypeId() == TYPEID_UNIT && l_Victim->ToCreature()->IsInEvadeMode()))
        p_DamageInfo.Absorb(p_DamageInfo.GetAmount());
}

uint32 Unit::DealDamage(Unit* p_Victim, uint32 p_Damage, CleanDamage const* p_CleanDamage, DamageEffectType p_DamageType, SpellSchoolMask p_DamageSchoolMask, SpellInfo const* p_SpellProto, bool p_DurabilityLoss, uint32 p_AbsorbDamage /*=0*/)
{
    if (p_Victim->isDead() || p_Victim->GetHealth(this) == 0)
    {
        p_Damage = 0;
        return 0; ///< Prevent double death
    }

    // need for operations with Player class
    Player* plr = p_Victim->ToPlayer();

    if (plr && !IsPlayer())
        plr->m_LastDamageActionTime[GetGUID()] = time(nullptr);

    if (IsPlayer() && !plr)
        ToPlayer()->m_LastDamageActionTime[p_Victim->GetGUID()] = time(nullptr);

    if (p_Damage > 4000000 && p_Victim && p_Victim->IsPlayer() && IsPlayer() && p_SpellProto && this->GetGUID() != p_Victim->GetGUID() && p_SpellProto->SpellFamilyName != SPELLFAMILY_GENERIC) ///< Log huge damage in PVP, when it's not self-done
    {
        /// Eye of Azshara - Lightning Strike
        if (p_SpellProto->Id != 192794)
        {
            std::string l_AuraListAttacker = "";
            for (auto m_Aura : m_appliedAuras)
            {
                l_AuraListAttacker += std::to_string(m_Aura.first) + ",";
            }
            std::string l_AuraListVictim = "";
            for (auto m_Aura : p_Victim->m_appliedAuras)
            {
                l_AuraListVictim += std::to_string(m_Aura.first) + ",";
            }
            if (GetMap() && (GetMap()->IsRaid() || GetMap()->IsDungeon()))
                sLog->outExtChat("#log-damage-703", "", false, "-----------------\nDamage: %d, from %s to %s , Spell: %d\nAttacker Auras: %s\nVictim Auras: %s", p_Damage, GetName(), p_Victim->GetName(), p_SpellProto->Id, l_AuraListAttacker.c_str(), l_AuraListVictim.c_str());
        }
    }

    /// Update to Leigon 7.1.5 build 23420
    /// Stagger handler
    if (p_Victim && p_Victim->ToPlayer() && p_Victim->getClass() == CLASS_MONK && p_DamageType != DamageEffectType::SELF_DAMAGE)
    {
        if (!p_SpellProto || (p_SpellProto->Id != LIGHT_STAGGER && p_SpellProto->Id != MODERATE_STAGGER && p_SpellProto->Id != HEAVY_STAGGER))
            p_Damage = p_Victim->CalcStaggerDamage(p_Victim->ToPlayer(), p_Damage, p_DamageSchoolMask, p_SpellProto);
    }

    // Custom MoP Script - Cloak of Shadows
    if (p_Victim && p_Victim->getClass() == CLASS_ROGUE && p_DamageType == SPELL_DIRECT_DAMAGE && HasAura(31224) && (!p_SpellProto || !p_SpellProto->HasEffect(SPELL_EFFECT_INSTAKILL)))
        p_Damage = 0;

    /// Custom MoP Script - Subterfuge , should be called from normal hit
    if (p_Victim && HasAura(108208) && HasAura(115191) && !HasAura(115192) && (p_DamageType == DIRECT_DAMAGE || HasAura(121471)))
        CastSpell(this, 115192, true);

    /// Custom MoP Script - Focused Will
    if (IsPlayer() && p_Victim->getClass() == CLASS_PRIEST)
    {
        if (plr->GetActiveSpecializationID() == SPEC_PRIEST_DISCIPLINE)
        {
            if (p_Victim->CountPctFromMaxHealth(15) < p_Damage) ///< last update 7.0.3 (Tue Jul 19 2016) Build 21375
                p_Victim->CastSpell(p_Victim, 45242, true);
        }
    }

    /// @todo update me ?
    /// Custom MoP Script
    if (IsPlayer() && getClass() == CLASS_MONK && ToPlayer()->GetActiveSpecializationID() == SPEC_MONK_BREWMASTER && HasAura(115315))
    {
        if (p_Damage > 0)
        {
            if (Aura* l_BlackOxStatue = GetAura(115315))
                l_BlackOxStatue->SetScriptData(0, p_Damage);
        }
    }

    /// Mindbender
    if (GetEntry() == 62982 || GetEntry() == 67236)
    {
        /// Caster receives 0.75% mana when the Mindbender attacksabsorb
        if (Unit* l_Owner = GetOwner())
            l_Owner->ModifyPower(POWER_MANA, CalculatePct(l_Owner->GetPower(POWER_MANA), 0.75f));
    }

    /// Temporal Shield - 115610
    if (p_Victim->IsPlayer() && p_Damage != 0 && p_Victim->HasAura(115610))
    {
        int32 l_Bp = p_Damage / 3;

        /// Temporal Ripples : Add remaining amount to the basepoints
        l_Bp += p_Victim->GetRemainingPeriodicAmount(p_Victim->GetGUID(), 115611, SPELL_AURA_PERIODIC_HEAL, 0);

        p_Victim->CastCustomSpell(p_Victim, 115611, &l_Bp, NULL, NULL, true);
    }

    /// While Aspect of the Wild is active, Hati and your primary pet also trigger a Thunderslash with each auto attack
    if (ToCreature() && p_DamageType == DIRECT_DAMAGE && !p_SpellProto)
    {
        Creature* l_Creature    = ToCreature();
        Unit* l_Owner           = l_Creature ? l_Creature->GetOwner() : nullptr;

        if (l_Creature->GetEntry() == 100324 && l_Owner && l_Owner->ToPlayer()->HasAura(193530) && l_Owner->ToPlayer()->HasAura(238087))
            CastSpell(this, 243234, true);

        if (Pet* l_Pet = l_Creature->ToPet())
        {
            if ((l_Owner = l_Pet->GetOwner()))
            {
                if (Player* l_PlrOwner = l_Owner->ToPlayer())
                {
                    if (l_PlrOwner->HasAura(238087) && l_PlrOwner->HasAura(193530))
                        CastSpell(this, 243234, true);
                }
            }
        }
    }

    /// Health leech handling (Damage)
    if (GetTypeId() == TypeID::TYPEID_PLAYER && p_Damage > 0 && (!p_SpellProto || p_SpellProto->Id != SPELL_PLAYER_LIFE_STEAL))
    {
        float l_Percentage = GetFloatValue(EPlayerFields::PLAYER_FIELD_LIFESTEAL);

        if (ToPlayer() && ToPlayer()->GetActiveSpecializationID() == SPEC_DEMON_HUNTER_HAVOC && HasAura(162264)) ///< Metamorphosis
        {
            int32 l_Amount = 0;
            if (p_Victim->IsPlayer())
                l_Amount -= CalculatePct(l_Amount, 60); ///< Metamorphosis leech reduced by 60% in PvP
            l_Percentage += l_Amount;
        }

        int32 l_Heal = CalculatePct(p_Damage, (int32)l_Percentage);

        if (p_SpellProto)
            switch (p_SpellProto->Id) ///< Leech do not work on all damages
            {
                case 222168: ///< Horrific Slam
                case 191259: ///< Mark of the Hidden Satyr
                case 191380: ///< Mark of the Distant Army
                    l_Heal = 0;
                default:
                    break;
            }

        CastCustomSpell(this, SPELL_PLAYER_LIFE_STEAL, &l_Heal, nullptr, nullptr, true);
    }

    if (p_Victim->IsAIEnabled)
    {
        p_Victim->GetAI()->DamageTaken(this, p_Damage, p_SpellProto);

        if (InstanceScript* l_Instance = GetInstanceScript())
        {
            if (l_Instance->CheckDamageManager())
                l_Instance->UpdateDamageManager(p_Victim->GetGUID(), p_Damage);
        }
    }

    if (IsAIEnabled)
        GetAI()->DamageDealt(p_Victim, p_Damage, p_DamageType, p_SpellProto);

    if (p_Victim->GetGUID() != GetGUID())
        SetLastDamagedGuid(p_Victim->GetGUID());

    if (GetTypeId() == TypeID::TYPEID_PLAYER
        && p_Victim->GetTypeId() == TypeID::TYPEID_UNIT
        && p_Victim->ToCreature()->GetFlagsExtra() & CreatureFlagsExtra::CREATURE_FLAG_EXTRA_LOG_GROUP_DMG)
    {
        CreatureDamageLog l_Log;
        l_Log.AttackerGuid = GetGUIDLow();
        l_Log.Damage       = p_Damage;
        l_Log.Spell        = p_SpellProto ? p_SpellProto->Id : 0;
        l_Log.Time         = time(nullptr);

        p_Victim->ToCreature()->AddDamageLog(l_Log);
    }

    if (Player* l_Player = p_Victim->ToPlayer())
    {
        if (l_Player->GetCommandStatus(CHEAT_GOD))
            return p_Damage;

        /// Signal to pets that their owner was attacked
        Pet* l_Pet = l_Player->GetPet();

        if (l_Pet && l_Pet->isAlive())
            l_Pet->AI()->OwnerDamagedBy(this);

        sScriptMgr->OnPlayerTakeDamage(l_Player, this, p_DamageType, p_Damage, p_DamageSchoolMask, p_CleanDamage);
    }

    if (Player* l_Player = ToPlayer())
        sScriptMgr->OnPlayerDealDamage(l_Player, p_Victim, p_DamageType, p_Damage, p_DamageSchoolMask, p_CleanDamage);

    if (p_DamageType != NODAMAGE)
    {
        // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
        if (p_SpellProto)
        {
            if (!(p_SpellProto->AttributesEx4 & SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS))
            {
                // Repentance shared damage removal
                if (p_CleanDamage && p_CleanDamage->mitigated_damage)
                    p_Victim->RemoveAurasDueToSpell(20066);

                p_Victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, p_SpellProto->Id);
            }
        }
        else
        {
            p_Victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, 0);
            p_Victim->RemoveAura(198158); ///< Hackfix to remove Mass Invis, as the spellinfo_override table can't have both interrupt flags removed and then others added (needed to remove some to get it to work, so can't add the 0x2 flag)
        }

        // We're going to call functions which can modify content of the list during iteration over it's elements
        // Let's copy the list so we can prevent iterator invalidation
        AuraEffectList l_VCopyDamageCopy(p_Victim->GetAuraEffectsByType(SPELL_AURA_SHARE_DAMAGE_PCT));
        // copy damage to casters of this aura
        for (AuraEffectList::iterator l_Itr = l_VCopyDamageCopy.begin(); l_Itr != l_VCopyDamageCopy.end(); ++l_Itr)
        {
            // Check if aura was removed during iteration - we don't need to work on such auras
            if (!((*l_Itr)->GetBase()->IsAppliedOnTarget(p_Victim->GetGUID())))
                continue;
            // check damage school mask
            if (((*l_Itr)->GetMiscValue() & p_DamageSchoolMask) == 0)
                continue;

            Unit* l_ShareDamageTarget = (*l_Itr)->GetCaster();
            if (!l_ShareDamageTarget)
                continue;
            SpellInfo const* l_Spell = (*l_Itr)->GetSpellInfo();

            uint32 l_Share = CalculatePct(p_Damage, (*l_Itr)->GetAmount());

            // Voodoo Doll
            if (l_Spell->Id == 116000 && p_Victim->IsPlayer())
            {
                Player* l_Player = p_Victim->ToPlayer();
                std::list<Unit*> l_GroupList;

                l_Player->GetPartyMembers(l_GroupList);
                for (auto l_SecondItr : l_GroupList)
                {
                    // Voodoo visual
                    if (!l_SecondItr->HasAura(122151))
                        continue;

                    if (l_SecondItr->GetGUID() == l_Player->GetGUID())
                        continue;

                    DamageInfo l_DamageInfo(l_ShareDamageTarget, l_SecondItr, l_Share, l_Spell, DIRECT_DAMAGE, WeaponAttackType::BaseAttack);
                    l_ShareDamageTarget->DealDamageMods(l_DamageInfo);
                    l_ShareDamageTarget->DealDamage(l_DamageInfo.GetTarget(), l_DamageInfo.GetAmount(), NULL, l_DamageInfo.GetDamageType(), l_DamageInfo.GetSchoolMask(), l_DamageInfo.GetSpellInfo(), false, l_DamageInfo.GetAbsorb());
                }
            }
            else
            {
                DamageInfo l_DamageInfo(this, l_ShareDamageTarget, l_Share, l_Spell, NODAMAGE, WeaponAttackType::BaseAttack);
                // TODO: check packets if damage is done by victim, or by attacker of victim
                DealDamageMods(l_DamageInfo);
                DealDamage(l_DamageInfo.GetTarget(), l_DamageInfo.GetAmount(), NULL, l_DamageInfo.GetDamageType(), l_DamageInfo.GetSchoolMask(), l_DamageInfo.GetSpellInfo(), false, l_DamageInfo.GetAbsorb());
            }
        }
    }

    /// Rage from Damage made (only from direct weapon damage)
    if (p_CleanDamage && p_DamageType == DIRECT_DAMAGE && this != p_Victim && getPowerType() == POWER_RAGE && IsPlayer())
    {
        Player* l_Player = ToPlayer();

        /// Only Druids in Bear form and warrior
        if (l_Player->GetShapeshiftForm() == FORM_BEAR_FORM || l_Player->getClass() == CLASS_WARRIOR)
        {
            float l_WeaponSpeed = GetAttackTime(p_CleanDamage->attackType) / 1000.0f;

            float l_RageGain = l_WeaponSpeed * 1.75f;

            if (l_Player->GetShapeshiftForm() == FORM_BEAR_FORM)
            {
                ///< http://us.battle.net/forums/en/wow/topic/20743504316?page=13#248
                l_RageGain = 7.875f;
            }
            else
            {
                float l_RageMultiplier = 0.0f;

                if (l_Player->GetActiveSpecializationID() == SPEC_WARRIOR_ARMS)
                    l_RageMultiplier = (p_CleanDamage->hitOutCome == MELEE_HIT_CRIT ? 5.6f : 4.3f); /// 7.3.2: 27 or 35 rage if crit
                else if (l_Player->GetActiveSpecializationID() == SPEC_WARRIOR_FURY)
                    l_RageMultiplier = 0.8f;

                if (p_CleanDamage->attackType == WeaponAttackType::OffAttack)
                    l_RageGain *= 0.5f;
                if (!p_SpellProto && HasAura(202296)) ///< Endless Rage - Your auto attack generates 30 additional Rage
                {
                    if (AuraEffect* l_AuraEffect = GetAuraEffect(202296, EFFECT_0))
                        AddPct(l_RageGain, l_AuraEffect->GetAmount());
                }
                l_RageGain *= l_RageMultiplier;
            }
            /*AddPct(l_RageGain, GetTotalAuraModifier(SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT));*/
            RewardRage(l_RageGain);
        }
    }

    if (p_DamageType != NODAMAGE && (p_Damage || (p_CleanDamage && p_CleanDamage->absorbed_damage)))
    {
        if (p_Victim != this && p_Victim->IsPlayer()) // does not support creature push_back
        {
            if (p_DamageType != DOT || (p_SpellProto && p_SpellProto->IsChanneled()))
            {
                uint32 const l_SpellTypesToInterrupt[2] = { CurrentSpellTypes::CURRENT_CHANNELED_SPELL, CurrentSpellTypes::CURRENT_GENERIC_SPELL };

                for (int l_I = 0; l_I < 2; l_I++)
                {
                    if (Spell* spell = p_Victim->m_currentSpells[l_SpellTypesToInterrupt[l_I]])
                    {
                        if (spell->getState() == SPELL_STATE_PREPARING)
                        {
                            uint32 interruptFlags = spell->m_spellInfo->InterruptFlags;
                            if (interruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)
                                p_Victim->InterruptNonMeleeSpells(false);
                        }
                    }
                }
            }
        }
    }

    uint64 l_Health = p_Victim->GetHealth(this);

    // duel ends when player has 1 or less hp
    bool l_DuelHasEnded = false;
    bool l_DuelWasMounted = false;
    if (p_Victim->IsPlayer() && p_Victim->ToPlayer()->m_Duel && p_Damage >= (l_Health-1))
    {
        // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
        if (p_Victim->ToPlayer()->m_Duel->opponent == this || p_Victim->ToPlayer()->m_Duel->opponent->GetGUID() == GetOwnerGUID() || p_Victim == this)
            p_Damage = l_Health - 1;

        l_DuelHasEnded = true;
    }
    else if (p_Victim->IsVehicle() && p_Damage >= (l_Health-1) && p_Victim->GetCharmer() && p_Victim->GetCharmer()->IsPlayer())
    {
        Player* l_VictimRider = p_Victim->GetCharmer()->ToPlayer();

        if (l_VictimRider && l_VictimRider->m_Duel && l_VictimRider->m_Duel->isMounted)
        {
            // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
            if (l_VictimRider->m_Duel->opponent == this || l_VictimRider->m_Duel->opponent->GetGUID() == GetCharmerGUID())
                p_Damage = l_Health - 1;

            l_DuelWasMounted = true;
            l_DuelHasEnded = true;
        }
    }

    if (IsPlayer() && this != p_Victim)
    {
        Player* p_Killer = ToPlayer();

        // in bg, count dmg if victim is also a player
        if (p_Victim->IsPlayer())
            if (Battleground* l_Bg = p_Killer->GetBattleground())
                l_Bg->UpdatePlayerScore(p_Killer, NULL, SCORE_DAMAGE_DONE, p_Damage + p_AbsorbDamage);

        p_Killer->UpdateCriteria(CRITERIA_TYPE_DAMAGE_DONE, p_Damage, 0, 0, p_Victim);

        if (p_Killer->m_HighestHitDealt < p_Damage)
            p_Killer->m_HighestHitDealt = p_Damage;
    }
    else if (GetTypeId() == TYPEID_UNIT && this != p_Victim && IsPetGuardianStuff())
    {
        if (GetOwner() && GetOwner()->IsPlayer())
        {
            Player* l_KillerOwner = GetOwner()->ToPlayer();

            if (p_Victim->IsPlayer())
                if (Battleground* l_Bg = l_KillerOwner->GetBattleground())
                    l_Bg->UpdatePlayerScore(l_KillerOwner, NULL, SCORE_DAMAGE_DONE, p_Damage + p_AbsorbDamage);
        }
    }

    if (Player* l_Player = p_Victim->ToPlayer())
    {
        if (l_Player->m_HighestHitReceived < p_Damage)
            l_Player->m_HighestHitReceived = p_Damage;
    }

    if (p_Victim->GetEntry() == 5925)
        return p_Damage;

    /// Maybe it's better to create a flag.
    bool l_IsKillable = p_Victim->ToCreature() ? p_Victim->ToCreature()->IsKillable() : true;
    bool l_NeedToKill = l_Health <= p_Damage;

    if (l_NeedToKill && l_IsKillable)
    {
        if (p_Victim->IsPlayer() && p_Victim != this)
        {
            p_Victim->ToPlayer()->m_TotalDamageReceived += l_Health;
        }

        Kill(p_Victim, p_DurabilityLoss, p_SpellProto ? p_SpellProto : NULL);
    }
    else
    {
        if (p_Victim->IsPlayer())
            p_Victim->ToPlayer()->m_TotalDamageReceived += p_Damage;

        p_Victim->ModifyHealth(l_IsKillable ? -(int32)p_Damage : (l_NeedToKill ? l_Health - 1 : -(int32)p_Damage), this);

        if (p_DamageType == DIRECT_DAMAGE || p_DamageType == SPELL_DIRECT_DAMAGE)
            p_Victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE, p_SpellProto ? p_SpellProto->Id : 0);

        if (p_Victim->GetTypeId() != TYPEID_PLAYER)
            p_Victim->AddThreat(this, float(p_Damage), p_DamageSchoolMask, p_SpellProto);
        else                                                // victim is a player
        {
            // random durability for items (HIT TAKEN)
            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))
            {
                EquipmentSlots l_Slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));
                p_Victim->ToPlayer()->DurabilityPointLossForEquipSlot(l_Slot);
            }
        }

        /// Rage/Pain from damage received
        if (this != p_Victim && p_Victim->ToPlayer() && (p_Victim->ToPlayer()->GetActiveSpecializationID() == SpecIndex::SPEC_WARRIOR_PROTECTION || p_Victim->ToPlayer()->GetActiveSpecializationID() == SpecIndex::SPEC_DEMON_HUNTER_VENGEANCE))
        {
            Player* l_PlayerVictim = p_Victim->ToPlayer();

            /// From Simulation Craft -> rage_gain_from_damage_taken = 50.0 * s -> result_amount / expected_max_health;
            /// Formula -> http://us.battle.net/forums/en/wow/topic/20747754822

            RandomPropertiesPointsEntry const* l_RandProperty = sRandomPropertiesPointsStore.LookupEntry(l_PlayerVictim->GetAverageItemLevelEquipped());
            if (l_RandProperty != nullptr)
            {
                float l_Expected_max_health = l_RandProperty->EpicPropertiesPoints[0] * (l_PlayerVictim->GetActiveSpecializationID() == SpecIndex::SPEC_WARRIOR_PROTECTION ? 8.484262f : 8.318556f);
                l_Expected_max_health += GetCreateStat(STAT_STAMINA);
                l_Expected_max_health *= GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT);

                HpPerStaTableEntry const* l_HpBase = g_HpPerStaTable.LookupEntry(getLevel());
                float l_Ratio = l_HpBase ? l_HpBase->m_HP : 10.0f;
                l_Expected_max_health *= l_Ratio;

                float l_PowerGain = 50.0f * (p_Damage + (p_CleanDamage ? p_CleanDamage->absorbed_damage : 0)) / l_Expected_max_health;

                if (l_PlayerVictim->GetActiveSpecializationID() == SpecIndex::SPEC_WARRIOR_PROTECTION)
                    p_Victim->RewardRage(l_PowerGain);
                else
                    p_Victim->ModifyPower(POWER_PAIN, uint32(l_PowerGain * GetPowerCoeff(POWER_PAIN)));
            }
        }

        if (IsPlayer())
        {
            // random durability for items (HIT DONE)
            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))
            {
                EquipmentSlots slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));
                ToPlayer()->DurabilityPointLossForEquipSlot(slot);
            }
        }

        if (p_DamageType != NODAMAGE && p_Damage && (!p_SpellProto || (p_SpellProto && !p_SpellProto->IsAffectingArea())))
        {
            if (p_Victim != this && p_Victim->IsPlayer()) // does not support creature push_back
            {
                if (p_DamageType != DOT)
                {
                    uint32 const l_SpellTypesToInterrupt[2] = { CurrentSpellTypes::CURRENT_CHANNELED_SPELL, CurrentSpellTypes::CURRENT_GENERIC_SPELL };

                    for (int l_Itr = 0; l_Itr < 2; l_Itr++)
                    {
                        if (Spell* l_Spell = p_Victim->m_currentSpells[l_SpellTypesToInterrupt[l_Itr]])
                        {
                            if (l_Spell->getState() == SPELL_STATE_PREPARING)
                            {
                                uint32 l_InterruptFlags = l_Spell->m_spellInfo->InterruptFlags;
                                if (l_InterruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)
                                    p_Victim->InterruptNonMeleeSpells(false);
                                else if (l_InterruptFlags & SPELL_INTERRUPT_FLAG_PUSH_BACK)
                                    l_Spell->Delayed();
                            }
                        }
                    }
                }
            }
        }

        // last damage from duel opponent
        if (l_DuelHasEnded)
        {
            Player* l_He = l_DuelWasMounted ? p_Victim->GetCharmer()->ToPlayer() : p_Victim->ToPlayer();

            ASSERT(l_He && l_He->m_Duel);

            if (l_DuelWasMounted) // In this case victim==mount
                p_Victim->SetHealth(1);
            else
                l_He->SetHealth(1);

            l_He->m_Duel->opponent->CombatStopWithPets(true);
            l_He->CombatStopWithPets(true);

            l_He->CastSpell(l_He, 7267, true);                  // beg
            l_He->DuelComplete(DUEL_WON);
        }
    }

    if (getClass() == CLASS_WARLOCK)
    {
        DamageDone* l_DamageDone = nullptr;

        if (p_SpellProto)
            l_DamageDone = new DamageDone(p_Damage, getMSTime(), p_SpellProto->Id);
        else
            l_DamageDone = new DamageDone(p_Damage, getMSTime(), 0);

        SetDamageDone(l_DamageDone);
    }

    return p_Damage;
}

/// Last Update 7.1.5 - build 23420
uint32 Unit::CalcStaggerDamage(Player* p_Victim, uint32 p_Damage, SpellSchoolMask p_DamageSchoolMask, SpellInfo const* p_SpellProto, bool p_BypassCalc /*= false*/)
{
    if (p_Victim->GetActiveSpecializationID() != SPEC_MONK_BREWMASTER)
        return p_Damage;

    if (p_SpellProto && (p_SpellProto->HasEffect(SPELL_EFFECT_INSTAKILL) || p_SpellProto->Id == 230214))
        return p_Damage;

    if (p_Damage <= 0)
        return p_Damage;

    uint32 l_Stagger = 40;

    /// IronSkin Brew increase stagger amount by 40%
    if (AuraEffect* l_AuraEffect = p_Victim->GetAuraEffect(215479, EFFECT_0))
        l_Stagger += l_AuraEffect->GetAmount();

    /// Fortifying Brew increase stagger amount by 20%
    if (p_Victim->HasAura(120954))
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(115203);
        uint32 l_FortifyingBrewStagger = l_SpellInfo->Effects[EFFECT_0].BasePoints;
        l_Stagger += l_FortifyingBrewStagger;
    }

    /// High Tolerange increase stagger amount by 10%
    if (AuraEffect* l_AuraEffect = p_Victim->GetAuraEffect(196737, EFFECT_0))
        l_Stagger += l_AuraEffect->GetAmount();

    /// Staggering increase stagger amount by 6%
    if (p_Victim->HasAura(138233))
        l_Stagger += 6;                             ///< last update 5.4.0 17153

    /// If it's not a physical attack, such that 50% of your normal stagger amount works against magic damage.
    if (!(!p_SpellProto || ((p_SpellProto->DmgClass == SPELL_DAMAGE_CLASS_RANGED || p_SpellProto->DmgClass == SPELL_DAMAGE_CLASS_MELEE) && p_DamageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)))
    {
        float l_MagicEffectiveness = 0.5f;

        if (Aura const* l_StaggerAura = GetAura(115069))
            l_MagicEffectiveness = static_cast<float>(l_StaggerAura->GetSpellInfo()->Effects[SpellEffIndex::EFFECT_0].BasePoints) / 100.f;

        if (AuraEffect const* l_MysticVitalityEffect = GetAuraEffect(237076, SpellEffIndex::EFFECT_0)) /// ID - 237076 Mystic Vitality, stagger 40% more effective against magic damage
            AddPct(l_MagicEffectiveness, l_MysticVitalityEffect->GetAmount());

        l_Stagger *= l_MagicEffectiveness;
    }

    /// Stagger can't be > 100%, but we check after seing what type of damage we take, so against magic damage you can be > 50% (since it's 50% effectiveness against magic damage)
    if (l_Stagger > 100)
        l_Stagger = 100;

    int32 l_StaggeredDamage = CalculatePct(p_Damage, l_Stagger);

    if (p_BypassCalc || l_Stagger == 100)
        l_StaggeredDamage = p_Damage;

    uint32 l_SpellId = 0;
    uint32 l_TicksNumber = p_Victim->HasAura(208881) ? 26 : 20; ///< Jewel of the Lost Abbey - 208881

    AuraEffect* l_AurEff = p_Victim->GetAuraEffect(LIGHT_STAGGER, 0, p_Victim->GetGUID());
    if (!l_AurEff)
        l_AurEff = p_Victim->GetAuraEffect(MODERATE_STAGGER, 0, p_Victim->GetGUID());
    if (!l_AurEff)
        l_AurEff = p_Victim->GetAuraEffect(HEAVY_STAGGER, 0, p_Victim->GetGUID());

    /// Add remaining ticks to damage done
    if (l_AurEff)
    {
        if (Aura* l_Aura = l_AurEff->GetBase())
            l_StaggeredDamage += l_AurEff->GetAmount() * ((l_Aura->GetDuration() / l_AurEff->GetAmplitude())); ///< m_ticknumber can't be used here cuz stagger is recasted every 0.5sec, so m_ticknumber = 0 at all time
    }
    if (int64(l_StaggeredDamage) < p_Victim->CountPctFromMaxHealth(30))
        l_SpellId = LIGHT_STAGGER;
    else if (int64(l_StaggeredDamage) < p_Victim->CountPctFromMaxHealth(60))
        l_SpellId = MODERATE_STAGGER;
    else
        l_SpellId = HEAVY_STAGGER;

    int32 l_StaggeredTick = l_StaggeredDamage / l_TicksNumber;

    p_Victim->RemoveAura(LIGHT_STAGGER);
    p_Victim->RemoveAura(MODERATE_STAGGER);
    p_Victim->RemoveAura(HEAVY_STAGGER);
    p_Victim->CastCustomSpell(p_Victim, l_SpellId, &l_StaggeredTick, &l_StaggeredDamage, nullptr, true);
    p_Victim->CastCustomSpell(p_Victim, 124255, nullptr, &l_StaggeredDamage, nullptr, true); ///< Update Stagger bar on damage taken

    ///< Jewel of the Lost Abbey - 208881
    if (Aura* l_Aura = p_Victim->GetAura(l_SpellId))
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(208881);
        if (!l_SpellInfo)
            return p_Damage *= CalculatePct(1, 100 - l_Stagger);

        l_Aura->SetMaxDuration(p_Victim->HasAura(208881) ? l_Aura->GetDuration() + l_SpellInfo->Effects[EFFECT_0].BasePoints /10 * IN_MILLISECONDS : l_Aura->GetDuration());
        l_Aura->SetDuration(l_Aura->GetMaxDuration());
    }

    p_Damage = static_cast<int32>(static_cast<float>(p_Damage) * CalculatePct(1.0f, 100 - l_Stagger));
    return p_Damage;
}

void Unit::CastStop(uint32 except_spellid)
{
    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id != except_spellid)
            InterruptSpell(CurrentSpellTypes(i), false);
}

void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastData& triggerData)
{
    if (m_cleanupDone)
        return;

    if (!spellInfo)
    {
        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell by caster: %s %u)", (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
        return;
    }

    Map* l_Map = Map::GetCurrentMapThread();
    if (l_Map && GetMap() && GetMap() != l_Map)
    {
        sLog->outExtChat("#jarvis-log", "danger", true, "Threadguard triggered for Unit::Castspell %u (GUID = %u) (Map (Id : %u) modifying Map (Id : %u))", spellInfo->Id, GetGUIDLow(), l_Map->GetId(), GetMap()->GetId());
        if (sWorld->getBoolConfig(CONFIG_ENABLE_UNSAFE_SPELL_AURA_HOOK_STACK_TRACE))
        {
            ACE_Stack_Trace l_StackTrace;
            sLog->outExtChat("#jarvis-log", "danger", true, l_StackTrace.c_str());
        }
    }

    // TODO: this is a workaround - not needed anymore, but required for some scripts :(
    //! by cyberbrest: i remove it as all prock spell by arrea with NeedsToBeTriggeredByCaster check are not work correct. ispesially new.
    //! if u uncomment it - force originalcaster guid on HandlePeriodicTriggerSpellAuraTick
    //if (!originalCaster && triggeredByAura)
    //    originalCaster = triggeredByAura->GetCasterGUID();

    Spell* spell = new Spell(this, spellInfo, triggerData.triggerFlags);

    spell->SetTriggerCastData(triggerData);

    if (value)
    {
        for (CustomSpellValues::const_iterator itr = value->begin(); itr != value->end(); ++itr)
            spell->SetSpellValue(itr->first, itr->second);

        spell->SetCustomCritChance(value->GetCustomCritChance());
    }

    spell->prepare(&targets);
}

void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster, float periodicDamageModifier /* = 0.0f*/, uint64 p_AreaTriggerGUID /* = 0*/)
{
    Map* l_Map = Map::GetCurrentMapThread();
    if (l_Map && GetMap() && GetMap() != l_Map)
    {
        sLog->outExtChat("#jarvis-log", "danger", true, "Threadguard triggered for Unit::Castspell %u (GUID = %u) (Map (Id : %u) modifying Map (Id : %u))", spellInfo->Id, GetGUIDLow(), l_Map->GetId(), GetMap()->GetId());
        if (sWorld->getBoolConfig(CONFIG_ENABLE_UNSAFE_SPELL_AURA_HOOK_STACK_TRACE))
        {
            ACE_Stack_Trace l_StackTrace;
            sLog->outExtChat("#jarvis-log", "danger", true, l_StackTrace.c_str());
        }
    }

    if (IsPlayer() && ToPlayer()->GetSession()->PlayerLoading())
    {
        if (spellInfo->HasEffect(SPELL_EFFECT_SUMMON))
        {
            uint32 l_SpellId = spellInfo->Id;
            AddDelayedEvent([=]() -> void
            {
                CastSpell(this, l_SpellId, true);
            }, 1);
        }
    }

    if (!spellInfo)
        return;

    // TODO: this is a workaround - not needed anymore, but required for some scripts :(
    if (!originalCaster && triggeredByAura)
        originalCaster = triggeredByAura->GetCasterGUID();

    // Override spell Id
    if (!spellInfo->OverrideSpellList.empty() && IsPlayer())
    {
        for (auto itr : spellInfo->OverrideSpellList)
        {
            if (ToPlayer()->HasSpell(itr))
            {
                SpellInfo const* overrideSpellInfo = sSpellMgr->GetSpellInfo(itr);
                if (overrideSpellInfo)
                    spellInfo = overrideSpellInfo;
                break;
            }
        }
    }

    Unit::AuraEffectList swaps = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS);
    Unit::AuraEffectList const& swaps2 = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2);
    if (!swaps2.empty())
        swaps.insert(swaps.end(), swaps2.begin(), swaps2.end());

    if (!swaps.empty())
    {
        for (Unit::AuraEffectList::const_iterator itr = swaps.begin(); itr != swaps.end(); ++itr)
        {
            if ((*itr)->IsAffectingSpell(spellInfo))
            {
                if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo((*itr)->GetAmount()))
                    spellInfo = newInfo;
                break;
            }
        }
    }

    Spell* spell = new Spell(this, spellInfo, triggerFlags, originalCaster);

    if (value)
    {
        for (CustomSpellValues::const_iterator itr = value->begin(); itr != value->end(); ++itr)
            spell->SetSpellValue(itr->first, itr->second);

        spell->SetCustomCritChance(value->GetCustomCritChance());
    }

    spell->m_CastItem = castItem;
    spell->SetPeriodicDamageModifier(periodicDamageModifier);
    spell->m_AreaTriggerGUID = p_AreaTriggerGUID;
    spell->prepare(&targets, triggeredByAura);
}

class DelayCastSpellEvent : public BasicEvent
{
    public:
        DelayCastSpellEvent(uint64 p_Guid, uint64 p_TargetGuid, uint32 p_SpellID, bool p_Triggered) :
            BasicEvent(), m_Guid(p_Guid), m_TargetGuid(p_TargetGuid), m_SpellID(p_SpellID), m_Triggered(p_Triggered),
            m_WithMod(false) { }

        DelayCastSpellEvent(uint64 p_Guid, Position const* p_Pos, uint32 p_SpellID, bool p_Triggered) :
            BasicEvent(), m_Guid(p_Guid), m_Dest(*p_Pos), m_HasDest(true), m_SpellID(p_SpellID), m_Triggered(p_Triggered), m_TargetGuid(0) { }

        DelayCastSpellEvent(uint64 p_Guid, uint64 p_TargetGuid, uint32 p_SpellID, bool p_Triggered, SpellValueMod p_Mod, int32 p_ModValue) :
            BasicEvent(), m_Guid(p_Guid), m_TargetGuid(p_TargetGuid), m_SpellID(p_SpellID), m_Triggered(p_Triggered),
            m_WithMod(true), m_Mod(p_Mod), m_ModValue(p_ModValue) { }

        virtual ~DelayCastSpellEvent() { }

        virtual bool Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
        {
            if (Unit* l_Unit = sObjectAccessor->FindUnit(m_Guid))
            {
                bool l_ShouldLog    = l_Unit->GetMapId() == 1520;
                uint32 l_StartTime  = l_ShouldLog ? getMSTime() : 0;

                if (m_TargetGuid)
                {
                    if (Unit* l_Target = Unit::GetUnit(*l_Unit, m_TargetGuid))
                    {
                        if (m_WithMod)
                            l_Unit->CastCustomSpell(m_SpellID, m_Mod, m_ModValue, l_Target, m_Triggered);
                        else
                            l_Unit->CastSpell(l_Target, m_SpellID, m_Triggered);
                    }
                }
                else if (m_HasDest)
                    l_Unit->CastSpell(m_Dest, m_SpellID, m_Triggered);

                if (l_ShouldLog)
                {
                    uint32 l_TimeTaken = getMSTime() - l_StartTime;
                    if (l_TimeTaken >= 5)
                        sLog->outAshran("DelayCastSpellEvent::execute %u taken %u ms", m_SpellID, l_TimeTaken);
                }
            }

            return true;
        }

        virtual void Abort(uint64 p_EndTime) { }

    private:
        uint64 m_Guid;
        uint64 m_TargetGuid;
        uint32 m_SpellID;
        bool m_Triggered;
        bool m_WithMod;
        SpellValueMod m_Mod;
        int32 m_ModValue;

        bool m_HasDest;
        Position m_Dest;
};

class DelayRemoveAuraEvent : public BasicEvent
{
    public:
        DelayRemoveAuraEvent(uint64 p_Guid, uint32 p_SpellID) : BasicEvent(), m_Guid(p_Guid), m_SpellID(p_SpellID) { }

        virtual ~DelayRemoveAuraEvent() { }

        virtual bool Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
        {
            if (Unit* l_Unit = sObjectAccessor->FindUnit(m_Guid))
            {
                bool l_ShouldLog = l_Unit->GetMapId() == 1520;
                uint32 l_StartTime = l_ShouldLog ? getMSTime() : 0;

                l_Unit->RemoveAura(m_SpellID);

                if (l_ShouldLog)
                {
                    uint32 l_TimeTaken = getMSTime() - l_StartTime;
                    if (l_TimeTaken >= 5)
                        sLog->outAshran("DelayRemoveAuraEvent::execute %u taken %u ms", m_SpellID, l_TimeTaken);
                }
            }

            return true;
        }

        virtual void Abort(uint64 p_EndTime) { }

    private:
        uint64 m_Guid;
        uint32 m_SpellID;
};

void Unit::DelayedCastSpell(Unit* p_Victim, uint32 p_SpellId, bool p_Triggered, uint32 p_Delay)
{
    m_Events.AddEvent(new DelayCastSpellEvent(GetGUID(), p_Victim->GetGUID(), p_SpellId, p_Triggered), m_Events.CalculateTime(p_Delay));
}

void Unit::DelayedCastSpell(Position const* p_Position, uint32 p_SpellID, bool p_Triggered, uint32 p_Delay)
{
    m_Events.AddEvent(new DelayCastSpellEvent(GetGUID(), p_Position, p_SpellID, p_Triggered), m_Events.CalculateTime(p_Delay));
}

void Unit::DelayedCastSpell(Unit* p_Victim, uint32 p_SpellId, bool p_Triggered, SpellValueMod p_Mod, int32 p_ModValue, uint32 p_Delay)
{
    m_Events.AddEvent(new DelayCastSpellEvent(GetGUID(), p_Victim->GetGUID(), p_SpellId, p_Triggered, p_Mod, p_ModValue), m_Events.CalculateTime(p_Delay));
}

void Unit::DelayedRemoveAura(uint32 p_SpellID, uint32 p_Delay)
{
    m_Events.AddEvent(new DelayRemoveAuraEvent(GetGUID(), p_SpellID), m_Events.CalculateTime(p_Delay));
}

void Unit::CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster, float periodicDamageModifier, uint64 p_AreaTriggerGUID /*= 0*/)
{
    CastSpell(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster, periodicDamageModifier, p_AreaTriggerGUID);
}

void Unit::CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags /*= TRIGGER_NONE*/, Item* castItem /*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/, float periodicDamageModifier /* = 0.0f */, uint64 p_AreaTriggerGUID /*= 0*/)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    CastSpell(victim, spellInfo, triggerFlags, castItem, triggeredByAura, originalCaster, periodicDamageModifier, p_AreaTriggerGUID);
}

void Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, bool triggered, Item* castItem/*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)
{
    CastSpell(victim, spellInfo, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
}

void Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster, float periodicDamageModifier /* = 0.0f */, uint64 p_AreaTriggerGUID /*= 0*/)
{
    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetUnitTarget(victim);
    CastSpell(targets, spellInfo, NULL, triggerFlags, castItem, triggeredByAura, originalCaster, periodicDamageModifier, p_AreaTriggerGUID);
}

class DelayCustomCastEvent : public BasicEvent
{
    public:
        DelayCustomCastEvent(uint64 p_Guid, uint64 p_TargetGuid, uint32 p_SpellID, int32 const p_BP0, int32 const p_BP1, int32 const p_BP2, bool p_Triggered) :
            BasicEvent(), m_Guid(p_Guid), m_TargetGuid(p_TargetGuid), m_SpellID(p_SpellID), m_BP0(p_BP0), m_BP1(p_BP1), m_BP2(p_BP2), m_Triggered(p_Triggered) { }

        virtual ~DelayCustomCastEvent() { }

        virtual bool Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
        {
            if (Unit* l_Unit = sObjectAccessor->FindUnit(m_Guid))
            {
                if (Unit* l_Target = Unit::GetUnit(*l_Unit, m_TargetGuid))
                    l_Unit->CastCustomSpell(l_Target, m_SpellID, &m_BP0, &m_BP1, &m_BP2, m_Triggered);
            }

            return true;
        }

        virtual void Abort(uint64 p_EndTime) { }

    private:
        uint64 m_Guid;
        uint64 m_TargetGuid;
        uint32 m_SpellID;
        int32 const m_BP0;
        int32 const m_BP1;
        int32 const m_BP2;
        bool m_Triggered;
};

void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster, uint32 p_Delay /*= 0*/)
{
    if (p_Delay)
    {
        m_Events.AddEvent(new DelayCustomCastEvent(GetGUID(), target->GetGUID(), spellId, bp0 ? *bp0 : 0, bp1 ? *bp1 : 0, bp2 ? *bp2 : 0, triggered), m_Events.CalculateTime(p_Delay));
        return;
    }

    CustomSpellValues values;
    if (bp0)
        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
    if (bp1)
        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
    if (bp2)
        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
}

void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, int32 const* bp3, int32 const* bp4, int32 const* bp5, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
{
    CustomSpellValues values;
    if (bp0)
        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
    if (bp1)
        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
    if (bp2)
        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
    if (bp3)
        values.AddSpellMod(SPELLVALUE_BASE_POINT3, *bp3);
    if (bp4)
        values.AddSpellMod(SPELLVALUE_BASE_POINT4, *bp4);
    if (bp5)
        values.AddSpellMod(SPELLVALUE_BASE_POINT5, *bp5);
    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
}

void Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
{
    CustomSpellValues values;
    values.AddSpellMod(mod, value);
    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
}

void Unit::CastCustomSpell(uint32 spellId, CustomSpellValues const& value, Unit* victim, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetUnitTarget(victim);

    CastSpell(targets, spellInfo, &value, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
}

void Unit::CastCustomSpell(float x, float y, float z, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster, uint64 p_AreaTriggerGUID)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    CustomSpellValues values;
    if (bp0)
        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
    if (bp1)
        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
    if (bp2)
        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);

    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetDst(x, y, z, GetOrientation());

    CastSpell(targets, spellInfo, &values, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster, 0.0f, p_AreaTriggerGUID);
}

void Unit::CastCustomSpell(Position const p_Pos, uint32 p_SpellID, int32 const* p_Bp0, int32 const* p_Bp1, int32 const* p_Bp2, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_TriggeredByAura /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/, uint64 p_AreaTriggerGUID /*= 0*/)
{
    CastCustomSpell(p_Pos.m_positionX, p_Pos.m_positionY, p_Pos.m_positionZ, p_SpellID, p_Bp0, p_Bp1, p_Bp2, p_Triggered, p_CastItem, p_TriggeredByAura, p_OriginalCaster, p_AreaTriggerGUID);
}

void Unit::CastSpell(Position const p_Pos, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_AurEff /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo)
        return;

    SpellCastTargets l_Targets;
    l_Targets.SetCaster(this);
    l_Targets.SetDst(p_Pos.m_positionX, p_Pos.m_positionY, p_Pos.m_positionZ, p_Pos.m_orientation);

    CastSpell(l_Targets, l_SpellInfo, nullptr, p_Triggered ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE, p_CastItem, p_AurEff, p_OriginalCaster);
}

void Unit::CastSpell(SpellDestination const* p_Dest, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_AurEff /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo)
        return;

    SpellCastTargets l_Targets;
    l_Targets.SetCaster(this);
    l_Targets.SetDst(p_Dest->_position.m_positionX, p_Dest->_position.m_positionY, p_Dest->_position.m_positionZ, p_Dest->_position.m_orientation);

    CastSpell(l_Targets, l_SpellInfo, nullptr, p_Triggered ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE, p_CastItem, p_AurEff, p_OriginalCaster);
}

void Unit::CastSpell(WorldLocation const* p_Loc, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_AurEff /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/)
{
    CastSpell(p_Loc->m_positionX, p_Loc->m_positionY, p_Loc->m_positionZ, p_SpellID, p_Triggered, p_CastItem, p_AurEff, p_OriginalCaster);
}

void Unit::CastSpell(uint32 p_LocEntry, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_AurEff /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/)
{
    WorldSafeLocsEntry const* l_Loc = sWorldSafeLocsStore.LookupEntry(p_LocEntry);
    if (l_Loc == nullptr)
        return;

    CastSpell(l_Loc->x, l_Loc->y, l_Loc->z, p_SpellID, p_Triggered, p_CastItem, p_AurEff, p_OriginalCaster);
}

void Unit::CastSpell(G3D::Vector3 p_Pos, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem /*= nullptr*/, AuraEffect const* p_AurEff /*= nullptr*/, uint64 p_OriginalCaster /*= 0*/)
{
    CastSpell(p_Pos.x, p_Pos.y, p_Pos.z, p_SpellID, p_Triggered, p_CastItem, p_AurEff, p_OriginalCaster);
}

void Unit::CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetDst(x, y, z, GetOrientation());

    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
}

void Unit::CastSpell(float x, float y, float z, uint32 spellId, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetDst(x, y, z, GetOrientation());

    CastSpell(targets, spellInfo, nullptr, triggerFlags, castItem, triggeredByAura, originalCaster);
}

void Unit::CastSpell(GameObject* go, uint32 spellId, bool triggered, Item* castItem, AuraEffect* triggeredByAura, uint64 originalCaster)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    SpellCastTargets targets;
    targets.SetCaster(this);
    targets.SetGOTarget(go);

    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
}

void Unit::CastSpell(Item* p_ItemTarget, uint32 p_SpellID, bool p_Triggered, Item* p_CastItem, AuraEffect* p_TriggeredByAura, uint64 p_OriginalCaster)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo)
        return;

    SpellCastTargets l_Targets;
    l_Targets.SetCaster(this);
    l_Targets.SetItemTarget(p_ItemTarget);

    CastSpell(l_Targets, l_SpellInfo, nullptr, p_Triggered ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE, p_CastItem, p_TriggeredByAura, p_OriginalCaster);
}

// Obsolete func need remove, here only for comotability vs another patches
uint32 Unit::SpellNonMeleeDamageLog(Unit* p_Victim, uint32 p_SpellID, uint32 p_Damage)
{
    /*SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);

    p_Damage = SpellDamageBonusDone(p_Victim, l_SpellInfo, p_Damage, EFFECT_0, SPELL_DIRECT_DAMAGE);
    uint32 l_UnmitigatedDamage = p_Damage;
    p_Damage = p_Victim->SpellDamageBonusTaken(this, l_SpellInfo, p_Damage, SPELL_DIRECT_DAMAGE);

    SpellNonMeleeDamage l_DamageInfo(this, p_Victim, p_Damage, l_UnmitigatedDamage, l_SpellInfo, SPELL_DIRECT_DAMAGE, WeaponAttackType::BaseAttack);
    CalculateSpellDamageTaken(l_DamageInfo);
    DealDamageMods(l_DamageInfo);
    SendSpellNonMeleeDamageLog(l_DamageInfo);
    DealSpellDamage(l_DamageInfo, true);
    return l_DamageInfo.GetAmount();*/
    return 0;
}

void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage& p_DamageInfo, bool p_Crit, std::ostringstream* p_DamageLogStream/* = nullptr*/)
{
    Unit* l_Victim = p_DamageInfo.GetTarget();
    if (!l_Victim || !l_Victim->isAlive())
        return;

    SpellInfo const* l_SpellInfo = p_DamageInfo.GetSpellInfo();

    /// Eonar the Lifebinder - Foul Steps, casted by player
    if (l_SpellInfo && l_SpellInfo->Id == 250139)
        return;

    /// 7.0.3 i'm not sure it's work this way anymore
    {
        uint32 l_Damage = p_DamageInfo.GetAmount();

        if (p_DamageLogStream)
            *p_DamageLogStream << " CalculateSpellDamageTaken " << l_Damage << std::endl;

        /// Tanks now take 25% additional damage while engaged in PvP combat. -> https://worldofwarcraft.com/en-us/news/20252902/hotfixes-october-3
        if (IsPlayer() && l_Victim->IsPlayer() && l_Victim->ToPlayer()->IsActiveSpecTankSpec())
        {
            l_Damage += CalculatePct(l_Damage, 25.0f);
            if (p_DamageLogStream)
                *p_DamageLogStream << " Tank in PvP -25%" << std::endl;
        }

        // WoD: Apply factor on damages depending on creature level and expansion
        if ((IsPlayer() || IsPetGuardianStuff()) && l_Victim->GetTypeId() == TYPEID_UNIT)
            l_Damage *= CalculateDamageDealtFactor(this, l_Victim->ToCreature());
        else if (GetTypeId() == TYPEID_UNIT && (l_Victim->IsPlayer() || l_Victim->IsPetGuardianStuff()))
            l_Damage *= CalculateDamageTakenFactor(l_Victim, ToCreature());

        p_DamageInfo.SetAmount(l_Damage);
    }

    /// Checking denying armor reduction from Tigereye Brew for Storm Earth and Fire (137639) Spirits
    bool l_DenyReduceArmor = false;
    if (GetEntry() == 69791 || GetEntry() == 69792)
    {
        if (GetOwner() && GetOwner()->ToPlayer())
        {
            if (GetOwner()->HasAura(247483))
                l_DenyReduceArmor = true;
        }
    }

    if (IsDamageReducedByArmor(p_DamageInfo.GetSchoolMask(), l_SpellInfo) && !IsDealingFixedDamage() && !l_DenyReduceArmor)
    {
        if (p_DamageLogStream)
            *p_DamageLogStream << " before armor reduction" << p_DamageInfo.GetAmount() << std::endl;

        CalcArmorReducedDamage(p_DamageInfo);

        if (p_DamageLogStream)
            *p_DamageLogStream << " after armor reduction " << p_DamageInfo.GetAmount() << std::endl;
    }

    bool l_Blocked = false;
    // Per-school calc
    switch (l_SpellInfo->DmgClass)
    {
        // Melee and Ranged Spells
        case SPELL_DAMAGE_CLASS_RANGED:
        case SPELL_DAMAGE_CLASS_MELEE:
        {
            // Physical Damage
            if (p_DamageInfo.GetSchoolMask() & SPELL_SCHOOL_MASK_NORMAL)
            {
                // Get blocked status
                l_Blocked = isSpellBlocked(l_Victim, l_SpellInfo, p_DamageInfo.GetAttackType());
            }

            if (p_Crit)
            {
                p_DamageInfo.HitInfo |= SPELL_HIT_TYPE_CRIT;
                p_DamageInfo.SetAmount(MeleeCriticalDamageBonus(l_SpellInfo, p_DamageInfo.GetAmount(), l_Victim, p_DamageInfo.GetAttackType(), p_DamageLogStream));
            }

            // Spell weapon based damage CAN BE crit & blocked at same time
            if (l_Blocked)
            {
                // double blocked amount if block is critical
                uint32 l_Value = l_Victim->GetBlockPercent();
                if (l_Victim->isBlockCritical())
                    l_Value *= 2; // double blocked percent

                p_DamageInfo.Block(CalculatePct(p_DamageInfo.GetAmount(), l_Value));
            }

            break;
        }
        // Magical Attacks
        case SPELL_DAMAGE_CLASS_NONE:
        case SPELL_DAMAGE_CLASS_MAGIC:
        {
            /// Magic Damage can be block only by Paladin Protection
            if (l_Victim->HasAura(152261)) ///< Holy Shield
            {
                /// Get blocked status
                l_Blocked = isSpellBlocked(l_Victim, l_SpellInfo, p_DamageInfo.GetAttackType());
            }

            /// If crit add critical bonus
            if (p_Crit)
            {
                p_DamageInfo.HitInfo |= SPELL_HIT_TYPE_CRIT;
                p_DamageInfo.SetAmount(SpellCriticalDamageBonus(l_SpellInfo, p_DamageInfo.GetAmount(), l_Victim, p_DamageLogStream));
            }

            if (l_Blocked)
            {
                // double blocked amount if block is critical
                uint32 l_Value = l_Victim->GetBlockPercent();
                if (l_Victim->isBlockCritical())
                    l_Value *= 2; // double blocked percent

                p_DamageInfo.Block(CalculatePct(p_DamageInfo.GetAmount(), l_Value));
            }
            break;
        }
        default:
            break;
    }

    if (l_Blocked && l_Victim->IsPlayer())
        sScriptMgr->OnPlayerBlock(l_Victim->ToPlayer(), this);
    // Calculate absorb resist
    CalcAbsorbResist(p_DamageInfo);
}

void Unit::DealSpellDamage(SpellNonMeleeDamage& p_DamageInfo, bool p_DurabilityLoss)
{
    Unit* l_Victim = p_DamageInfo.GetTarget();

    if (!l_Victim)
        return;

    if (!l_Victim->isAlive() || l_Victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (l_Victim->GetTypeId() == TYPEID_UNIT && l_Victim->ToCreature()->IsInEvadeMode()))
        return;

    SpellInfo const* l_SpellProto = p_DamageInfo.GetSpellInfo();
    if (!l_SpellProto)
        return;

    // Call default DealDamage
    CleanDamage l_CleanDamage(p_DamageInfo.GetUnmitigatedAmount(), p_DamageInfo.GetAbsorb(), WeaponAttackType::BaseAttack, MELEE_HIT_NORMAL);
    p_DamageInfo.SetAmount(DealDamage(l_Victim, p_DamageInfo.GetAmount(), &l_CleanDamage, p_DamageInfo.GetDamageType(), p_DamageInfo.GetSchoolMask(), l_SpellProto, p_DurabilityLoss, p_DamageInfo.GetAbsorb()));
}

// TODO for melee need create structure as in
void Unit::CalculateMeleeDamage(CalcDamageInfo* p_DamageInfo)
{
    Unit* l_Victim = p_DamageInfo->GetTarget();
    if (!l_Victim)
        return;

    if (!isAlive() || !l_Victim->isAlive())
        return;

    Map* l_Map = l_Victim->GetMap();
    if (!l_Map)
        return;

    // Select HitInfo/procAttacker/procVictim flag based on attack type
    switch (p_DamageInfo->GetAttackType())
    {
        case WeaponAttackType::BaseAttack:
            p_DamageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;
            p_DamageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
            break;
        case WeaponAttackType::OffAttack:
            p_DamageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;
            p_DamageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
            p_DamageInfo->HitInfo      = HITINFO_OFFHAND;
            break;
        default:
            return;
    }

    // Physical Immune check
    if (l_Victim->IsImmunedToDamage(p_DamageInfo->GetSchoolMask()))
    {
       p_DamageInfo->HitInfo       |= HITINFO_NORMALSWING;
       p_DamageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;

       p_DamageInfo->procEx        |= PROC_EX_IMMUNE;
       p_DamageInfo->CancelDamage();
       return;
    }

    uint32 l_Damage = 0;
    l_Damage += CalculateDamage(p_DamageInfo->GetAttackType(), false, true, l_Victim);

    if (ToCreature() && ToCreature()->IsAIEnabled)
        ToCreature()->AI()->OnCalculateMeleeDamage(l_Victim, &l_Damage, p_DamageInfo);

    // Add melee damage bonus
    l_Damage = MeleeDamageBonusDone(l_Victim, l_Damage, p_DamageInfo->GetAttackType());

    uint32 l_UnmitigedDamage = l_Damage;

    l_Damage = l_Victim->MeleeDamageBonusTaken(this, l_Damage, p_DamageInfo->GetAttackType());

    ///< Warlock's pets melee formulas
    if (GetOwner() && (GetEntry() == WarlockPet::FelGuard || GetEntry() == 98035))
    {
        ///< Warlock's pets melee formulas, Expendables - 211218 is for all pets
        if (AuraEffect* l_TheExpendablesEffect = GetAuraEffect(211218, EFFECT_0))
            AddPct(l_Damage, l_TheExpendablesEffect->GetAmount());
    }

    ///< Windwalker Monk's Xuen autoattack formula:
    if (ToCreature() && ToCreature()->GetEntry() == 63508 && ToCreature()->GetOwner() && ToCreature()->GetOwner()->ToPlayer())
    {
        float l_OwnerAP = ToCreature()->GetOwner()->ToPlayer()->GetTotalAttackPowerValue(WeaponAttackType::BaseAttack);
        l_Damage = 4.509f * l_OwnerAP / 3.5f;

        l_Damage = l_Victim->MeleeDamageBonusTaken(this, l_Damage, p_DamageInfo->GetAttackType());

        ///< Windborne Blows
        {
            uint8 l_Rank = ToCreature()->GetOwner()->ToPlayer()->GetRankOfArtifactPowerId(1376);
            float l_Amount = 5 * (1 + (l_Rank-1) / 10);
            AddPct(l_Damage, l_Amount);
        }

        ///< Ferocity of the Broken
        if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(241136))
            AddPct(l_Damage, l_SpellInfo->Effects[EFFECT_0].BasePoints);

        ///< Versatility
        l_Damage *= (1.0f + (ToCreature()->GetOwner()->ToPlayer()->GetFloatValue(PLAYER_FIELD_VERSATILITY) / 100.0f));

        ///< Windwalker spec modifier
        if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(137025))
            AddPct(l_Damage, l_SpellInfo->Effects[EFFECT_0].BasePoints);
    }

    // WoD: Tanks now take 25% additional damage while engaged in PvP combat.
    if (IsPlayer() && l_Victim->IsPlayer() && l_Victim->ToPlayer()->IsActiveSpecTankSpec())
        l_Damage += CalculatePct(l_Damage, 25.0f);

    // Force Of Nature pets damage
    if (ToCreature() && ToCreature()->GetEntry() == 103822 && ToCreature()->GetOwner() && ToCreature()->GetOwner()->ToPlayer())
        if (SpellInfo const* l_FNSpellInfo = sSpellMgr->GetSpellInfo(205636))
            l_Damage = CalculatePct(ToCreature()->GetOwner()->ToPlayer()->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL), l_FNSpellInfo->Effects[EFFECT_3].MiscValue);

    if (ToCreature() && (ToCreature()->GetEntry() == DeathKnightPet::Abomination || ToCreature()->GetEntry() == DeathKnightPet::Ghoul || ToCreature()->GetEntry() == DeathKnightPet::ArmyOfTheDead) && ToCreature()->GetOwner() && ToCreature()->GetOwner()->ToPlayer())
    {
        ///< DK's Sludge Belcher and Ghoul increasing damage from Death debuff on enemy
        if (Aura* l_DeathDebuff = l_Victim->GetAura(191730, ToCreature()->GetOwner()->GetGUID()))
            if (SpellInfo const* l_DebuffInfo = sSpellMgr->GetSpellInfo(191730))
                AddPct(l_Damage, l_DebuffInfo->Effects[EFFECT_0].BasePoints * l_DeathDebuff->GetStackAmount());

        ///< DK's Sludge Belcher and Ghoul increasing damage from Master of Ghouls
        if (ToCreature()->GetOwner()->HasAura(246995))
            if (SpellInfo const* l_BuffInfo = sSpellMgr->GetSpellInfo(246995))
                AddPct(l_Damage, l_BuffInfo->Effects[EFFECT_0].BasePoints);
    }

    if (ToCreature() && ToCreature()->GetEntry() == 58965)
    {
        if ((p_DamageInfo->GetAttackType() == WeaponAttackType::BaseAttack || p_DamageInfo->GetAttackType() == WeaponAttackType::OffAttack))
            l_Damage = CalculatePct(l_Damage, 65);
    }

    ///< Shadowfiend's and Mindbender's attack formula
    if (ToCreature() && (ToCreature()->GetEntry() == 19668 || ToCreature()->GetEntry() == 62982) && ToCreature()->GetOwner())
    {
        ///< Only for Shadowfiend
        if (ToCreature()->GetEntry() == 19668)
        {
            l_Damage = ToCreature()->GetOwner()->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL) * 2.1844f;
            l_Damage = ToCreature()->GetOwner()->MeleeDamageBonusDone(l_Victim, l_Damage, p_DamageInfo->GetAttackType());
            l_Damage = l_Victim->MeleeDamageBonusTaken(ToCreature()->GetOwner(), l_Damage, p_DamageInfo->GetAttackType());

            ///< Shadowcrawl
            if (AuraEffect* l_AuraEffect = GetAuraEffect(63619, EFFECT_1))
                AddPct(l_Damage, l_AuraEffect->GetAmount());

            ///< Forbidden Flame
            if (AuraEffect* l_AuraEffect = ToCreature()->GetOwner()->GetAuraEffect(214925, EFFECT_0))
                AddPct(l_Damage, l_AuraEffect->GetAmount());

            ///< Will of the Conclave
            if (AuraEffect* l_AuraEffect = ToCreature()->GetOwner()->GetAuraEffect(241148, EFFECT_0))
                AddPct(l_Damage, l_AuraEffect->GetAmount());

            ///< Darkening Whispers
            if (AuraEffect* l_AuraEffect = ToCreature()->GetOwner()->GetAuraEffect(214927, EFFECT_0))
                AddPct(l_Damage, l_AuraEffect->GetAmount());

            ///< Darkness of the Conclave
            if (AuraEffect* l_AuraEffect = ToCreature()->GetOwner()->GetAuraEffect(241150, EFFECT_0))
                AddPct(l_Damage, l_AuraEffect->GetAmount());
        }

        if (Player* l_PlayerOwner = ToCreature()->GetOwner()->ToPlayer())
        {
            MS::Artifact::Manager* l_Artifact = l_PlayerOwner->GetCurrentlyEquippedArtifact();
            if (l_Artifact)
            {
                if (l_Artifact->GetLevel() > 0 && l_PlayerOwner->HasAura(219655))
                {
                    float l_PctFromTraits = 0.65f * (std::min((uint32)l_Artifact->GetLevel(), 52u) + 6);
                    AddPct(l_Damage, l_PctFromTraits);
                }
            }
        }
    }

    ///< Sin'dorei Spite
    if ((IsWarlockPet() || GetEntry() == 98035 /* Dreadstalkers */) && GetOwner())
        if (AuraEffect* l_AuraEff = GetOwner()->GetAuraEffect(208871, EFFECT_0))
            AddPct(l_Damage, l_AuraEff->GetAmount());

    // WoD: Apply factor on damages depending on creature level and expansion
    if ((IsPlayer() || IsPetGuardianStuff()) && l_Victim->GetTypeId() == TYPEID_UNIT)
        l_Damage *= CalculateDamageDealtFactor(this, l_Victim->ToCreature());
    else if (GetTypeId() == TYPEID_UNIT && (l_Victim->IsPlayer() || l_Victim->IsPetGuardianStuff()))
        l_Damage *= CalculateDamageTakenFactor(l_Victim, ToCreature());

    p_DamageInfo->ResetAmount(l_Damage, l_UnmitigedDamage);

    /// Checking denying armor reduction from Tigereye Brew for Storm Earth and Fire (137639) Spirits
    bool l_DenyReduceArmor = false;
    if (GetEntry() == 69791 || GetEntry() == 69792)
    {
        if (GetOwner() && GetOwner()->ToPlayer())
        {
            if (GetOwner()->HasAura(247483))
                l_DenyReduceArmor = true;
        }
    }

    // Calculate armor reduction
    if (IsDamageReducedByArmor(p_DamageInfo->GetSchoolMask()) && !l_DenyReduceArmor)
        CalcArmorReducedDamage(*p_DamageInfo);

    p_DamageInfo->hitOutCome = RollMeleeOutcomeAgainst(l_Victim, p_DamageInfo->GetAttackType());

    switch (p_DamageInfo->hitOutCome)
    {
        case MELEE_HIT_EVADE:
            p_DamageInfo->HitInfo        |= HITINFO_MISS | HITINFO_SWINGNOHITSOUND;
            p_DamageInfo->TargetState     = VICTIMSTATE_EVADES;
            p_DamageInfo->procEx         |= PROC_EX_EVADE;
            p_DamageInfo->CancelDamage();
            return;
        case MELEE_HIT_MISS:
            p_DamageInfo->HitInfo        |= HITINFO_MISS;
            p_DamageInfo->TargetState     = VICTIMSTATE_INTACT;
            p_DamageInfo->procEx         |= PROC_EX_MISS;
            p_DamageInfo->CancelDamage();
            break;
        case MELEE_HIT_NORMAL:
            p_DamageInfo->TargetState     = VICTIMSTATE_HIT;
            p_DamageInfo->procEx         |= PROC_EX_NORMAL_HIT;
            break;
        case MELEE_HIT_CRIT:
        {
            p_DamageInfo->HitInfo        |= HITINFO_CRITICALHIT;
            p_DamageInfo->TargetState     = VICTIMSTATE_HIT;
            p_DamageInfo->procEx         |= PROC_EX_CRITICAL_HIT;

            p_DamageInfo->ResetAmount(MeleeCriticalDamageBonus(nullptr, p_DamageInfo->GetAmount(), l_Victim, p_DamageInfo->GetAttackType()), MeleeCriticalDamageBonus(nullptr, l_UnmitigedDamage, l_Victim, p_DamageInfo->GetAttackType()));
            break;
        }
        case MELEE_HIT_PARRY:
            p_DamageInfo->TargetState  = VICTIMSTATE_PARRY;
            p_DamageInfo->procEx      |= PROC_EX_PARRY;
            p_DamageInfo->SetAmount(0);

            ///< Hack fix for DH T21 Veng 4P bonus because PROC_EX_PARRY cannot be checked in ProcEventInfo.GetHitMask()
            if (l_Victim->HasAura(251774))
            {
                if (Player* l_Player = l_Victim->ToPlayer())
                {
                    if (SpellInfo const* l_Veng4PInfo = sSpellMgr->GetSpellInfo(251774))
                    {
                        if (getMSTime() > l_Victim->m_SpellHelper.GetUint32(eSpellHelpers::Veng4PLastProcTime) + l_Veng4PInfo->Effects[EFFECT_1].BasePoints)
                        {
                            l_Player->ReduceSpellCooldown(187827, l_Veng4PInfo->Effects[EFFECT_0].BasePoints);
                            l_Victim->m_SpellHelper.GetUint32(eSpellHelpers::Veng4PLastProcTime) = getMSTime();
                        }
                    }
                }
            }
            break;
        case MELEE_HIT_DODGE:
            p_DamageInfo->TargetState  = VICTIMSTATE_DODGE;
            p_DamageInfo->procEx      |= PROC_EX_DODGE;
            p_DamageInfo->SetAmount(0);
            break;
        case MELEE_HIT_BLOCK:
            p_DamageInfo->TargetState = VICTIMSTATE_HIT;
            p_DamageInfo->HitInfo    |= HITINFO_BLOCK;
            p_DamageInfo->procEx     |= PROC_EX_BLOCK | PROC_EX_NORMAL_HIT;
            // 30% damage blocked, double blocked amount if block is critical
            p_DamageInfo->Block(CalculatePct(p_DamageInfo->GetAmount(), l_Victim->isBlockCritical() ? l_Victim->GetBlockPercent() * 2 : l_Victim->GetBlockPercent()));
            break;
        case MELEE_HIT_GLANCING:
        {
            p_DamageInfo->HitInfo     |= HITINFO_GLANCING;
            p_DamageInfo->TargetState  = VICTIMSTATE_HIT;
            p_DamageInfo->procEx      |= PROC_EX_NORMAL_HIT;
            int32 leveldif = int32(l_Victim->getLevelForTarget(this)) - int32(getLevelForTarget(l_Victim));
            if (leveldif > 3)
                leveldif = 3;
            float l_ReducePercent = 1 - leveldif * 0.1f;

            p_DamageInfo->SetAmount(uint32(l_ReducePercent * p_DamageInfo->GetAmount()));
            break;
        }
        case MELEE_HIT_CRUSHING:
            p_DamageInfo->HitInfo     |= HITINFO_CRUSHING;
            p_DamageInfo->TargetState  = VICTIMSTATE_HIT;
            p_DamageInfo->procEx      |= PROC_EX_NORMAL_HIT;
            // 150% normal damage
            p_DamageInfo->ResetAmount(CalculatePct(p_DamageInfo->GetAmount(), 150), CalculatePct(l_UnmitigedDamage, 150));
            break;
        default:
            break;
    }

    // Always apply HITINFO_AFFECTS_VICTIM in case its not a miss
    if (!(p_DamageInfo->HitInfo & HITINFO_MISS))
        p_DamageInfo->HitInfo |= HITINFO_AFFECTS_VICTIM;

    /// only for normal weapon damage
    if (p_DamageInfo->GetAttackType() == WeaponAttackType::BaseAttack || p_DamageInfo->GetAttackType() == WeaponAttackType::OffAttack)
    {
        /// Calculate absorb resist
        if (int32(p_DamageInfo->GetAmount()) > 0)
        {
            p_DamageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;

            uint32 l_PreviousDamage = p_DamageInfo->GetAmount();

            /// Calculate absorb & resists
            CalcAbsorbResist(*p_DamageInfo);

            if (p_DamageInfo->GetAbsorb())
            {
                p_DamageInfo->HitInfo |= (p_DamageInfo->GetAbsorb() == l_PreviousDamage ? HITINFO_FULL_ABSORB : HITINFO_PARTIAL_ABSORB);
                p_DamageInfo->procEx |= PROC_EX_ABSORB;
            }

            if (p_DamageInfo->GetResist())
                p_DamageInfo->HitInfo |= (p_DamageInfo->GetResist() == l_PreviousDamage ? HITINFO_FULL_RESIST : HITINFO_PARTIAL_RESIST);
        }
        else ///< Impossible get negative result but....
            p_DamageInfo->CancelDamage();

        // only for normal weapon damage
        if (p_DamageInfo->GetDamageType() == DIRECT_DAMAGE)
        {
            // Custom MoP Script - Zen Meditation - 115176
            if (Aura* zenMeditation = l_Victim->GetAura(115176, l_Victim->GetGUID()))
                if (!l_Victim->HasAura(208878))
                    l_Victim->RemoveAura(115176);
        }

        if (l_Victim->HasAura(202631) && p_DamageInfo->procEx & PROC_EX_PARRY)
        {
            l_Victim->CastSpell(l_Victim, 202633, true);
        }
    }
}

void Unit::DealMeleeDamage(CalcDamageInfo* p_DamageInfo, bool p_DurabilityLoss)
{
    Unit* l_Victim = p_DamageInfo->GetTarget();

    if (!l_Victim->isAlive() || l_Victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (l_Victim->GetTypeId() == TYPEID_UNIT && l_Victim->ToCreature()->IsInEvadeMode()))
        return;

    if (isPet())
    {
        if (Unit* l_Owner = GetOwner())
        {
            if (l_Owner->HasAura(191334)) ///< Mastery: Hunting Companion
            {
                if (Player* l_Player = l_Owner->ToPlayer())
                {
                    float l_Mastery = l_Player->GetFloatValue(PLAYER_FIELD_MASTERY) / 2.0f;

                    if (l_Owner->HasAura(186289)) ///< Aspect of The Eagle
                        if (SpellInfo const * l_SpellInfo = sSpellMgr->GetSpellInfo(186289))
                            l_Mastery += float(l_SpellInfo->Effects[EFFECT_1].BasePoints);

                    if (roll_chance_f(l_Mastery))
                    {
                        if (SpellInfo const* l_MoongoseBite = sSpellMgr->GetSpellInfo(190928))
                        {
                            l_Player->RestoreCharge(l_MoongoseBite->ChargeCategoryEntry);
                        }
                    }
                }
            }
        }
    }

    // Hmmmm dont like this emotes client must by self do all animations
    if (p_DamageInfo->HitInfo & HITINFO_CRITICALHIT)

        l_Victim->HandleEmoteCommand(EMOTE_ONESHOT_WOUND_CRITICAL);
    if (p_DamageInfo->GetBlock() && p_DamageInfo->TargetState != VICTIMSTATE_BLOCKS)
        l_Victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);

    if (p_DamageInfo->TargetState == VICTIMSTATE_PARRY)
    {
        // Get attack timers
        float l_OffTime  = float(l_Victim->getAttackTimer(WeaponAttackType::OffAttack));
        float l_BaseTime = float(l_Victim->getAttackTimer(WeaponAttackType::BaseAttack));
        // Reduce attack time
        if (l_Victim->haveOffhandWeapon() && l_OffTime < l_BaseTime)
        {
            float l_Percent20 = l_Victim->GetAttackTime(WeaponAttackType::OffAttack) * 0.20f;
            float l_Percent60 = 3.0f * l_Percent20;
            if (l_OffTime > l_Percent20 && l_OffTime <= l_Percent60)
                l_Victim->setAttackTimer(WeaponAttackType::OffAttack, uint32(l_Percent20));
            else if (l_OffTime > l_Percent60)
            {
                l_OffTime -= 2.0f * l_Percent20;
                l_Victim->setAttackTimer(WeaponAttackType::OffAttack, uint32(l_OffTime));
            }
        }
        else
        {
            float l_Percent20 = l_Victim->GetAttackTime(WeaponAttackType::BaseAttack) * 0.20f;
            float l_Percent60 = 3.0f * l_Percent20;
            if (l_BaseTime > l_Percent20 && l_BaseTime <= l_Percent60)
                l_Victim->setAttackTimer(WeaponAttackType::BaseAttack, uint32(l_Percent20));
            else if (l_BaseTime > l_Percent60)
            {
                l_BaseTime -= 2.0f * l_Percent20;
                l_Victim->setAttackTimer(WeaponAttackType::BaseAttack, uint32(l_BaseTime));
            }
        }
    }

    // Call default DealDamage
    CleanDamage l_CleanDamage(p_DamageInfo->GetUnmitigatedAmount(), p_DamageInfo->GetAbsorb(), p_DamageInfo->GetAttackType(), p_DamageInfo->hitOutCome);
    p_DamageInfo->SetAmount(DealDamage(p_DamageInfo->GetTarget(), p_DamageInfo->GetAmount(), &l_CleanDamage, p_DamageInfo->GetDamageType(), p_DamageInfo->GetSchoolMask(), p_DamageInfo->GetSpellInfo(), p_DurabilityLoss, p_DamageInfo->GetAbsorb()));

    // If this is a creature and it attacks from behind it has a probability to daze it's victim
    if ((p_DamageInfo->hitOutCome == MELEE_HIT_CRIT || p_DamageInfo->hitOutCome == MELEE_HIT_CRUSHING || p_DamageInfo->hitOutCome == MELEE_HIT_NORMAL || p_DamageInfo->hitOutCome == MELEE_HIT_GLANCING) &&
        GetTypeId() != TYPEID_PLAYER && !ToCreature()->IsControlledByPlayer() && !l_Victim->HasInArc(M_PI, this)
        && (l_Victim->IsPlayer() || !l_Victim->ToCreature()->isWorldBoss()))
    {
        // -probability is between 0% and 40%
        // 20% base chance
        float l_Probability = 20.0f;

        // there is a newbie protection, at level 10 just 7% base chance; assuming linear function
        if (l_Victim->getLevelForTarget(this) < 30)
            l_Probability = 0.65f * l_Victim->getLevelForTarget(this) + 0.5f;

        uint32 l_VictimDefense = l_Victim->GetMaxSkillValueForLevel(this);
        uint32 l_AttackerMeleeSkill = GetMaxSkillValueForLevel();

        l_Probability *= l_AttackerMeleeSkill/(float)l_VictimDefense;

        if (l_Probability > 40.0f)
            l_Probability = 40.0f;

        if (l_Victim->IsPlayer() && l_Victim->ToPlayer()->IsActiveSpecTankSpec())
            l_Probability = 0.0f;

        if (roll_chance_f(l_Probability))
            CastSpell(l_Victim, 1604, true);
    }

    if (IsPlayer())
        ToPlayer()->CastItemCombatSpell(p_DamageInfo->GetTarget(), p_DamageInfo->GetAttackType(), p_DamageInfo->procVictim, p_DamageInfo->procEx);

    // Do effect if any damage done to target
    if (p_DamageInfo->GetAmount())
    {
        // We're going to call functions which can modify content of the list during iteration over it's elements
        // Let's copy the list so we can prevent iterator invalidation
        AuraEffectList l_VDamageShieldsCopy(l_Victim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD));
        for (AuraEffectList::const_iterator l_DamageShieldItr = l_VDamageShieldsCopy.begin(); l_DamageShieldItr != l_VDamageShieldsCopy.end(); ++l_DamageShieldItr)
        {
            SpellInfo const* l_SpellProto = (*l_DamageShieldItr)->GetSpellInfo();
            // Damage shield can be resisted...
            if (SpellMissInfo l_MissInfo = l_Victim->SpellHitResult(this, l_SpellProto, false))
            {
                l_Victim->SendSpellMiss(this, l_SpellProto->Id, l_MissInfo);
                continue;
            }

            // ...or immuned
            if (IsImmunedToDamage(l_SpellProto))
            {
                l_Victim->SendSpellDamageImmune(this, l_SpellProto->Id);
                continue;
            }
            uint32 l_Damage = (*l_DamageShieldItr)->GetAmount();
            uint32 l_UnmitigatedDamage = l_Damage;

            if (Unit* l_Caster = (*l_DamageShieldItr)->GetCaster())
            {
                l_Damage = l_Caster->SpellDamageBonusDone(this, l_SpellProto, l_Damage, (*l_DamageShieldItr)->GetEffIndex(),SPELL_DIRECT_DAMAGE);
                l_UnmitigatedDamage = l_Damage;
                l_Damage = this->SpellDamageBonusTaken(l_Caster, l_SpellProto, l_Damage, SPELL_DIRECT_DAMAGE, (*l_DamageShieldItr)->GetEffIndex());
            }

            // No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that
            DamageInfo l_DamageInfo(this, l_Victim, l_Damage, l_UnmitigatedDamage, l_SpellProto, SPELL_DIRECT_DAMAGE, WeaponAttackType::BaseAttack);
            l_Victim->DealDamageMods(l_DamageInfo);

            l_Damage = l_DamageInfo.GetAmount();

            // TODO: Move this to a packet handler
            int32 l_OverKill = int64(l_Damage) - GetHealth(l_Victim);

            WorldPacket l_Data(SMSG_SPELL_DAMAGE_SHIELD, (2 * (16 + 2)) + 4 + 4 + 4 + 4 + 4 + 1);
            l_Data.appendPackGUID(l_Victim->GetGUID());             ///< Defender
            l_Data.appendPackGUID(GetGUID());                       ///< Attacker
            l_Data << uint32(l_SpellProto->Id);                     ///< SpellID
            l_Data << uint32(l_Damage);                             ///< TotalDamage
            l_Data << uint32(l_OverKill > 0 ? l_OverKill : 0);      ///< OverKill
            l_Data << uint32(l_SpellProto->SchoolMask);             ///< SchoolMask
            l_Data << uint32(0);                                    ///< LogAbsorbed => FIX ME: Send resisted damage, both fully resisted and partly resisted
            l_Data.WriteBit(false);                                 ///< HasLogData
            l_Data.FlushBits();

            l_Victim->SendMessageToSet(&l_Data, true);
            l_Victim->DealDamage(this, l_Damage, 0, l_DamageInfo.GetDamageType(), l_DamageInfo.GetSchoolMask(), l_DamageInfo.GetSpellInfo(), true, l_DamageInfo.GetAbsorb());
        }
    }
}

void Unit::HandleEmoteCommand(uint32 p_EmoteId, uint64 p_ReceiverGuid)
{
    EmotesEntry const* l_EmoteInfo = sEmotesStore.LookupEntry(p_EmoteId);
    if (!l_EmoteInfo)
    {
        SetUInt32Value(UNIT_FIELD_EMOTE_STATE, 0);
        return;
    }

    if (!isAlive())
        return;

    switch (l_EmoteInfo->EmoteSpecProc)
    {
        case EmoteTypes::OneStep:
        {
            WorldPacket l_Data(SMSG_EMOTE, 4 + 2 + 16);
            l_Data.appendPackGUID(GetGUID());
            l_Data << uint32(p_EmoteId);

            if (p_ReceiverGuid)
            {
                Player* l_Player = ObjectAccessor::FindPlayer(p_ReceiverGuid);
                if (!l_Player || !l_Player->GetSession())
                    return;

                l_Player->GetSession()->SendPacket(&l_Data);
            }
            else
                SendMessageToSet(&l_Data, true);

            break;
        }
        case EmoteTypes::EmoteLoop:
        case EmoteTypes::StateLoop:
            SetUInt32Value(UNIT_FIELD_EMOTE_STATE, p_EmoteId);
            break;
        default:
            break;
    }
}

bool Unit::IsDamageReducedByArmor(SpellSchoolMask schoolMask, SpellInfo const* spellInfo, uint8 effIndex)
{
    /// spells with SPELL_SCHOOL_MASK_ALL can't be reduced by armor
    if (schoolMask == SPELL_SCHOOL_MASK_ALL)
        return false;

    // only physical spells damage gets reduced by armor
    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
        return false;

    if (spellInfo)
    {
        switch (spellInfo->Id)
        {
            case Stagger::HEAVY_STAGGER:
            case Stagger::MODERATE_STAGGER:
            case Stagger::LIGHT_STAGGER:
                return false;
            default:
                break;
        }

        /// Chaos spells, even if changing school mask, don't get reduced by armor
        if (spellInfo->SchoolMask == SPELL_SCHOOL_MASK_ALL)
            return false;

        // there are spells with no specific attribute but they have "ignores armor" in tooltip
        if (spellInfo->AttributesCu & SPELL_ATTR0_CU_IGNORE_ARMOR)
            return false;

        /// Trauma (bleed) should be reduced by armor (it's exception)
        if (spellInfo->Id == 215537)
            return true;

        // bleeding effects are not reduced by armor
        if (effIndex < spellInfo->EffectCount)
        {
            if (spellInfo->Effects[effIndex].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE ||
                spellInfo->Effects[effIndex].ApplyAuraName == SPELL_AURA_PERIODIC_SCHOOL_DAMAGE ||
                spellInfo->Effects[effIndex].Effect == SPELL_EFFECT_SCHOOL_DAMAGE)
                if (spellInfo->GetEffectMechanicMask(effIndex) & (1LL << MECHANIC_BLEED))
                    return false;
        }

        for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
        {
            if (spellInfo->Effects[i].Effect == SPELL_EFFECT_SCHOOL_DAMAGE &&
                spellInfo->GetEffectMechanicMask(i) & (1LL << MECHANIC_BLEED))
                return false;
        }

        if (spellInfo->Id == 111400) ///< Burning Rush
            return false;
    }

    return true;
}

void Unit::CalcArmorReducedDamage(DamageInfo& p_DamageInfo)
{
    Unit* l_Victim = p_DamageInfo.GetTarget();
    uint32 l_NewDamage = 0;
    float l_Armor = float(l_Victim->GetArmor(this));

    // bypass enemy armor by SPELL_AURA_BYPASS_ARMOR_FOR_CASTER
    int32 l_ArmorBypassPct = 0;
    AuraEffectList const & l_ReductionAuras = l_Victim->GetAuraEffectsByType(SPELL_AURA_BYPASS_ARMOR_FOR_CASTER);
    for (AuraEffectList::const_iterator l_Itr = l_ReductionAuras.begin(); l_Itr != l_ReductionAuras.end(); ++l_Itr)
    {
        if ((*l_Itr)->GetCasterGUID() == GetGUID())
            l_ArmorBypassPct += (*l_Itr)->GetAmount();
    }
    l_Armor = CalculatePct(l_Armor, 100 - std::min(l_ArmorBypassPct, 100));

    // Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura
    l_Armor += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_NORMAL);

    if (SpellInfo const* l_SpellInfo = p_DamageInfo.GetSpellInfo())
        if (Player* l_ModOwner = GetSpellModOwner())
            l_ModOwner->ApplySpellMod(l_SpellInfo->Id, SPELLMOD_IGNORE_ARMOR, l_Armor);

    AuraEffectList const& l_ArmorPenetrationPct = GetAuraEffectsByType(SPELL_AURA_MOD_ARMOR_PENETRATION_PCT);
    for (AuraEffectList::const_iterator l_SecondItr = l_ArmorPenetrationPct.begin(); l_SecondItr != l_ArmorPenetrationPct.end(); ++l_SecondItr)
    {
        if ((*l_SecondItr)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
            l_Armor -= CalculatePct(l_Armor, (*l_SecondItr)->GetAmount());
    }

    if (l_Armor < 0.0f)
        l_Armor = 0.0f;

    int l_ScalingLevel = std::max(getLevel() > GT_MAX_LEVEL ? GT_MAX_LEVEL : getLevel(), 1);
    float l_TmpValue = l_Armor / (l_Armor + g_ArmorMitigationByLvlTable.LookupEntry(l_ScalingLevel)->m_Multiplier);

    if (l_TmpValue < 0.0f)
        l_TmpValue = 0.0f;

    // Wod MaxValue
    if (l_TmpValue > 0.85f)
        l_TmpValue = 0.85f;

    int32 l_Damage = p_DamageInfo.GetAmount();
    p_DamageInfo.SetAmount(std::max((int)(l_Damage - (l_Damage * l_TmpValue)), 1));

    if (SpellInfo const* l_SpellInfo = p_DamageInfo.GetSpellInfo())
        LOG_SPELL(this, l_SpellInfo->Id, "Spell %s: CalcArmorReducedDamage(): %i - %f = %i", l_SpellInfo->GetNameForLogging().c_str(), l_Damage, l_TmpValue * 100.0f, l_NewDamage); ///<  ISO C++11 does not allow conversion from string literal to 'char *'
}

bool Unit::IsSpellResisted(Unit* victim, SpellSchoolMask schoolMask, SpellInfo const* spellInfo)
{
    if (!victim || !victim->isAlive())
        return false;

    Player* owner = GetCharmerOrOwnerPlayerOrPlayerItself();
    if (!owner)
        return false;

    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0 && (!spellInfo || (spellInfo->AttributesEx4 & SPELL_ATTR4_IGNORE_RESISTANCES) == 0))
    {
        float victimResistance = float(victim->GetResistance(schoolMask));
        victimResistance += float(owner->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));

        victimResistance -= float(owner->GetSpellPenetrationItemMod());

        // Resistance can't be lower then 0.
        if (victimResistance < 0.0f)
            victimResistance = 0.0f;

        uint32 level = victim->getLevelForTarget(owner);
        float resistanceConstant = 0.0f;

        // @TODO update me http://wow.gamepedia.com/Combat_rating_system & SimulationCraft
        if (level >= 61)
            resistanceConstant = 150 + ((level - 60) * (level - 67.5));
        else if (level >= 21 && level <= 60)
            resistanceConstant = 50 + ((level - 20) * 2.5);
        else
            resistanceConstant = 50.0f;

        float averageResist = victimResistance / (victimResistance + resistanceConstant);

        int32 tmp = int32(averageResist * 10000);
        int32 rand = irand(0, 10000);
        return (rand < tmp);
    }
    return false;
}

void Unit::CalcAbsorbResist(DamageInfo& p_DamageInfo)
{
    if (!p_DamageInfo.GetTarget() || !p_DamageInfo.GetTarget()->isAlive() || !p_DamageInfo.GetAmount())
        return;

    SpellInfo const* l_SpellInfo = p_DamageInfo.GetSpellInfo();
    SpellSchoolMask l_SchoolMask = p_DamageInfo.GetSchoolMask();
    Unit* l_Victim = p_DamageInfo.GetTarget();

    // Magic damage, check for resists
    // Ignore spells that cant be resisted
    if ((l_SchoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0 && (!l_SpellInfo || (l_SpellInfo->AttributesEx4 & SPELL_ATTR4_IGNORE_RESISTANCES) == 0))
    {
        float l_VictimResistance = float(l_Victim->GetResistance(l_SchoolMask));

        Player* l_PlayerOwner = GetCharmerOrOwnerPlayerOrPlayerItself();

        l_VictimResistance += float(l_PlayerOwner ? l_PlayerOwner->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, l_SchoolMask) : GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, l_SchoolMask));

        if (l_PlayerOwner)
            l_VictimResistance -= float(l_PlayerOwner->GetSpellPenetrationItemMod());

        // Resistance can't be lower then 0.
        if (l_VictimResistance < 0.0f)
            l_VictimResistance = 0.0f;

        uint32 l_Level = l_Victim->getLevelForTarget(this);
        float l_ResistanceConstant = 0.0f;

        // http://elitistjerks.com/f15/t29453-combat_ratings_level_85_cataclysm/
        if (l_Level >= 61)
            l_ResistanceConstant = 150 + ((l_Level - 60) * (l_Level - 67.5));
        else if (l_Level >= 21 && l_Level <= 60)
            l_ResistanceConstant = 50 + ((l_Level - 20) * 2.5);
        else
            l_ResistanceConstant = 50.0f;

        float l_AverageResist = l_VictimResistance / (l_VictimResistance + l_ResistanceConstant);
        float l_DiscreteResistProbability[11];
        for (uint32 l_Itr = 0; l_Itr < 11; ++l_Itr)
        {
            l_DiscreteResistProbability[l_Itr] = 0.5f - 2.5f * fabs(0.1f * l_Itr - l_AverageResist);
            if (l_DiscreteResistProbability[l_Itr] < 0.0f)
                l_DiscreteResistProbability[l_Itr] = 0.0f;
        }

        if (l_AverageResist <= 0.1f)
        {
            l_DiscreteResistProbability[0] = 1.0f - 7.5f * l_AverageResist;
            l_DiscreteResistProbability[1] = 5.0f * l_AverageResist;
            l_DiscreteResistProbability[2] = 2.5f * l_AverageResist;
        }

        float l_Rand = float(rand_norm());
        uint32 l_Itr = 0;
        float probabilitySum = l_DiscreteResistProbability[0];

        while (l_Rand >= probabilitySum && l_Itr < 10)
            probabilitySum += l_DiscreteResistProbability[++l_Itr];

        float l_DamageResisted = float(p_DamageInfo.GetAmount() * l_Itr / 10);

/*
        AuraEffectList const& l_ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
        for (AuraEffectList::const_iterator l_SecondItr = l_ResIgnoreAuras.begin(); l_SecondItr != l_ResIgnoreAuras.end(); ++l_SecondItr)
            if ((*l_SecondItr)->GetMiscValue() & l_SchoolMask)
                AddPct(l_DamageResisted, -(*l_SecondItr)->GetAmount());*/

        p_DamageInfo.Resist(uint32(l_DamageResisted));
    }

    // Ignore Absorption Auras
    float l_AuraAbsorbMod = 0;
    AuraEffectList const& l_AbsIgnoreAurasA = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL);
    for (AuraEffectList::const_iterator l_Itr = l_AbsIgnoreAurasA.begin(); l_Itr != l_AbsIgnoreAurasA.end(); ++l_Itr)
    {
        if (!((*l_Itr)->GetMiscValue() & l_SchoolMask))
            continue;

        if ((*l_Itr)->GetAmount() > l_AuraAbsorbMod)
            l_AuraAbsorbMod = float((*l_Itr)->GetAmount());
    }

    AuraEffectList const& l_AbsIgnoreAurasB = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL);
    for (AuraEffectList::const_iterator l_Itr = l_AbsIgnoreAurasB.begin(); l_Itr != l_AbsIgnoreAurasB.end(); ++l_Itr)
    {
        if (!((*l_Itr)->GetMiscValue() & l_SchoolMask))
            continue;

        if (((*l_Itr)->GetAmount() > l_AuraAbsorbMod) && (*l_Itr)->IsAffectingSpell(l_SpellInfo))
            l_AuraAbsorbMod = float((*l_Itr)->GetAmount());
    }
    RoundToInterval(l_AuraAbsorbMod, 0.0f, 100.0f);

    // We're going to call functions which can modify content of the list during iteration over it's elements
    // Let's copy the list so we can prevent iterator invalidation
    AuraEffectList l_VSchoolAbsorbCopy(l_Victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_ABSORB));
    l_VSchoolAbsorbCopy.sort(JadeCore::AbsorbAuraOrderPred());

    // absorb without mana cost
    for (AuraEffectList::iterator l_Itr = l_VSchoolAbsorbCopy.begin(); (l_Itr != l_VSchoolAbsorbCopy.end()) && (p_DamageInfo.GetAmount() > 0); ++l_Itr)
    {
        AuraEffect* l_AbsorbAuraEff = *l_Itr;
        Aura* l_Aura = l_AbsorbAuraEff->GetBase();

        // Check if aura was removed during iteration - we don't need to work on such auras
        AuraApplication const* l_AuraApplication = l_AbsorbAuraEff->GetBase()->GetApplicationOfTarget(l_Victim->GetGUID());
        if (!l_AuraApplication)
            continue;

        /// Check if we can select information about aura spell
        if (!l_AuraApplication->GetBase() || !l_AuraApplication->GetBase()->GetSpellInfo())
            continue;

        /// Check MiscValue from SpellInfo, not from loaded inforamation
        SpellInfo const* l_CurrentSpellInfo = sSpellMgr->GetSpellInfo(l_AuraApplication->GetBase()->GetSpellInfo()->Id);
        uint8 l_SpellEffIndex = l_AbsorbAuraEff->GetEffIndex();
        if (!l_CurrentSpellInfo)
            continue;
        int32 l_SpellEffMiscValue = l_CurrentSpellInfo->Effects[l_SpellEffIndex].MiscValue;

        /// Check if this school absorb spell should have effect on current spell
        if (!(l_SpellEffMiscValue & l_SchoolMask))
            continue;

        /// Check for physical damage - for example Demonbolt (SPELL_SCHOOL_MASK_ALL) into Anti-Magic Shell (SPELL_SCHOOL_MASK_SPELL)
        if (!(l_SpellEffMiscValue & SPELL_SCHOOL_MASK_NORMAL) && (l_SchoolMask & SPELL_SCHOOL_MASK_NORMAL))
            continue;

        // get amount which can be still absorbed by the aura
        int32 l_CurrentAbsorb = l_AbsorbAuraEff->GetAmount();
        // aura with infinite absorb amount - let the scripts handle absorption amount, set here to 0 for safety
        if (l_CurrentAbsorb < 0)
            l_CurrentAbsorb = 0;

        uint32 l_TempAbsorb = uint32(l_CurrentAbsorb);

        bool l_DefaulPrevented = false;

        l_AbsorbAuraEff->GetBase()->CallScriptEffectAbsorbHandlers(l_AbsorbAuraEff, l_AuraApplication, p_DamageInfo, l_TempAbsorb, l_DefaulPrevented);
        l_CurrentAbsorb = l_TempAbsorb;

        if (l_DefaulPrevented)
        {
            if (l_Victim != this && l_CurrentAbsorb != -1 && l_Aura->GetCaster())
            {
                uint32 l_InterruptSpellId = l_SpellInfo ? l_SpellInfo->Id : 0;
                l_Victim->SendAbsorbLog(this, l_InterruptSpellId, l_CurrentSpellInfo->Id, l_Aura->GetCaster(), l_CurrentAbsorb);
            }
            continue;
        }

        // Apply absorb mod auras
        AddPct(l_CurrentAbsorb, -l_AuraAbsorbMod);

        // absorb must be smaller than the damage itself
        l_CurrentAbsorb = RoundToInterval(l_CurrentAbsorb, 0, int32(p_DamageInfo.GetAmount()));

        p_DamageInfo.Absorb(l_CurrentAbsorb);

        l_TempAbsorb = l_CurrentAbsorb;

        l_Aura->CallScriptEffectAfterAbsorbHandlers(l_AbsorbAuraEff, l_AuraApplication, p_DamageInfo, l_TempAbsorb);

        if (l_Victim != this && l_TempAbsorb != -1 && l_Aura->GetCaster())
        {
            uint32 l_InterruptSpellId = l_SpellInfo ? l_SpellInfo->Id : 0;
            l_Victim->SendAbsorbLog(this, l_InterruptSpellId, l_CurrentSpellInfo->Id, l_Aura->GetCaster(), l_TempAbsorb);
        }

        /// Check if our aura is using amount to count damage
        if (l_AbsorbAuraEff->GetAmount() >= 0 && !l_AbsorbAuraEff->GetSpellInfo()->HasAttribute(SPELL_ATTR6_NOT_LIMIT_ABSORB))
        {
            // Reduce shield amount
            if (l_AbsorbAuraEff->GetBase()->GetId() != 201633)  ///< Earthen Shield Totem absorb should not be reduced after use
                l_AbsorbAuraEff->SetAmount(l_AbsorbAuraEff->GetAmount() - l_CurrentAbsorb);

            // Aura cannot absorb anything more - remove it
            if (l_AbsorbAuraEff->GetAmount() <= 0 && l_AbsorbAuraEff->GetBase()->GetId() != 115069 && l_AbsorbAuraEff->GetBase()->GetId() != 152280) // Custom MoP Script - Stance of the Sturdy Ox shoudn't be removed at any damage, Defile too
            {
                if (l_AbsorbAuraEff->GetBase()->GetId() != 203538)  ///< Greater Blessing Of King should not be removed even with 0 remaining absorb
                    l_Aura->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
            }
        }
    }

    // absorb by mana cost
    AuraEffectList l_VManaShieldCopy(l_Victim->GetAuraEffectsByType(SPELL_AURA_MANA_SHIELD));
    for (AuraEffectList::const_iterator l_Itr = l_VManaShieldCopy.begin(); (l_Itr != l_VManaShieldCopy.end()) && (p_DamageInfo.GetAmount() > 0); ++l_Itr)
    {
        AuraEffect* l_AbsorbAuraEff = *l_Itr;
        Aura* l_Aura = l_AbsorbAuraEff->GetBase();

        // Check if aura was removed during iteration - we don't need to work on such auras
        AuraApplication const* l_AuraApplication = l_AbsorbAuraEff->GetBase()->GetApplicationOfTarget(l_Victim->GetGUID());
        if (!l_AuraApplication)
            continue;
        // check damage school mask

        uint32 l_AbsorbMask = l_AbsorbAuraEff->GetMiscValue();
        if (!(l_AbsorbMask & l_SchoolMask))
            continue;

        if ((l_SchoolMask & ~l_AbsorbMask) == SPELL_SCHOOL_MASK_NORMAL)
        {
            l_SchoolMask = SPELL_SCHOOL_MASK_NORMAL;
            p_DamageInfo.ChangeSchoolMask(l_SchoolMask);
            continue;
        }

        // get amount which can be still absorbed by the aura
        int32 l_CurrentAbsorb = l_AbsorbAuraEff->GetAmount();
        // aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety
        if (l_CurrentAbsorb < 0)
            l_CurrentAbsorb = 0;

        uint32 l_TempAbsorb = l_CurrentAbsorb;

        bool l_DefaultPrevented = false;

        l_AbsorbAuraEff->GetBase()->CallScriptEffectManaShieldHandlers(l_AbsorbAuraEff, l_AuraApplication, p_DamageInfo, l_TempAbsorb, l_DefaultPrevented);
        l_CurrentAbsorb = l_TempAbsorb;

        if (l_DefaultPrevented)
            continue;

        AddPct(l_CurrentAbsorb, -l_AuraAbsorbMod);

        // absorb must be smaller than the damage itself
        l_CurrentAbsorb = RoundToInterval(l_CurrentAbsorb, 0, int32(p_DamageInfo.GetAmount()));

        int32 l_ManaReduction = l_CurrentAbsorb;

        // lower absorb amount by talents
        if (float l_ManaMultiplier = l_AbsorbAuraEff->GetSpellInfo()->Effects[l_AbsorbAuraEff->GetEffIndex()].CalcValueMultiplier(l_AbsorbAuraEff->GetCaster()))
            l_ManaReduction = int32(float(l_ManaReduction) * l_ManaMultiplier);

        int32 l_ManaTaken = -l_Victim->ModifyPower(POWER_MANA, -l_ManaReduction);

        // take case when mana has ended up into account
        l_CurrentAbsorb = l_CurrentAbsorb ? int32(float(l_CurrentAbsorb) * (float(l_ManaTaken) / float(l_ManaReduction))) : 0;

        p_DamageInfo.Absorb(l_CurrentAbsorb);

        l_TempAbsorb = l_CurrentAbsorb;
        l_Aura->CallScriptEffectAfterManaShieldHandlers(l_AbsorbAuraEff, l_AuraApplication, p_DamageInfo, l_TempAbsorb);

        // Check if our aura is using amount to count damage
        if (l_AbsorbAuraEff->GetAmount() >= 0)
        {
            l_AbsorbAuraEff->SetAmount(l_AbsorbAuraEff->GetAmount() - l_CurrentAbsorb);
            if ((l_AbsorbAuraEff->GetAmount() <= 0))
                l_Aura->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
        }
    }

    // split damage auras - only when not damaging self
    if (l_Victim != this)
    {
        // We're going to call functions which can modify content of the list during iteration over it's elements
        // Let's copy the list so we can prevent iterator invalidation
        AuraEffectList l_VSplitDamagePctCopy(l_Victim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_PCT));
        for (AuraEffectList::iterator l_Itr = l_VSplitDamagePctCopy.begin(), next; (l_Itr != l_VSplitDamagePctCopy.end()) &&  (p_DamageInfo.GetAmount() > 0); ++l_Itr)
        {
            // Check if aura was removed during iteration - we don't need to work on such auras
            AuraApplication const* l_AuraApplication = (*l_Itr)->GetBase()->GetApplicationOfTarget(l_Victim->GetGUID());
            if (!l_AuraApplication)
                continue;

            // check damage school mask
            if (!((*l_Itr)->GetMiscValue() & l_SchoolMask))
                continue;

            // Damage can be splitted only if aura has an alive caster
            Unit* l_Caster = (*l_Itr)->GetCaster();
            if (!l_Caster || (l_Caster == l_Victim) || !l_Caster->IsInWorld() || !l_Caster->isAlive())
                continue;

            uint32 l_SplitDamage = CalculatePct(p_DamageInfo.GetAmount(), (*l_Itr)->GetAmount());

            bool l_DefaulPrevented = false;

            (*l_Itr)->GetBase()->CallScriptEffectSplitDamageHandlers((*l_Itr), l_AuraApplication, p_DamageInfo, l_SplitDamage, l_DefaulPrevented);

            if (l_DefaulPrevented || l_SplitDamage == 0)
                continue;

            // absorb must be smaller than the damage itself
            l_SplitDamage = RoundToInterval(l_SplitDamage, uint32(0), uint32(p_DamageInfo.GetAmount()));

            p_DamageInfo.Absorb(l_SplitDamage);

            // check if caster is immune to damage
            if (l_Caster->IsImmunedToDamage(l_SchoolMask))
            {
                l_Victim->SendSpellMiss(l_Caster, (*l_Itr)->GetSpellInfo()->Id, SPELL_MISS_IMMUNE);
                continue;
            }

            // don't damage caster if he has immunity
            if (l_Caster->IsImmunedToDamage((*l_Itr)->GetSpellInfo()))
                continue;

            SpellNonMeleeDamage l_SplittedDamageInfo(this, l_Caster, l_SplitDamage, (*l_Itr)->GetSpellInfo(), DIRECT_DAMAGE, (*l_Itr)->GetBase()->GetSpellXSpellVisualID(), WeaponAttackType::BaseAttack);
            l_SplittedDamageInfo.ChangeSchoolMask(SpellSchoolMask(l_SchoolMask));

            DealDamageMods(l_SplittedDamageInfo);

            // Need to remove all auras breakable by damage.
            l_Caster->RemoveAurasBreakableByDamage();

            SendSpellNonMeleeDamageLog(l_SplittedDamageInfo);

            CleanDamage l_CleanDamage = CleanDamage(l_SplittedDamageInfo.GetUnmitigatedAmount(), 0, WeaponAttackType::BaseAttack, MELEE_HIT_NORMAL);
            DealDamage(l_Caster, l_SplittedDamageInfo.GetAmount(), &l_CleanDamage, DIRECT_DAMAGE, l_SchoolMask, (*l_Itr)->GetSpellInfo(), false, p_DamageInfo.GetAbsorb());
        }
    }
}

void Unit::CalcHealAbsorb(Unit* p_Victim, const SpellInfo* p_HealSpell, uint32& p_HealAmount, uint32 &p_Absorb)
{
    if (!p_HealAmount)
        return;

    int32 l_RemainingHeal = p_HealAmount;

    // Need remove expired auras after
    bool l_ExistExpired = false;

    DamageInfo l_DamageInfo(this, p_Victim, p_HealAmount, p_HealAmount, p_HealSpell, DamageEffectType::HEAL);

    // absorb without mana cost
    AuraEffectList const& l_VHealAbsorb = p_Victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);
    for (AuraEffectList::const_iterator l_Itr = l_VHealAbsorb.begin(); l_Itr != l_VHealAbsorb.end() && l_RemainingHeal > 0; ++l_Itr)
    {
        AuraEffect* l_AbsorbAuraEff = *l_Itr;
        Aura* l_Aura = l_AbsorbAuraEff->GetBase();

        // Check if aura was removed during iteration - we don't need to work on such auras
        AuraApplication const* l_AuraApplication = l_AbsorbAuraEff->GetBase()->GetApplicationOfTarget(p_Victim->GetGUID());
        if (!l_AuraApplication)
            continue;
        if (!(l_AbsorbAuraEff->GetMiscValue() & p_HealSpell->SchoolMask))
            continue;

        // Max Amount can be absorbed by this aura
        int32 l_CurrentAbsorb = (*l_Itr)->GetAmount();
        // aura with infinite absorb amount - let the scripts handle absorption amount, set here to 0 for safety
        if (l_CurrentAbsorb < 0)
            l_CurrentAbsorb = 0;

        uint32 l_TempAbsorb = uint32(l_CurrentAbsorb);

        bool l_DefaultPrevented = false;

        l_AbsorbAuraEff->GetBase()->CallScriptEffectAbsorbHandlers(l_AbsorbAuraEff, l_AuraApplication, l_DamageInfo, l_TempAbsorb, l_DefaultPrevented);
        l_CurrentAbsorb = l_TempAbsorb;

        if (l_DefaultPrevented)
            continue;

        // absorb must be smaller than the damage itself
        l_CurrentAbsorb = RoundToInterval(l_CurrentAbsorb, 0, int32(l_DamageInfo.GetAmount()));

        l_DamageInfo.Absorb(l_CurrentAbsorb);

        l_TempAbsorb = l_CurrentAbsorb;
        l_Aura->CallScriptEffectAfterAbsorbHandlers(l_AbsorbAuraEff, l_AuraApplication, l_DamageInfo, l_TempAbsorb);

        // Check if our aura is using amount to count damage
        if (l_AbsorbAuraEff->GetAmount() >= 0)
        {
            // Reduce shield amount
            l_AbsorbAuraEff->SetAmount(l_AbsorbAuraEff->GetAmount() - l_CurrentAbsorb);
            // Aura cannot absorb anything more - remove it
            if (l_AbsorbAuraEff->GetAmount() <= 0)
                l_ExistExpired = true;
        }
    }

    // Remove all expired absorb auras
    if (l_ExistExpired)
    {
        for (AuraEffectList::const_iterator l_Itr = l_VHealAbsorb.begin(); l_Itr != l_VHealAbsorb.end();)
        {
            AuraEffect* l_AuraEffect = *l_Itr;
            ++l_Itr;
            if (l_AuraEffect->GetAmount() <= 0)
            {
                uint32 l_RemovedAura = p_Victim->m_removedAurasCount;
                l_AuraEffect->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
                if (l_RemovedAura+1 < p_Victim->m_removedAurasCount)
                    l_Itr = l_VHealAbsorb.begin();
            }
        }
    }

    p_Absorb = l_DamageInfo.GetAbsorb();
    p_HealAmount -= p_Absorb;
}

void Unit::AttackerStateUpdate (Unit* p_Victim, WeaponAttackType p_AttackType, bool p_Extra)
{
    if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
        return;

    if (!p_Victim->isAlive())
        return;

    if (!IsAIEnabled || !GetMap()->Instanceable())
        if ((p_AttackType == WeaponAttackType::BaseAttack || p_AttackType == WeaponAttackType::OffAttack) && !IsWithinLOSInMap(p_Victim))
            return;

    CombatStart(p_Victim);
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);

    if (p_AttackType != WeaponAttackType::BaseAttack && p_AttackType != WeaponAttackType::OffAttack)
        return;                                             // ignore ranged case

    // melee attack spell casted at main hand attack only - no normal melee dmg dealt
    if (p_AttackType == WeaponAttackType::BaseAttack && m_currentSpells[CURRENT_MELEE_SPELL] && !p_Extra)
        m_currentSpells[CURRENT_MELEE_SPELL]->cast();
    else
    {
        // attack can be redirected to another target
        p_Victim = GetMeleeHitRedirectTarget(p_Victim);

        bool l_CheatGod = p_Victim->IsPlayer() && p_Victim->ToPlayer()->GetCommandStatus(PlayerCommandStates::CHEAT_GOD);

        CalcDamageInfo l_DamageInfo(this, p_Victim, 0, GetMeleeDamageSchoolMask(), DIRECT_DAMAGE, p_AttackType);
        CalculateMeleeDamage(&l_DamageInfo);
        // Send log damage message to client
        DealDamageMods(l_DamageInfo);

        if (!l_CheatGod)
            DealMeleeDamage(&l_DamageInfo, true);

        SendAttackStateUpdate(&l_DamageInfo);

        //TriggerAurasProcOnEvent(damageInfo);
        ProcDamageAndSpell(l_DamageInfo.GetTarget(), l_DamageInfo.procAttacker, l_DamageInfo.procVictim, l_DamageInfo.procEx, l_DamageInfo);

        if (l_CheatGod)
            DealMeleeDamage(&l_DamageInfo, true);

        if (ToCreature() && ToCreature()->IsAIEnabled)
            ToCreature()->AI()->OnMeleeAttackDone(p_Victim, &l_DamageInfo, p_AttackType);
    }
}

void Unit::HandleProcExtraAttackFor(Unit* victim)
{
    while (m_extraAttacks)
    {
        AttackerStateUpdate(victim, WeaponAttackType::BaseAttack, true);
        --m_extraAttacks;
    }
}

MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit* victim, WeaponAttackType attType)
{
    // This is only wrapper

    // Miss chance based on melee
    float miss_chance = MeleeSpellMissChance(victim, NULL, attType);

    // Critical hit chance
    float crit_chance = GetUnitCriticalChance(attType, victim);

    float dodge_chance = victim->GetUnitDodgeChance(this);
    float block_chance = victim->GetUnitBlockChance(this);
    float parry_chance = victim->GetUnitParryChance(this);

    return RollMeleeOutcomeAgainst(victim, attType, int32(crit_chance*100), int32(miss_chance*100), int32(dodge_chance*100), int32(parry_chance*100), int32(block_chance*100));
}

MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit* victim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance)
{
    if (victim->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS) && victim->isInFront(this))
        return MELEE_HIT_MISS;
    else
    {
        if (Vehicle* l_Vehicle = victim->GetVehicleKit())
        {
            for (int8 l_I = 0; l_I < MAX_VEHICLE_SEATS; ++l_I)
            {
                if (Unit* l_Passenger = l_Vehicle->GetPassenger(l_I))
                {
                    if (l_Passenger->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS) && l_Passenger->isInFront(this))
                        return MELEE_HIT_MISS;
                }
            }
        }
    }

    MeleeHitOutcome l_HitResult = MELEE_HIT_NORMAL;
    SpellMissInfo l_SpellResult = SPELL_MISS_NONE;
    if (victim->ToCreature() && victim->IsAIEnabled)
        ((Unit*)victim)->ToCreature()->GetAI()->CheckHitResult(l_HitResult, l_SpellResult, (Unit*)this);

    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode())
        return MELEE_HIT_EVADE;

    int32    sum = 0, tmp = 0;
    int32    roll = urand (0, 10000);

    int32 attackerLevel = getLevelForTarget(victim);
    int32 victimLevel = victim->getLevelForTarget(this);

    tmp = miss_chance;

    if (tmp > 0 && roll < (sum += tmp))
        return MELEE_HIT_MISS;

    // always crit against a sitting target (except 0 crit chance)
    if (victim->IsPlayer() && crit_chance > 0 && !victim->IsStandState())
       return MELEE_HIT_CRIT;

    // Dodge chance
    // only players can't dodge if attacker is behind
    if (victim->IsPlayer() && victim->HasInArc(M_PI, this))
    {
        // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE) * 100;
        dodge_chance = int32(float(dodge_chance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));

        tmp = dodge_chance;
        if ((tmp > 0) && roll < (sum += tmp))
        {
            victim->RemoveAura(195630); ///< Elusive Brawler :  Increased Dodge chance until your next successful Dodge.

            ///< Item - Monk T21 Brewmaster 4P Bonus
            if (victim->IsPlayer())
            {
                if (AuraEffect* l_AuraEffect = victim->GetAuraEffect(251830, EFFECT_0))
                {
                    if (!victim->ToPlayer()->HasSpellCooldown(251830))
                    {
                        uint32 l_Cooldown = (l_AuraEffect->GetAmount() / 10) * IN_MILLISECONDS;
                        victim->ToPlayer()->ReduceSpellCooldown(115181, l_Cooldown);
                        victim->ToPlayer()->AddSpellCooldown(251830, 0, 1 * IN_MILLISECONDS);
                    }
                }
            }

            return MELEE_HIT_DODGE;
        }
    }

    // parry & block chances
    // check if attack comes from behind, nobody can parry or block if attacker is behind
    if (victim->HasInArc(M_PI, this))
    {
        if (victim->IsPlayer() || !(victim->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_PARRY))
        {
            int32 tmp2 = parry_chance;
            if (tmp2 > 0 && roll < (sum += tmp2))
                return MELEE_HIT_PARRY;
        }

        if (victim->IsPlayer() || !(victim->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_BLOCK))
        {
            tmp = block_chance;
            if (tmp > 0 && roll < (sum += tmp))
            {
                if (victim->IsPlayer())
                    sScriptMgr->OnPlayerBlock(victim->ToPlayer(), this);
                return MELEE_HIT_BLOCK;
            }
        }
    }

    // Critical chance
    tmp = crit_chance;

    if (tmp > 0 && roll < (sum += tmp))
    {
        if (!(GetTypeId() == TYPEID_UNIT && (ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_CRIT)))
            return MELEE_HIT_CRIT;
    }

    // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
    if (attType != WeaponAttackType::RangedAttack && (IsPlayer() || ToCreature()->isPet()) &&
        victim->ToCreature() && !victim->ToCreature()->isPet() && victim->getLevelForTarget(this) > (attackerLevel + 3))
    {
        tmp = (10 + 10 * (victimLevel - attackerLevel)) * 100;
        if (roll < (sum += tmp))
        {
            sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: GLANCING <%d, %d)", sum - 4000, sum);
            return MELEE_HIT_GLANCING;
        }
    }

    // mobs can score crushing blows if they're 4 or more levels above victim
    if (attackerLevel >= victimLevel + 4 &&
        // can be from by creature (if can) or from controlled player that considered as creature
        !IsControlledByPlayer() &&
        !(GetTypeId() == TYPEID_UNIT && ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_CRUSH))
    {
        // add 2% chance per level, min. is 15%
        tmp = attackerLevel - victimLevel * 1000 - 1500;
        if (roll < (sum += tmp))
        {
            sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: CRUSHING <%d, %d)", sum - tmp, sum);
            return MELEE_HIT_CRUSHING;
        }
    }

    return MELEE_HIT_NORMAL;
}

uint8 Unit::getLevelForTarget(WorldObject const* target) const
{
    Unit const* l_Unit = target ? target->ToUnit() : nullptr;
    Creature const* l_Creature = ToCreature();

    if (!l_Unit || !l_Creature || (IsPetGuardianStuff() && GetCharmerOrOwnerPlayerOrPlayerItself()))
        return getLevel();

    CreatureTemplate const* l_Template = l_Creature->GetCreatureTemplate();
    int32 l_Level       = getLevel();
    int32 l_LevelTarget = l_Unit->getLevel();
    int32 l_LevelMin    = l_Template->ScaleLevelMin;
    int32 l_LevelMax    = l_Template->ScaleLevelMax;
    int8 l_LevelDelta   = l_Template->ScaleLevelDelta;

    /// Apply owner level scaling data if the summon don't have scaling data
    /// Will be usefull for totems and pets summoned by creature in the continents
    if (Unit* l_Owner = GetOwner())
    {
        if (Creature* l_OwnerCreature = l_Owner->ToCreature())
        {
            CreatureTemplate const* l_OwnerTemplate = l_OwnerCreature->GetCreatureTemplate();
            if (!l_LevelMin && !l_LevelMax && l_OwnerTemplate->ScaleLevelMin && l_OwnerTemplate->ScaleLevelMax)
            {
                l_LevelTarget = l_Unit->getLevel();
                l_LevelMin = l_OwnerTemplate->ScaleLevelMin;
                l_LevelMax = l_OwnerTemplate->ScaleLevelMax;
                l_LevelDelta = l_OwnerTemplate->ScaleLevelDelta;
            }
        }
    }

    if (l_LevelMin && l_LevelMax)
    {
        if (l_LevelMin <= l_LevelTarget && l_LevelTarget <= l_LevelMax)
            l_Level = l_LevelTarget;
        else if (l_LevelMin >= l_LevelTarget)
            l_Level = l_LevelMin;
        else if (l_LevelMax <= l_LevelTarget)
            l_Level = l_LevelMax;

        l_Level += l_LevelDelta;
    }

    if (l_Level < 1)
        return 1;

    if (l_Level > 123)
        return 123;

    return uint8(l_Level);
}

uint32 Unit::CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct, Unit* p_Victim)
{
    float min_damage, max_damage;

    Creature* l_Creature = ToCreature();
    if (IsPlayer() && (normalized || !addTotalPct))
        ToPlayer()->CalculateMinMaxDamage(attType, normalized, addTotalPct, min_damage, max_damage);
    else if (l_Creature && !GetOwner())
    {
        float weapon_mindamage = 0;
        float weapon_maxdamage = 0;

        uint8 l_LevelForTarget = getLevelForTarget(p_Victim);
        CreatureLevelStat const* l_ScaleStat = l_Creature->GetScaleLevelStat(l_LevelForTarget);
        if (!CanUseAttackType(attType))
        {
            weapon_mindamage = 0;
            weapon_maxdamage = 0;
        }
        else if (l_ScaleStat)
        {
            weapon_mindamage = l_ScaleStat->baseMinDamage;
            weapon_maxdamage = l_ScaleStat->baseMaxDamage;
        }
        else
        {
            weapon_mindamage = GetBaseWeaponDamageRange(attType, MINDAMAGE);
            weapon_maxdamage = GetBaseWeaponDamageRange(attType, MAXDAMAGE);
        }

        float l_DmgMultiplier = l_Creature->GetCreatureTemplate()->dmg_multiplier;

        if (l_Creature->IsAIEnabled)
            l_Creature->AI()->GetDamageMultiplier(l_DmgMultiplier);

        float l_BaseValue = 0.0f;
        float l_BasePct = 0.0f;
        float l_TotalValue = 0.0f;

        switch (attType)
        {
            case WeaponAttackType::RangedAttack:
                l_BaseValue     = GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_VALUE);
                l_BasePct       = GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT);
                l_TotalValue    = GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE);

                min_damage = ((l_BaseValue + weapon_mindamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct;
                max_damage = ((l_BaseValue + weapon_maxdamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct;
                break;
            case WeaponAttackType::BaseAttack:
                l_BaseValue     = GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_VALUE);
                l_BasePct       = GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT);
                l_TotalValue    = GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE);

                min_damage = ((l_BaseValue + weapon_mindamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct;
                max_damage = ((l_BaseValue + weapon_maxdamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct;
                break;
            case WeaponAttackType::OffAttack:
                l_BaseValue     = GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_VALUE);
                l_BasePct       = GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT);
                l_TotalValue    = GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE);

                min_damage = (((l_BaseValue + weapon_mindamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct) / 2;
                max_damage = (((l_BaseValue + weapon_maxdamage) * l_DmgMultiplier * l_BasePct + l_TotalValue) * m_ModDamagePercentTotalPct) / 2;
                break;
            default:
                min_damage = 0.0f;
                max_damage = 0.0f;
                break;
        }
    }
    else
    {
        switch (attType)
        {
            case WeaponAttackType::RangedAttack:
                min_damage = m_WeaponDamage[WeaponAttackType::RangedAttack][MINDAMAGE];
                max_damage = m_WeaponDamage[WeaponAttackType::RangedAttack][MAXDAMAGE];
                break;
            case WeaponAttackType::BaseAttack:
                min_damage = m_WeaponDamage[WeaponAttackType::BaseAttack][MINDAMAGE];
                max_damage = m_WeaponDamage[WeaponAttackType::BaseAttack][MAXDAMAGE];
                break;
            case WeaponAttackType::OffAttack:
                min_damage = m_WeaponDamage[WeaponAttackType::OffAttack][MINDAMAGE];
                max_damage = m_WeaponDamage[WeaponAttackType::OffAttack][MAXDAMAGE];
                break;
            default:
                min_damage = 0.0f;
                max_damage = 0.0f;
                break;
        }
    }

    if (min_damage > max_damage)
        std::swap(min_damage, max_damage);

    if (max_damage == 0.0f)
        max_damage = 5.0f;

    return urand((uint32)min_damage, (uint32)max_damage);
}

void Unit::SendMeleeAttackStart(Unit* victim)
{
    WorldPacket data(SMSG_ATTACK_START, 2 * (16 + 2));

    uint64 attackerGuid = GetGUID();
    uint64 victimGuid = victim->GetGUID();

    data.appendPackGUID(attackerGuid);
    data.appendPackGUID(victimGuid);

    SendMessageToSet(&data, true);
}

void Unit::SendMeleeAttackStop(Unit* victim)
{
    WorldPacket data(SMSG_ATTACK_STOP, (2 * (16 + 2)) + 1);

    uint64 victimGUID = victim ? victim->GetGUID() : 0;
    uint64 attackerGUID = GetGUID();

    data.appendPackGUID(attackerGUID);
    data.appendPackGUID(victimGUID);
    data.WriteBit(victim ? victim->isDead() : false);
    data.FlushBits();

    SendMessageToSet(&data, true);
}

bool Unit::isSpellBlocked(Unit* victim, SpellInfo const* spellProto, WeaponAttackType /*attackType*/)
{
    // These spells can't be blocked
    if (spellProto && spellProto->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)
        return false;

    if (victim->HasInArc(M_PI, this))
    {
        // Check creatures flags_extra for disable block
        if (victim->GetTypeId() == TYPEID_UNIT &&
            victim->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_BLOCK)
                return false;

        if (roll_chance_f(victim->GetUnitBlockChance(this)))
            return true;
    }
    return false;
}

bool Unit::isBlockCritical()
{
    if (roll_chance_i(GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_CRIT_CHANCE)))
        return true;
    return false;
}

int32 Unit::GetMechanicResistChance(const SpellInfo* spell)
{
    if (!spell)
        return 0;
    int32 resist_mech = 0;
    for (uint8 eff = 0; eff < spell->EffectCount; ++eff)
    {
        if (!spell->Effects[eff].IsEffect())
           break;
        int32 effect_mech = spell->GetEffectMechanic(eff);
        if (effect_mech)
        {
            int32 temp = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
            if (resist_mech < temp)
                resist_mech = temp;
        }
    }
    return resist_mech;
}

uint32 Unit::GetDodgeChance(const Unit* p_Victim)
{
    int32 dodgeChance = int32(p_Victim->GetUnitDodgeChance(this));

    /// Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
    dodgeChance += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE);
    dodgeChance = int32(float(dodgeChance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
    /// Reduce dodge chance by attacker expertise rating
    if (dodgeChance < 0)
        dodgeChance = 0;

    return dodgeChance;
}

uint32 Unit::GetParryChance(const Unit* p_Victim)
{
    int32 l_ParryChance = int32(p_Victim->GetUnitParryChance(this));

    if (l_ParryChance < 0)
        l_ParryChance = 0;

    return l_ParryChance;
}

uint32 Unit::GetBlockChance(const Unit* p_Victim)
{
    int32 l_BlockChance = int32(p_Victim->GetUnitBlockChance(this));

    if (l_BlockChance < 0)
        l_BlockChance = 0;

    return l_BlockChance;
}

// Melee based spells hit result calculations
SpellMissInfo Unit::MeleeSpellHitResult(Unit* victim, SpellInfo const* spell)
{
    if (victim->isInFront(this) && victim->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS))
        return SPELL_MISS_DEFLECT;
    else
    {
        if (Vehicle* l_Vehicle = victim->GetVehicleKit())
        {
            for (int8 l_I = 0; l_I < MAX_VEHICLE_SEATS; ++l_I)
            {
                if (Unit* l_Passenger = l_Vehicle->GetPassenger(l_I))
                {
                    if (l_Passenger->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS) && l_Passenger->isInFront(this))
                        return SPELL_MISS_DEFLECT;
                }
            }
        }
    }

    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore
    // resist and deflect chances
    if (spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT || spell->IsInterruptSpell())
        return SPELL_MISS_NONE;

    WeaponAttackType attType = WeaponAttackType::BaseAttack;

    // Check damage class instead of attack type to correctly handle judgments
    // - they are meele, but can't be dodged/parried/deflected because of ranged dmg class
    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
        attType = WeaponAttackType::RangedAttack;

    int32 roll = urand(0, 10000);

    // Roll miss
    int32 tmp = int32(MeleeSpellMissChance(victim, spell, attType)) * 100;
    if (roll < tmp)
        return SPELL_MISS_MISS;

    // Roll resist
    // Chance resist mechanic (select max value from every mechanic spell effect)
    int32 l_Resist = (victim->GetMechanicResistChance(spell) * 100);
    tmp += l_Resist;
    if (roll < l_Resist)
        return SPELL_MISS_RESIST;

    // Charge spells aren't suppose to take care of dodge parry or block
    if (spell->AttributesCu & SPELL_ATTR0_CU_CHARGE)
        return SPELL_MISS_NONE;

    bool canDodge = true;
    bool canParry = true;
    bool canBlock = spell->AttributesEx3 & SPELL_ATTR3_BLOCKABLE_SPELL;

    // Same spells cannot be parry/dodge
    if (spell->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)
        return SPELL_MISS_NONE;

    // Ranged attacks can only miss, resist and deflect
    if (attType == WeaponAttackType::RangedAttack)
    {
        // only if in front
        if (victim->HasInArc(M_PI, this) || victim->HasAura(186265) /* Hunter's Aspectof the Turtle */)
        {
            int32 deflect_chance = victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
            tmp+=deflect_chance;
            if (roll < deflect_chance)
                return SPELL_MISS_DEFLECT;
        }

        /// Since MoP, Hunter ranged attacks are dodgeable
        /// http://www.mmo-champion.com/threads/1090757-Hunter-ranged-attacks-now-able-to-be-dodged-in-MOP
        /// http://eu.battle.net/wow/en/forum/topic/9338743978
        if (getClass() == CLASS_HUNTER)
            canParry = false;
        else
            return SPELL_MISS_NONE;
    }

    // Check for attack from behind
    if (!victim->HasInArc(M_PI, this))
    {
        if (spell->AttributesCu & SPELL_ATTR0_CU_REQ_CASTER_BEHIND_TARGET)
            canParry = false;
        else
        {
            // Can`t dodge from behind in PvP (but its possible in PvE)
            if (victim->IsPlayer())
                canDodge = false;
            // Can`t parry or block
            canParry = false;
            canBlock = false;
        }
    }
    // Check creatures flags_extra for disable parry
    if (victim->GetTypeId() == TYPEID_UNIT)
    {
        uint32 flagEx = victim->ToCreature()->GetFlagsExtra();
        if (flagEx & CREATURE_FLAG_EXTRA_NO_PARRY)
            canParry = false;
        // Check creatures flags_extra for disable block
        if (flagEx & CREATURE_FLAG_EXTRA_NO_BLOCK)
            canBlock = false;
    }
    // Ignore combat result aura
    AuraEffectList const& ignore = GetAuraEffectsByType(SPELL_AURA_IGNORE_COMBAT_RESULT);
    for (AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
    {
        if (!(*i)->IsAffectingSpell(spell))
            continue;
        switch ((*i)->GetMiscValue())
        {
            case MELEE_HIT_DODGE:
                canDodge = false;
                break;
            case MELEE_HIT_BLOCK:
                canBlock = false;
                break;
            case MELEE_HIT_PARRY:
                canParry = false;
                break;
            default:
                break;
        }
    }

    if (canDodge)
    {
        int32 l_DodgeChance = GetDodgeChance(victim) * 100;
        tmp += l_DodgeChance;
        if (roll < l_DodgeChance)
        {
            victim->RemoveAura(195630); ///< Elusive Brawler :  Increased Dodge chance until your next successful Dodge.

            ///< Item - Monk T21 Brewmaster 4P Bonus
            if (victim->IsPlayer())
            {
                if (AuraEffect* l_AuraEffect = victim->GetAuraEffect(251830, EFFECT_0))
                {
                    if (!victim->ToPlayer()->HasSpellCooldown(251830))
                    {
                        uint32 l_Cooldown = (l_AuraEffect->GetAmount() / 10) * IN_MILLISECONDS;
                        victim->ToPlayer()->ReduceSpellCooldown(115181, l_Cooldown);
                        victim->ToPlayer()->AddSpellCooldown(251830, 0, 1 * IN_MILLISECONDS);
                    }
                }
            }

            return SPELL_MISS_DODGE;
        }
    }

    if (canParry)
    {
        int32 l_ParryChance = GetParryChance(victim) * 100;
        tmp += l_ParryChance;
        if (roll < l_ParryChance)
            return SPELL_MISS_PARRY;
    }

    if (canBlock)
    {
        int32 l_BlockChance = GetBlockChance(victim) * 100;

        tmp += l_BlockChance;
        if (roll < l_BlockChance)
            return SPELL_MISS_BLOCK;
    }

    return SPELL_MISS_NONE;
}

SpellMissInfo Unit::MagicSpellHitResult(Unit* p_Victim, SpellInfo const* p_Spell)
{
    if (p_Victim->isInFront(this) && p_Victim->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS))
        return SPELL_MISS_DEFLECT;
    else
    {
        if (Vehicle* l_Vehicle = p_Victim->GetVehicleKit())
        {
            for (int8 l_I = 0; l_I < MAX_VEHICLE_SEATS; ++l_I)
            {
                if (Unit* l_Passenger = l_Vehicle->GetPassenger(l_I))
                {
                    if (l_Passenger->HasAuraType(SPELL_AURA_DEFLECT_FRONT_SPELLS) && l_Passenger->isInFront(this))
                        return SPELL_MISS_DEFLECT;
                }
            }
        }
    }

    // Can`t miss on dead target (on skinning for example)
    if ((!p_Victim->isAlive() && p_Victim->GetTypeId() != TYPEID_PLAYER) || p_Spell->HasAttribute(SPELL_ATTR3_IGNORE_HIT_RESULT))
        return SPELL_MISS_NONE;

    if (p_Spell->IsInterruptSpell())
    {
        // only deflect works here
        int32 l_DeflectChance = p_Victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS);
        if (roll_chance_i(l_DeflectChance))
            return SPELL_MISS_DEFLECT;

        return SPELL_MISS_NONE;
    }

    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore
    // resist and deflect chances
    if (p_Spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)
        return SPELL_MISS_NONE;

    uint32 l_Roll = urand(0, 10000);

    // Roll miss
    uint32 l_Tmp = uint32(MagicSpellMissChance(p_Victim, p_Spell)) * 100;
    if (l_Roll < l_Tmp)
        return SPELL_MISS_MISS;

    // Roll resist
    // Chance resist mechanic (select max value from every mechanic spell effect)
    l_Tmp += p_Victim->GetMechanicResistChance(p_Spell) * 100;
    if (l_Roll < l_Tmp)
        return SPELL_MISS_RESIST;

    // cast by caster in front of victim
    if (p_Victim->HasInArc(M_PI, this) || p_Victim->HasAura(186265) /* Hunter's Aspect of the Turtle */)
    {
        int32 l_DeflectChance = p_Victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
        l_Tmp += l_DeflectChance;
        if (l_Roll < l_Tmp)
            return SPELL_MISS_DEFLECT;
    }

    /// Same spells cannot be parry/dodge
    if (p_Spell->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)
        return SPELL_MISS_NONE;

    return SPELL_MISS_NONE;
}

// Calculate spell hit result can be:
// Every spell can: Evade/Immune/Reflect/Sucesful hit
// For melee based spells:
//   Miss
//   Dodge
//   Parry
// For spells
//   Resist
SpellMissInfo Unit::SpellHitResult(Unit* p_Victim, SpellInfo const* p_Spell, bool p_CanReflect)
{
    /// Ghostly shell heal for every negative dot it prevented
    if (p_Victim->HasAura(202534))
    {
        SpellInfo const* l_CloakOfShadowsInfo = sSpellMgr->GetSpellInfo(31224);

        if (l_CloakOfShadowsInfo)
        {
            if (!p_Spell->IsPositive() && !p_Spell->IsPassive() && p_Spell->HasEffect(SPELL_EFFECT_APPLY_AURA) && l_CloakOfShadowsInfo->CanDispelAura(p_Spell))
            {
                Player* l_Player = p_Victim->ToPlayer();
                int8 l_Rank = l_Player->GetRankOfArtifactPowerId(1066);
                SpellInfo const* l_GhostlyShellHealInfo = sSpellMgr->GetSpellInfo(202536);

                if (l_GhostlyShellHealInfo)
                {
                    int32 l_HealPct = l_Rank * l_GhostlyShellHealInfo->Effects[EFFECT_0].BasePoints;

                    uint64 l_VictimGUID = p_Victim->GetGUID();

                    /// Prevent Stack overflow in VERY SPECIFIC case
                    l_Player->AddDelayedEvent([l_Player, l_VictimGUID, l_HealPct]() -> void
                    {
                        Unit* l_Victim = sObjectAccessor->GetUnit(*l_Player, l_VictimGUID);
                        if (!l_Victim)
                            return;

                        l_Player->CastCustomSpell(l_Victim, 202536, &l_HealPct, nullptr, nullptr, true);
                    }, 1);
                }
            }
        }
    }

    /// Greater fade should make any spell to miss, whatever flag they have. EXCEPTION: Allies should be able to heal the priest.
    if (p_Victim->HasAura(213602) && !(p_Victim == this) && !p_Spell->IsInterruptSpell() && !IsValidAssistTarget(p_Victim))
        return SPELL_MISS_MISS;

    /// Dungeon/Raid bosses are immuned to pet taunts
    if (p_Victim->ToCreature() && p_Victim->ToCreature()->IsDungeonBoss() && p_Spell->HasEffect(SpellEffects::SPELL_EFFECT_ATTACK_ME) && IsPetGuardianStuff())
        return SpellMissInfo::SPELL_MISS_IMMUNE;

    // Check for immune
    if (p_Victim->IsImmunedToSpell(p_Spell) && (!IsFriendlyTo(p_Victim) || p_Spell->Id == 197341))
    {
        if (p_Victim->ToCreature() && p_Victim->IsAIEnabled) ///< For Immune AI
        {
            MeleeHitOutcome l_HitResult = MELEE_HIT_MISS;
            SpellMissInfo l_SpellResult = SPELL_MISS_IMMUNE;
            p_Victim->ToCreature()->GetAI()->CheckHitResult(l_HitResult, l_SpellResult, this, p_Spell);
        }
        return SPELL_MISS_IMMUNE;
    }

    /// Spells will miss if entity is further away than specified radius, Eg. Deceiver's Veil on Kil'jaeden
    Unit::AuraEffectList const& l_List = GetAuraEffectsByType(AuraType::SPELL_AURA_FOG_OF_WAR);
    for (Unit::AuraEffectList::const_iterator l_Iter = l_List.begin(); l_Iter != l_List.end(); ++l_Iter)
    {
        if (GetDistance(p_Victim) > float((*l_Iter)->GetMiscValue()))
            return SpellMissInfo::SPELL_MISS_MISS;
    }

    /// Cyclone victim is immune to healing
    if (p_Victim->HasAura(209753) && p_Spell->IsHealingSpell())
        return SPELL_MISS_IMMUNE;

    // All positive spells can`t miss
    // TODO: client not show miss log for this spells - so need find info for this in db2 and use it!
    if ((p_Spell->IsPositive() || p_Spell->IsHealingSpell())
        &&(!IsHostileTo(p_Victim)))  // prevent from affecting enemy by "positive" spell
        return SPELL_MISS_NONE;
    // Check for immune
    if (p_Victim->IsImmunedToDamage(p_Spell) && !IsFriendlyTo(p_Victim))
        return SPELL_MISS_IMMUNE;

    if (this == p_Victim)
        return SPELL_MISS_NONE;

    // Return evade for units in evade mode
    if (p_Victim->GetTypeId() == TYPEID_UNIT && p_Victim->ToCreature()->IsInEvadeMode())
        return SPELL_MISS_EVADE;

    /// Try victim reflect spell - 'Spell Reflect normally does not work with AoE spells'
    if (p_CanReflect && (!p_Spell->IsTargetingArea() || p_Spell->Id == 3355 || p_Spell->Id == 7268)) ///< Reflects with Freezin Trap and Arcane Missiles/Psychic Scream
    {
        int32 l_ReflectChance = p_Victim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
        Unit::AuraEffectList const& l_MReflectSpellsSchool = p_Victim->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
        for (Unit::AuraEffectList::const_iterator l_Itr = l_MReflectSpellsSchool.begin(); l_Itr != l_MReflectSpellsSchool.end(); ++l_Itr)
            if ((*l_Itr)->GetMiscValue() & p_Spell->GetSchoolMask())
                l_ReflectChance += (*l_Itr)->GetAmount();
        if (l_ReflectChance > 0 && roll_chance_i(l_ReflectChance) && !p_Spell->IsPositive() && !IsFriendlyTo(p_Victim))
        {
            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
            DamageInfo l_DamageInfo(this, p_Victim, 1, p_Spell, DamageEffectType::SPELL_DIRECT_DAMAGE);
            ProcDamageAndSpell(p_Victim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG, PROC_EX_REFLECT, l_DamageInfo);
            return SPELL_MISS_REFLECT;
        }
    }

    ///< Hunter's Aspect of The Turtle should get miss from certain spells that don't work generically
    if (p_Victim->HasAura(186265))
    {
        switch (p_Spell->Id)
        {
            case 199804: ///< Between the Eyes
            case 185763: ///< Pistol Shot
            case 202895: ///< Blunderbuss
            case 206505: ///< A Murder of Crows
            case 13812:  ///< Explosive Trap
                return SPELL_MISS_DEFLECT;
            default:
                break;
        }
    }

    if (p_Spell->AttributesEx8 & SPELL_ATTR8_CANT_MISS)
        return SPELL_MISS_NONE;

    // Taunt-like spells can't miss since 4.0.1
    if (p_Spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
        return SPELL_MISS_NONE;

    Unit * l_Checker = (isTotem() && GetOwner()) ? GetOwner() : this;

    switch (p_Spell->DmgClass)
    {
        case SPELL_DAMAGE_CLASS_RANGED:
        case SPELL_DAMAGE_CLASS_MELEE:
            return l_Checker->MeleeSpellHitResult(p_Victim, p_Spell);
        case SPELL_DAMAGE_CLASS_NONE:
        {
            // Warrior Charge
            if (p_Spell->SpellFamilyName == SPELLFAMILY_WARRIOR && (p_Spell->SpellFamilyFlags[0] & 0x01000000))
                return l_Checker->MeleeSpellHitResult(p_Victim, p_Spell);

            return SPELL_MISS_NONE;
        }
        case SPELL_DAMAGE_CLASS_MAGIC:
            return l_Checker->MagicSpellHitResult(p_Victim, p_Spell);
    }
    return SPELL_MISS_NONE;
}

float Unit::GetUnitDodgeChance(Unit const* p_Attacker) const
{
    if (!HasAuraWithAttribute(SPELL_ATTR10_CAN_DODGE_ON_CAST, 10) && (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED)))
        return 0.0f;

    float l_Chance = 0.0f;

    if (IsPlayer())
        l_Chance = GetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE);
    else
    {
        if (!ToCreature()->isTotem())
        {
            if (getLevelForTarget(p_Attacker) >= p_Attacker->getLevelForTarget(this))
            {
                uint8 l_LevelDiff = std::min(getLevelForTarget(p_Attacker) - p_Attacker->getLevelForTarget(this), STATS_CHANCE_SIZE - 1);
                l_Chance = g_BaseEnemyDodgeChance[l_LevelDiff];
            }

            l_Chance += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
        }
    }

    return l_Chance;
}

float Unit::GetUnitParryChance(Unit const* p_Attacker) const
{
    if ((!HasAuraWithAttribute(SPELL_ATTR10_CAN_PARRY_BLOCK_ON_CAST, 10) && IsNonMeleeSpellCasted(false)) || HasUnitState(UNIT_STATE_CONTROLLED))
        return 0.0f;

    float l_Chance = 0.0f;

    if (Player const* l_Player = ToPlayer())
    {
        if (l_Player->CanParry())
        {
            Item* l_Item = l_Player->GetWeaponForAttack(WeaponAttackType::BaseAttack, true);
            if (!l_Item)
                l_Item = l_Player->GetWeaponForAttack(WeaponAttackType::OffAttack, true);

            if (l_Item)
                l_Chance = GetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE);
        }
    }
    else if (GetTypeId() == TYPEID_UNIT)
    {
        if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
        {
            if (getLevelForTarget(p_Attacker) >= p_Attacker->getLevelForTarget(this))
            {
                uint8 l_LevelDiff = std::min(getLevelForTarget(p_Attacker) - p_Attacker->getLevelForTarget(this), STATS_CHANCE_SIZE - 1);
                l_Chance = g_BaseEnemyParryChance[l_LevelDiff];
            }

            l_Chance += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);

            /// 7.0.3 any source ?
            // Tanks specializations have a better chance to parry (+3%)
            if (p_Attacker->IsPlayer())
                if (p_Attacker->ToPlayer()->IsActiveSpecTankSpec())
                    l_Chance += 3.0f;
        }
    }

    return l_Chance;
}

float Unit::GetUnitMissChancePhysical(Unit const* p_Attacker, WeaponAttackType p_AttType) const
{
    float l_Chance = 0.0f;

    if (getLevelForTarget(p_Attacker) >= p_Attacker->getLevelForTarget(this))
    {
        uint8 l_LevelDiff = std::min(getLevelForTarget(p_Attacker) - p_Attacker->getLevelForTarget(this), STATS_CHANCE_SIZE - 1);
        l_Chance += g_BaseMissChancePhysical[l_LevelDiff];
    }

    if (p_AttType == WeaponAttackType::RangedAttack)
        l_Chance += GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
    else
        l_Chance += -(GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE));

    return l_Chance;
}

float Unit::GetUnitMissChanceSpell(Unit const* p_Attacker) const
{
    float l_Chance = 0.0f;

    if (getLevelForTarget(p_Attacker) >= p_Attacker->getLevelForTarget(this))
    {
        /// https://wow.gamepedia.com/Spell_hit
        /// Players will not miss against targets up to 3 levels above their character level.
        uint8 l_LevelDiff = getLevelForTarget(p_Attacker) - p_Attacker->getLevelForTarget(this);
        if (l_LevelDiff > 3)
            l_Chance += (float(l_LevelDiff) - 3.0f) * 3.0f;
    }

    l_Chance += -GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE);

    return l_Chance;
}

float Unit::GetUnitBlockChance(Unit const* p_Attacker) const
{
    if (HasUnitState(UNIT_STATE_CONTROLLED))
    {
        SpellInfo const* l_CurrentSpellInfo = nullptr;

        if (!(m_currentSpells[CURRENT_CHANNELED_SPELL] &&
            (l_CurrentSpellInfo = m_currentSpells[CURRENT_CHANNELED_SPELL]->GetSpellInfo()) &&
            (m_currentSpells[CURRENT_CHANNELED_SPELL]->GetSpellInfo()->AttributesEx10 & SPELL_ATTR10_CAN_PARRY_BLOCK_ON_CAST)))   /// If spell does not allow defensive abilities while channeling
        {
            if (IsNonMeleeSpellCasted(false))
                return 0.0f;
        }
    }


    if (Player const* l_Player = ToPlayer())
    {
        if (l_Player->CanBlock())
        {
            Item* l_Item = l_Player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
            if (l_Item && !l_Item->CantBeUse())
                return GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE);
        }
        // is player but has no block ability or no not broken shield equipped
        return 0.0f;
    }
    else
    {
        if (ToCreature()->isTotem())
            return 0.0f;
        else
        {
            float l_Block = 3.0f;
            l_Block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);

            if (getLevelForTarget(p_Attacker) > p_Attacker->getLevelForTarget(this))
            {
                uint8 l_LevelDiff = getLevelForTarget(p_Attacker) - p_Attacker->getLevelForTarget(this);
                l_Block += 1.5f * l_LevelDiff;
            }

            return l_Block;
        }
    }
}

float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victim) const
{
    float crit;

    if (IsPlayer())
    {
        switch (attackType)
        {
            case WeaponAttackType::BaseAttack:
                crit = GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE);
                break;
            case WeaponAttackType::OffAttack:
                crit = GetFloatValue(PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE);
                break;
            case WeaponAttackType::RangedAttack:
                crit = GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE);
                break;
            default:
                crit = 0.0f;
                break;
        }
    }
    // Pets have 100% of owner's crit_chance
    else
    {
        crit = (GetOwner() && GetOwner()->IsPlayer()) ? GetOwner()->ToPlayer()->GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE) : 5.0f;

        crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
        crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
    }

    // flat aura mods
    if (attackType == WeaponAttackType::RangedAttack)
        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE);
    else
        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE);

    crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);

    if (crit < 0.0f)
        crit = 0.0f;
    return crit;
}

void Unit::_DeleteRemovedAuras()
{
    while (!m_removedAuras.empty())
    {
        Aura* l_Aura = m_removedAuras.front();
        l_Aura->Delink();
        delete l_Aura;
        m_removedAuras.pop_front();
    }
}

void Unit::_UpdateSpells(uint32 time)
{
    bool l_LogRaid = GetMap()->IsRaid();
    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::time_point();

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
        start = std::chrono::steady_clock::now();

    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
        _UpdateAutoRepeatSpell();

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[0] += l_Now - start;
        start = l_Now;
    }

    // remove finished spells from current pointers
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
    {
        if (m_currentSpells[i] && m_currentSpells[i]->getState() == SPELL_STATE_FINISHED)
        {
            m_currentSpells[i]->SetReferencedFromCurrent(false);
            m_currentSpells[i] = NULL;                      // remove pointer
        }
    }

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[1] += l_Now - start;
        start = l_Now;
    }

    bool l_ShouldLogDiff = GetMapId() == 1520 || l_LogRaid;

    // m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)
    {
        uint32 l_LogTime = l_ShouldLogDiff ? getMSTime() : 0;
        Aura*& i_aura = m_auraUpdateIterator->second;
        uint32 l_ID = i_aura->GetId();                      ///< For logs
        ++m_auraUpdateIterator;                             ///< Need shift to next for allow update if need into aura update
        i_aura->UpdateOwner(time, this);
        if (l_ShouldLogDiff)
        {
            uint32 l_TimeTaken = getMSTime() - l_LogTime;
            if (l_TimeTaken > 5)
                sLog->outAshran("Aura %u taked %u ms to update", l_ID, l_TimeTaken);
        }
    }

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[2] += l_Now - start;
        start = l_Now;
    }

    // remove expired auras - do that after updates(used in scripts?)
    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end();)
    {
        uint32 l_LogTime = l_ShouldLogDiff ? getMSTime() : 0;
        Aura*& i_aura = i->second;
        uint32 l_ID = i_aura->GetId();                      ///< For logs

        if (i->second->IsExpired())
            RemoveOwnedAura(i, AURA_REMOVE_BY_EXPIRE);
        else
            ++i;

        if (l_ShouldLogDiff)
        {
            uint32 l_TimeTaken = getMSTime() - l_LogTime;
            if (l_TimeTaken > 5)
                sLog->outAshran("Aura::RemoveOwnedAura %u taked %u ms to update", l_ID, l_TimeTaken);
        }
    }

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[3] += l_Now - start;
        start = l_Now;
    }

    for (VisibleAuraMap::iterator itr = m_visibleAuras.begin(); itr != m_visibleAuras.end(); ++itr)
        if (itr->second->IsNeedClientUpdate())
            itr->second->ClientUpdate();

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[4] += l_Now - start;
        start = l_Now;
    }

    _DeleteRemovedAuras();

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[5] += l_Now - start;
        start = l_Now;
    }

    if (!m_gameObj.empty())
    {
        GameObjectList::iterator itr;
        for (itr = m_gameObj.begin(); itr != m_gameObj.end();)
        {
            if (!(*itr)->isSpawned())
            {
                (*itr)->SetOwnerGUID(0);
                (*itr)->SetRespawnTime(0);
                (*itr)->Delete();
                m_gameObj.erase(itr++);
            }
            else
                ++itr;
        }
    }

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[6] += l_Now - start;
        start = l_Now;
    }

    if (ToPlayer())
        ToPlayer()->UpdateCharges();

    if (sMapMgr->m_LogMapPerformance || l_LogRaid)
    {
        auto l_Now = std::chrono::steady_clock::now();
        GetMap()->m_UpdateSpellTime[7] += l_Now - start;
        start = l_Now;
    }
}

void Unit::_UpdateAutoRepeatSpell()
{
    // check "real time" interrupts
    // don't cancel spells which are affected by a SPELL_AURA_CAST_WHILE_WALKING or SPELL_AURA_ALLOW_ALL_CASTS_WHILE_WALKING effect
    bool l_AutoShoot = m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == 75; ///< hunter auto shot
    if (((IsPlayer() && ToPlayer()->IsMoving()) || IsNonMeleeSpellCasted(false, false, true, l_AutoShoot)) &&
        !HasAuraTypeWithAffectMask(SPELL_AURA_CAST_WHILE_WALKING, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo) && !HasAuraType(SPELL_AURA_ALLOW_ALL_CASTS_WHILE_WALKING) && !l_AutoShoot &&
        !(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->AttributesEx5 & SPELL_ATTR5_USABLE_WHILE_MOVING))
    {
        // cancel wand shoot
        InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
        m_AutoRepeatFirstCast = true;
        return;
    }

    // apply delay (Auto Shot - 75 not affected)
    if (m_AutoRepeatFirstCast && getAttackTimer(WeaponAttackType::RangedAttack) < 500 && !l_AutoShoot)
        setAttackTimer(WeaponAttackType::RangedAttack, 500);

    m_AutoRepeatFirstCast = false;

    // castroutine
    if (isAttackReady(WeaponAttackType::RangedAttack))
    {
        // Check if able to cast
        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->CheckCast(true) != SPELL_CAST_OK)
        {
            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
            return;
        }

        // we want to shoot
        Spell* spell = new Spell(this, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo, TRIGGERED_FULL_MASK);
        spell->prepare(&(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_targets));

        // all went good, reset attack
        resetAttackTimer(WeaponAttackType::RangedAttack);
    }
}

void Unit::SetCurrentCastedSpell(Spell* pSpell)
{
    ASSERT(pSpell);                                         // NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells

    CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();

    if (pSpell == m_currentSpells[CSpellType])             // avoid breaking self
        return;

    // break same type spell if it is not delayed
    if (Spell* l_CurrentSpell = GetCurrentSpell(CSpellType)) ///< l_CurrentSpell is not used
            InterruptSpell(CSpellType, false);

    // special breakage effects:
    switch (CSpellType)
    {
        case CURRENT_GENERIC_SPELL:
        {
            // generic spells always break channeled not delayed spells
            /// Some exception requires hackfixes : see Spell::GetNonInterruptableSpellBy();
            uint32 l_Except = pSpell->GetNonInterruptableSpellBy(pSpell->GetSpellInfo()->Id);
            if (!(pSpell->getTriggerCastFlags() & TRIGGERED_IGNORE_CAST_IN_PROGRESS) &&
                !(m_currentSpells[CURRENT_CHANNELED_SPELL] && (m_currentSpells[CURRENT_CHANNELED_SPELL]->GetSpellInfo()->Id == l_Except)))
                InterruptSpell(CURRENT_CHANNELED_SPELL, false);

            // autorepeat breaking
            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
            {
                // break autorepeat if not Auto Shot
                if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
                    InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
                m_AutoRepeatFirstCast = true;
            }
            if (pSpell->m_spellInfo->CalcCastTime(this) > 0)
                AddUnitState(UNIT_STATE_CASTING);

            break;
        }
        case CURRENT_CHANNELED_SPELL:
        {
            // channel spells always break generic non-delayed and any channeled spells
            if (!(pSpell->m_spellInfo->AttributesEx9 & SPELL_ATTR9_CASTABLE_WHILE_CAST_IN_PROGRESS))
                InterruptSpell(CURRENT_GENERIC_SPELL, false);

            InterruptSpell(CURRENT_CHANNELED_SPELL);

            // it also does break autorepeat if not Auto Shot
            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&
                m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
                InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
            AddUnitState(UNIT_STATE_CASTING);

            if (pSpell->GetCaster()->ToCreature())
                if (!(pSpell->m_spellInfo->ChannelInterruptFlags & CHANNEL_INTERRUPT_FLAG_INTERRUPT))
                    AddUnitState(UNIT_STATE_MOVE_IN_CASTING);

            break;
        }
        case CURRENT_AUTOREPEAT_SPELL:
        {
            // only Auto Shoot does not break anything
            if (pSpell->m_spellInfo->Id != 75)
            {
                // generic autorepeats break generic non-delayed and channeled non-delayed spells
                InterruptSpell(CURRENT_GENERIC_SPELL, false);
                InterruptSpell(CURRENT_CHANNELED_SPELL, false);
            }
            // special action: set first cast flag
            m_AutoRepeatFirstCast = true;

            break;
        }
        default:
            break; // other spell types don't break anything now
    }

    // current spell (if it is still here) may be safely deleted now
    if (m_currentSpells[CSpellType])
        m_currentSpells[CSpellType]->SetReferencedFromCurrent(false);

    // set new current spell
    m_currentSpells[CSpellType] = pSpell;
    pSpell->SetReferencedFromCurrent(true);

    pSpell->m_selfContainer = &(m_currentSpells[pSpell->GetCurrentContainer()]);
}

void Unit::InterruptSpell(CurrentSpellTypes spellType, bool withDelayed, bool withInstant, Spell* p_InterruptingSpell /*= nullptr*/)
{
    ASSERT(uint8(spellType) < CURRENT_MAX_SPELL);

    //sLog->outDebug(LOG_FILTER_UNITS, "Interrupt spell for unit %u.", GetEntry());
    Spell* spell = m_currentSpells[spellType];
    if (spell
        && (withDelayed || spell->getState() != SPELL_STATE_DELAYED)
        && (withInstant || spell->GetCastTime() > 0))
    {
        // for example, do not let self-stun aura interrupt itself
        if (!spell->IsInterruptable())
            return;

        // send autorepeat cancel message for autorepeat spells
        if (spellType == CURRENT_AUTOREPEAT_SPELL)
            if (IsPlayer())
                ToPlayer()->SendAutoRepeatCancel(this);

        if (spell->getState() != SPELL_STATE_FINISHED)
            spell->cancel();

        if (spell->GetCaster() && spell->GetCaster()->IsPlayer())
        {
            uint32 l_InterruptingSpellID = spell->GetCaster()->m_SpellHelper.GetUint32(eSpellHelpers::LastInterruptingSpell);
            sScriptMgr->OnSpellInterrupt(spell->GetCaster()->ToPlayer(), spell, p_InterruptingSpell, l_InterruptingSpellID);
        }

        if (spell->GetCaster())
        {
            if (Creature* l_Creature = spell->GetCaster()->ToCreature())
            {
                if (l_Creature->IsAIEnabled)
                    l_Creature->AI()->OnSpellInterrupted(spell->GetSpellInfo());
            }
        }

        m_currentSpells[spellType] = NULL;
        spell->SetReferencedFromCurrent(false);
    }
}

void Unit::FinishSpell(CurrentSpellTypes spellType, bool ok /*= true*/)
{
    Spell* spell = m_currentSpells[spellType];
    if (!spell)
        return;

    if (spellType == CURRENT_CHANNELED_SPELL)
        spell->SendChannelUpdate(0);

    spell->finish(ok);
}

bool Unit::IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled, bool skipAutorepeat, bool isAutoshoot, bool skipInstant) const
{
    // We don't do loop here to explicitly show that melee spell is excluded.
    // Maybe later some special spells will be excluded too.

    // if skipInstant then instant spells shouldn't count as being casted
    if (skipInstant && m_currentSpells[CURRENT_GENERIC_SPELL] && !m_currentSpells[CURRENT_GENERIC_SPELL]->GetCastTime())
        return false;

    // generic spells are casted when they are not finished and not delayed
    if (m_currentSpells[CURRENT_GENERIC_SPELL] &&
        (m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_FINISHED) &&
        (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))
    {
        if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
            return true;
    }
    // channeled spells may be delayed, but they are still considered casted
    else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&
        (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))
    {
        if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
            return true;
    }
    // autorepeat spells may be finished or delayed, but they are still considered casted
    else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
        return true;

    return false;
}

void Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)
{
    // generic spells are interrupted if they are not finished or delayed
    if (m_currentSpells[CURRENT_GENERIC_SPELL] && (!spell_id || m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id == spell_id))
        InterruptSpell(CURRENT_GENERIC_SPELL, withDelayed, withInstant);

    // autorepeat spells are interrupted if they are not finished or delayed
    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && (!spell_id || m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == spell_id))
        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, withDelayed, withInstant);

    // channeled spells are interrupted if they are not finished, even if they are delayed
    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && (!spell_id || m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id == spell_id))
        InterruptSpell(CURRENT_CHANNELED_SPELL, true, true);
}

void Unit::InterruptNonMeleeSpellsExcept(bool withDelayed, uint32 except, bool withInstant)
{
    // generic spells are interrupted if they are not finished or delayed
    if (m_currentSpells[CURRENT_GENERIC_SPELL] && m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id != except)
        InterruptSpell(CURRENT_GENERIC_SPELL, withDelayed, withInstant);

    // autorepeat spells are interrupted if they are not finished or delayed
    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != except)
        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, withDelayed, withInstant);

    // channeled spells are interrupted if they are not finished, even if they are delayed
    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id != except)
        InterruptSpell(CURRENT_CHANNELED_SPELL, true, true);
}

Spell* Unit::FindCurrentSpellBySpellId(uint32 spell_id) const
{
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; i++)
        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id == spell_id)
            return m_currentSpells[i];
    return NULL;
}

int32 Unit::GetCurrentSpellCastTime(uint32 spell_id) const
{
    if (Spell const* spell = FindCurrentSpellBySpellId(spell_id))
        return spell->GetCastTime();
    return 0;
}

SpellInfo const* Unit::GetCastSpellInfo(SpellInfo const* spellInfo) const
{
    Unit::AuraEffectList swaps = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS);
    Unit::AuraEffectList const& swaps2 = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2);
    if (!swaps2.empty())
        swaps.insert(swaps.end(), swaps2.begin(), swaps2.end());

    for (AuraEffect const* auraEffect : swaps)
    {
        if (uint32(auraEffect->GetMiscValue()) == spellInfo->Id || auraEffect->IsAffectingSpell(spellInfo))
            if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo(auraEffect->GetAmount()))
                return newInfo;
    }

    return spellInfo;
}

bool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const
{
    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);
}

bool Unit::isInBackInMap(Unit const* target, float distance, float arc) const
{
    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);
}

bool Unit::isInAccessiblePlaceFor(Creature const* c) const
{
    if (IsInWater())
        return c->CanSwim();
    else
        return c->canWalk() || c->CanFly();
}

bool Unit::IsInWater() const
{
    return GetBaseMap()->IsInWater(GetPositionX(), GetPositionY(), GetPositionZ());
}

bool Unit::IsUnderWater() const
{
    return GetBaseMap()->IsUnderWater(GetPositionX(), GetPositionY(), GetPositionZ());
}

void Unit::UpdateUnderwaterState(Map* m, float x, float y, float z)
{
    if (!isPet() && !IsVehicle())
        return;

    LiquidData liquid_status;
    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
    if (!res)
    {
        if (_lastLiquid && _lastLiquid->SpellID)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
        _lastLiquid = NULL;
        return;
    }

    if (uint32 liqEntry = liquid_status.entry)
    {
        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
        if (_lastLiquid && _lastLiquid->SpellID && _lastLiquid->Id != liqEntry)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        if (liquid && liquid->SpellID)
        {
            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
            {
                if (!HasAura(liquid->SpellID))
                    CastSpell(this, liquid->SpellID, true);
            }
            else
                RemoveAurasDueToSpell(liquid->SpellID);
        }

        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_ABOVEWATER);
        _lastLiquid = liquid;
    }
    else if (_lastLiquid && _lastLiquid->SpellID)
    {
        RemoveAurasDueToSpell(_lastLiquid->SpellID);
        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
        _lastLiquid = NULL;
    }
}

void Unit::DeMorph()
{
    RemoveAurasByType(AuraType::SPELL_AURA_CLONE_CASTER);
    SetDisplayId(GetNativeDisplayId());
}

Aura* Unit::_TryStackingOrRefreshingExistingAura(SpellInfo const* newAura, uint32 effMask, Unit* caster, int32* baseAmount /*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/, int32 castItemLevel /*= -1*/)
{
    ASSERT(casterGUID || caster);
    if (!casterGUID)
    {
        if (!caster->ToCreature() || caster->IsAnySummons() || IsAnySummons() || !newAura->StackAmount)
            casterGUID = caster->GetGUID();
    }

    // passive and Incanter's Absorption and auras with different type can stack with themselves any number of times
    if (!newAura->IsMultiSlotAura())
    {
        // check if cast item changed
        uint64 castItemGUID = 0;
        if (castItem)
            castItemGUID = castItem->GetGUID();

        // find current aura from spell and change it's stackamount, or refresh it's duration
        Aura* foundAura = GetOwnedAura(newAura->Id, casterGUID, (newAura->AttributesCu & SPELL_ATTR0_CU_ENCHANT_STACK) ? castItemGUID : 0, 0);
        if (foundAura != nullptr)
        {
            // effect masks do not match
            // extremely rare case
            // let's just recreate aura
            if (effMask != foundAura->GetEffectMask())
                return nullptr;

            // update basepoints with new values - effect amount will be recalculated in ModStackAmount
            for (uint8 i = 0; i < foundAura->GetEffectCount(); ++i)
            {
                if (!foundAura->HasEffect(i))
                    continue;

                int bp;
                if (baseAmount)
                    bp = *(baseAmount + i);
                else
                    bp = foundAura->GetSpellInfo()->Effects[i].BasePoints;

                int32* oldBP = const_cast<int32*>(&(foundAura->GetEffect(i)->m_baseAmount));
                *oldBP = bp;
            }

            // correct cast item guid if needed
            if (castItemGUID != foundAura->GetCastItemGUID())
            {
                uint64* oldGUID = const_cast<uint64 *>(&foundAura->m_castItemGuid);
                *oldGUID = castItemGUID;

                int32* oldItemLevel = const_cast<int32*>(&foundAura->m_castItemLevel);
                *oldItemLevel = castItemLevel;
            }

            // try to increase stack amount
            if (foundAura->GetId() != 980 && foundAura->GetId() != 195403) ///< 195403 = Gale burst aura (monk ww touch of death) was getting reseted by channeled abilities (like fists of fury)
                foundAura->ModStackAmount(1);

            // Agony is refreshed at manual reapply
            if (foundAura->GetId() == 980)
            {
                foundAura->RefreshSpellMods();
                foundAura->RefreshTimers();
            }

            return foundAura;
        }
    }

    return nullptr;
}

void Unit::_AddAura(UnitAura* aura, Unit* caster)
{
    ASSERT(!m_cleanupDone);
    m_ownedAuras.insert(AuraMap::value_type(aura->GetId(), aura));

    _RemoveNoStackAurasDueToAura(aura);

    if (aura->IsRemoved())
        return;

    aura->SetIsSingleTarget(caster && aura->GetSpellInfo()->IsSingleTarget());
    if (aura->IsSingleTarget())
    {
        ASSERT((IsInWorld() && !IsDuringRemoveFromWorld()) || (aura->GetCasterGUID() == GetGUID()));
        // register single target aura
        caster->GetSingleCastAuras().push_back(aura);
        // remove other single target auras
        Unit::AuraList& scAuras = caster->GetSingleCastAuras();
        for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
        {
            if ((*itr) != aura &&
                (*itr)->GetSpellInfo()->IsSingleTargetWith(aura->GetSpellInfo()))
            {
                /// Glyph Of Crittermorph
                if ((*itr)->GetSpellInfo()->Id == 118 && caster->HasAura(56382))
                {
                    if (Unit * l_Owner = aura->GetUnitOwner())
                    {
                        if (l_Owner->ToCreature() && l_Owner->ToCreature()->GetCreatureType() == CREATURE_TYPE_CRITTER)
                        {
                            ++itr;
                            continue;
                        }
                    }
                }

                (*itr)->Remove();
                itr = scAuras.begin();
            }
            else
                ++itr;
        }
    }
}

// creates aura application instance and registers it in lists
// aura application effects are handled separately to prevent aura list corruption
AuraApplication * Unit::_CreateAuraApplication(Aura* aura, uint32 effMask)
{
    if (Unit::GetUnsafeSpellOrAuraScriptHookThreadLocal())
    {
        if (!Unit::IsAlreadyReportedSpell(aura->GetId()))
        {
            std::string l_Channel = g_RealmID != 12 ? "#jarvis-spells" : "#jarvis";

            sLog->outExtChat(l_Channel, "danger", true, "RealmID : %u, worldserver_RelWithDebInfo // UnsafeSpellOrAuraScriptHook: Unit::_CreateAuraApplication %u", g_RealmID, aura->GetId());

            if (sWorld->getBoolConfig(CONFIG_ENABLE_UNSAFE_SPELL_AURA_HOOK_STACK_TRACE))
            {
                ACE_Stack_Trace l_StackTrace;
                sLog->outExtChat(l_Channel, "danger", true, l_StackTrace.c_str());
            }

            Unit::AddReportedSpell(aura->GetId());
        }
    }

    // can't apply aura on unit which is going to be deleted - to not create a memory leak
    ASSERT(!m_cleanupDone);
    // aura musn't be removed
    ASSERT(!aura->IsRemoved());

    // aura mustn't be already applied on target
    ASSERT (!aura->IsAppliedOnTarget(GetGUID()) && "Unit::_CreateAuraApplication: aura musn't be applied on target");

    SpellInfo const* aurSpellInfo = aura->GetSpellInfo();
    uint32 aurId = aurSpellInfo->Id;

    // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
    if (!isAlive() && !aurSpellInfo->IsDeathPersistent() && !(aurSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD) &&
        (GetTypeId() != TYPEID_PLAYER || !ToPlayer()->GetSession()->PlayerLoading()))
        return NULL;

    Unit* caster = aura->GetCaster();

    AuraApplication * aurApp = new AuraApplication(this, caster, aura, effMask);
    m_appliedAuras.insert(AuraApplicationMap::value_type(aurId, aurApp));

    if (aurSpellInfo->AuraInterruptFlags)
    {
        m_interruptableAuras.push_back(aurApp);
        AddInterruptMask(aurSpellInfo->AuraInterruptFlags);
    }

    if (AuraStateType aState = aura->GetSpellInfo()->GetAuraState())
        m_auraStateAuras.insert(AuraStateAurasMap::value_type(uint32(aState), aurApp));

    aura->_ApplyForTarget(this, caster, aurApp);
    return aurApp;
}

void Unit::_ApplyAuraEffect(Aura* aura, uint32 effIndex)
{
    ASSERT(aura);
    ASSERT(aura->HasEffect(effIndex));
    AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
    ASSERT(aurApp);
    if (!aurApp->GetEffectMask())
        _ApplyAura(aurApp, 1<<effIndex);
    else
        aurApp->_HandleEffect(effIndex, true);
}

// handles effects of aura application
// should be done after registering aura in lists
void Unit::_ApplyAura(AuraApplication* p_AurApp, uint32 p_EffMask)
{
    Aura* l_Aura = p_AurApp->GetBase();

    _RemoveNoStackAurasDueToAura(l_Aura);

    if (p_AurApp->GetRemoveMode())
        return;

    /// Update target aura state flag
    if (AuraStateType l_AState = l_Aura->GetSpellInfo()->GetAuraState())
        ModifyAuraState(l_AState, true);

    if (p_AurApp->GetRemoveMode())
        return;

    /// Sitdown on apply aura req seated
    if (l_Aura->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED && !IsSitState())
        SetStandState(UNIT_STAND_STATE_SIT);

    Unit* l_Caster = l_Aura->GetCaster();

    if (p_AurApp->GetRemoveMode())
        return;

    l_Aura->HandleAuraSpecificMods(p_AurApp, l_Caster, true, false);
    l_Aura->HandleAuraSpecificPeriodics(p_AurApp, l_Caster);

    if (l_Aura->GetCasterGUID() != GetGUID() && l_Caster)
        l_Caster->m_unitsWithMyAuras[GetGUID()].push_back(l_Aura->GetId());

    /// Epicurean
    if (IsPlayer() &&
        (getRace() == RACE_PANDAREN_ALLIANCE ||
        getRace() == RACE_PANDAREN_HORDE ||
        getRace() == RACE_PANDAREN_NEUTRAL))
    {
        if (l_Aura->GetSpellInfo()->AttributesEx2 & SPELL_ATTR2_FOOD_BUFF)
        {
            for (uint8 i = 0; i < l_Aura->GetEffectCount(); ++i)
            {
                if (l_Aura->GetEffect(i))
                    l_Aura->GetEffect(i)->ChangeAmount(l_Aura->GetEffect(i)->CalculateAmount(this) * 2);
            }
        }
    }

    /// apply effects of the aura
    for (uint8 i = 0; i < l_Aura->GetEffectCount(); ++i)
    {
        if (p_EffMask & 1<<i && (!p_AurApp->GetRemoveMode()))
            p_AurApp->_HandleEffect(i, true);
    }
}

// removes aura application from lists and unapplies effects
void Unit::_UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode)
{
    AuraApplication* aurApp = i->second;
    ASSERT(aurApp);
    ASSERT(!aurApp->GetRemoveMode());
    ASSERT(aurApp->GetTarget() == this);

    Map::SetLastAuraRemoved(aurApp->GetBase()->GetId());

    if (g_UnsafeSpellOrAuraScriptHook)
    {
        if (!Unit::IsAlreadyReportedSpell(aurApp->GetBase()->GetId()))
        {
            std::string l_Channel = g_RealmID != 12 ? "#jarvis-spells" : "#jarvis";
            sLog->outExtChat(l_Channel, "danger", true, "RealmID : %u, worldserver_RelWithDebInfo // UnsafeSpellOrAuraScriptHook: Unit::_UnapplyAura %u", g_RealmID, aurApp->GetBase()->GetId());
            if (sWorld->getBoolConfig(CONFIG_ENABLE_UNSAFE_SPELL_AURA_HOOK_STACK_TRACE))
            {
                ACE_Stack_Trace l_StackTrace;
                sLog->outExtChat(l_Channel, "danger", true, l_StackTrace.c_str());
            }

            Unit::AddReportedSpell(aurApp->GetBase()->GetId());
        }
    }

    aurApp->SetRemoveMode(removeMode);
    Aura* aura = aurApp->GetBase();

    // dead loop is killing the server probably
    ASSERT(m_removedAurasCount < 0xFFFFFFFF);

    ++m_removedAurasCount;

    Unit* caster = aura->GetCaster();

    // Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove
    m_appliedAuras.erase(i);

    if (aura->GetSpellInfo()->AuraInterruptFlags)
    {
        m_interruptableAuras.remove(aurApp);
        UpdateInterruptMask();
    }

    bool auraStateFound = false;
    AuraStateType auraState = aura->GetSpellInfo()->GetAuraState();
    if (auraState)
    {
        bool canBreak = false;
        // Get mask of all aurastates from remaining auras
        for (AuraStateAurasMap::iterator itr = m_auraStateAuras.lower_bound(auraState); itr != m_auraStateAuras.upper_bound(auraState) && !(auraStateFound && canBreak);)
        {
            if (itr->second == aurApp)
            {
                m_auraStateAuras.erase(itr);
                itr = m_auraStateAuras.lower_bound(auraState);
                canBreak = true;
                continue;
            }
            auraStateFound = true;
            ++itr;
        }
    }

    if (aurApp->GetBase()->GetSpellInfo() && aurApp->GetBase()->GetSpellInfo()->HasExpireTick())
        HandleExpireTick(aurApp);

    aurApp->_Remove();
    aura->_UnapplyForTarget(this, caster, aurApp);

    // remove effects of the spell - needs to be done after removing aura from lists
    for (uint8 itr = 0; itr < aura->GetEffectCount(); ++itr)
    {
        if (aurApp->HasEffect(itr))
            aurApp->_HandleEffect(itr, false);
    }

    // all effect mustn't be applied
    ASSERT(!aurApp->GetEffectMask());

    // Remove totem at next update if totem loses its aura
    if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE && GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem()&& ToTotem()->GetSummonerGUID() == aura->GetCasterGUID())
    {
        if (ToTotem()->GetSpell() == aura->GetId() && ToTotem()->GetTotemType() == TOTEM_PASSIVE)
            ToTotem()->setDeathState(JUST_DIED);
    }

    // Remove aurastates only if were not found
    if (!auraStateFound)
        ModifyAuraState(auraState, false);

    if (caster)
        caster->RemoveEntryInUnitsWithMyAurasList(GetGUID(), aura->GetId());

    aura->HandleAuraSpecificMods(aurApp, caster, false, false);

    // only way correctly remove all auras from list
    //if (removedAuras != m_removedAurasCount) new aura may be added
        i = m_appliedAuras.begin();
}

void Unit::HandleExpireTick(AuraApplication* aurApp)
{
    Aura* l_Aura = aurApp->GetBase();
    Unit* l_Caster = l_Aura->GetCaster();
    SpellInfo const* l_SpellInfo = l_Aura->GetSpellInfo();
    if (!l_Aura || !l_Caster || aurApp->GetRemoveMode() != AURA_REMOVE_BY_EXPIRE)
        return;

    if (l_Caster->IsPlayer() && (l_SpellInfo->HasAttribute(SpellAttr5::SPELL_ATTR5_HASTE_AFFECT_DURATION) || l_SpellInfo->HasAttribute(SpellAttr8::SPELL_ATTR8_HASTE_AFFECT_DURATION)))
    {
        for (uint8 i = 0; i < l_Aura->GetEffectCount(); ++i)
        {
            AuraEffect* l_AuraEffect = l_Aura->GetEffect(i);
            if (!l_AuraEffect)
                continue;

            float l_Amount = l_AuraEffect->GetAmount();
            float l_TicksAmount, l_Remaining = 0.0f;

            if (float(l_AuraEffect->GetAmplitude()) != 0)
                l_Remaining = modf(float(l_Aura->GetMaxDuration()) / float(l_AuraEffect->GetAmplitude()), &l_TicksAmount);

            if (l_Remaining <= 0.05f || l_AuraEffect->GetTickNumber() == 1) ///< Some auras put a "dot" on the target that only deals damage when the aura almost expires: They shouldn't deal any "expire" tick damage (eg: Paladin 'Execution Sentence' 213757)
                continue;

            l_Amount *= l_Remaining;

            switch (l_AuraEffect->GetAuraType())
            {
                case SPELL_AURA_PERIODIC_HEAL:
                {
                    l_Caster->HealBySpell(this, l_SpellInfo, l_Amount);
                    break;
                }
                case SPELL_AURA_PERIODIC_LEECH:
                {
                    l_Caster->HealBySpell(l_Caster, l_SpellInfo, l_Amount);

                    DamageInfo l_DamageInfo(l_Caster, this, l_Amount, l_SpellInfo, DamageEffectType::DOT, WeaponAttackType::BaseAttack);
                    l_Caster->DealDamageMods(l_DamageInfo);
                    l_Caster->CalcAbsorbResist(l_DamageInfo);

                    // Set trigger flag for additional proc
                    uint32 l_ProcAttacker = PROC_FLAG_DONE_PERIODIC;
                    uint32 l_ProcVictim = PROC_FLAG_TAKEN_PERIODIC;
                    uint32 l_ProcEx = PROC_EX_NORMAL_HIT | PROC_EX_INTERNAL_DOT;
                    if (l_DamageInfo.GetAbsorb())
                        l_ProcEx |= PROC_EX_ABSORB;

                    l_Amount = (l_Amount <= l_DamageInfo.GetAbsorb() + l_DamageInfo.GetResist()) ? 0 : (l_Amount - l_DamageInfo.GetAbsorb() - l_DamageInfo.GetResist());
                    if (l_Amount)
                        l_ProcVictim |= PROC_FLAG_TAKEN_DAMAGE;

                    int32 l_OverkillAdditional = l_Amount - GetHealth();
                    if (l_OverkillAdditional < 0)
                        l_OverkillAdditional = 0;

                    l_DamageInfo.SetOverHeal(l_OverkillAdditional);
                    l_Caster->ProcDamageAndSpell(this, l_ProcAttacker, l_ProcVictim, l_ProcEx, l_DamageInfo);

                    l_Caster->DealDamage(this, l_Amount, 0, DamageEffectType::DOT, l_DamageInfo.GetSchoolMask(), l_SpellInfo, true, l_DamageInfo.GetAbsorb());
                    SpellPeriodicAuraLogInfo l_PInfo(l_AuraEffect, uint32(l_Amount), 0, l_DamageInfo.GetAbsorb(), l_DamageInfo.GetResist(), 0.0f, false);
                    SendPeriodicAuraLog(&l_PInfo);
                    break;
                }
                case SPELL_AURA_PERIODIC_DAMAGE:
                {
                    DamageInfo l_DamageInfo(l_Caster, this, l_Amount, l_SpellInfo, DamageEffectType::DOT, WeaponAttackType::BaseAttack);
                    l_Caster->DealDamageMods(l_DamageInfo);
                    l_Caster->CalcAbsorbResist(l_DamageInfo);

                    // Set trigger flag for additional proc
                    uint32 l_ProcAttacker = PROC_FLAG_DONE_PERIODIC;
                    uint32 l_ProcVictim = PROC_FLAG_TAKEN_PERIODIC;
                    uint32 l_ProcEx = PROC_EX_NORMAL_HIT | PROC_EX_INTERNAL_DOT;
                    if (l_DamageInfo.GetAbsorb())
                        l_ProcEx |= PROC_EX_ABSORB;

                    l_Amount = (l_Amount <= l_DamageInfo.GetAbsorb() + l_DamageInfo.GetResist()) ? 0 : (l_Amount - l_DamageInfo.GetAbsorb() - l_DamageInfo.GetResist());
                    if (l_Amount)
                        l_ProcVictim |= PROC_FLAG_TAKEN_DAMAGE;

                    int32 l_OverkillAdditional = l_Amount - GetHealth();
                    if (l_OverkillAdditional < 0)
                        l_OverkillAdditional = 0;

                    l_DamageInfo.SetOverHeal(l_OverkillAdditional);
                    l_Caster->ProcDamageAndSpell(this, l_ProcAttacker, l_ProcVictim, l_ProcEx, l_DamageInfo);

                    l_Caster->DealDamage(this, l_Amount, 0, DamageEffectType::DOT, l_DamageInfo.GetSchoolMask(), l_SpellInfo, true, l_DamageInfo.GetAbsorb());
                    SpellPeriodicAuraLogInfo l_PInfo(l_AuraEffect, uint32(l_Amount), 0, l_DamageInfo.GetAbsorb(), l_DamageInfo.GetResist(), 0.0f, false);
                    SendPeriodicAuraLog(&l_PInfo);
                    break;
                }
                default:
                    break;
                }
        }
    }
}

void Unit::_UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode)
{
    // aura can be removed from unit only if it's applied on it, shouldn't happen
    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
    uint32 spellId = aurApp->GetBase()->GetId();
    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
    {
        if (iter->second == aurApp)
        {
            _UnapplyAura(iter, removeMode);
            return;
        }
        else
            ++iter;
    }
    ASSERT(false);
}

void Unit::_RemoveNoStackAurasDueToAura(Aura* aura)
{
    SpellInfo const* spellProto = aura->GetSpellInfo();

    // passive spell special case (only non stackable with ranks)
    if (spellProto->IsPassiveStackableWithRanks())
        return;

    bool remove = false;
    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
    {
        if (remove)
        {
            remove = false;
            i = m_appliedAuras.begin();
        }

        if (aura->CanStackWith(i->second->GetBase()))
            continue;

        /// Hack fix Poisoned Ammo stack with Serpent Sting
        if ((i->second->GetBase()->GetId() == 162543 && spellProto->Id == 118253) ||
            (i->second->GetBase()->GetId() == 118253 && spellProto->Id == 162543))
            continue;

        /// Hack fix for Sunfire and Stormstrike
        if (spellProto->Id == 164815 || spellProto->Id == 17364)
            continue;

        /// Hack fix for Stormflurry and Stormbringer
        if (spellProto->Id == 201845 || spellProto->Id == 17364 || spellProto->Id == 198367)
            continue;

        /// Hack fix for Blessing of Protection and Blessing of Freedom and Blessing of Sacrifice
        if (spellProto->Id == 6940 || spellProto->Id == 1022 || spellProto->Id == 1044)
            continue;

        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);
        if (i == m_appliedAuras.end())
            break;
        remove = true;
    }
}

void Unit::_RegisterAuraEffect(AuraEffect* aurEff, bool apply)
{
    if (apply)
        m_modAuras[aurEff->GetAuraType()].push_back(aurEff);
    else
        m_modAuras[aurEff->GetAuraType()].remove(aurEff);
}

// All aura base removes should go threw this function!
void Unit::RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode)
{
    Aura* aura = i->second;
    ASSERT(!aura->IsRemoved());

    // if unit currently update aura list then make safe update iterator shift to next
    if (m_auraUpdateIterator == i)
        ++m_auraUpdateIterator;

    m_ownedAuras.erase(i);
    m_removedAuras.push_back(aura);

    // Unregister single target aura
    if (aura->IsSingleTarget())
        aura->UnregisterSingleTarget();

    aura->_Remove(removeMode);

    i = m_ownedAuras.begin();
}

void Unit::RemoveOwnedAura(uint32 spellId, uint64 casterGUID, uint32 reqEffMask, AuraRemoveMode removeMode)
{
    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId);)
        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || itr->second->GetCasterGUID() == casterGUID))
        {
            RemoveOwnedAura(itr, removeMode);
            itr = m_ownedAuras.lower_bound(spellId);
        }
        else
            ++itr;
}

void Unit::RemoveOwnedAura(Aura* aura, AuraRemoveMode removeMode)
{
    if (aura->IsRemoved())
        return;

    ASSERT(aura->GetOwner() == this);

    uint32 spellId = aura->GetId();
    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
        if (itr->second == aura)
        {
            RemoveOwnedAura(itr, removeMode);
            return;
        }
    ASSERT(false);
}

Aura* Unit::GetOwnedAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask, Aura* except) const
{
    for (AuraMap::const_iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || itr->second->GetCasterGUID() == casterGUID) && (!itemCasterGUID || itr->second->GetCastItemGUID() == itemCasterGUID) && (!except || except != itr->second))
            return itr->second;
    return nullptr;
}

void Unit::RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode)
{
    AuraApplication * aurApp = i->second;

    // Do not remove aura which is already being removed
    if (aurApp->GetRemoveMode())
        return;

    Aura* aura = aurApp->GetBase();
    _UnapplyAura(i, mode);

    // Remove aura - for Area and Target auras
    if (aura->GetOwner() == this)
        aura->Remove(mode);

    /// Its already done in _UnapplyAura, but the line ^ can fuck the iterator
    i = m_appliedAuras.begin();
}

void Unit::RemoveAura(uint32 spellId, uint64 caster, uint32 reqEffMask, AuraRemoveMode removeMode)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
    {
        Aura const* aura = iter->second->GetBase();
        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
            && (!caster || aura->GetCasterGUID() == caster))
        {
            RemoveAura(iter, removeMode);
            return;
        }
        else
            ++iter;
    }
}

void Unit::RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode)
{
    Map::SetLastAuraRemoved(aurApp->GetBase()->GetId());

    // we've special situation here, RemoveAura called while during aura removal
    // this kind of call is needed only when aura effect removal handler
    // or event triggered by it expects to remove
    // not yet removed effects of an aura
    if (aurApp->GetRemoveMode())
    {
        // remove remaining effects of an aura
        for (uint8 itr = 0; itr < aurApp->GetEffectCount(); ++itr)
        {
            if (aurApp->HasEffect(itr))
                aurApp->_HandleEffect(itr, false);
        }
        return;
    }
    // no need to remove
    if (aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) != aurApp || aurApp->GetBase()->IsRemoved())
        return;
    uint32 spellId = aurApp->GetBase()->GetId();

    if (spellId == 115192 && mode != AURA_REMOVE_BY_EXPIRE)
        return;

    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
    {
        if (aurApp == iter->second)
        {
            RemoveAura(iter, mode);
            return;
        }
        else
            ++iter;
    }
}

void Unit::RemoveAura(Aura* aura, AuraRemoveMode mode)
{
    if (aura->IsRemoved())
        return;
    if (AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID()))
        RemoveAura(aurApp, mode);
}

void Unit::RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID, uint32 reqEffMask, AuraRemoveMode removeMode)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
    {
        Aura const* aura = iter->second->GetBase();
        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
            && (!casterGUID || aura->GetCasterGUID() == casterGUID))
        {
            RemoveAura(iter, removeMode);
            iter = m_appliedAuras.lower_bound(spellId);
        }
        else
            ++iter;
    }
}

void Unit::RemoveAuraFromStack(uint32 spellId, uint64 casterGUID, AuraRemoveMode removeMode)
{
    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
    {
        Aura* aura = iter->second;
        if ((aura->GetType() == UNIT_AURA_TYPE)
            && (!casterGUID || aura->GetCasterGUID() == casterGUID))
        {
            aura->ModStackAmount(-1, removeMode);
            return;
        }
        else
            ++iter;
    }
}

void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved/*= 1*/)
{
    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
    {
        Aura* aura = iter->second;
        if (aura->GetCasterGUID() == casterGUID)
        {
            if (chargesRemoved == 1 && dispeller->IsValidAttackTarget(this))
                chargesRemoved = GetAura(spellId)->GetStackAmount();

            DispelInfo dispelInfo(dispeller, dispellerSpellId, chargesRemoved);

            // Call OnDispel hook on AuraScript
            bool l_Prevented = aura->CallScriptDispel(&dispelInfo);
            if (l_Prevented)
            {
                ++iter;
                continue;
            }

            if (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES)
                aura->ModCharges(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);
            else
                aura->ModStackAmount(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);

            // Call AfterDispel hook on AuraScript
            aura->CallScriptAfterDispel(&dispelInfo);

            return;
        }
        else
            ++iter;
    }
}

void Unit::RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer)
{
    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
    {
        Aura* aura = iter->second;
        if (aura->GetCasterGUID() == casterGUID)
        {
            DispelInfo dispelInfo(stealer, spellId, 1);

            // Call OnDispel hook on AuraScript
            bool l_Prevented = aura->CallScriptDispel(&dispelInfo);
            if (l_Prevented)
            {
                ++iter;
                continue;
            }

            int32 damage[SpellEffIndex::MAX_EFFECTS];
            int32 baseDamage[SpellEffIndex::MAX_EFFECTS];
            uint32 effMask = 0;
            uint32 recalculateMask = 0;
            Unit* caster = aura->GetCaster();
            for (uint8 i = 0; i < aura->GetEffectCount(); ++i)
            {
                if (aura->GetEffect(i))
                {
                    baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
                    damage[i] = aura->GetEffect(i)->GetAmount();
                    effMask |= (1<<i);
                    if (aura->GetEffect(i)->CanBeRecalculated())
                        recalculateMask |= (1<<i);
                }
                else
                {
                    baseDamage[i] = 0;
                    damage[i] = 0;
                }
            }

            bool stealCharge = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;
            // Cast duration to unsigned to prevent permanent aura's such as Righteous Fury being permanently added to caster
            uint32 dur = std::min(2u * MINUTE * IN_MILLISECONDS, uint32(aura->GetDuration()));

            Aura* oldAura = stealer->GetAura(aura->GetId(), aura->GetCasterGUID());
            if (oldAura != nullptr)
            {
                if (stealCharge)
                    oldAura->ModCharges(1);
                else
                    oldAura->ModStackAmount(1);
                oldAura->SetDuration(int32(dur));
            }
            else
            {
                // single target state must be removed before aura creation to preserve existing single target aura
                if (aura->IsSingleTarget())
                    aura->UnregisterSingleTarget();

                Aura* newAura = Aura::TryRefreshStackOrCreate(aura->GetSpellInfo(), effMask, stealer, NULL, &baseDamage[0], NULL, stealer->GetGUID());
                if (newAura != nullptr)
                {
                    // created aura must not be single target aura,, so stealer won't loose it on recast
                    if (newAura->IsSingleTarget())
                    {
                        newAura->UnregisterSingleTarget();
                        // bring back single target aura status to the old aura
                        aura->SetIsSingleTarget(true);
                        caster->GetSingleCastAuras().push_back(aura);
                    }
                    // FIXME: using aura->GetMaxDuration() maybe not blizzlike but it fixes stealing of spells like Innervate
                    newAura->SetLoadedState(aura->GetMaxDuration(), int32(dur), stealCharge ? 1 : aura->GetCharges(), 1, recalculateMask, &damage[0]);
                    newAura->ApplyForTargets();
                }
            }

            if (stealCharge)
                aura->ModCharges(-1, AURA_REMOVE_BY_ENEMY_SPELL);
            else
                aura->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL);

            // Call AfterDispel hook on AuraScript
            aura->CallScriptAfterDispel(&dispelInfo);

            return;
        }
        else
            ++iter;
    }
}

void Unit::RemoveAurasDueToItemSpell(Item* castItem, uint32 spellId)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
    {
        if (!castItem || iter->second->GetBase()->GetCastItemGUID() == castItem->GetGUID())
        {
            RemoveAura(iter);
            iter = m_appliedAuras.upper_bound(spellId);          // overwrite by more appropriate
        }
        else
            ++iter;
    }
}

void Unit::RemoveAurasByType(AuraType auraType, uint64 casterGUID, Aura* exceptAura, uint32 exceptAuraId, bool negative, bool positive)
{
    ///< Subterfuge fix
    if (auraType == SPELL_AURA_MOD_STEALTH && getClass() == CLASS_ROGUE)
        RemoveAura(158188);

    /// Use list copy ON PURPOSE to avoid corrupted iterator if a aura get deleted while we loop over them
    /// Don't use reference, that will lead to crash.
    AuraEffectList l_Auras = GetAuraEffectsByType(auraType);

    std::vector<int32> l_DivineSteedIds = { 221883, 221885, 221886, 221887 };

    for (Unit::AuraEffectList::const_iterator l_Itr = l_Auras.begin(); l_Itr != l_Auras.end(); ++l_Itr)
    {
        Aura* l_Aura = (*l_Itr)->GetBase();
        if (!l_Aura)
            continue;

        AuraApplication * l_AuraApp = l_Aura->GetApplicationOfTarget(GetGUID());
        if (!l_AuraApp)
            continue;

        if (l_Aura != exceptAura && l_Aura->GetId() != exceptAuraId && (!casterGUID || l_Aura->GetCasterGUID() == casterGUID)
            && ((negative && !l_AuraApp->IsPositive()) || (positive && l_AuraApp->IsPositive()))
            && (auraType != AuraType::SPELL_AURA_MOUNTED || (std::find(l_DivineSteedIds.begin(), l_DivineSteedIds.end(), l_Aura->GetId()) == l_DivineSteedIds.end())))
            RemoveAura(l_AuraApp);
    }
}

void Unit::RemoveEffectsByType(AuraType auraType, uint64 casterGUID, Aura* exceptAura, uint32 exceptAuraId, bool negative, bool positive)
{
    for (AuraEffectList::iterator iter = m_modAuras[auraType].begin(); iter != m_modAuras[auraType].end();)
    {
        Aura* aura = (*iter)->GetBase();
        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());

        if (!aurApp)
        {
            ++iter;
            continue;
        }

        ++iter;

        if (aura != exceptAura && aura->GetId() != exceptAuraId && (!casterGUID || aura->GetCasterGUID() == casterGUID)
            && ((negative && !aurApp->IsPositive()) || (positive && aurApp->IsPositive())))
        {
            uint32 removedAuras = m_removedAurasCount;
            uint8 l_NbAuraEffectType = 0;
            uint8 l_NbAuraEffect = 0;

            for (; l_NbAuraEffect < aurApp->GetBase()->GetSpellInfo()->EffectCount; ++l_NbAuraEffect)
            {
                if (AuraEffect* l_AuraEffect = GetAuraEffect(aurApp->GetBase()->GetSpellInfo()->Id, l_NbAuraEffect))
                {
                    if (l_AuraEffect->GetAuraType() == auraType)
                    {
                        l_AuraEffect->ChangeAmount(0);
                        ++l_NbAuraEffectType;
                    }
                }
            }

            if (l_NbAuraEffectType == l_NbAuraEffect)
            {
                RemoveAura(aurApp);
                if (m_removedAurasCount > removedAuras + 1)
                    iter = m_modAuras[auraType].begin();
            }
        }
    }
}

void Unit::RemoveAurasWithAttribute(uint32 flags)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        SpellInfo const* spell = iter->second->GetBase()->GetSpellInfo();
        if (spell->Attributes & flags)
            RemoveAura(iter);
        else
            ++iter;
    }
}

void Unit::RemoveNotOwnSingleTargetAuras(uint32 newPhase)
{
    // single target auras from other casters
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        AuraApplication const* aurApp = iter->second;
        Aura const* aura = aurApp->GetBase();

        if (aura->GetCasterGUID() != GetGUID() && aura->GetSpellInfo()->IsSingleTarget())
        {
            if (!newPhase)
                RemoveAura(iter);
            else
            {
                Unit* caster = aura->GetCaster();
                if (!caster || !caster->InSamePhase(this) || !(newPhase & caster->GetPhaseMask()))
                    RemoveAura(iter);
                else
                    ++iter;
            }
        }
        else
            ++iter;
    }

    // single target auras at other targets
    AuraList& scAuras = GetSingleCastAuras();
    for (AuraList::iterator iter = scAuras.begin(); iter != scAuras.end();)
    {
        Aura* aura = *iter;
        if ((aura->GetUnitOwner() && aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(this)) ||
            (aura->GetUnitOwner() && aura->GetUnitOwner() != this && !(newPhase & aura->GetUnitOwner()->GetPhaseMask())))
        {
            aura->Remove();
            iter = scAuras.begin();
        }
        else
            ++iter;
    }
}

void Unit::RemoveAurasWithInterruptFlags(uint64 flag, uint64 except)
{
    if (!(m_interruptMask & flag))
        return;

    // interrupt auras
    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end();)
    {
        Aura* aura = (*iter)->GetBase();
        ++iter;

        if ((aura->GetSpellInfo()->AuraInterruptFlags & flag) && (!except || aura->GetId() != except) &&
             ((flag & AURA_INTERRUPT_FLAG_MOVE) == 0 || !(aura->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_USABLE_WHILE_MOVING)))
        {
            ///< Vengeful Retreat and Eye Beam
            if (aura->GetSpellInfo()->Id == 198013 && HasAura(198793)) {}
            else
            {
                uint32 removedAuras = m_removedAurasCount;
                RemoveAura(aura);
                if (m_removedAurasCount > removedAuras + 1)
                    iter = m_interruptableAuras.begin();
            }
        }
    }

    // interrupt channeled spell
    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
    {
        if (spell->getState() == SPELL_STATE_CASTING
            && (spell->m_spellInfo->ChannelInterruptFlags & flag)
            && spell->m_spellInfo->Id != except
            && !(flag & AURA_INTERRUPT_FLAG_MOVE && (HasAuraTypeWithAffectMask(SPELL_AURA_CAST_WHILE_WALKING, spell->m_spellInfo) ||
            HasAuraType(SPELL_AURA_ALLOW_ALL_CASTS_WHILE_WALKING) ||
            spell->m_spellInfo->AttributesEx5 & SPELL_ATTR5_USABLE_WHILE_MOVING)))
        {
            /// Zen Meditation should be channeled, but apply a levitation aura, it handles a movement opcode
            if (spell->m_spellInfo->Id == 115176)
                return;

            ///< Vengeful Retreat and Eye Beam
            if (spell->m_spellInfo->Id == 198013 && HasAura(198793))
                return;

            ///< Demonwrath
            if (spell->m_spellInfo->Id == 193440 && flag & CHANNEL_INTERRUPT_FLAG_INTERRUPT)
                return;

            ///< Essence Font
            if (spell->m_spellInfo->Id == 191837 && flag & CHANNEL_INTERRUPT_FLAG_INTERRUPT)
                return;

            InterruptNonMeleeSpells(false);
        }
    }

    UpdateInterruptMask();
}

void Unit::RemoveFlagsAuras()
{
    RemoveAura(131528); // Horde Insigna
    RemoveAura(131527); // Alliance Insigna

    if (Player* plr = ToPlayer())
    {
        if (Battleground* bg = plr->GetBattleground())
        {
            switch (bg->GetTypeID(true))
            {
                case BATTLEGROUND_KT:
                    ((BattlegroundKT*)bg)->EventPlayerDroppedOrb(plr);
                    break;
                case BATTLEGROUND_WS:
                    ((BattlegroundWS*)bg)->EventPlayerDroppedFlag(plr);
                    break;
                case BATTLEGROUND_TP:
                    ((BattlegroundTP*)bg)->EventPlayerDroppedFlag(plr);
                    break;
                case BATTLEGROUND_DG:
                    ((BattlegroundDG*)bg)->EventPlayerDroppedFlag(plr);
                    break;
                case BATTLEGROUND_EY:
                    ((BattlegroundEY*)bg)->EventPlayerDroppedFlag(plr);
                    break;
                default:
                    break;
            }
        }
    }
}

void Unit::RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        Aura const* aura = iter->second->GetBase();
        if (!casterGUID || aura->GetCasterGUID() == casterGUID)
        {
            SpellInfo const* spell = aura->GetSpellInfo();
            if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
            {
                RemoveAura(iter);
                continue;
            }
        }
        ++iter;
    }
}

void Unit::RemoveMovementImpairingAuras()
{
    RemoveAurasWithMechanic((1LL << MECHANIC_SNARE) | (1LL << MECHANIC_ROOT));
}

void Unit::RemoveAurasBreakableByDamage()
{
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE);
    RemoveAurasWithAttribute(SPELL_ATTR0_BREAKABLE_BY_DAMAGE);

    ///@TODO remove this hackfix.
    // Hack fix for Paralysis, don't want to spend time for debuging why it doesn't remove
    if (HasAura(115078))
        RemoveAura(115078);
}

void Unit::RemoveAurasWithMechanic(uint64 mechanic_mask, AuraRemoveMode removemode, uint32 except, uint8 count)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        uint8 aurasCount = 0;
        Aura const* aura = iter->second->GetBase();

        /// Hackfix for Kargath Bladefist, Impale cannot be dispelled
        /// Hackfix for Gul'dan, don't remove (Empowered) Bonds of Fel when a druid changes his shapeshift
        /// Hackfix for Trilliax, don't remove Stuffed
        /// Maybe need to add a hook here
        if (aura->GetId() == 159113 || aura->GetId() == 209011 || aura->GetId() == 206384 || aura->GetId() == 214573)
        {
            ++iter;
            continue;
        }

        if (!except || aura->GetId() != except)
        {
            if (aura->GetSpellInfo()->GetAllEffectsMechanicMask() & mechanic_mask)
            {
                RemoveAura(iter, removemode);
                aurasCount++;
                if (count && aurasCount == count)
                    break;

                continue;
            }
        }
        ++iter;
    }
}

void Unit::RemoveAreaAurasDueToLeaveWorld()
{
    // make sure that all area auras not applied on self are removed - prevent access to deleted pointer later
    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
    {
        Aura* aura = iter->second;
        ++iter;
        Aura::ApplicationMap const& appMap = aura->GetApplicationMap();
        for (Aura::ApplicationMap::const_iterator itr = appMap.begin(); itr!= appMap.end();)
        {
            AuraApplication * aurApp = itr->second;
            ++itr;
            Unit* target = aurApp->GetTarget();
            if (target == this)
                continue;
            target->RemoveAura(aurApp);
            // things linked on aura remove may apply new area aura - so start from the beginning
            iter = m_ownedAuras.begin();
        }
    }

    /// We need to remove all area auras which are casted by the pet and owned by the pet owner
    if (isPet())
    {
        if (Unit* l_Owner = GetOwner())
        {
            Unit::AuraMap& auras = l_Owner->GetOwnedAuras();
            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end();)
            {
                Aura* l_Aura = itr->second;
                ++itr;

                if (l_Aura->GetCasterGUID() != GetGUID())
                    continue;

                Aura::ApplicationMap const& l_AppMap = l_Aura->GetApplicationMap();
                for (Aura::ApplicationMap::const_iterator iter = l_AppMap.begin(); iter != l_AppMap.end();)
                {
                    AuraApplication * aurApp = iter->second;
                    ++iter;

                    Unit* l_Target = aurApp->GetTarget();
                    if (l_Target == this)
                        continue;

                    l_Target->RemoveAura(aurApp);

                    // things linked on aura remove may apply new area aura - so start from the beginning
                    itr  = auras.begin();
                    iter = l_AppMap.begin();
                }
            }
        }
    }

    // remove area auras owned by others
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        if (iter->second->GetBase()->GetOwner() != this)
        {
            RemoveAura(iter);
        }
        else
            ++iter;
    }
}

void Unit::RemoveAllAuras()
{
    // this may be a dead loop if some events on aura remove will continiously apply aura on remove
    // we want to have all auras removed, so use your brain when linking events
    while (!m_appliedAuras.empty() || !m_ownedAuras.empty())
    {
        AuraApplicationMap::iterator aurAppIter;
        for (aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)
            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);

        AuraMap::iterator aurIter;
        for (aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)
            RemoveOwnedAura(aurIter);
    }
}

void Unit::RemoveNonPassivesAuras()
{
    // this may be a dead loop if some events on aura remove will continiously apply aura on remove
    // we want to have all auras removed, so use your brain when linking events
    for (AuraApplicationMap::iterator aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)
    {
        Aura* aura = aurAppIter->second->GetBase();
        // Don't remove warsong's and twin peak's flags buffs
        if (!aura->IsPassive() && aura->GetId() != 23333 && aura->GetId() != 23335)
            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);
        else
            ++aurAppIter;
    }

    for (AuraMap::iterator aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)
    {
        Aura* aura = aurIter->second;
        // Don't remove warsong's and twin peak's flags buffs
        if (!aura->IsPassive() && aura->GetId() != 23333 && aura->GetId() != 23335)
            RemoveOwnedAura(aurIter);
        else
            ++aurIter;
    }
}

void Unit::RemoveArenaAuras()
{
    RemoveAura(77616); ///< Dark Simulacrum

    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        AuraApplication* l_AurApp = iter.second;
        Aura* l_Aura = l_AurApp->GetBase();

        if (!(l_Aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_UNK21)                                                ///< don't remove stances, shadowform, pally/hunter auras
            && !l_Aura->IsPassive()                                                                                     ///< don't remove passive auras
            && (l_AurApp->IsPositive() || !(l_Aura->GetSpellInfo()->AttributesEx3 & SPELL_ATTR3_DEATH_PERSISTENT))
            && !l_AurApp->GetRemoveMode())                                                                              ///< not negative death persistent auras
            RemoveAura(l_AurApp);
    }
}

void Unit::RemoveNegativeAuras()
{
    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        AuraApplication* l_AurApp = iter.second;
        Aura* l_Aura = l_AurApp->GetBase();

        if (!l_AurApp->IsPositive()                                       ///< don't remove stances, shadowform, pally/hunter auras
            && !l_Aura->IsPassive()                                       ///< don't remove passive auras
            && !l_Aura->IsDeathPersistent()                               ///< don't remove death persistent auras
            && !l_AurApp->GetRemoveMode())
            RemoveAura(l_AurApp);
    }
}

void Unit::RemoveAllAurasOnDeath()
{
    // used just after dieing to remove all visible auras
    // and disable the mods for the passive ones
    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        Aura const* l_Aura = iter.second->GetBase();
        if (!l_Aura->IsPassive() && !l_Aura->IsDeathPersistent())
            _UnapplyAura(iter.second, AURA_REMOVE_BY_DEATH);
    }

    AuraMap l_OwnedAuras = m_ownedAuras;
    for (auto iter : l_OwnedAuras)
    {
        Aura* l_Aura = iter.second;
        if (!l_Aura->IsPassive() && !l_Aura->IsDeathPersistent())
            RemoveOwnedAura(l_Aura, AURA_REMOVE_BY_DEATH);
    }
}

void Unit::RemoveAllAurasRequiringDeadTarget()
{
    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        Aura const* l_Aura = iter.second->GetBase();
        if (!l_Aura->IsPassive() && l_Aura->GetSpellInfo()->IsRequiringDeadTarget())
            _UnapplyAura(iter.second, AURA_REMOVE_BY_DEFAULT);
    }

    AuraMap l_OwnedAuras = m_ownedAuras;
    for (auto iter : l_OwnedAuras)
    {
        Aura* aura = iter.second;
        if (!aura->IsPassive() && aura->GetSpellInfo()->IsRequiringDeadTarget())
            RemoveOwnedAura(aura, AURA_REMOVE_BY_DEFAULT);
    }
}

void Unit::RemoveAllAurasExceptType(AuraType type)
{
    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        Aura const* l_Aura = iter.second->GetBase();
        if (!l_Aura->GetSpellInfo()->HasAura(type))
            _UnapplyAura(iter.second, AURA_REMOVE_BY_DEFAULT);
    }

    AuraMap l_OwnedAuras = m_ownedAuras;
    for (auto iter : l_OwnedAuras)
    {
        Aura* aura = iter.second;
        if (!aura->GetSpellInfo()->HasAura(type))
            RemoveOwnedAura(aura, AURA_REMOVE_BY_DEFAULT);
    }
}

void Unit::RemoveAllAurasByType(AuraType type)
{
    AuraApplicationMap l_AppliedAuras = m_appliedAuras;
    for (auto iter : l_AppliedAuras)
    {
        Aura const* l_Aura = iter.second->GetBase();
        if (l_Aura->GetSpellInfo()->HasAura(type))
            _UnapplyAura(iter.second, AURA_REMOVE_BY_DEFAULT);
    }

    AuraMap l_OwnedAuras = m_ownedAuras;
    for (auto iter : l_OwnedAuras)
    {
        Aura* aura = iter.second;
        if (aura->GetSpellInfo()->HasAura(type))
            RemoveOwnedAura(aura, AURA_REMOVE_BY_DEFAULT);
    }
}

void Unit::RemoveAllAurasByCaster(uint64 p_Guid)
{
    AuraMap l_OwnedAuras = m_ownedAuras;
    for (auto iter : l_OwnedAuras)
    {
        Aura* aura = iter.second;
        if (aura->GetCasterGUID() == p_Guid)
            RemoveOwnedAura(aura, AURA_REMOVE_BY_DEFAULT);
    }
}

void Unit::DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime)
{
    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);++iter)
    {
        Aura* aura = iter->second;
        if (!caster || aura->GetCasterGUID() == caster)
        {
            if (aura->GetDuration() < delaytime)
                aura->SetDuration(0);
            else
                aura->SetDuration(aura->GetDuration() - delaytime);

            // update for out of range group members (on 1 slot use)
            aura->SetNeedClientUpdateForTargets();
        }
    }
}

void Unit::_RemoveAllAuraStatMods()
{
    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, false);
}

void Unit::_ApplyAllAuraStatMods()
{
    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, true);
}

std::list<AuraEffect*> Unit::GetAuraEffectsByMechanic(uint32 mechanic_mask) const
{
    AuraEffectList list;
    for (AuraApplicationMap::const_iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
    {
        Aura const* aura = iter->second->GetBase();
        for (uint8 i = 0; i < aura->GetSpellInfo()->EffectCount; ++i)
        {
            if (aura->GetSpellInfo()->GetEffectMechanicMask(i) & mechanic_mask)
            {
                if (iter->second)
                    if (iter->second->GetBase())
                        if (iter->second->GetBase()->GetEffect(i))
                            list.push_back(iter->second->GetBase()->GetEffect(i));
            }
        }
    }

    return list;
}

AuraEffect* Unit::GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
{
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
            return itr->second->GetBase()->GetEffect(effIndex);
    return nullptr;
}

AuraEffect* Unit::GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 caster) const
{
    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);
    while (rankSpell)
    {
        if (AuraEffect* aurEff = GetAuraEffect(rankSpell, effIndex, caster))
            return aurEff;
        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);
    }
    return nullptr;
}

AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
{
    AuraEffectList const& auras = GetAuraEffectsByType(type);
    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
    {
        SpellInfo const* spell = (*i)->GetSpellInfo();
        if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
        {
            if (casterGUID && (*i)->GetCasterGUID() != casterGUID)
                continue;
            return (*i);
        }
    }
    return nullptr;
}

AuraApplication * Unit::GetAuraApplication(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask, AuraApplication * except) const
{
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
    {
        Aura const* aura = itr->second->GetBase();
        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || aura->GetCasterGUID() == casterGUID) && (!itemCasterGUID || aura->GetCastItemGUID() == itemCasterGUID) && (!except || except != itr->second))
            return itr->second;
    }
    return NULL;
}

Aura* Unit::GetAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask) const
{
    AuraApplication * aurApp = GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask);
    return aurApp ? aurApp->GetBase() : nullptr;
}

AuraApplication * Unit::GetAuraApplicationOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask, AuraApplication* except) const
{
    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);
    while (rankSpell)
    {
        if (AuraApplication * aurApp = GetAuraApplication(rankSpell, casterGUID, itemCasterGUID, reqEffMask, except))
            return aurApp;
        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);
    }
    return NULL;
}

Aura* Unit::GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask) const
{
    AuraApplication * aurApp = GetAuraApplicationOfRankedSpell(spellId, casterGUID, itemCasterGUID, reqEffMask);
    return aurApp ? aurApp->GetBase() : nullptr;
}

void Unit::GetDispellableAuraList(Unit* caster, uint32 dispelMask, DispelChargesList& dispelList)
{
    AuraMap const& auras = GetOwnedAuras();
    for (AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
    {
        Aura* aura = itr->second;
        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
        if (!aurApp)
            continue;

        // don't try to remove passive auras
        if (aura->IsPassive())
            continue;

        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
        {
            if (aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
            {
                // do not remove positive auras if friendly target
                //               negative auras if non-friendly target
                if (aurApp->IsPositive() == IsFriendlyTo(caster))
                    continue;
            }

            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
            // Polymorph instead of 1 / (5 + 1) -> 16%.
            bool dispel_charges = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;
            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
            if (charges > 0)
                dispelList.push_back(std::make_pair(aura, charges));
        }
    }
}

StackOnDuration* Unit::GetStackOnDuration(uint32 p_SpellID)
{
    if (m_StackOnDurationMap.find(p_SpellID) != m_StackOnDurationMap.end())
        return &m_StackOnDurationMap[p_SpellID];

    return nullptr;
}

void Unit::AddToStackOnDuration(uint32 p_SpellID, uint64 p_DurationTime, int32 p_Amount)
{
    if (m_StackOnDurationMap.find(p_SpellID) == m_StackOnDurationMap.end())
        m_StackOnDurationMap.insert(std::make_pair(p_SpellID, StackOnDuration(p_DurationTime, p_Amount)));
    else
    {
        StackOnDuration* l_Stack = GetStackOnDuration(p_SpellID);
        l_Stack->m_StackDuration.push_back(std::make_pair(p_DurationTime, p_Amount));
    }
}

void Unit::RemoveStackOnDuration(uint32 p_SpellID)
{
    if (m_StackOnDurationMap.find(p_SpellID) == m_StackOnDurationMap.end())
        return;
    else
        m_StackOnDurationMap.erase(m_StackOnDurationMap.find(p_SpellID));
}

bool Unit::HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
{
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
            return true;
    return false;
}

uint32 Unit::GetAuraCount(uint32 spellId) const
{
    uint32 count = 0;
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
    {
        if (!itr->second->GetBase()->GetStackAmount())
            count++;
        else
            count += (uint32)itr->second->GetBase()->GetStackAmount();
    }
    return count;
}

bool Unit::HasAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint32 reqEffMask) const
{
    if (GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask))
        return true;
    return false;
}

bool Unit::HasAuraType(AuraType auraType) const
{
    return (!m_modAuras[auraType].empty());
}

bool Unit::HasAuraTypeWithCaster(AuraType auratype, uint64 caster) const
{
    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
        if (caster == (*i)->GetCasterGUID())
            return true;
    return false;
}

bool Unit::HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const
{
    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
        if (miscvalue == (*i)->GetMiscValue())
            return true;
    return false;
}

bool Unit::HasAuraTypeWithAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
{
    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
        if ((*i)->IsAffectingSpell(affectedSpell))
            return true;
    return false;
}

bool Unit::HasAuraTypeWithValue(AuraType auratype, int32 value) const
{
    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
        if (value == (*i)->GetAmount())
            return true;
    return false;
}

bool Unit::HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid)
{
    if (!(m_interruptMask & flag))
        return false;
    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end(); ++iter)
    {
        if (!(*iter)->IsPositive() && (*iter)->GetBase()->GetSpellInfo()->AuraInterruptFlags & flag && (!guid || (*iter)->GetBase()->GetCasterGUID() == guid))
            return true;
    }
    return false;
}

bool Unit::HasNegativeAuraWithAttribute(uint32 flag, uint64 guid)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
    {
        Aura const* aura = iter->second->GetBase();
        if (!iter->second->IsPositive() && aura->GetSpellInfo()->Attributes & flag && (!guid || aura->GetCasterGUID() == guid))
            return true;
    }
    return false;
}

bool Unit::HasAuraWithNegativeCaster(uint32 spellid)
{
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellid); itr != m_appliedAuras.upper_bound(spellid); ++itr)
    {
        if (Unit * caster = (itr->second->GetBase()->GetCaster()))
        {
            if (!caster->IsFriendlyTo(this))
                return true;
        }
    }
    return false;
}

bool Unit::HasAuraWithMechanic(uint64 mechanicMask)
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
    {
        SpellInfo const* spellInfo  = iter->second->GetBase()->GetSpellInfo();
        if (spellInfo->Mechanic && (mechanicMask & (1LL << spellInfo->Mechanic)))
            return true;

        for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
            if (iter->second->HasEffect(i) && spellInfo->Effects[i].Effect && spellInfo->Effects[i].Mechanic)
                if (mechanicMask & (1LL << spellInfo->Effects[i].Mechanic))
                    return true;
    }

    return false;
}

bool Unit::HasAuraWithAttribute(uint32 p_Attributes, uint8 p_Flag) const
{
    for (AuraApplicationMap::const_iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
    {
        Aura const* l_Aura = iter->second->GetBase();
        if (l_Aura == nullptr)
            return false;

        switch (p_Flag)
        {
        case 0: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr0)p_Attributes);
        case 1: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr1)p_Attributes);
        case 2: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr2)p_Attributes);
        case 3: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr3)p_Attributes);
        case 4: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr4)p_Attributes);
        case 5: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr5)p_Attributes);
        case 6: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr6)p_Attributes);
        case 7: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr7)p_Attributes);
        case 8: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr8)p_Attributes);
        case 9: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr9)p_Attributes);
        case 10: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr10)p_Attributes);
        case 11: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr11)p_Attributes);
        case 12: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr12)p_Attributes);
        case 13: return l_Aura->GetSpellInfo()->HasAttribute((SpellAttr13)p_Attributes);
        }
    }
    return false;
}

bool Unit::HasAuraWithDispelFlagsFromCaster(Unit* p_Caster, DispelType p_DispelType)
{
    DispelChargesList l_Diseases;
    GetDispellableAuraList(p_Caster, (1 << p_DispelType), l_Diseases);
    bool l_HasDispel = false;
    for (auto l_Itr : l_Diseases)
    {
        if (Aura* l_Aura = l_Itr.first)
        {
            /// if target has aura with dispel type from caster
            if (l_Aura->GetCasterGUID() == p_Caster->GetGUID())
            {
                l_HasDispel = true;
                break;
            }
        }
    }

    return l_HasDispel;
}

bool Unit::IsActiveSaveAbility() const
{
    for (AuraApplicationMap::const_iterator l_Iter = m_appliedAuras.begin(); l_Iter != m_appliedAuras.end(); ++l_Iter)
    {
        Aura const* l_Aura = l_Iter->second->GetBase();

        switch (l_Aura->GetId())
        {
            case 192081: ///< Druid: Ironfur
            case 215479: ///< Monk: Ironskin Brew
            case 132403: ///< Paladin: Shield of the Righteous
            case 77535:  ///< DK: Blood Shield
            case 203819: ///< DH: Demon Spikes
            case 132404: ///< Warrior: Shield Block
                return true;
            default:
                break;
        }
    }

    return false;
}

AuraEffect* Unit::IsScriptOverriden(SpellInfo const* spell, int32 script) const
{
    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
    {
        if ((*i)->GetMiscValue() == script)
            if ((*i)->IsAffectingSpell(spell))
                return (*i);
    }
    return nullptr;
}

uint32 Unit::GetDiseasesByCaster(uint64 casterGUID, bool remove)
{
    static const AuraType diseaseAuraTypes[] =
    {
        SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague
        SPELL_AURA_PERIODIC_SCHOOL_DAMAGE, ///< Presumed
        SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague
        SPELL_AURA_NONE
    };

    uint32 diseases = 0;
    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        for (AuraEffectList::iterator i = m_modAuras[*itr].begin(); i != m_modAuras[*itr].end();)
        {
            // Get auras with disease dispel type by caster
            if ((*i)->GetSpellInfo()->Dispel == DISPEL_DISEASE
                && (*i)->GetCasterGUID() == casterGUID)
            {
                ++diseases;

                if (remove)
                {
                    RemoveAura((*i)->GetId(), (*i)->GetCasterGUID());
                    i = m_modAuras[*itr].begin();
                    continue;
                }
            }
            ++i;
        }
    }

    // Burning Blood, Item - Death Knight T12 Blood 2P Bonus
    if (HasAura(98957, casterGUID))
    {
        uint32 _min = 2;
        diseases = std::max(diseases, _min);
    }

    return diseases;
}

uint32 Unit::GetDoTsByCaster(uint64 casterGUID) const
{
    static const AuraType diseaseAuraTypes[] =
    {
        SPELL_AURA_PERIODIC_DAMAGE,
        SPELL_AURA_PERIODIC_SCHOOL_DAMAGE,
        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,
        SPELL_AURA_NONE
    };

    uint32 dots = 0;
    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);
        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
        {
            // Get auras by caster
            if ((*i)->GetCasterGUID() == casterGUID)
                ++dots;
        }
    }
    return dots;
}

int32 Unit::GetTotalAuraModifier(AuraType auratype, AuraEffect const* excludeAura /* nullptr*/, AuraEffect* includeAura /* nullptr*/) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList auras(GetAuraEffectsByType(auratype));
    if (includeAura)
    {
        AuraEffectList::const_iterator iter = find(auras.begin(), auras.end(), includeAura);
        if (iter == auras.end())
            auras.push_back((includeAura));
    }

    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
        if ((*i) != excludeAura)
             if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                 modifier += (*i)->GetAmount();

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

float Unit::GetTotalAuraMultiplier(AuraType auratype) const
{
    float multiplier = 1.0f;

    std::map<SpellGroup, int32> SameEffectSpellGroup;
    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        /// Check if the Aura Effect has a the Same Effect Stack Rule and if so, use the highest amount of that SpellGroupSameEffectSpellGrou
        /// If the Aura Effect does not have this Stack Rule, it returns false so we can add to the multiplier as usual
        if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
            AddPct(multiplier, (*i)->GetAmount());
    }
    /// Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier
    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        AddPct(multiplier, itr->second);

    return multiplier;
}

int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype)
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetAmount() > modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetAmount() < modifier)
        {
            if ((*i)->GetBase()->GetId() == 116 && auratype == SPELL_AURA_MOD_DECREASE_SPEED) // Frostbolt speed reduction is always at 50%
                modifier = (*i)->GetBaseAmount();
            else
                modifier = (*i)->GetAmount();
        }
    }

    return modifier;
}

int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, AuraEffect const* excludeAura /* nullptr*/, AuraEffect* includeAura /* nullptr*/) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList auras(GetAuraEffectsByType(auratype));
    if (includeAura)
    {
        AuraEffectList::const_iterator iter = find(auras.begin(), auras.end(), includeAura);
        if (iter == auras.end())
            auras.push_back((includeAura));
    }

    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
         if ((*i)->GetMiscValue() & misc_mask && (*i) != excludeAura)
             if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                 modifier += (*i)->GetAmount();

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

int32 Unit::GetTotalAuraModifierByMiscBMask(AuraType auratype, uint32 misc_mask, AuraEffect const* excludeAura /* nullptr*/, AuraEffect* includeAura /* nullptr*/) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList auras(GetAuraEffectsByType(auratype));

    if (includeAura)
    {
        AuraEffectList::const_iterator iter = find(auras.begin(), auras.end(), includeAura);
        if (iter == auras.end())
            auras.push_back((includeAura));
    }

    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
         if ((*i)->GetMiscValueB() & misc_mask && (*i) != excludeAura)
             if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                 modifier += (*i)->GetAmount();

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

float Unit::GetTotalAuraMultiplierByMiscBMask(AuraType auratype, uint32 misc_mask, AuraEffect const* excludeAura /* nullptr*/, AuraEffect* includeAura /* nullptr*/) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    float modifier = 100.f;

    AuraEffectList auras(GetAuraEffectsByType(auratype));

    if (includeAura)
    {
        AuraEffectList::const_iterator iter = find(auras.begin(), auras.end(), includeAura);
        if (iter == auras.end())
            auras.push_back((includeAura));
    }

    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
         if ((*i)->GetMiscValueB() & misc_mask && (*i) != excludeAura)
             if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                 AddPct(modifier, (*i)->GetSpellInfo()->GetFloatAmount((*i)->GetAmount(), (*i)->GetFloatAmount()));

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        AddPct(modifier, itr->second);

    modifier -= 100.0f;

    return modifier;
}

float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    float multiplier = 1.0f;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if (((*i)->GetMiscValue() & misc_mask))
        {
            // Check if the Aura Effect has a the Same Effect Stack Rule and if so, use the highest amount of that SpellGroup
            // If the Aura Effect does not have this Stack Rule, it returns false so we can add to the multiplier as usual
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                AddPct(multiplier, (*i)->GetAmount());
        }
    }
    // Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier
    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        AddPct(multiplier, itr->second);

    return multiplier;
}

int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, AuraEffect const* except) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if (except != (*i) && (*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() > modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() < modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue() == misc_value)
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                modifier += (*i)->GetAmount();
    }

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

int32 Unit::GetTotalAuraModifierByBothMiscValues(AuraType p_AuraType, int32 p_MiscA, int32 p_MiscB) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(p_AuraType);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue() == p_MiscA && (*i)->GetMiscValueB() == p_MiscB)
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                modifier += (*i)->GetAmount();
    }

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    float multiplier = 1.0f;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue() == misc_value)
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                AddPct(multiplier, (*i)->GetAmount());
    }

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        AddPct(multiplier, itr->second);

    return multiplier;
}

int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() > modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() < modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->IsAffectingSpell(affectedSpell))
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                modifier += (*i)->GetAmount();
    }

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        modifier += itr->second;

    return modifier;
}

float Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
{
    std::map<SpellGroup, int32> SameEffectSpellGroup;
    float multiplier = 1.0f;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->IsAffectingSpell(affectedSpell))
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
                AddPct(multiplier, (*i)->GetAmount());
    }

    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        AddPct(multiplier, itr->second);

    return multiplier;
}

float Unit::GetTotalCooldownRecoveryRateForSpell(uint32 p_SpellID, AuraEffect const* p_IncludeAura /*= nullptr*/, AuraEffect const* p_ExcludeAura /*= nullptr*/) const
{
    float l_Modifier = 1.0f;

    std::set<uint32> l_ProcessedSpells;

    AuraEffectList const& l_EffectList = GetAuraEffectsByType(AuraType::SPELL_AURA_MOD_COOLDOWN_RECOVERY_RATE);
    for (AuraEffectList::const_iterator l_Iter = l_EffectList.begin(); l_Iter != l_EffectList.end(); ++l_Iter)
    {
        SpellInfo const* l_SpellInfo = (*l_Iter)->GetSpellInfo();

        /// Don't process exclude aura at all
        if (p_ExcludeAura && l_SpellInfo->Id == p_ExcludeAura->GetId())
            continue;

        if (l_ProcessedSpells.find(l_SpellInfo->Id) != l_ProcessedSpells.end())
            continue;

        l_ProcessedSpells.insert(l_SpellInfo->Id);

        auto const l_List = sSpellMgr->GetChangeRecoveryRateSpells(l_SpellInfo->Id);

        bool l_Found = false;
        for (int32 const& l_Spell : l_List)
        {
            /// We're only checking SpellIDs
            if (l_Spell < 0)
                continue;

            if (l_Spell == p_SpellID)
            {
                l_Found = true;
                break;
            }
        }

        if (l_Found || l_List.empty())
        {
            if ((*l_Iter)->GetAmount() > 0.0f)
                l_Modifier *= 100.0f / (100.0f + float((*l_Iter)->GetAmount()));
            else
                l_Modifier *= (100.0f - float((*l_Iter)->GetAmount())) / 100.0f;
        }
    }

    /// Process include aura if not already done
    if (p_IncludeAura && l_ProcessedSpells.find(p_IncludeAura->GetId()) == l_ProcessedSpells.end())
    {
        auto const l_List = sSpellMgr->GetChangeRecoveryRateSpells(p_IncludeAura->GetId());

        bool l_Found = false;
        for (int32 const& l_Spell : l_List)
        {
            /// We're only checking SpellIDs
            if (l_Spell < 0)
                continue;

            if (l_Spell == p_SpellID)
            {
                l_Found = true;
                break;
            }
        }

        if (l_Found || l_List.empty())
        {
            if (p_IncludeAura->GetAmount() > 0.0f)
                l_Modifier *= 100.0f / (100.0f + float(p_IncludeAura->GetAmount()));
            else
                l_Modifier *= (100.0f - float(p_IncludeAura->GetAmount())) / 100.0f;
        }
    }

    return l_Modifier;
}

float Unit::GetTotalChargeRecoveryRateForCategory(uint32 p_CategoryID, AuraEffect const* p_IncludeAura /*= nullptr*/, AuraEffect const* p_ExcludeAura /*= nullptr*/) const
{
    float l_Modifier = 1.0f;

    std::set<uint32> l_ProcessedSpells;

    AuraEffectList const& l_EffectList = GetAuraEffectsByType(AuraType::SPELL_AURA_MOD_COOLDOWN_RECOVERY_RATE);
    for (AuraEffectList::const_iterator l_Iter = l_EffectList.begin(); l_Iter != l_EffectList.end(); ++l_Iter)
    {
        SpellInfo const* l_SpellInfo = (*l_Iter)->GetSpellInfo();

        /// Don't process exclude aura at all
        if (p_ExcludeAura && l_SpellInfo->Id == p_ExcludeAura->GetId())
            continue;

        if (l_ProcessedSpells.find(l_SpellInfo->Id) != l_ProcessedSpells.end())
            continue;

        l_ProcessedSpells.insert(l_SpellInfo->Id);

        auto const l_List = sSpellMgr->GetChangeRecoveryRateSpells(l_SpellInfo->Id);

        bool l_Found = false;
        for (int32 const& l_Spell : l_List)
        {
            /// We're only checking ChargeCategoryIDs
            if (l_Spell > 0)
                continue;

            SpellCategoryEntry const* l_ChargeInfo = sSpellCategoryStore.LookupEntry(std::abs(l_Spell));
            if (!l_ChargeInfo)
                continue;

            if (l_ChargeInfo->Id == p_CategoryID)
            {
                l_Found = true;
                break;
            }
        }

        if (l_Found || l_List.empty())
        {
            if ((*l_Iter)->GetAmount() > 0.0f)
                l_Modifier *= 100.0f / (100.0f + float((*l_Iter)->GetAmount()));
            else
                l_Modifier *= (100.0f - float((*l_Iter)->GetAmount())) / 100.0f;
        }
    }

    /// Process include aura if not already done
    if (p_IncludeAura && l_ProcessedSpells.find(p_IncludeAura->GetId()) == l_ProcessedSpells.end())
    {
        auto const l_List = sSpellMgr->GetChangeRecoveryRateSpells(p_IncludeAura->GetId());

        bool l_Found = false;
        for (int32 const& l_Spell : l_List)
        {
            /// We're only checking ChargeCategoryIDs
            if (l_Spell > 0)
                continue;

            SpellCategoryEntry const* l_ChargeInfo = sSpellCategoryStore.LookupEntry(std::abs(l_Spell));
            if (!l_ChargeInfo)
                continue;

            if (l_ChargeInfo->Id == p_CategoryID)
            {
                l_Found = true;
                break;
            }
        }

        if (l_Found || l_List.empty())
        {
            if (p_IncludeAura->GetAmount() > 0.0f)
                l_Modifier *= 100.0f / (100.0f + float(p_IncludeAura->GetAmount()));
            else
                l_Modifier *= (100.0f - float(p_IncludeAura->GetAmount())) / 100.0f;
        }
    }

    return l_Modifier;
}

int32 Unit::GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->IsAffectingSpell(affectedSpell) && (*i)->GetAmount() > modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

int32 Unit::GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
{
    int32 modifier = 0;

    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
    {
        if ((*i)->IsAffectingSpell(affectedSpell) && (*i)->GetAmount() < modifier)
            modifier = (*i)->GetAmount();
    }

    return modifier;
}

void Unit::_RegisterDynObject(DynamicObject* dynObj)
{
    m_dynObj.push_back(dynObj);
}

void Unit::_RegisterAreaTrigger(AreaTrigger* areaTrigger)
{
    m_AreaTrigger.push_back(areaTrigger);
}

void Unit::_UnregisterDynObject(DynamicObject* dynObj)
{
    m_dynObj.remove(dynObj);
}

void Unit::_UnregisterAreaTrigger(AreaTrigger* areaTrigger)
{
    m_AreaTrigger.remove(areaTrigger);
}

DynamicObject* Unit::GetDynObject(uint32 spellId)
{
    if (m_dynObj.empty())
        return NULL;

    for (DynObjectList::const_iterator i = m_dynObj.begin(); i != m_dynObj.end();++i)
    {
        DynamicObject* dynObj = *i;
        if (dynObj->GetSpellId() == spellId)
            return dynObj;
    }
    return NULL;
}

AreaTrigger* Unit::GetAreaTrigger(uint32 spellId)
{
    if (m_AreaTrigger.empty())
        return nullptr;

    for (AreaTriggerList::const_iterator i = m_AreaTrigger.begin(); i != m_AreaTrigger.end();++i)
    {
        AreaTrigger* areaTrigger = *i;
        if (areaTrigger->GetSpellId() == spellId)
            return areaTrigger;
    }
    return nullptr;
}

AreaTrigger* Unit::GetLastAreaTrigger(uint32 spellId)
{
    if (m_AreaTrigger.empty())
        return nullptr;

    AreaTrigger* l_LastAreatrigger = nullptr;
    for (AreaTriggerList::const_iterator i = m_AreaTrigger.begin(); i != m_AreaTrigger.end(); ++i)
    {
        AreaTrigger* areaTrigger = *i;
        if (areaTrigger->GetSpellId() == spellId)
            l_LastAreatrigger = areaTrigger;
    }
    return l_LastAreatrigger;
}

int32 Unit::CountDynObject(uint32 spellId)
{
    int32 count = 0;

    if (m_dynObj.empty())
        return 0;
    for (DynObjectList::const_iterator i = m_dynObj.begin(); i != m_dynObj.end();++i)
    {
        DynamicObject* dynObj = *i;
        if (dynObj->GetSpellId() == spellId)
            count++;
    }
    return count;
}

int32 Unit::CountAreaTrigger(uint32 spellId)
{
    int32 count = 0;

    if (m_AreaTrigger.empty())
        return 0;

    for (AreaTriggerList::const_iterator i = m_AreaTrigger.begin(); i != m_AreaTrigger.end();++i)
    {
        AreaTrigger* areaTrigger = *i;
        if (areaTrigger->GetSpellId() == spellId)
            count++;
    }
    return count;
}

void Unit::GetDynObjectList(std::list<DynamicObject*> &list, uint32 spellId)
{
    if (m_dynObj.empty())
        return;

    for (DynObjectList::const_iterator i = m_dynObj.begin(); i != m_dynObj.end();++i)
    {
        DynamicObject* dynObj = *i;
        if (dynObj->GetSpellId() == spellId)
            list.push_back(dynObj);
    }
}

void Unit::GetAreaTriggerList(std::list<AreaTrigger*> &list, uint32 spellId)
{
    if (m_AreaTrigger.empty())
        return;

    for (AreaTriggerList::const_iterator i = m_AreaTrigger.begin(); i != m_AreaTrigger.end();++i)
    {
        AreaTrigger* areaTrigger = *i;
        if (areaTrigger->GetSpellId() == spellId)
            list.push_back(areaTrigger);
    }
}

void Unit::RemoveDynObject(uint32 spellId)
{
    if (m_dynObj.empty())
        return;

    for (DynObjectList::iterator i = m_dynObj.begin(); i != m_dynObj.end();)
    {
        DynamicObject* dynObj = *i;
        if (dynObj->GetSpellId() == spellId)
        {
            dynObj->Remove();
            i = m_dynObj.begin();
        }
        else
            ++i;
    }
}

void Unit::RemoveAreaTrigger(uint32 spellId)
{
    if (m_AreaTrigger.empty())
        return;

    for (AreaTriggerList::iterator i = m_AreaTrigger.begin(); i != m_AreaTrigger.end();)
    {
        AreaTrigger* areaTrigger = *i;
        if (areaTrigger->GetSpellId() == spellId && !areaTrigger->IsOnRemove())
        {
            areaTrigger->Remove(0);
            i = m_AreaTrigger.begin();
        }
        else
            ++i;
    }
}

void Unit::RemoveAllDynObjects()
{
    while (!m_dynObj.empty())
        m_dynObj.front()->Remove();
}

void Unit::RemoveAllAreasTrigger()
{
    std::list<AreaTrigger*> l_ToRemoveATs;
    for (AreaTrigger* l_AreaTrigger : m_AreaTrigger)
    {
        if (l_AreaTrigger->IsOnRemove())
            continue;

        l_ToRemoveATs.push_back(l_AreaTrigger);
    }

    for (AreaTrigger* l_AreaTrigger : l_ToRemoveATs)
        l_AreaTrigger->Remove(0);
}

GameObject* Unit::GetGameObject(uint32 spellId) const
{
    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)
        if ((*i)->GetSpellId() == spellId)
            return *i;

    return NULL;
}

void Unit::AddGameObject(GameObject* gameObj)
{
    if (!gameObj || gameObj->GetOwnerGUID() != 0)
        return;

    m_gameObj.push_back(gameObj);
    gameObj->SetOwnerGUID(GetGUID());

    if (IsPlayer() && gameObj->GetSpellId())
    {
        SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(gameObj->GetSpellId());
        // Need disable spell use for owner
        if (createBySpell && createBySpell->IsCooldownStartedOnEvent())
            // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
            ToPlayer()->AddSpellAndCategoryCooldowns(createBySpell, 0, NULL, true);
    }
}

void Unit::RemoveGameObject(GameObject* gameObj, bool del)
{
    if (!gameObj || gameObj->GetOwnerGUID() != GetGUID())
        return;

    gameObj->SetOwnerGUID(0);

    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)
    {
        if (m_ObjectSlot[i] == gameObj->GetGUID())
        {
            m_ObjectSlot[i] = 0;
            break;
        }
    }

    // GO created by some spell
    if (uint32 spellid = gameObj->GetSpellId())
    {
        RemoveAurasDueToSpell(spellid);

        if (IsPlayer())
        {
            SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(spellid);
            // Need activate spell use for owner
            if (createBySpell && createBySpell->IsCooldownStartedOnEvent())
                // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
                ToPlayer()->SendCooldownEvent(createBySpell);
        }
    }

    m_gameObj.remove(gameObj);

    if (del)
    {
        gameObj->SetRespawnTime(0);
        gameObj->Delete();
    }
}

void Unit::RemoveGameObject(uint32 spellid, bool del)
{
    if (m_gameObj.empty())
        return;
    GameObjectList::iterator i, next;
    for (i = m_gameObj.begin(); i != m_gameObj.end(); i = next)
    {
        next = i;
        if (spellid == 0 || (*i)->GetSpellId() == spellid)
        {
            (*i)->SetOwnerGUID(0);
            if (del)
            {
                (*i)->SetRespawnTime(0);
                (*i)->Delete();
            }

            next = m_gameObj.erase(i);
        }
        else
            ++next;
    }
}

void Unit::RemoveAllGameObjects()
{
    // remove references to unit
    while (!m_gameObj.empty())
    {
        GameObjectList::iterator i = m_gameObj.begin();
        (*i)->SetOwnerGUID(0);
        (*i)->SetRespawnTime(0);
        (*i)->Delete();
        m_gameObj.erase(i);
    }
}

void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage& p_Log)
{
    WorldPacket data(SMSG_SPELL_NON_MELEE_DAMAGE_LOG, 73);

    ObjectGuid l_Target = p_Log.GetTarget()->GetGUID();
    ObjectGuid l_Caster = p_Log.GetActor()->GetGUID();

    int32 l_Overkill = p_Log.GetAmount() > p_Log.GetTarget()->GetHealth() ? int64(p_Log.GetAmount()) - p_Log.GetTarget()->GetHealth() : 0;

    data.appendPackGUID(l_Target);                                               ///< TargetGUID
    data.appendPackGUID(l_Caster);                                               ///< CasterGUID
    data.appendGuid128(Guid128(GUID_TYPE_CAST, 0, p_Log.GetSpellInfo()->Id, 0)); ///< CastID
    data << uint32(p_Log.GetSpellInfo()->Id);                                    ///< SpellID
    data << uint32(p_Log.m_SpellXSpellVisualID);                                 ///< SpellXSpellVisualID
    data << uint32(p_Log.GetAmount());                                           ///< Damage
    data << int32(l_Overkill > 0 ? l_Overkill : -1);                             ///< OverKill
    data << uint8(p_Log.GetSchoolMask());                                        ///< SchoolMask
    data << uint32(p_Log.GetAbsorb());                                           ///< Absorbed
    data << uint32(p_Log.GetResist());                                           ///< Resisted
    data << uint32(p_Log.GetBlock());                                            ///< ShieldBlock

    data.WriteBit(false);                                                        ///< Periodic
    data.WriteBits(p_Log.HitInfo, 7);                                            ///< Flags
    data.WriteBit(false);                                                        ///< HasDebugData
    data.WriteBit(false);                                                        ///< HasLogData
    data.WriteBit(false);                                                        ///< HasSandboxScaling
    data.FlushBits();

    SendMessageToSet(&data, true);
}

void Unit::SendSpellNonMeleeDamageLog(Unit* p_Target, uint32 p_SpellID, uint32 p_Damage, SpellSchoolMask p_DamageSchoolMask, uint32 p_AbsorbedDamage, uint32 p_Resist, bool p_PhysicalDamage, uint32 p_Blocked, uint32 p_SpellXSpellVisualID, bool p_CriticalHit)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo)
        return;

    SpellNonMeleeDamage l_Log(this, p_Target, p_Damage, l_SpellInfo, SPELL_DIRECT_DAMAGE, p_SpellXSpellVisualID);
    l_Log.ChangeSchoolMask(p_DamageSchoolMask);
    l_Log.Absorb(p_AbsorbedDamage);
    l_Log.Block(p_Blocked);
    l_Log.Resist(p_Resist);

    l_Log.physicalLog = p_PhysicalDamage;
    if (p_CriticalHit)
        l_Log.HitInfo |= SPELL_HIT_TYPE_CRIT;

    SendSpellNonMeleeDamageLog(l_Log);
}

void Unit::ProcDamageAndSpell(Unit* p_Victim, uint32 p_ProcAttacker, uint32 p_ProcVictim, uint32 p_ProcExtra, DamageInfo& p_DamageInfo, SpellInfo const* p_ProcAura, Aura const* p_ProcEffect)
{
     // Not much to do if no flags are set.
    if (p_ProcAttacker)
        ProcDamageAndSpellFor(false, p_Victim, p_ProcAttacker, p_ProcExtra, p_DamageInfo, p_ProcAura, p_ProcEffect);
    // Now go on with a victim's events'n'auras
    // Not much to do if no flags are set or there is no victim
    if (p_Victim && p_Victim->isAlive() && p_ProcVictim)
        p_Victim->ProcDamageAndSpellFor(true, this, p_ProcVictim, p_ProcExtra, p_DamageInfo, p_ProcAura, p_ProcEffect);
}

void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* p_Info)
{
    AuraEffect const* l_Aura = p_Info->auraEff;

    uint32 l_Amount              = 0;
    uint32 l_Resisted            = 0;
    uint32 l_OverHealOrKill      = 0;
    uint32 l_SchoolMaskOrPower   = 0;
    uint32 l_AbsorbedOrAmplitude = 0;

    switch (l_Aura->GetAuraType())
    {
        case SPELL_AURA_PERIODIC_DAMAGE:
        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
        case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
            l_Amount                = p_Info->damage;
            l_OverHealOrKill        = p_Info->overDamage;
            l_SchoolMaskOrPower     = l_Aura->GetSpellInfo()->GetSchoolMask();
            l_AbsorbedOrAmplitude   = p_Info->absorb;
            l_Resisted              = p_Info->resist;
            break;

        case SPELL_AURA_PERIODIC_HEAL:
        case SPELL_AURA_OBS_MOD_HEALTH:
            l_Amount                = p_Info->damage;
            l_OverHealOrKill        = p_Info->overDamage;
            l_SchoolMaskOrPower     = l_Aura->GetSpellInfo()->GetSchoolMask();
            l_AbsorbedOrAmplitude   = p_Info->absorb;
            break;

        case SPELL_AURA_OBS_MOD_POWER:
        case SPELL_AURA_PERIODIC_ENERGIZE:
            l_Amount            = p_Info->damage;
            l_SchoolMaskOrPower = l_Aura->GetMiscValue();
            break;

        case SPELL_AURA_PERIODIC_MANA_LEECH:
            l_Amount            = p_Info->damage;
            l_SchoolMaskOrPower = l_Aura->GetMiscValue();
            break;

        default:
            break;
    }

    WorldPacket l_Data(SMSG_SPELL_PERIODIC_AURA_LOG, 100);
    l_Data.appendPackGUID(GetGUID());                           ///< Target GUID
    l_Data.appendPackGUID(l_Aura->GetCasterGUID());             ///< Caster GUID
    l_Data << uint32(l_Aura->GetId());                          ///< Spell ID
    l_Data << uint32(1);                                        ///< Entries Count
    l_Data.WriteBit(0);                                         ///< Has Log Data
    l_Data.FlushBits();

    /// First JamPeriodicAuraLogEffect
    l_Data << uint32(l_Aura->GetAuraType());                    ///< Effect
    l_Data << uint32(l_Amount);                                 ///< Amount
    l_Data << uint32(l_OverHealOrKill);                         ///< Over Heal Or Kill
    l_Data << uint32(l_SchoolMaskOrPower);                      ///< School Mask Or Power
    l_Data << uint32(l_AbsorbedOrAmplitude);                    ///< Absorbed Or Amplitude
    l_Data << uint32(l_Resisted);                               ///< Resisted

    l_Data.WriteBit(p_Info->critical);                          ///< Crit
    l_Data.WriteBit(false);                                     ///< Has Debug Info
    l_Data.WriteBit(false);                                     ///< Has SandboxScaling
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);
}

/// Build and send SMSG_SPELL_MISS_LOG packet
/// @p_Target   : Target for the missed spell
/// @p_SpellId  : Missed spell ID
/// @p_MissInfo : Miss type
void Unit::SendSpellMiss(Unit* p_Target, uint32 p_SpellID, SpellMissInfo p_MissInfo)
{
    WorldPacket l_Data(SMSG_SPELL_MISS_LOG, 4 + 16 + 2 + 1 + 16 + 2 + 1 + 1);
    l_Data << uint32(p_SpellID);                                    ///< SpellID
    l_Data.appendPackGUID(GetGUID());                               ///< Caster
    l_Data << uint32(1);                                            ///< EntriesCount

    /// for (l_I = 0; l_I < EntriesCount; ++l_I)
        l_Data.appendPackGUID(p_Target->GetGUID());                 ///< Victim
        l_Data << uint8(p_MissInfo);                                ///< MissReason
        l_Data.WriteBit(false);                                     ///< HasDebug
        l_Data.FlushBits();

        /// if (HasDebug)
            ///data << float(0.0f);                                  ///< HitRoll
            ///data << float(0.0f);                                  ///< HitRollNeeded
        /// endif
    /// end loop

    SendMessageToSet(&l_Data, true);
}

void Unit::SendSpellDamageResist(Unit * p_Target, uint32 p_SpellID)
{
    WorldPacket l_Data(SMSG_PROCRESIST, 8+8+4+1);
    l_Data.appendPackGUID(GetGUID());
    l_Data.appendPackGUID(p_Target->GetGUID());
    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(false);
    l_Data.WriteBit(false);
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);
}

void Unit::SendSpellDamageImmune(Unit* p_Target, uint32 p_SpellID)
{
    uint64 l_CasterGUID = GetGUID();
    uint64 l_TargetGUID = p_Target->GetGUID();
    bool l_IsPeriodic = sSpellMgr->GetSpellInfo(p_SpellID) ? sSpellMgr->GetSpellInfo(p_SpellID)->IsPeriodic() : false;

    WorldPacket l_Data(SMSG_SPELL_OR_DAMAGE_IMMUNE, (2 * (16 + 2)) + 4 + 1);

    l_Data.appendPackGUID(l_CasterGUID);
    l_Data.appendPackGUID(l_TargetGUID);
    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(l_IsPeriodic);
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);
}

void Unit::SendAttackStateUpdate(CalcDamageInfo* p_DamageInfo)
{
    uint32 l_Count = 1;
    int32 l_Overkill = p_DamageInfo->GetAmount() > p_DamageInfo->GetTarget()->GetHealth() ? int64(p_DamageInfo->GetAmount()) - p_DamageInfo->GetTarget()->GetHealth() : 0;

    ByteBuffer l_Buffer(1000);
    l_Buffer << uint32(p_DamageInfo->HitInfo);                 ///< HitInfo
    l_Buffer.append(p_DamageInfo->GetActor()->GetPackGUID());  ///< AttackerGUID
    l_Buffer.append(p_DamageInfo->GetTarget()->GetPackGUID()); ///< TargetGUID
    l_Buffer << uint32(p_DamageInfo->GetAmount());             ///< Damage
    l_Buffer << uint32(l_Overkill < 0 ? 0 : l_Overkill);       ///< OverDamage
    l_Buffer << uint8(l_Count);                                ///< HasSubDmg

    for (uint32 l_Itr = 0; l_Itr < l_Count; ++l_Itr)
    {
        l_Buffer << uint32(p_DamageInfo->GetSchoolMask());     ///< SchoolMask
        l_Buffer << uint32(p_DamageInfo->GetAmount());         ///< IntDamage
        l_Buffer << float(p_DamageInfo->GetAmount());          ///< FloatDamage
    }

    if (p_DamageInfo->HitInfo & (HITINFO_FULL_ABSORB | HITINFO_PARTIAL_ABSORB))
    {
        for (uint32 l_Itr = 0; l_Itr < l_Count; ++l_Itr)
            l_Buffer << uint32(p_DamageInfo->GetAbsorb());     ///< Absorbed

    }

    if (p_DamageInfo->HitInfo & (HITINFO_FULL_RESIST | HITINFO_PARTIAL_RESIST))
    {
        for (uint32 l_Itr = 0; l_Itr < l_Count; ++l_Itr)
            l_Buffer << uint32(p_DamageInfo->GetResist());     ///< Resisted
    }

    l_Buffer << uint8(p_DamageInfo->TargetState);
    l_Buffer << uint32(0);                                     ///< Unknown VictimState
    l_Buffer << uint32(0);                                     ///< MeleeSpellID

    if (p_DamageInfo->HitInfo & HITINFO_BLOCK)
        l_Buffer << uint32(p_DamageInfo->GetBlock());          ///< BlockAmount

    if (p_DamageInfo->HitInfo & HITINFO_RAGE_GAIN)
        l_Buffer << uint32(0);                                 ///< RageGained

    //! Probably used for debugging purposes, as it is not known to appear on retail servers
    if (p_DamageInfo->HitInfo & HITINFO_UNK1)
    {
        l_Buffer << uint32(0);                                 ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        l_Buffer << float(0);                                  ///< AttackerState
        for (uint8 i = 0; i < 2; ++i)
        {
            l_Buffer << float(0);
            l_Buffer << float(0);
        }
        l_Buffer << uint32(0);
    }

    if (p_DamageInfo->HitInfo & 0x3000)
        l_Buffer << float(0);

    l_Buffer << uint8(0);                                      ///< SandboxScaling.Type
    l_Buffer << uint8(0);                                      ///< SandboxScaling.TargetLevel
    l_Buffer << uint8(0);                                      ///< SandboxScaling.Expansion
    l_Buffer << uint8(0);                                      ///< SandboxScaling.Class
    l_Buffer << uint8(0);                                      ///< SandboxScaling.TargetMinScalingLevel
    l_Buffer << uint8(0);                                      ///< SandboxScaling.TargetMaxScalingLevel
    l_Buffer << int16(0);                                      ///< SandboxScaling.PlayerLevelDelta
    l_Buffer << int8(0);                                       ///< andboxScaling.TargetScalingLevelDelta

    WorldPacket data(SMSG_ATTACKER_STATE_UPDATE, l_Buffer.size() + 4 + 1);
    data.WriteBit(false);
    data.FlushBits();
    data << uint32(l_Buffer.size());
    data.append(l_Buffer);

    SendMessageToSet(&data, true);
}

void Unit::SendAttackStateUpdate(uint32 p_HitInfo, Unit* p_Target, uint8 /*p_SwingType*/, SpellSchoolMask p_DamageSchoolMask, uint32 p_Damage, uint32 p_AbsorbDamage, uint32 p_Resist, VictimState p_TargetState, uint32 p_BlockedAmount)
{
    CalcDamageInfo l_DamageInfo(this, p_Target, p_Damage, p_DamageSchoolMask, DIRECT_DAMAGE);
    l_DamageInfo.Absorb(p_AbsorbDamage);
    l_DamageInfo.Block(p_BlockedAmount);
    l_DamageInfo.Resist(p_Resist);
    l_DamageInfo.HitInfo = p_HitInfo;
    l_DamageInfo.TargetState = p_TargetState;

    SendAttackStateUpdate(&l_DamageInfo);
}

bool Unit::HandleHasteAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
{
    SpellInfo const* hasteSpell = triggeredByAura->GetSpellInfo(); //< hasteSpell is never read 01/18/16

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;
    Unit* target = victim;
    int32 basepoints0 = 0;

    // processed charge only counting case
    if (!triggered_spell_id)
        return true;

    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);

    if (!triggerEntry)
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(triggered_spell_id))
        return false;

    if (basepoints0)
        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, cooldown);

    return true;
}

bool Unit::HandleSpellCritChanceAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
{
    SpellInfo const* triggeredByAuraSpell = triggeredByAura->GetSpellInfo(); ///> triggerByAuraSpell is never read 01/18/16

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;
    Unit* target = victim;
    int32 basepoints0 = 0;

    // processed charge only counting case
    if (!triggered_spell_id)
        return true;

    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);

    if (!triggerEntry)
        return false;

    // default case
    if (!target || (target != this && !target->isAlive()))
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(triggered_spell_id))
        return false;

    if (basepoints0)
        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, cooldown);

    return true;
}

bool Unit::HandleAuraProcOnPowerAmount(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 procFlag, uint32 /*procEx*/, uint32 cooldown)
{
    // Get triggered aura spell info
    SpellInfo const* auraSpellInfo = triggeredByAura->GetSpellInfo();

    // Get effect index used for the proc
    uint32 effIndex = triggeredByAura->GetEffIndex(); ///< effIndex is never read 01/18/16

    // Power amount required to proc the spell
    int32 powerAmountRequired = triggeredByAura->GetAmount();
    // Power type required to proc
    Powers powerRequired = Powers(auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].MiscValue);

    // Set trigger spell id, target, custom basepoints
    uint32 trigger_spell_id = auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;

    Unit*  target = NULL;
    int32  basepoints0 = 0;

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    /* Try handle unknown trigger spells or with invalid power amount or misc value
    if (sSpellMgr->GetSpellInfo(trigger_spell_id) == NULL || powerAmountRequired == NULL || powerRequired >= MAX_POWER)
    {
        switch (auraSpellInfo->SpellFamilyName)
        {
            case SPELLFAMILY_GENERIC:
            {
                break;
            }
        }
    }*/

    // All ok. Check current trigger spell
    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(trigger_spell_id);
    if (triggerEntry == NULL)
    {
        // Not cast unknown spell
        // sLog->outError("Unit::HandleAuraProcOnPowerAmount: Spell %u have 0 in EffectTriggered[%d], not handled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
        return false;
    }

    // not allow proc extra attack spell at extra attack
    if (m_extraAttacks && triggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
        return false;

    if (!powerRequired || !powerAmountRequired)
        return false;

    if (GetPower(powerRequired) != powerAmountRequired)
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(trigger_spell_id))
        return false;

    // try detect target manually if not set
    if (target == NULL)
        target = !(procFlag & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;

    if (basepoints0)
        CastCustomSpell(target, trigger_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, cooldown);

    return true;
}

//victim may be NULL
bool Unit::HandleDummyAuraProc(Unit* victim, DamageInfo* p_DmgInfo, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown)
{
    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();
    uint32 effIndex = triggeredByAura->GetEffIndex();
    int32  triggerAmount = triggeredByAura->GetAmount();

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;
    uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers
                                  // otherwise, it's the triggered_spell_id by default
    Unit* target = victim;
    int32 basepoints0 = 0;
    uint64 originalCaster = 0;

    uint16 l_VisualID = 0;
    if (procSpell)
    {
        if (SpellXSpellVisualEntry const* l_VisualEntry = sSpellXSpellVisualStore.LookupEntry(procSpell->GetSpellXSpellVisualId(this)))
            l_VisualID = l_VisualEntry->VisualID;
    }

    switch (dummySpell->SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
        {
            switch (dummySpell->Id)
            {
                case 206150: // Challenger's Might
                {
                    switch (effIndex)
                    {
                        case EFFECT_8:
                        {
                            if (!triggerAmount)
                                return false;

                            /// Necrotic can only procs off main hand attacks
                            if (!(procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))
                                return false;

                            triggered_spell_id = 209858;
                            break;
                        }
                        default:
                            break;
                    }

                    break;
                }
                case 108007: // Indomitable, Indomitable Pride (normal)
                case 109785: // Indomitable, Indomitable Pride (lfr)
                case 109786: // Indomitable, Indomitable Pride (heroic)
                    if (!victim)
                        return false;
                    if (!damage)
                        return false;
                    if (effIndex != EFFECT_1)
                        return false;

                    if (!HealthBelowPctDamaged(50, damage))
                        return false;

                    if (Aura const* aur = triggeredByAura->GetBase())
                        if (AuraEffect const* aurEff = aur->GetEffect(EFFECT_1))
                            basepoints0 = int32(CalculatePct(damage, aurEff->GetAmount()));

                    triggered_spell_id = 108008;
                    break;
                case 104561:// Windsong
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (ToPlayer()->HasSpellCooldown(104561))
                        return false;

                    switch (urand(0, 2))
                    {
                        case 0: // Critical Strike
                            CastSpell(this, 104509, true);
                            break;
                        case 1: // Haste
                            CastSpell(this, 104510, true);
                            break;
                        case 2: // Mastery
                        default:
                            CastSpell(this, 104423, true);
                            break;
                    }

                    ToPlayer()->AddSpellCooldown(104561, 0, 60 * IN_MILLISECONDS);
                    return false;
                }
                case 120033:// Jade Spirit
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (ToPlayer()->HasSpellCooldown(104993))
                        return false;

                    basepoints0 = 1650;
                    int32 basepoints1 = 0;

                    if (GetPowerPct(POWER_MANA) >= 25.0f)
                        CastCustomSpell(this, 104993, &basepoints0, &basepoints1, NULL, true);
                    else
                        CastSpell(this, 104993, true);

                    ToPlayer()->AddSpellCooldown(104993, 0, 60 * IN_MILLISECONDS);
                    return false;
                }
                case 118333:// Dancing Steel
                case 142531:// Bloody Dancing Steel
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK)
                    {
                        if (Item* mainItem = ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
                        {
                            if (GetStat(STAT_AGILITY) > GetStat(STAT_STRENGTH))
                                CastSpell(this, 118334, true, mainItem);
                            else
                                CastSpell(this, 118335, true, mainItem);
                        }
                    }
                    else if (procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
                    {
                        if (Item* offItem = ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
                        {
                            if (GetStat(STAT_AGILITY) > GetStat(STAT_STRENGTH))
                                CastSpell(this, 118334, true, offItem);
                            else
                                CastSpell(this, 118335, true, offItem);
                        }
                    }

                    break;
                }
                case 142536:// Spirit of Conquest
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (ToPlayer()->HasSpellCooldown(142535))
                        return false;

                    triggered_spell_id = 142535;
                    CastSpell(this, triggered_spell_id, true);
                    ToPlayer()->AddSpellCooldown(142535, 0, 60 * IN_MILLISECONDS);
                    return false;
                }
                // Weight of Feather, Scales of Life
                case 96879:
                case 97117:
                {
                    if (!victim)
                        return false;

                    int32 max_amount = triggeredByAura->GetAmount();
                    int32 add_heal = int64(damage) - (victim->GetMaxHealth() - victim->GetHealth());
                    if (add_heal <= 0)
                        return false;

                    int32 old_amount = 0;

                    if (AuraEffect* aurEff = victim->GetAuraEffect(96881, EFFECT_0))
                        old_amount = aurEff->GetAmount();

                    int32 new_amount = old_amount + add_heal;

                    int32 bp0 = std::min(new_amount, max_amount);
                    CastCustomSpell(victim, 96881, &bp0, 0, 0, true);
                    return true;
                }
                // Wrath of Tarecgosa
                case 101056:
                {
                    if (!procSpell)
                        return false;

                    if (!victim)
                        return false;

                    if (GetGUID() == victim->GetGUID())
                        return false;

                    float l_ProcChance = 5.0f;
                    if (procFlag & PROC_FLAG_DONE_PERIODIC)
                        l_ProcChance = 10.f;

                    constexpr int32 l_MaxLevel = 100;
                    constexpr int32 l_MaxDiff = l_MaxLevel - 85;

                    float l_Coeff = getLevel() >= l_MaxLevel ? 0.0f : float(l_MaxLevel - getLevel()) / l_MaxDiff;
                    l_ProcChance *= l_Coeff;

                    if (procFlag & PROC_FLAG_DONE_PERIODIC)
                    {
                        if (!roll_chance_f(l_ProcChance))
                            return false;

                        basepoints0 = damage;
                        triggered_spell_id = 101085;
                        break;
                    }
                    else
                    {
                        if (!roll_chance_f(l_ProcChance))
                            return false;

                        triggered_spell_id = procSpell->Id;
                    }
                    break;
                }
                // Eye for an Eye
                case 25988:
                {
                    // return damage % to attacker but < 50% own total health
                    basepoints0 = int32(std::min(uint64(CalculatePct(damage, triggerAmount)), uint64(CountPctFromMaxHealth(50, victim))));
                    triggered_spell_id = 25997;
                    break;
                }
                // Sweeping Strikes
                case 18765:
                case 35429:
                {
                    target = SelectNearbyTarget(victim, NOMINAL_MELEE_RANGE, 0U, true, true, false, true);
                    if (!target)
                        return false;

                    triggered_spell_id = 26654;
                    break;
                }
                // Unstable Power
                case 24658:
                {
                    if (!procSpell || procSpell->Id == 24659)
                        return false;
                    // Need remove one 24659 aura
                    RemoveAuraFromStack(24659);
                    return true;
                }
                // Restless Strength
                case 24661:
                {
                    // Need remove one 24662 aura
                    RemoveAuraFromStack(24662);
                    return true;
                }
                // Adaptive Warding (Frostfire Regalia set)
                case 28764:
                {
                    if (!procSpell)
                        return false;

                    // find Mage Armor
                    if (!GetAuraEffect(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT, SPELLFAMILY_MAGE, 0x10000000, 0, 0))
                        return false;

                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))
                    {
                        case SPELL_SCHOOL_NORMAL:
                        case SPELL_SCHOOL_HOLY:
                            return false;                   // ignored
                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 28765; break;
                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 28768; break;
                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 28766; break;
                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 28769; break;
                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 28770; break;
                        default:
                            return false;
                    }

                    target = this;
                    break;
                }
                // Obsidian Armor (Justice Bearer`s Pauldrons shoulder)
                case 27539:
                {
                    if (!procSpell)
                        return false;

                    switch (GetFirstSchoolInMask(procSpell->GetSchoolMask()))
                    {
                        case SPELL_SCHOOL_NORMAL:
                            return false;                   // ignore
                        case SPELL_SCHOOL_HOLY:   triggered_spell_id = 27536; break;
                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 27533; break;
                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 27538; break;
                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 27534; break;
                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 27535; break;
                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 27540; break;
                        default:
                            return false;
                    }

                    target = this;
                    break;
                }
                // Mana Leech (Passive) (Priest Pet Aura)
                case 28305:
                {
                    // Cast on owner
                    target = GetOwner();
                    if (!target)
                        return false;

                    if (GetEntry() == 62982 || GetEntry() == 67236) // Mindbender
                    {
                        target->EnergizeBySpell(target, 123051, CalculatePct(target->GetMaxPower(POWER_MANA), 0.5f), POWER_MANA);
                        return false;
                    }

                    triggered_spell_id = 34650;
                    break;
                }
                // Mark of Malice
                case 33493:
                {
                    // Cast finish spell at last charge
                    if (triggeredByAura->GetBase()->GetCharges() > 1)
                        return false;

                    target = this;
                    triggered_spell_id = 33494;
                    break;
                }
                // Twisted Reflection (boss spell)
                case 21063:
                    triggered_spell_id = 21064;
                    break;
                // Vampiric Aura (boss spell)
                case 38196:
                {
                    basepoints0 = 3 * damage;               // 300%
                    if (basepoints0 < 0)
                        return false;

                    triggered_spell_id = 31285;
                    target = this;
                    break;
                }
                // Aura of Madness (Darkmoon Card: Madness trinket)
                //=====================================================
                // 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)
                // 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)
                // 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)
                // 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)
                // 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)
                // 41005 Manic: +35 haste (spell, melee and ranged) (All classes)
                // 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)
                // 41011 Martyr Complex: +35 stamina (All classes)
                // 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
                // 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
                case 39446:
                {
                    if (GetTypeId() != TYPEID_PLAYER || !isAlive())
                        return false;

                    // Select class defined buff
                    switch (getClass())
                    {
                        case CLASS_PALADIN:                 // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
                        case CLASS_DRUID:                   // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
                            triggered_spell_id = RAND(39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409);
                            cooldown_spell_id = 39511;
                            break;
                        case CLASS_ROGUE:                   // 39511, 40997, 40998, 41002, 41005, 41011
                        case CLASS_WARRIOR:                 // 39511, 40997, 40998, 41002, 41005, 41011
                        case CLASS_DEATH_KNIGHT:
                            triggered_spell_id = RAND(39511, 40997, 40998, 41002, 41005, 41011);
                            cooldown_spell_id = 39511;
                            break;
                        case CLASS_PRIEST:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409
                        case CLASS_SHAMAN:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409
                        case CLASS_MAGE:                    // 40999, 41002, 41005, 41009, 41011, 41406, 41409
                        case CLASS_WARLOCK:                 // 40999, 41002, 41005, 41009, 41011, 41406, 41409
                            triggered_spell_id = RAND(40999, 41002, 41005, 41009, 41011, 41406, 41409);
                            cooldown_spell_id = 40999;
                            break;
                        case CLASS_HUNTER:                  // 40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409
                            triggered_spell_id = RAND(40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409);
                            cooldown_spell_id = 40997;
                            break;
                        default:
                            return false;
                    }

                    target = this;
                    if (roll_chance_i(10))
                        ToPlayer()->Say("This is Madness!", LANG_UNIVERSAL); // TODO: It should be moved to database, shouldn't it?
                    break;
                }
                // Sunwell Exalted Caster Neck (??? neck)
                // cast ??? Light's Wrath if Exalted by Aldor
                // cast ??? Arcane Bolt if Exalted by Scryers
                case 46569:
                    return false;                           // old unused version
                // Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)
                // cast 45479 Light's Wrath if Exalted by Aldor
                // cast 45429 Arcane Bolt if Exalted by Scryers
                case 45481:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // Get Aldor reputation rank
                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
                    {
                        target = this;
                        triggered_spell_id = 45479;
                        break;
                    }
                    // Get Scryers reputation rank
                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
                    {
                        // triggered at positive/self casts also, current attack target used then
                        if (target && IsFriendlyTo(target))
                        {
                            target = getVictim();
                            if (!target)
                            {
                                uint64 selected_guid = ToPlayer()->GetSelection();
                                target = ObjectAccessor::GetUnit(*this, selected_guid);
                                if (!target)
                                    return false;
                            }
                            if (IsFriendlyTo(target))
                                return false;
                        }

                        triggered_spell_id = 45429;
                        break;
                    }
                    return false;
                }
                // Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)
                // cast 45480 Light's Strength if Exalted by Aldor
                // cast 45428 Arcane Strike if Exalted by Scryers
                case 45482:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // Get Aldor reputation rank
                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
                    {
                        target = this;
                        triggered_spell_id = 45480;
                        break;
                    }
                    // Get Scryers reputation rank
                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
                    {
                        triggered_spell_id = 45428;
                        break;
                    }
                    return false;
                }
                // Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)
                // cast 45431 Arcane Insight if Exalted by Aldor
                // cast 45432 Light's Ward if Exalted by Scryers
                case 45483:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // Get Aldor reputation rank
                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
                    {
                        target = this;
                        triggered_spell_id = 45432;
                        break;
                    }
                    // Get Scryers reputation rank
                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
                    {
                        target = this;
                        triggered_spell_id = 45431;
                        break;
                    }
                    return false;
                }
                // Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)
                // cast 45478 Light's Salvation if Exalted by Aldor
                // cast 45430 Arcane Surge if Exalted by Scryers
                case 45484:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // Get Aldor reputation rank
                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
                    {
                        target = this;
                        triggered_spell_id = 45478;
                        break;
                    }
                    // Get Scryers reputation rank
                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
                    {
                        triggered_spell_id = 45430;
                        break;
                    }
                    return false;
                }
                // Living Seed
                case 48504:
                {
                    triggered_spell_id = 48503;
                    basepoints0 = triggerAmount;
                    target = this;
                    break;
                }
                // Purified Shard of the Scale - Onyxia 10 Caster Trinket
                case 69755:
                {
                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69733 : 69729;
                    break;
                }
                // Shiny Shard of the Scale - Onyxia 25 Caster Trinket
                case 69739:
                {
                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69734 : 69730;
                    break;
                }
                case 71519: // Deathbringer's Will Normal
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (ToPlayer()->HasSpellCooldown(dummySpell->Id))
                        return false;

                    std::vector<uint32> RandomSpells;
                    switch (getClass())
                    {
                        case CLASS_WARRIOR:
                        case CLASS_PALADIN:
                        case CLASS_DEATH_KNIGHT:
                            RandomSpells.push_back(71484);
                            RandomSpells.push_back(71491);
                            RandomSpells.push_back(71492);
                            break;
                        case CLASS_SHAMAN:
                        case CLASS_ROGUE:
                            RandomSpells.push_back(71486);
                            RandomSpells.push_back(71485);
                            RandomSpells.push_back(71492);
                            break;
                        case CLASS_DRUID:
                            RandomSpells.push_back(71484);
                            RandomSpells.push_back(71485);
                            RandomSpells.push_back(71492);
                            break;
                        case CLASS_HUNTER:
                            RandomSpells.push_back(71486);
                            RandomSpells.push_back(71491);
                            RandomSpells.push_back(71485);
                            break;
                        default:
                            return false;
                    }
                    if (RandomSpells.empty()) // shouldn't happen
                        return false;

                    triggered_spell_id = RandomSpells[irand(0, (RandomSpells.size() - 1))];
                    ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, cooldown);
                    break;
                }
                case 71562: // Deathbringer's Will Heroic
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (ToPlayer()->HasSpellCooldown(dummySpell->Id))
                        return false;

                    std::vector<uint32> RandomSpells;
                    switch (getClass())
                    {
                        case CLASS_WARRIOR:
                        case CLASS_PALADIN:
                        case CLASS_DEATH_KNIGHT:
                            RandomSpells.push_back(71561);
                            RandomSpells.push_back(71559);
                            RandomSpells.push_back(71560);
                            break;
                        case CLASS_SHAMAN:
                        case CLASS_ROGUE:
                            RandomSpells.push_back(71558);
                            RandomSpells.push_back(71556);
                            RandomSpells.push_back(71560);
                            break;
                        case CLASS_DRUID:
                            RandomSpells.push_back(71561);
                            RandomSpells.push_back(71556);
                            RandomSpells.push_back(71560);
                            break;
                        case CLASS_HUNTER:
                            RandomSpells.push_back(71558);
                            RandomSpells.push_back(71559);
                            RandomSpells.push_back(71556);
                            break;
                        default:
                            return false;
                    }
                    if (RandomSpells.empty()) // shouldn't happen
                        return false;

                    triggered_spell_id = RandomSpells[irand(0, (RandomSpells.size() - 1))];
                    ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, cooldown);
                    break;
                }
                case 71875: // Item - Black Bruise: Necrotic Touch Proc
                case 71877:
                {
                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
                    triggered_spell_id = 71879;
                    break;
                }
                // Item - Shadowmourne Legendary
                case 71903:
                {
                    if (!victim || !victim->isAlive() || HasAura(73422))  // cant collect shards while under effect of Chaos Bane buff
                        return false;

                    CastSpell(this, 71905, true, NULL, triggeredByAura);

                    // this can't be handled in AuraScript because we need to know victim
                    Aura const* dummy = GetAura(71905);
                    if (!dummy || dummy->GetStackAmount() < 10)
                        return false;

                    RemoveAurasDueToSpell(71905);
                    triggered_spell_id = 71904;
                    target = victim;
                    break;
                }
                // Shadow's Fate (Shadowmourne questline)
                case 71169:
                {
                    target = triggeredByAura->GetCaster();
                    if (!target)
                        return false;
                    Player* player = target->ToPlayer();
                    if (!player)
                        return false;
                    // not checking Infusion auras because its in targetAuraSpell of credit spell
                    if (player->GetQuestStatus(24749) == QUEST_STATUS_INCOMPLETE)       // Unholy Infusion
                    {
                        if (GetEntry() != 36678)                                        // Professor Putricide
                            return false;
                        CastSpell(target, 71518, true);                                 // Quest Credit
                        return true;
                    }
                    else if (player->GetQuestStatus(24756) == QUEST_STATUS_INCOMPLETE)  // Blood Infusion
                    {
                        if (GetEntry() != 37955)                                        // Blood-Queen Lana'thel
                            return false;
                        CastSpell(target, 72934, true);                                 // Quest Credit
                        return true;
                    }
                    else if (player->GetQuestStatus(24757) == QUEST_STATUS_INCOMPLETE)  // Frost Infusion
                    {
                        if (GetEntry() != 36853)                                        // Sindragosa
                            return false;
                        CastSpell(target, 72289, true);                                 // Quest Credit
                        return true;
                    }
                    else if (player->GetQuestStatus(24547) == QUEST_STATUS_INCOMPLETE)  // A Feast of Souls
                        triggered_spell_id = 71203;
                    break;
                }
                // Essence of the Blood Queen
                case 70871:
                {
                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
                    CastCustomSpell(70872, SPELLVALUE_BASE_POINT0, basepoints0, this);
                    return true;
                }
                case 65032: // Boom aura (321 Boombot)
                {
                    if (victim->GetEntry() != 33343)   // Scrapbot
                        return false;

                    InstanceScript* instance = GetInstanceScript();
                    if (!instance)
                        return false;

                    instance->DoCastSpellOnPlayers(65037);  // Achievement criteria marker
                    break;
                }
                // Dark Hunger (The Lich King encounter)
                case 69383:
                {
                    basepoints0 = CalculatePct(int32(damage), 50);
                    triggered_spell_id = 69384;
                    break;
                }
                case 47020: // Enter vehicle XT-002 (Scrapbot)
                {
                    if (GetTypeId() != TYPEID_UNIT)
                        return false;

                    Unit* vehicleBase = GetVehicleBase();
                    if (!vehicleBase)
                        return false;

                    // Todo: Check if this amount is blizzlike
                    vehicleBase->ModifyHealth(vehicleBase->CountPctFromMaxHealth(1));
                    break;
                }
            }
            break;
        }
        case SPELLFAMILY_MAGE:
        {
            switch (dummySpell->Id)
            {
                case 37424: // Incanter's Regalia set (add trigger chance to Mana Shield)
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    target = this;
                    triggered_spell_id = 37436;
                    break;
                }
                case 44448: ///< Pyroblast Clearcasting Driver
                {
                    if (!procSpell || !procSpell->CanTriggerHotStreak())
                        return false;

                    if (!damage && !(procEx & PROC_EX_ABSORB))
                        return false;

                    if (procEx & (PROC_EX_INTERNAL_DOT | PROC_EX_INTERNAL_MULTISTRIKE))
                        return false;

                    /// Prevent proc on victim fire mage
                    if (procFlag & PROC_FLAG_TAKEN_DAMAGE)
                        return false;

                    if (procEx & PROC_EX_CRITICAL_HIT)
                    {
                        if (procSpell->Id == 194466 && HasAura(238127) && m_SpellHelper.GetBool(eSpellHelpers::PhoenixsFlamesChain))
                            m_SpellHelper.GetBool(eSpellHelpers::PhoenixsFlamesChain) = false;
                        else if (procSpell->Id == 194466 && HasAura(238127) && !m_SpellHelper.GetBool(eSpellHelpers::PhoenixsFlamesChain))
                            return false;

                        if (!HasAura(48107))
                        {
                            if (!HasAura(48108))
                            {
                                CastSpell(this, 48107, true, castItem); ///< Heating Up
                                return true;
                            }
                        }
                        else
                        {
                            RemoveAura(48107);
                            triggered_spell_id = 48108; ///< Pyroblast!
                            target = this;
                            break;
                        }
                    }
                    else
                    {
                        if (Aura* l_HeatingUp = GetAura(48107, GetGUID()))
                        {
                            uint32 l_GracePeriod = 200;
                            if (l_HeatingUp->GetDuration() < l_HeatingUp->GetMaxDuration() - l_GracePeriod)
                                l_HeatingUp->SetDuration(500);
                        }
                        return false;
                    }
                    break;
                }
                case 64411: // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
                {
                    if (!victim)
                        return false;
                    basepoints0 = int32(CalculatePct(damage, 15));
                    if (AuraEffect* aurEff = victim->GetAuraEffect(64413, 0, GetGUID()))
                    {
                        // The shield can grow to a maximum size of 20, 000 damage absorbtion
                        aurEff->SetAmount(std::min<int32>(aurEff->GetAmount() + basepoints0, 20000));

                        // Refresh and return to prevent replacing the aura
                        aurEff->GetBase()->RefreshDuration();
                        return true;
                    }
                    target = victim;
                    triggered_spell_id = 64413;
                    break;
                }
                default:
                    break;
            }
        }
        case SPELLFAMILY_WARRIOR:
        {
            switch (dummySpell->Id)
            {
                // Item - Warrior T13 Protection 2P Bonus (Revenge)
                case 105908:
                    if (!victim)
                        return false;

                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (victim != ToPlayer()->GetSelectedUnit())
                        return false;

                    basepoints0 = int32(CalculatePct(damage, 20));
                    triggered_spell_id = 105909;

                    if (AuraEffect const* aurEff = GetAuraEffect(triggered_spell_id, EFFECT_0))
                        basepoints0 += aurEff->GetAmount();

                    target = this;

                    break;
                // Item - Warrior T12 Protection 2P Bonus
                case 99239:
                {
                    basepoints0 = int32(CalculatePct(damage, triggerAmount / 2)); // 2 ticks
                    triggered_spell_id = 99240;
                    target = victim;
                    break;
                }
                // Victorious
                case 32216:
                {
                    RemoveAura(dummySpell->Id);
                    return false;
                }
            }
            // Retaliation
            if (dummySpell->SpellFamilyFlags[1] & 0x8)
            {
                // check attack comes not from behind
                if (!HasInArc(M_PI, victim))
                    return false;

                triggered_spell_id = 22858;
                break;
            }
            break;
        }
        case SPELLFAMILY_WARLOCK:
        {
            switch (dummySpell->Id)
            {
                case 37377: // Shadowflame (Voidheart Raiment set bonus)
                {
                    triggered_spell_id = 37379;
                    break;
                }
                case 37381: // Pet Healing (Corruptor Raiment or Rift Stalker Armor)
                {
                    target = GetGuardianPet();
                    if (!target)
                        return false;

                    // heal amount
                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
                    triggered_spell_id = 37382;
                    break;
                }
                case 39437: // Shadowflame Hellfire (Voidheart Raiment set bonus)
                {
                    triggered_spell_id = 37378;
                    break;
                }
                default:
                    break;
            }

            break;
        }
        case SPELLFAMILY_PRIEST:
        {
            // Vampiric Touch
            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
            {
                if (!victim || !victim->isAlive())
                    return false;

                if (effIndex != 0)
                    return false;

                // victim is caster of aura
                if (triggeredByAura->GetCasterGUID() != victim->GetGUID())
                    return false;

                // Energize 1% of max. mana
                victim->CastSpell(victim, 57669, true, castItem, triggeredByAura);
                return true;                                // no hidden cooldown
            }

            switch (dummySpell->Id)
            {
                // Shadowflame, Item - Priest T12 Shadow 2P Bonus
                case 99155:
                {
                    if (!GetOwner())
                        return false;

                    if (!(GetOwner()->GetShapeshiftForm() == FORM_SHADOWFORM) || !GetOwner()->HasAura(99154))
                        return false;

                    target = victim;
                    basepoints0 = int32(CalculatePct(damage, 20));
                    triggered_spell_id = 99156;
                    break;
                }
                // Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)
                case 40438:
                {
                    // Shadow Word: Pain
                    if (procSpell->SpellFamilyFlags[0] & 0x8000)
                        triggered_spell_id = 40441;
                    // Renew
                    else if (procSpell->SpellFamilyFlags[0] & 0x40)
                        triggered_spell_id = 40440;
                    else
                        return false;

                    target = this;
                    break;
                }
                // Oracle Healing Bonus ("Garments of the Oracle" set)
                case 26169:
                {
                    // heal amount
                    basepoints0 = int32(CalculatePct(damage, 10));
                    target = this;
                    triggered_spell_id = 26170;
                    break;
                }
                // Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set
                case 39372:
                {
                    if (!procSpell || (procSpell->GetSchoolMask() & (SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_SHADOW)) == 0)
                        return false;

                    // heal amount
                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
                    target = this;
                    triggered_spell_id = 39373;
                    break;
                }
                // Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)
                case 28809:
                {
                    triggered_spell_id = 28810;
                    break;
                }
                // Priest T10 Healer 2P Bonus
                case 70770:
                    // Flash Heal
                    if (procSpell->SpellFamilyFlags[0] & 0x800)
                    {
                        triggered_spell_id = 70772;
                        SpellInfo const* blessHealing = sSpellMgr->GetSpellInfo(triggered_spell_id);
                        if (!blessHealing)
                            return false;
                        basepoints0 = int32(CalculatePct(damage, triggerAmount) / (blessHealing->GetMaxDuration() / blessHealing->Effects[0].Amplitude));
                    }
                    break;
                // Shadowy Apparition
                case 78203:
                    if (Aura* aur = GetAura(dummySpell->Id))
                    {
                        int32 chance = aur->GetEffect(0)->GetAmount();
                        if (IsMoving())
                            chance *= 5;
                        if (effIndex !=0 || !procSpell || !roll_chance_i(chance))
                            return false;

                        std::list<Creature*> summons;
                        GetAllMinionsByEntry(summons, 46954);
                        if (summons.size() > 3)
                            return false;

                        int32 bp0 = 1;
                        CastCustomSpell(this, 87426, &bp0, NULL, NULL, true);

                        std::list<Creature*> new_summons;
                        GetAllMinionsByEntry(new_summons, 46954);

                        Unit* summon = NULL;
                        for (std::list<Creature*>::iterator new_itr = new_summons.begin(); new_itr != new_summons.end(); ++new_itr)
                        {
                            summon = NULL;
                            for (std::list<Creature*>::iterator itr = summons.begin(); itr != summons.end(); ++itr)
                                if ((*new_itr)->GetGUID() == (*itr)->GetGUID())
                                    summon = *new_itr;
                            if (!summon)
                            {
                                summon = *new_itr;
                                break;
                            }
                        }
                        if (summon)
                        {
                            //summon->m_FollowingRefManager.clearReferences();
                            CastSpell(summon, 87213, true);
                            summon->CastSpell(summon, 87427, true);
                            summon->GetAI()->AttackStart(victim);
                        }
                    }
                    break;
            }
            break;
        }
        case SPELLFAMILY_DRUID:
        {
            switch (dummySpell->Id)
            {
                // Item - Shaman T12 Enhancement 4P Bonus
                case 99213:
                    triggered_spell_id = 99212;
                    target = victim;
                    break;
                // Item - Rogue T12 2P Bonus
                case 99174:
                {
                    triggerAmount = 3;
                    basepoints0 = CalculatePct(damage, triggerAmount);
                    triggered_spell_id = 99173;
                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
                    break;
                }
                // Item  Druid T12 Restoration 4P Bonus
                case 99015:
                {
                    if (!victim || !victim->ToPlayer())
                        return false;

                    Player* plr = victim->ToPlayer();
                    if (!plr)
                        return false;

                    std::list<Player*> plrList;
                    JadeCore::AnyFriendlyUnitInObjectRangeCheck check(this, this, 15.0f);
                    JadeCore::PlayerListSearcher<JadeCore::AnyFriendlyUnitInObjectRangeCheck> searcher(this, plrList, check);
                    VisitNearbyObject(15.0f, searcher);
                    if (plrList.empty())
                        return false;

                    plrList.remove(plr);

                    if (plrList.empty())
                        return false;

                    plrList.sort(JadeCore::HealthPctOrderPred());
                    plrList.resize(1);

                    int32 bp0 = damage;

                    CastCustomSpell(plrList.front(), 99017, &bp0, 0, 0, true);
                    return true;
                }
                // Item - Druid T12 Feral 4P Bonus
                case 99009:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    int32 l_Chance = 20 * GetPower(Powers::POWER_COMBO_POINT);
                    if (!roll_chance_i(l_Chance))
                        return false;

                    if (Aura* l_Aura = GetAura(50334))
                        l_Aura->SetDuration(l_Aura->GetDuration() + 2000);
                    break;
                }
                // Item  Druid T12 Feral 2P Bonus
                case 99001:
                    triggerAmount /= 2;
                    basepoints0 = int32(CalculatePct(damage, triggerAmount));
                    triggered_spell_id = 99002;
                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
                    target = victim;
                    break;
                case 28719: // Healing Touch (Dreamwalker Raiment set)
                {
                    // mana back
                    basepoints0 = int32(CalculatePct(procSpell->ManaCost, 30));
                    target = this;
                    triggered_spell_id = 28742;
                    break;
                }
                case 37288: // Mana Restore (Malorne Raiment set / Malorne Regalia set)
                case 37295:
                {
                    target = this;
                    triggered_spell_id = 37238;
                    break;
                }
                case 40442: // Druid Tier 6 Trinket
                {
                    float  chance;

                    // Starfire
                    if (procSpell->SpellFamilyFlags[0] & 0x4)
                    {
                        triggered_spell_id = 40445;
                        chance = 25.0f;
                    }
                    // Rejuvenation
                    else if (procSpell->SpellFamilyFlags[0] & 0x10)
                    {
                        triggered_spell_id = 40446;
                        chance = 25.0f;
                    }
                    // Mangle (Bear)
                    else if (procSpell->SpellFamilyFlags[1] & 0x00000440)
                    {
                        triggered_spell_id = 40452;
                        chance = 40.0f;
                    }
                    else
                        return false;

                    if (!roll_chance_f(chance))
                        return false;

                    target = this;
                    break;
                }
                case 44835: // Maim Interrupt
                {
                    // Deadly Interrupt Effect
                    triggered_spell_id = 32747;
                    break;
                }
                case 70723: // Item - Druid T10 Balance 4P Bonus
                {
                    // Wrath & Starfire
                    if ((procSpell->SpellFamilyFlags[0] & 0x5) && (procEx & PROC_EX_CRITICAL_HIT))
                    {
                        triggered_spell_id = 71023;
                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
                        if (!triggeredSpell)
                            return false;
                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
                        // Add remaining ticks to damage done
                        basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
                    }
                    break;
                }
                case 70664: // Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
                {
                    // Proc only from normal Rejuvenation
                    if (l_VisualID != 32)
                        return false;

                    Player* caster = ToPlayer();
                    if (!caster)
                        return false;
                    if (!caster->GetGroup() && victim == this)
                        return false;

                    CastCustomSpell(70691, SPELLVALUE_BASE_POINT0, damage, victim, true);
                    return true;
                }
                case 102351:// Cenarion Ward
                {
                    if (!victim || !damage)
                        return false;

                    if (procSpell && procSpell->IsPositive())
                        return false;

                    if (!(procFlag & TAKEN_HIT_PROC_FLAG_MASK))
                        return false;

                    target = this;
                    triggered_spell_id = 102352;
                    break;
                }
            }
            break;
        }
        case SPELLFAMILY_ROGUE:
        {
            switch (dummySpell->Id)
            {
                case 51626: // Deadly Brew
                case 51667: // Cut to the Chase
                    return false;
                case 57934: // Tricks of the Trade
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    Unit* redirectTarget = GetMisdirectionTarget();
                    RemoveAura(57934);

                    // Item - Rogue T12 4P Bonus
                    if (HasAura(99175))
                    {
                        uint32 spellIds[3] = {99186, 99187, 99188};
                        uint32 crIds[3] = {CR_HASTE_MELEE, CR_CRIT_MELEE, CR_MASTERY};
                        uint32 i = urand(0, 2);
                        int32 bp0 = int32(CalculatePct(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + crIds[i]), 25));
                        CastCustomSpell(this, spellIds[i], &bp0, 0, 0, true);
                    }
                    // Item - Rogue T13 2P Bonus
                    if (HasAura(105849))
                        CastSpell(this, 105864, true);

                    if (!redirectTarget)
                        break;
                    CastSpell(this,59628,true);
                    CastSpell(redirectTarget,57933,true);
                    break;
                }
                default:
                    break;
            }

            break;
        }
        case SPELLFAMILY_PALADIN:
        {
            switch (dummySpell->Id)
            {
                case 96887: // Variable Pulse Lightning Capacitor
                case 97119: // Variable Pulse Lightning Capacitor (Heroic)
                {
                    if (!victim)
                        return false;

                    if (Aura* aur = GetAura(96890))
                    {
                        uint8 stacks = aur->GetStackAmount();
                        if (roll_chance_i(15))
                        {
                            int32 bp0 = dummySpell->Effects[EFFECT_0].CalcValue() * stacks;
                            CastCustomSpell(victim, 96891, &bp0, 0, 0, true);
                            aur->Remove();
                            return true;
                        }
                    }
                    triggered_spell_id = 96890;
                    target = this;
                    break;
                }
                // Item - Collecting Mana, Tyrande's Favirite Doll
                case 92272:
                {
                    if (procSpell && procSpell->ManaCostPercentage)
                    {
                        const int32 maxmana = 4200;
                        int32 mana = int32(0.2f * CalculatePct(GetCreateMana(), procSpell->ManaCostPercentage));
                        if (AuraEffect* aurEff = GetAuraEffect(92596, EFFECT_0))
                        {
                            int32 oldamount = aurEff->GetAmount();
                            if (oldamount < maxmana)
                            {
                                int32 newamount = std::min(maxmana, (oldamount + mana));
                                aurEff->ChangeAmount(newamount);
                            }
                        }
                        else
                        {
                            int32 bp = std::min(mana, maxmana);
                            CastCustomSpell(this, 92596, &bp, 0, 0, true);
                        }
                    }
                    break;
                }
                // Item - Paladin T12 Holy 4P Bonus
                case 99070:
                {
                    if (!victim || !victim->ToPlayer())
                        return false;

                    Player* plr = victim->ToPlayer();
                    if (!plr)
                        return false;

                    std::list<Player*> plrList;
                    JadeCore::AnyFriendlyUnitInObjectRangeCheck check(this, this, 15.0f);
                    JadeCore::PlayerListSearcher<JadeCore::AnyFriendlyUnitInObjectRangeCheck> searcher(this, plrList, check);
                    VisitNearbyObject(15.0f, searcher);
                    if (plrList.empty())
                        return false;

                    plrList.remove(plr);

                    if (plrList.empty())
                        return false;

                    plrList.sort(JadeCore::HealthPctOrderPred());
                    plrList.resize(1);

                    int32 bp0 = int32(CalculatePct(damage, 10));

                    CastCustomSpell(plrList.front(), 99017, &bp0, 0, 0, true);
                    return true;
                }
                // Item - Paladin T12 Protection 2P Bonus
                case 99074:
                    basepoints0 = int32(CalculatePct(damage, triggerAmount));
                    triggered_spell_id = 99075;
                    target = victim;
                    break;
                // Item - Paladin T12 Retribution 2P Bonus
                case 99093:
                    if (!victim || GetGUID() == victim->GetGUID())
                        return false;
                    basepoints0 = int32(CalculatePct(damage, triggerAmount / 2)); // 2 ticks
                    triggered_spell_id = 99092;
                    target = victim;
                    break;
                // Ancient Crusader (player)
                case 86701:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    //if caster has no guardian of ancient kings aura then remove dummy aura
                    if (!HasAura(86698))
                    {
                        RemoveAurasDueToSpell(86701);
                        return false;
                    }

                    CastSpell(this, 86700, true);
                    return true;
                }
                // Ancient Crusader (guardian)
                case 86703:
                {
                    if (!GetOwner() || GetOwner()->GetTypeId() != TYPEID_PLAYER)
                        return false;

                    GetOwner()->CastSpell(this, 86700, true);
                    return true;
                }
                // Ancient Healer
                case 86674:
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // if caster has no guardian of ancient kings aura then remove dummy aura
                    if (!HasAura(86669))
                    {
                        RemoveAurasDueToSpell(86674);
                        return false;
                    }

                    // check for single target spell (TARGET_SINGLE_FRIEND, NO_TARGET)
                    if (!(procSpell->Effects[triggeredByAura->GetEffIndex()].TargetA.GetTarget() == TARGET_UNIT_TARGET_ALLY) &&
                        (procSpell->Effects[triggeredByAura->GetEffIndex()].TargetB.GetTarget() == 0))
                        return false;

                    std::list<Creature*> petlist;
                    GetCreatureListWithEntryInGrid(petlist, 46499, 100.0f);
                    if (!petlist.empty())
                    {
                        for (std::list<Creature*>::const_iterator itr = petlist.begin(); itr != petlist.end(); ++itr)
                        {
                            Unit* pPet = (*itr);
                            if (pPet->GetOwnerGUID() == GetGUID())
                            {
                                int32 bp0 = damage;
                                int32 bp1 = damage / 10;
                                pPet->CastCustomSpell(victim, 86678, &bp0, &bp1, NULL, true);
                            }
                        }
                    }

                    return true;
                }
                case 28789: // Holy Power (Redemption Armor set)
                {
                    if (!victim)
                        return false;

                    // Set class defined buff
                    switch (victim->getClass())
                    {
                        case CLASS_PALADIN:
                        case CLASS_PRIEST:
                        case CLASS_SHAMAN:
                        case CLASS_DRUID:
                            triggered_spell_id = 28795;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
                            break;
                        case CLASS_MAGE:
                        case CLASS_WARLOCK:
                            triggered_spell_id = 28793;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
                            break;
                        case CLASS_HUNTER:
                        case CLASS_ROGUE:
                            triggered_spell_id = 28791;     // Increases the friendly target's attack power by $s1 for $d.
                            break;
                        case CLASS_WARRIOR:
                            triggered_spell_id = 28790;     // Increases the friendly target's armor
                            break;
                        default:
                            return false;
                    }

                    break;
                }
                case 40470: // Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)
                {
                    if (!procSpell)
                        return false;

                    float chance;

                    // Flash of light
                    if (procSpell->SpellFamilyFlags[0] & 0xC0000000)
                    {
                        triggered_spell_id = 40471;
                        chance = 15.0f;
                    }
                    // Judgement (any)
                    else if (procSpell->GetSpellSpecific() == SpellSpecificType::SpellSpecificJudgement)
                    {
                        triggered_spell_id = 40472;
                        chance = 50.0f;
                    }
                    else
                        return false;

                    if (!roll_chance_f(chance))
                        return false;

                    break;
                }
                case 64890: // Item - Paladin T8 Holy 2P Bonus
                {
                    triggered_spell_id = 64891;
                    basepoints0 = triggerAmount * damage / 300;
                    break;
                }
                case 71406: // Tiny Abomination in a Jar
                case 71545: // Tiny Abomination in a Jar (Heroic)
                {
                    if (!victim || !victim->isAlive())
                        return false;

                    CastSpell(this, 71432, true, NULL, triggeredByAura);

                    Aura const* dummy = GetAura(71432);
                    if (!dummy || dummy->GetStackAmount() < (dummySpell->Id == 71406 ? 8 : 7))
                        return false;

                    RemoveAurasDueToSpell(71432);
                    triggered_spell_id = 71433;  // default main hand attack
                    // roll if offhand
                    if (Player const* player = ToPlayer())
                    if (player->GetWeaponForAttack(WeaponAttackType::OffAttack, true) && urand(0, 1))
                        triggered_spell_id = 71434;
                    target = victim;
                    break;
                }
                case 71880: // Item - Icecrown 25 Normal Dagger Proc
                {
                    switch (getPowerType())
                    {
                        case POWER_MANA:
                            triggered_spell_id = 71881;
                            break;
                        case POWER_RAGE:
                            triggered_spell_id = 71883;
                            break;
                        case POWER_ENERGY:
                            triggered_spell_id = 71882;
                            break;
                        case POWER_RUNIC_POWER:
                            triggered_spell_id = 71884;
                            break;
                        default:
                            return false;
                    }
                    break;
                }
                case 71892: // Item - Icecrown 25 Heroic Dagger Proc
                {
                    switch (getPowerType())
                    {
                        case POWER_MANA:
                            triggered_spell_id = 71888;
                            break;
                        case POWER_RAGE:
                            triggered_spell_id = 71886;
                            break;
                        case POWER_ENERGY:
                            triggered_spell_id = 71887;
                            break;
                        case POWER_RUNIC_POWER:
                            triggered_spell_id = 71885;
                            break;
                        default:
                            return false;
                    }
                    break;
                }
                /// Bulwark of Order
                /// Updated as of 7.0.3 - 22522
                case 209389:
                {
                    target = this;
                    basepoints0 = CalculatePct(damage, triggerAmount);
                    break;
                }
            }
            break;
        }
        case SPELLFAMILY_SHAMAN:
        {
            switch (dummySpell->Id)
            {
                // Totemic Power (The Earthshatterer set)
                case 28823:
                {
                    if (!victim)
                        return false;

                    // Set class defined buff
                    switch (victim->getClass())
                    {
                        case CLASS_PALADIN:
                        case CLASS_PRIEST:
                        case CLASS_SHAMAN:
                        case CLASS_DRUID:
                            triggered_spell_id = 28824;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
                            break;
                        case CLASS_MAGE:
                        case CLASS_WARLOCK:
                            triggered_spell_id = 28825;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
                            break;
                        case CLASS_HUNTER:
                        case CLASS_ROGUE:
                            triggered_spell_id = 28826;     // Increases the friendly target's attack power by $s1 for $d.
                            break;
                        case CLASS_WARRIOR:
                            triggered_spell_id = 28827;     // Increases the friendly target's armor
                            break;
                        default:
                            return false;
                    }
                    break;
                }
                // Lesser Healing Wave (Totem of Flowing Water Relic)
                case 28849:
                {
                    target = this;
                    triggered_spell_id = 28850;
                    break;
                }
                // Shaman Tier 6 Trinket
                case 40463:
                {
                    if (!procSpell)
                        return false;

                    float chance;
                    if (procSpell->SpellFamilyFlags[0] & 0x1)
                    {
                        triggered_spell_id = 40465;         // Lightning Bolt
                        chance = 15.0f;
                    }
                    else if (procSpell->SpellFamilyFlags[0] & 0x80)
                    {
                        triggered_spell_id = 40465;         // Lesser Healing Wave
                        chance = 10.0f;
                    }
                    else if (procSpell->SpellFamilyFlags[1] & 0x00000010)
                    {
                        triggered_spell_id = 40466;         // Stormstrike
                        chance = 50.0f;
                    }
                    else
                        return false;

                    if (!roll_chance_f(chance))
                        return false;

                    target = this;
                    break;
                }
                // Shaman T8 Elemental 4P Bonus
                case 64928:
                {
                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
                    triggered_spell_id = 64930;            // Electrified
                    break;
                }
                // Shaman T9 Elemental 4P Bonus
                case 67228:
                {
                    // Lava Burst
                    if (procSpell->SpellFamilyFlags[1] & 0x1000)
                    {
                        triggered_spell_id = 71824;
                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
                        if (!triggeredSpell)
                            return false;
                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
                    }
                    break;
                }
                // Item - Shaman T10 Restoration 4P Bonus
                case 70808:
                {
                    // Chain Heal
                    if ((procSpell->SpellFamilyFlags[0] & 0x100) && (procEx & PROC_EX_CRITICAL_HIT))
                    {
                        triggered_spell_id = 70809;
                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
                        if (!triggeredSpell)
                            return false;
                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
                        // Add remaining ticks to healing done
                        basepoints0 += GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_HEAL);
                    }
                    break;
                }
                // Item - Shaman T10 Elemental 2P Bonus
                case 70811:
                {
                    // Lightning Bolt & Chain Lightning
                    if (procSpell->SpellFamilyFlags[0] & 0x3)
                    {
                        if (ToPlayer()->HasSpellCooldown(16166))
                        {
                            uint32 newCooldownDelay = ToPlayer()->GetSpellCooldownDelay(16166);
                            if (newCooldownDelay < 3000)
                                newCooldownDelay = 0;
                            else
                                newCooldownDelay -= 2000;

                            ToPlayer()->AddSpellCooldown(16166, 0, newCooldownDelay);
                            ToPlayer()->ReduceSpellCooldown(16166, 2000);
                            return true;
                        }
                    }
                    return false;
                }
                // Item - Shaman T10 Elemental 4P Bonus
                case 70817:
                {
                    if (!target)
                        return false;
                    // try to find spell Flame Shock on the target
                    if (AuraEffect const* aurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, GetGUID()))
                    {
                        Aura* flameShock  = aurEff->GetBase();
                        int32 maxDuration = flameShock->GetMaxDuration();
                        int32 newDuration = flameShock->GetDuration() + 2 * aurEff->GetAmplitude();

                        flameShock->SetDuration(newDuration);
                        // is it blizzlike to change max duration for FS?
                        if (newDuration > maxDuration)
                            flameShock->SetMaxDuration(newDuration);

                        return true;
                    }
                    // if not found Flame Shock
                    return false;
                }
                break;
            }
            break;
        }
        case SPELLFAMILY_DEATHKNIGHT:
        {
            switch (dummySpell->Id)
            {
                // Item - Death Knight T12 DPS 4P Bonus
                case 98996:
                    basepoints0 = int32(CalculatePct(damage, triggerAmount));
                    triggered_spell_id = 99000;
                    target = victim;
                    break;
                case 49028: ///< Dancing Rune Weapon
                case 192566: ///< Additional Dancing Rune Weapon given by Mouth of Hell
                {
                    /// Handle in spell_dk_dancing_rune_weapon_copy
                    return false;
                }
                case 61257: // Runic Power Back on Snare/Root
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    // only for spells and hit/crit (trigger start always) and not start from self casted spells
                    if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == victim)
                        return false;
                    // Need snare or root mechanic
                    if (!(procSpell->GetAllEffectsMechanicMask() & ((1LL << MECHANIC_ROOT) | (1LL << MECHANIC_SNARE))))
                        return false;
                    triggered_spell_id = 61258;
                    target = this;
                    break;
                }
                case 77606: // Dark Simulacrum
                {
                    if (!procSpell)
                        return false;

                    Unit* caster = triggeredByAura->GetCaster();
                    victim = this;

                    if (!caster || !victim)
                        return false;

                    bool l_IsStolenSpell = sObjectMgr->IsStolenSpell(procSpell->Id);
                    uint64& l_SimulacrumTarget = caster->m_SpellHelper.GetUint64(eSpellHelpers::SimulacrumTarget);
                    l_SimulacrumTarget = 0;

                    if ((!procSpell->IsCanBeStolen() || !triggeredByAura) && !l_IsStolenSpell)
                        return false;

                    if (Creature* targetCreature = victim->ToCreature())
                        if (!targetCreature->isCanGiveSpell(caster, procSpell) && !l_IsStolenSpell)
                            return false;

                    l_SimulacrumTarget = victim->GetGUID();

                    if (HasAura(77616))
                        return false;

                    // Replacer
                    int32  basepoints0 = procSpell->Id;
                    caster->CastCustomSpell(this, 77616, &basepoints0, NULL, NULL, true);

                    // SpellPower
                    basepoints0 = victim->SpellBaseDamageBonusDone(SpellSchoolMask(procSpell->SchoolMask));
                    caster->CastCustomSpell(caster, 94984, &basepoints0, &basepoints0, NULL, true);
                    return true;
                }
            }

            break;
        }
        case SPELLFAMILY_POTION:
        {
            // alchemist's stone
            if (dummySpell->Id == 17619)
            {
                if (procSpell->SpellFamilyName == SPELLFAMILY_POTION)
                {
                    for (uint8 i = 0; i < procSpell->EffectCount; i++)
                    {
                        if (procSpell->Effects[i].Effect == SPELL_EFFECT_HEAL)
                        {
                            triggered_spell_id = 21399;
                        }
                        else if (procSpell->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
                        {
                            triggered_spell_id = 21400;
                        }
                        else
                            continue;

                        basepoints0 = int32(CalculateSpellDamage(this, procSpell, i) * 0.4f);
                        CastCustomSpell(this, triggered_spell_id, &basepoints0, NULL, NULL, true, NULL, triggeredByAura);
                    }
                    return true;
                }
            }
            break;
        }
        case SPELLFAMILY_MONK:
        {
            switch (dummySpell->Id)
            {
                case 137639:// Earth and Fire
                {
                    if (GetTypeId() != TYPEID_PLAYER)
                        return false;

                    if (effIndex != 2)
                        return false;

                    if (!damage || !procSpell)
                        return false;

                    if (procSpell->IsPositive())
                        return false;

                    Unit* firstSpirit = NULL;
                    Unit* secondSpirit = NULL;

                    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) // Find spirits
                    {
                        if ((*itr)->GetEntry() == eMonkPets::Earth || (*itr)->GetEntry() == eMonkPets::Fire)
                        {
                            if (!firstSpirit)
                            {
                                firstSpirit = *itr;
                                continue;
                            }
                            if (!secondSpirit)
                            {
                                secondSpirit = *itr;
                                continue;
                            }
                        }
                    }

                    if (firstSpirit && (firstSpirit->getVictim() || getVictim()))
                    {
                        if (firstSpirit->getVictim() != victim && !firstSpirit->ToCreature()->HasSpellCooldown(procSpell->Id))
                        {
                            firstSpirit->CastSpell(firstSpirit->getVictim() ? firstSpirit->getVictim() : getVictim(), procSpell->Id, true);
                            firstSpirit->ToCreature()->_AddCreatureSpellCooldown(procSpell->Id, time(nullptr) + 1);
                        }
                    }

                    if (secondSpirit && (secondSpirit->getVictim() || getVictim()))
                    {
                        if (secondSpirit->getVictim() != victim && !secondSpirit->ToCreature()->HasSpellCooldown(procSpell->Id))
                        {
                            secondSpirit->CastSpell(secondSpirit->getVictim() ? secondSpirit->getVictim() : getVictim(), procSpell->Id, true);
                            secondSpirit->ToCreature()->_AddCreatureSpellCooldown(procSpell->Id, time(nullptr) + 1);
                        }
                    }

                    return true;
                }
            }
            break;
        }
        default:
            break;
    }

    // if not handled by custom case, get triggered spell from dummySpell proto
    if (!triggered_spell_id)
        triggered_spell_id = dummySpell->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;

    // processed charge only counting case
    if (!triggered_spell_id)
        return true;

    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);
    if (!triggerEntry)
        return false;

    if (cooldown_spell_id == 0)
        cooldown_spell_id = triggered_spell_id;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(cooldown_spell_id))
        return false;

    if (basepoints0)
        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura, originalCaster);
    else
        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura, originalCaster);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(cooldown_spell_id, 0, cooldown);

    return true;
}

bool Unit::HandleObsModEnergyAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
{
    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo(); ///< dummySpell is never read 01/18/16

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;
    Unit* target = victim;
    int32 basepoints0 = 0;

    // processed charge only counting case
    if (!triggered_spell_id)
        return true;

    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);

    // Try handle unknown trigger spells
    if (!triggerEntry)
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(triggered_spell_id))
        return false;
    if (basepoints0)
        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, cooldown);
    return true;
}

bool Unit::HandleModDamagePctTakenAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
{
    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo(); ///< dummySpell is never read 01/18/16

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;
    Unit* target = victim;
    int32 basepoints0 = 0;

    // processed charge only counting case
    if (!triggered_spell_id)
        return true;

    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);

    if (!triggerEntry)
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(triggered_spell_id))
        return false;

    if (basepoints0)
        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, cooldown);

    return true;
}

// Used in case when access to whole aura is needed
// All procs should be handled like this...
bool Unit::HandleAuraProc(Unit* victim, uint32 /*damage*/, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown, bool * handled)
{
    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();

    switch (dummySpell->SpellFamilyName)
    {
        case SPELLFAMILY_GENERIC:
            switch (dummySpell->Id)
            {
                /// Nevermelting Ice Crystal
                case 71564:
                    RemoveAuraFromStack(71564);
                    *handled = true;
                    break;
                // Gaseous Bloat
                case 70672:
                {
                    *handled = true;
                    uint32 stack = triggeredByAura->GetStackAmount();
                    int32 const mod = (GetMap()->GetSpawnMode() & 1) ? 1500 : 1250;
                    int32 dmg = 0;
                    for (uint8 i = 1; i < stack; ++i)
                        dmg += mod * stack;
                    if (Unit* caster = triggeredByAura->GetCaster())
                        caster->CastCustomSpell(70701, SPELLVALUE_BASE_POINT0, dmg);
                    break;
                }
                // Ball of Flames Proc
                case 71756:
                    RemoveAuraFromStack(dummySpell->Id);
                    *handled = true;
                    break;
                // Discerning Eye of the Beast
                case 59915:
                {
                    CastSpell(this, 59914, true);   // 59914 already has correct basepoints in DB2, no need for custom bp
                    *handled = true;
                    break;
                }
                // Swift Hand of Justice
                case 59906:
                {
                    int32 bp0 = CalculatePct(GetMaxHealth(), dummySpell->Effects[EFFECT_0].CalcValue());
                    CastCustomSpell(this, 59913, &bp0, NULL, NULL, true);
                    *handled = true;
                    break;
                }
            }

            break;
        case SPELLFAMILY_PALADIN:
        {
            // Repentance aura drop
            if (dummySpell->Id == 20066)
            {
                *handled = true;
                if (procSpell == nullptr || procSpell->Id == 20066)
                    return false;
                if (procSpell->SpellFamilyName == SPELLFAMILY_PALADIN &&
                    procSpell->SpellFamilyFlags[0] == 0x20000000 && procSpell->SpellFamilyFlags[1] == 0x00000800)
                    return false;
                return true;
            }
            break;
        }
        case SPELLFAMILY_WARRIOR:
        {
            switch (dummySpell->Id)
            {
                // Item - Warrior T10 Protection 4P Bonus
                case 70844:
                {
                    int32 basepoints0 = CalculatePct(GetMaxHealth(victim), dummySpell->Effects[EFFECT_1].CalcValue());
                    CastCustomSpell(this, 70845, &basepoints0, NULL, NULL, true);
                    break;
                }
                default:
                    break;
            }
            break;
        }
    }
    return false;
}

bool Unit::HandleProcTriggerSpell(Unit* victim, DamageInfo* p_DamageInfo, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)
{
    // Get triggered aura spell info
    SpellInfo const* auraSpellInfo = triggeredByAura->GetSpellInfo();

    // Basepoints of trigger aura
    int32 triggerAmount = triggeredByAura->GetAmount();

    // Set trigger spell id, target, custom basepoints
    uint32 trigger_spell_id = auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;

    Unit*  target = NULL;
    int32  basepoints0 = 0;

    if (triggeredByAura->GetAuraType() == SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE)
        basepoints0 = triggerAmount;

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    // Try handle unknown trigger spells
    if (sSpellMgr->GetSpellInfo(trigger_spell_id) == NULL)
    {
        switch (auraSpellInfo->SpellFamilyName)
        {
            case SPELLFAMILY_GENERIC:
            {
                switch (auraSpellInfo->Id)
                {
                    case 23780:             // Aegis of Preservation (Aegis of Preservation trinket)
                        trigger_spell_id = 23781;
                        break;
                    case 33896:             // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)
                        trigger_spell_id = 33898;
                        break;
                    case 43820:             // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
                        // Pct value stored in dummy
                        basepoints0 = victim->GetCreateHealth() * auraSpellInfo->Effects[1].CalcValue() / 100;
                        target = victim;
                        break;
                    case 139316:            ////< Putrify (Dark Animus trash - Throne of Thunder)
                    {
                        if (GetTypeId() != TYPEID_UNIT)
                            return false;

                        trigger_spell_id = 139317;
                        target = victim;
                        break;
                    }
                    case 140296:            ///< Conductive Shield (Lei Shen trash - Throne of Thunder)
                    {
                        if (GetTypeId() != TYPEID_UNIT)
                            return false;

                        trigger_spell_id = 140299;
                        target = victim;
                        break;
                    }
                    case 138201:            /// Lei Shen's gift (Lei Shen trash - Throne of Thunder)
                    {
                        if (GetTypeId() != TYPEID_UNIT)
                            return false;

                        trigger_spell_id = 138210;
                        target = victim;
                        break;
                    }
                    case 57345:             // Darkmoon Card: Greatness
                    {
                        float stat = 0.0f;
                        // strength
                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 60229;stat = GetStat(STAT_STRENGTH); }
                        // agility
                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 60233;stat = GetStat(STAT_AGILITY);  }
                        // intellect
                        if (GetStat(STAT_INTELLECT)> stat) { trigger_spell_id = 60234;stat = GetStat(STAT_INTELLECT);}
                    }
                    case 64568:             // Blood Reserve
                    {
                        if (HealthBelowPctDamaged(35, p_DamageInfo->GetAmount()))
                        {
                            CastCustomSpell(this, 64569, &triggerAmount, NULL, NULL, true);
                            RemoveAura(64568);
                        }
                        return false;
                    }
                    case 67702:             // Death's Choice, Item - Coliseum 25 Normal Melee Trinket
                    {
                        float stat = 0.0f;
                        // strength
                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67708;stat = GetStat(STAT_STRENGTH); }
                        // agility
                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67703;                               }
                        break;
                    }
                    case 67771:             // Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket
                    {
                        float stat = 0.0f;
                        // strength
                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67773;stat = GetStat(STAT_STRENGTH); }
                        // agility
                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67772;                               }
                        break;
                    }
                    // Mana Drain Trigger
                    case 27522:
                    case 40336:
                    {
                        // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
                        if (isAlive())
                            CastSpell(this, 29471, true, castItem, triggeredByAura);
                        if (victim && victim->isAlive())
                            CastSpell(victim, 27526, true, castItem, triggeredByAura);
                        return true;
                    }
                    // Evasive Maneuvers
                    case 50240:
                    {
                        // Remove a Evasive Charge
                        Aura* charge = GetAura(50241);
                        if (charge->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL))
                            RemoveAurasDueToSpell(50240);
                        break;
                    }
                }
                break;
            }
            case SPELLFAMILY_PRIEST:
            {
                // Greater Heal Refund
                if (auraSpellInfo->Id == 37594)
                    trigger_spell_id = 37595;
                break;
            }
            case SPELLFAMILY_DRUID:
            {
                switch (auraSpellInfo->Id)
                {
                    // Druid Forms Trinket
                    case 37336:
                    {
                        switch (GetShapeshiftForm())
                        {
                            case FORM_NONE:
                                trigger_spell_id = 37344;
                                break;
                            case FORM_CAT_FORM:
                                trigger_spell_id = 37341;
                                break;
                            case FORM_BEAR_FORM:
                                trigger_spell_id = 37340;
                                break;
                            case FORM_TREE_OF_LIFE:
                                trigger_spell_id = 37342;
                                break;
                            case FORM_MOONKIN_FORM:
                                trigger_spell_id = 37343;
                                break;
                            default:
                                return false;
                        }
                        break;
                    }
                    // Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)
                    case 67353:
                    {
                        switch (GetShapeshiftForm())
                        {
                            case FORM_CAT_FORM:
                                trigger_spell_id = 67355;
                                break;
                            case FORM_BEAR_FORM:
                                trigger_spell_id = 67354;
                                break;
                            default:
                                return false;
                        }
                        break;
                    }
                    default:
                        break;
                }
                break;
            }
            case SPELLFAMILY_HUNTER:
            {
                if (auraSpellInfo->Id == 53234)     ///< Piercing Shots
                    {
                        trigger_spell_id = 63468;

                        SpellInfo const* TriggerPS = sSpellMgr->GetSpellInfo(trigger_spell_id);
                        if (!TriggerPS)
                            return false;

                        basepoints0 = CalculatePct(int32(p_DamageInfo->GetAmount()), triggerAmount) / (TriggerPS->GetMaxDuration() / TriggerPS->Effects[0].Amplitude);
                        basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), trigger_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
                        break;
                    }
                // Item - Hunter T9 4P Bonus
                if (auraSpellInfo->Id == 67151)
                {
                    trigger_spell_id = 68130;
                    target = this;
                    break;
                }
                break;
            }
            case SPELLFAMILY_PALADIN:
            {
                switch (auraSpellInfo->Id)
                {
                    // Healing Discount
                    case 37705:
                    {
                        trigger_spell_id = 37706;
                        target = this;
                        break;
                    }
                    // Soul Preserver
                    case 60510:
                    {
                        switch (getClass())
                        {
                            case CLASS_DRUID:
                                trigger_spell_id = 60512;
                                break;
                            case CLASS_PALADIN:
                                trigger_spell_id = 60513;
                                break;
                            case CLASS_PRIEST:
                                trigger_spell_id = 60514;
                                break;
                            case CLASS_SHAMAN:
                                trigger_spell_id = 60515;
                                break;
                        }

                        target = this;
                        break;
                    }
                    case 37657: // Lightning Capacitor
                    case 54841: // Thunder Capacitor
                    case 67712: // Item - Coliseum 25 Normal Caster Trinket
                    case 67758: // Item - Coliseum 25 Heroic Caster Trinket
                    {
                        if (!victim || !victim->isAlive() || GetTypeId() != TYPEID_PLAYER)
                            return false;

                        uint32 stack_spell_id = 0;
                        switch (auraSpellInfo->Id)
                        {
                            case 37657:
                                stack_spell_id = 37658;
                                trigger_spell_id = 37661;
                                break;
                            case 54841:
                                stack_spell_id = 54842;
                                trigger_spell_id = 54843;
                                break;
                            case 67712:
                                stack_spell_id = 67713;
                                trigger_spell_id = 67714;
                                break;
                            case 67758:
                                stack_spell_id = 67759;
                                trigger_spell_id = 67760;
                                break;
                        }

                        CastSpell(this, stack_spell_id, true, NULL, triggeredByAura);

                        Aura* dummy = GetAura(stack_spell_id);
                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
                            return false;

                        RemoveAurasDueToSpell(stack_spell_id);
                        target = victim;
                        break;
                    }
                    // Item - Paladin T13 Protection 2P Bonus (Judgement)
                    case 105800:
                    {
                        if (!p_DamageInfo->GetAmount())
                            return false;

                        basepoints0 = triggerAmount * p_DamageInfo->GetAmount() / 100.0f;
                        trigger_spell_id = 105801;
                        break;
                    }
                    default:
                        break;
                }
                break;
            }
            case SPELLFAMILY_SHAMAN:
            {
                switch (auraSpellInfo->Id)
                {
                    // Lightning Shield (The Ten Storms set)
                    case 23551:
                    {
                        trigger_spell_id = 23552;
                        target = victim;
                        break;
                    }
                    // Damage from Lightning Shield (The Ten Storms set)
                    case 23552:
                    {
                        trigger_spell_id = 27635;
                        break;
                    }
                    // Mana Surge (The Earthfury set)
                    case 23572:
                    {
                        if (!procSpell)
                            return false;
                        basepoints0 = int32(CalculatePct(procSpell->ManaCost, 35));
                        trigger_spell_id = 23571;
                        target = this;
                        break;
                    }
                }
                break;
            }
            case SPELLFAMILY_DEATHKNIGHT:
            {
                // Item - Death Knight T10 Melee 4P Bonus
                if (auraSpellInfo->Id == 70656)
                {
                    if (GetTypeId() != TYPEID_PLAYER || getClass() != CLASS_DEATH_KNIGHT)
                        return false;

                    for (uint8 i = 0; i < MAX_RUNES; ++i)
                        if (ToPlayer()->GetRuneCooldown(i) == 0)
                            return false;
                }
                break;
            }
            case SPELLFAMILY_ROGUE:
            {
                switch (auraSpellInfo->Id)
                {
                    // Rogue T10 2P bonus, should only proc on caster
                    case 70805:
                    {
                        if (victim != this)
                            return false;
                        break;
                    }
                    // Rogue T10 4P bonus, should proc on victim
                    case 70803:
                    {
                        target = victim;
                        break;
                    }
                }
                break;
            }
            case SPELLFAMILY_DEMONHUNTER:
            {
                switch (triggeredByAura->GetId())
                {
                    case 203783: ///< Shear Passive
                    {
                        /// Can be triggered by Shear and Sever only (cannot be set by spell_proc_event because of wrong spellclassmasks)
                        if (!procSpell || (procSpell->Id != 203782 && procSpell->Id != 235964))
                            return false;

                        /// Sever has 100% chance
                        /// Shear needs to calculate chance
                        if (procSpell->Id == 203782)
                        {
                            /// Currently, that chance is (4%, 12%, 25%, 40%, 60%, 80%, 90%, 100%, based on how many Shears since you got a soul) (c) wowhead
                            uint8 l_Chances[8] = { 4, 12, 25, 40, 60, 80, 90, 100 };
                            uint8 l_CurrentChance = l_Chances[triggerAmount];

                            /// +10% from Frailty
                            if (victim->HasAura(247456))
                                l_CurrentChance += 10;

                            if (!roll_chance_i(l_CurrentChance))
                            {
                                /// Increase amount of Shears since you got a soul
                                if (triggeredByAura)
                                    triggeredByAura->SetAmount(triggerAmount + 1 );

                                return false;
                            }
                        }

                        trigger_spell_id = 226258; ///< Spawn Lesser Soul Fragment

                        target = victim;

                        /// Reset amount of Shears since you got a soul
                        if (triggeredByAura)
                            triggeredByAura->SetAmount(0);

                        break;
                    }
                    case 178940: ///< Shattered Souls (Havoc)
                    {
                        trigger_spell_id = 209651;

                        if (p_DamageInfo && p_DamageInfo->GetTarget() && p_DamageInfo->GetTarget()->ToCreature())
                        {
                            if (p_DamageInfo->GetTarget()->ToCreature()->GetCreatureType() == CreatureType::CREATURE_TYPE_DEMON)
                                basepoints0 = 1;
                        }

                        break;
                    }
                    case 204254: ///< Shattered Souls (Veng)
                    {
                        if (p_DamageInfo && p_DamageInfo->GetTarget() && p_DamageInfo->GetTarget()->ToCreature())
                        {
                            CastSpell(p_DamageInfo->GetTarget(), 203795, true);

                            if (p_DamageInfo->GetTarget()->ToCreature()->GetCreatureType() == CreatureType::CREATURE_TYPE_DEMON)
                            {
                                std::list<AreaTrigger*> l_SoulFragments;
                                GetAreaTriggerList(l_SoulFragments, 203795);

                                if (!l_SoulFragments.empty())
                                {
                                    l_SoulFragments.sort(JadeCore::AreaTriggerDurationPctOrderPred(false));
                                    if (l_SoulFragments.front())
                                        l_SoulFragments.front()->SetCustomData(1);
                                }
                            }
                        }

                        break;
                    }
                }
                break;
            }
            default:
                 break;
        }
    }

    // All ok. Check current trigger spell
    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(trigger_spell_id);
    if (triggerEntry == NULL)
    {
        // Don't cast unknown spell
        // sLog->outError(LOG_FILTER_UNITS, "Unit::HandleProcTriggerSpell: Spell %u has 0 in EffectTriggered[%d]. Unhandled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
        if (SpellProcTriggered(victim, p_DamageInfo, triggeredByAura, procSpell, procFlags, procEx, cooldown))
            return true;
        return false;
    }

    // not allow proc extra attack spell at extra attack
    if (m_extraAttacks && triggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
        return false;

    // Custom requirements (not listed in procEx) Warning! damage dealing after this
    // Custom triggered spells
    switch (auraSpellInfo->Id)
    {
        // Item - Death Knight T12 Blood 2P Bonus (wrong spellname, that's warrior item set)
        case 105907:
            if (!procSpell)
                return false;
            if (procSpell->Id != 12294 && !roll_chance_i(50))
                return false;
            break;
        case 14190: ///< Seal Fate
        {
            if (GetTypeId() != TypeID::TYPEID_PLAYER)
                return false;

            if (!(procEx & PROC_EX_CRITICAL_HIT))
                return false;

            if (!procSpell || procSpell->IsFinishingMove())
                return false;

            break;
        }
        case 104428:// Elemental Force (DND)
        {
            if (!IsValidAttackTarget(victim))
                return false;

            break;
        }
        // Item - Mage T13 2P Bonus (Haste)
        case 105788:
            if (!procSpell)
                return false;
            if (procSpell->Id != 30451 && !roll_chance_i(50))
                return false;
            break;
        // Item - Hunter T12 2P Bonus
        case 99057:
            if (!victim || GetGUID() == victim->GetGUID())
                return false;
            break;
        // Item - Warrior T12 DPS 4P Bonus
        case 99238:
            // there are 3 Raging Blow spells, filter it
            if (!procSpell || !(procSpell->Id == 12294 || procSpell->Id == 96103))
                return false;
            break;
        case 90998: // Song of Sorrow, Sorrowsong
        case 91003: // Song of Sorrow, Sorrowsong (H)
        case 92180: // Item - Proc Armor, Leaden Despair
        case 92185: // Item - Proc Armor, Leaden Despair (H)
        case 92236: // Item - Proc Mastery Below 35%, Symbiotic Worm
        case 92356: // Item - Proc Mastery Below 35%, Symbiotic Worm (H)
        case 92234: // Item - Proc Dodge Below 35%, Bedrock Talisman
        case 96947: // Loom of Fate, Spediersilk Spindle
        case 97130: // Loom of Fate, Spediersilk Spindle (H)
        case 105552: // Item - Death Knight T12 Blood 2P Bonus
            if (!HealthBelowPct(35) && !HealthBelowPctDamaged(35, p_DamageInfo->GetAmount()))
                return false;
            break;
        case 125732:// Glyph of Honor
        {
            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            if (!procSpell)
                return false;

            if (procSpell->Id != 115080)
                return false;

            break;
        }
        case 31829: // Item Paladin - Pvp Retributon 4P bonus
        {
            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            if (ToPlayer()->HasSpellCooldown(31829))
                return false;

            ToPlayer()->AddSpellCooldown(31829, 0, 8 * IN_MILLISECONDS);

            break;
        }
        case 2823:  // Deadly Poison
        case 3408:  // Crippling Poison
        case 5761:  // Mind-Numbling Poison
        case 8679:  // Wound Poison
        case 108211:// Leeching Poison
        {
            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            // Don't trigger poison if no damage dealed (except for absorb)
            if (!p_DamageInfo->GetAmount() && !(procEx & PROC_EX_ABSORB))
                return false;

            break;
        }
        case 79684: ///< Arcane Missile
            return false;
        case 144586:// Item - Paladin T16 Retribution 2P Bonus - 144586 (proc Warrior of the Light - 144587)
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 59578)
                return false;

            break;
        }
        case 144593://Item - Paladin T16 Retribution 4P Bonus
        {
            if (!procSpell)
                return false;

            if (procSpell->PowerType != POWER_HOLY_POWER)
                return false;

            break;
        }
        case 53576: // Infusion of Light
        {
            if (!procSpell)
                return false;

            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            if (!(procSpell->Id == 25912) && !(procSpell->Id == 25914))
                return false;

            if (!(procEx & PROC_EX_CRITICAL_HIT))
                return false;

            break;
        }
        case 68164:// Glyph of Thunder Strike
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 6343)
                return false;

            break;
        }
        case 165698:///< Item - Druid WoD PvP Feral 4P Bonus
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 5221)
                return false;

            if (!(procEx & PROC_EX_CRITICAL_HIT))
                return false;

            break;
        }
        case 170877:///< Item Rogue WoD PvP Subtlety 4P Bonus
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 1966)
                return false;

            break;
        }
        case 144865:// Item - Druid T16 Feral 2P bonus
            if (procSpell->Id != 16864 && procSpell->Id != 135700)
                return false;
            break;
        case 145003:// Item - Shaman T16 Elemental 4P Bonus
        {
            if (!roll_chance_i(20))
                return false;

            if (procSpell->Id != 403 && procSpell->Id != 421)
                return false;

            if (ToPlayer()->GetActiveSpecializationID() != SPEC_DK_UNHOLY)
                return false;

            break;
        }
        case 122509:// Ultimatum
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 23922 || procEx != PROC_EX_CRITICAL_HIT)
                return false;

            break;
        }
        case 57954: // Glyph of Fire From the Heavens
        {
            if (!procSpell)
                return false;

            if ((procSpell->Id != 24275 && procSpell->Id != 20271) || procEx != PROC_EX_CRITICAL_HIT)
                return false;

            break;
        }
        // Item - Dragon Soul Legendary Daggers
        case 109939:
        {
            if (!victim)
                return false;

            if (HasAura(109949))
                return false;

            if (Aura* aur = GetAura(109941))
            {
                uint8 stacks = aur->GetStackAmount();
                if (stacks >= 30)
                {
                    float chance = ((1.0f / (51.0f - stacks)) * 100);
                    if (roll_chance_f(chance))
                    {
                        CastSpell(victim, 109949, true);
                        aur->Remove();
                        return false;
                    }
                }
            }
            break;
        }
        // Fusing Vapors, Yor'sahj, Dragon Soul
        case 103968:
            if (GetHealthPct() > 50.0f)
                return false;
            break;
        // Embedded Blade, Mannoroth, Well of Eternity
        case 109542:
            if (!victim)
                return false;
            target = victim;
            break;
        case 76857: // Mastery : Critical Block
        case 108942:// Phantasm
        case 113043:// Omen of Clarity (new)
        case 122464:// Dematerialize
        case 124487:// Zen Focus
        case 115946:// Glyph of Burning Anger
        case 131542:// Relentless Grip
        case 131564:// Arcane Intensity
            return false;
        case 35551: // Combat Potency
        {
            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            if (!(procFlags & PROC_FLAG_DONE_OFFHAND_ATTACK))
                return false;

            if (procSpell && procSpell->Id != 86392)
                return false;

            if (roll_chance_f(30.0f))
                return true;

            break;
        }
        case 116645:// Teachings of The Monastery (Blackout Kick)
        {
            if (!procSpell)
                return false;

            if (procSpell->Id != 100784 && procSpell->Id != 228649)
                return false;

            break;
            }
        // Persistent Shield (Scarab Brooch trinket)
        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
        case 26467:
        {
            basepoints0 = int32(CalculatePct(p_DamageInfo->GetAmount(), 15));
            target = victim;
            trigger_spell_id = 26470;
            break;
        }
        // Unyielding Knights (item exploit 29108\29109)
        case 38164:
        {
            if (!victim || victim->GetEntry() != 19457)  // Proc only if your target is Grillok
                return false;
            break;
        }
        // Deflection
        case 52420:
        {
            if (!HealthBelowPctDamaged(35, p_DamageInfo->GetAmount()))
                return false;
            break;
        }

        // Cheat Death
        case 28845:
        {
            // When your health drops below 20%
            if (HealthBelowPctDamaged(20, p_DamageInfo->GetAmount()) || HealthBelowPct(20))
                return false;
            break;
        }
        // Greater Heal Refund (Avatar Raiment set)
        case 37594:
        {
            if (!victim || !victim->isAlive())
                return false;

            // Doesn't proc if target already has full health
            if (victim->IsFullHealth())
                return false;
            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.
            if (victim->GetHealth(this) + p_DamageInfo->GetAmount() < victim->GetMaxHealth(this))
                return false;
            break;
        }
        // Bonus Healing (Crystal Spire of Karabor mace)
        case 40971:
        {
            // If your target is below $s1% health
            if (!victim || !victim->isAlive() || victim->HealthAbovePct(triggerAmount))
                return false;
            break;
        }
        // Deathbringer Saurfang - Blood Beast's Blood Link
        case 72176:
            basepoints0 = 3;
            break;
        // Professor Putricide - Ooze Spell Tank Protection
        case 71770:
            if (victim)
                victim->CastSpell(victim, trigger_spell_id, true);    // EffectImplicitTarget is self
            return true;
        case 45057: // Evasive Maneuvers (Commendation of Kael`thas trinket)
        case 71634: // Item - Icecrown 25 Normal Tank Trinket 1
        case 71640: // Item - Icecrown 25 Heroic Tank Trinket 1
        case 75475: // Item - Chamber of Aspects 25 Normal Tank Trinket
        case 75481: // Item - Chamber of Aspects 25 Heroic Tank Trinket
        {
            // Procs only if damage takes health below $s1%
            if (!HealthBelowPctDamaged(triggerAmount, p_DamageInfo->GetAmount()))
                return false;
            break;
        }
        case 196730: ///< Special Delivery
        {
            /// Only proc with Drinking Ironskin or Purifying Brew
            if (!procSpell || !(procSpell->Id == 119582 || procSpell->Id == 115308))
                return false;
            break;
        }
        case 215550: ///< In For The Kill
        {
            if (!procSpell || (procSpell->Id != 12294 && procSpell->Id != 246820) || !victim || victim->GetHealthPct() >= 20.0f)
                return false;
            break;
        }
        case 194918: ///< Blighted Rune Weapon
        {
            target = victim;
            break;
        }
        default:
            break;
    }

    // Custom basepoints/target for exist spell
    // dummy basepoints or other customs
    switch (trigger_spell_id)
    {
        // Auras which should proc on area aura source (caster in this case):
        // Cast positive spell on enemy target
        case 7099:  // Curse of Mending
        case 39703: // Curse of Mending
        case 29494: // Temptation
        {
            target = victim;
            break;
        }
        // Item - Druid T10 Balance 2P Bonus
        case 16870:
        {
            if (HasAura(70718))
                CastSpell(this, 70721, true);
            break;
        }
        // Enlightenment (trigger only from mana cost spells)
        case 35095:
        {
            if (!procSpell || procSpell->PowerType != POWER_MANA || (procSpell->ManaCost == 0 && procSpell->ManaCostPercentage == 0))
                return false;
            break;
        }
        case 52437:  // Sudden Death
        {
            // Item - Warrior T10 Melee 4P Bonus
            if (AuraEffect const* aurEff = GetAuraEffect(70847, 0))
            {
                if (!roll_chance_i(aurEff->GetAmount()))
                    break;
                CastSpell(this, 70849, true, castItem, triggeredByAura); // Extra Charge!
                CastSpell(this, 71072, true, castItem, triggeredByAura); // Slam GCD Reduced
                CastSpell(this, 71069, true, castItem, triggeredByAura); // Execute GCD Reduced
            }
            break;
        }
        // Shadow's Fate (Shadowmourne questline)
        case 71169:
        {
            if (GetTypeId() != TYPEID_PLAYER)
                return false;

            Player* player = ToPlayer();
            if (player->GetQuestStatus(24749) == QUEST_STATUS_INCOMPLETE)       // Unholy Infusion
            {
                if (!player->HasAura(71516) || victim->GetEntry() != 36678)    // Shadow Infusion && Professor Putricide
                    return false;
            }
            else if (player->GetQuestStatus(24756) == QUEST_STATUS_INCOMPLETE)  // Blood Infusion
            {
                if (!player->HasAura(72154) || victim->GetEntry() != 37955)    // Thirst Quenched && Blood-Queen Lana'thel
                    return false;
            }
            else if (player->GetQuestStatus(24757) == QUEST_STATUS_INCOMPLETE)  // Frost Infusion
            {
                if (!player->HasAura(72290) || victim->GetEntry() != 36853)    // Frost-Imbued Blade && Sindragosa
                    return false;
            }
            else if (player->GetQuestStatus(24547) != QUEST_STATUS_INCOMPLETE)  // A Feast of Souls
                return false;

            if (victim->GetTypeId() != TYPEID_UNIT)
                return false;
            // critters are not allowed
            if (victim->GetCreatureType() == CREATURE_TYPE_CRITTER)
                return false;
            break;
        }
        case 3409:  // Crippling Poison
        case 112961:// Leeching Poison
        {
            // Shuriken Toss cannot trigger non lethal poison
            if (procSpell)
            {
                if (procSpell->Id == 137584 || procSpell->Id == 137585 ||
                    procSpell->Id == 140308 || procSpell->Id == 140309)
                    return false;
            }

            break;
        }
    }

    if (cooldown)
    {
        if (IsPlayer() && ToPlayer()->HasSpellCooldown(trigger_spell_id))
            return false;
        else if (ToCreature() && ToCreature()->HasSpellCooldown(trigger_spell_id))
            return false;
    }

    // try detect target manually if not set
    if (target == NULL)
        target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;

    if (basepoints0)
        CastCustomSpell(target, trigger_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
    else
        CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);

    if (cooldown && trigger_spell_id != 14189)  ///< Seal Fate Has 0 cooldown to proc with mutilate
    {
        if (IsPlayer())
            ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, cooldown);
        else if (ToCreature())
            ToCreature()->_AddCreatureSpellCooldown(trigger_spell_id, time(nullptr) + (cooldown / TimeConstants::IN_MILLISECONDS));
    }

    return true;
}

bool Unit::HandleProcMeleeTriggerSpell(Unit* p_Victim, DamageInfo* p_DamageInfo, AuraEffect* p_TriggeredByAura, SpellInfo const* p_ProcSpell, uint32 p_ProcFlags, uint32 p_ProcEx, uint32 p_Cooldown)
{
    /// Get triggered aura spell info
    SpellInfo const* l_AuraSpellInfo = p_TriggeredByAura->GetSpellInfo();

    /// Set trigger spell id, target, custom basepoints
    uint32 l_TriggerSpellID = l_AuraSpellInfo->Effects[p_TriggeredByAura->GetEffIndex()].TriggerSpell;

    Unit* l_Target = p_Victim;

    Item* l_CastItem = p_TriggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer() ? ToPlayer()->GetItemByGuid(p_TriggeredByAura->GetBase()->GetCastItemGUID()) : nullptr;

    /// All ok. Check current trigger spell
    SpellInfo const* l_TriggerEntry = sSpellMgr->GetSpellInfo(l_TriggerSpellID);
    if (l_TriggerEntry == nullptr)
    {
        /// Don't cast unknown spell
        if (SpellProcTriggered(p_Victim, p_DamageInfo, p_TriggeredByAura, p_ProcSpell, p_ProcFlags, p_ProcEx, p_Cooldown))
            return true;
        return false;
    }

    /// not allow proc extra attack spell at extra attack
    if (m_extraAttacks && l_TriggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
        return false;

    if (p_Cooldown)
    {
        if (IsPlayer() && ToPlayer()->HasSpellCooldown(l_TriggerSpellID))
            return false;
        else if (ToCreature() && ToCreature()->HasSpellCooldown(l_TriggerSpellID))
            return false;
    }

    /// try detect target manually if not set
    if (l_Target == nullptr)
        l_Target = !(p_ProcFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && l_TriggerEntry && l_TriggerEntry->IsPositive() ? this : p_Victim;

    CastSpell(l_Target, l_TriggerSpellID, true, l_CastItem, p_TriggeredByAura);

    if (p_Cooldown)
    {
        if (IsPlayer())
            ToPlayer()->AddSpellCooldown(l_TriggerSpellID, 0, p_Cooldown);
        else
            ToCreature()->_AddCreatureSpellCooldown(l_TriggerSpellID, time(nullptr) + (p_Cooldown / TimeConstants::IN_MILLISECONDS));
    }

    return true;
}

bool Unit::HandleOverrideClassScriptAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 cooldown)
{
    int32 scriptId = triggeredByAura->GetMiscValue();

    if (!victim || !victim->isAlive())
        return false;

    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && IsPlayer()
        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;

    uint32 triggered_spell_id = 0;

    switch (scriptId)
    {
        case 4533:                                          // Dreamwalker Raiment 2 pieces bonus
        {
            // Chance 50%
            if (!roll_chance_i(50))
                return false;

            switch (victim->getPowerType())
            {
                case POWER_MANA:   triggered_spell_id = 28722; break;
                case POWER_RAGE:   triggered_spell_id = 28723; break;
                case POWER_ENERGY: triggered_spell_id = 28724; break;
                default:
                    return false;
            }
            break;
        }
        case 4537:                                          // Dreamwalker Raiment 6 pieces bonus
            triggered_spell_id = 28750;                     // Blessing of the Claw
            break;
        default:
            break;
    }

    // not processed
    if (!triggered_spell_id)
        return false;

    // standard non-dummy case
    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);

    if (!triggerEntry)
        return false;

    if (cooldown && IsPlayer() && ToPlayer()->HasSpellCooldown(triggered_spell_id))
        return false;

    CastSpell(victim, triggered_spell_id, true, castItem, triggeredByAura);

    if (cooldown && IsPlayer())
        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, cooldown);

    return true;
}

void Unit::setPowerType(Powers new_powertype)
{
    SetUInt32Value(UNIT_FIELD_DISPLAY_POWER, new_powertype);

    if (IsPlayer())
    {
        if (ToPlayer()->GetGroup())
            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);
    }
    else if (Pet* pet = ToCreature()->ToPet())
    {
        if (pet->isControlled())
        {
            Unit* owner = GetOwner();
            if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
        }
    }

    switch (new_powertype)
    {
        default:
        case POWER_MANA:
            break;
        case POWER_RAGE:
            SetMaxPower(POWER_RAGE, GetCreatePowers(POWER_RAGE));
            SetPower(POWER_RAGE, 0);
            break;
        case POWER_FOCUS:
            SetMaxPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
            SetPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
            break;
        case POWER_ENERGY:
            SetMaxPower(POWER_ENERGY, GetCreatePowers(POWER_ENERGY));
            break;
    }

    SetPower(new_powertype, GetPower(new_powertype));

    if (IsPlayer())
        ToPlayer()->UpdateManaRegen();
}

FactionTemplateEntry const* Unit::getFactionTemplateEntry() const
{
    FactionTemplateEntry const* entry = sFactionTemplateStore.LookupEntry(getFaction());
    if (!entry)
    {
        static uint64 guid = 0;                             // prevent repeating spam same faction problem

        if (GetGUID() != guid)
            guid = GetGUID();
    }
    return entry;
}

// function based on function Unit::UnitReaction from 13850 client
ReputationRank Unit::GetReactionTo(Unit const* target) const
{
    // always friendly to self
    if (this == target)
        return REP_FRIENDLY;

    if (!target)
        return REP_FRIENDLY;

    // always friendly to charmer or owner
    if (GetCharmerOrOwnerOrSelf() == target->GetCharmerOrOwnerOrSelf())
        return REP_FRIENDLY;

    Player const* selfPlayerOwner = GetAffectingPlayer();
    Player const* targetPlayerOwner = target->GetAffectingPlayer();

    // check forced reputation to support SPELL_AURA_FORCE_REACTION
    if (selfPlayerOwner)
    {
        if (FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry())
        {
            if (ReputationRank const* repRank = selfPlayerOwner->GetReputationMgr().GetForcedRankIfAny(targetFactionTemplateEntry))
                return *repRank;
        }
    }
    else if (targetPlayerOwner)
    {
        if (FactionTemplateEntry const* selfFactionTemplateEntry = getFactionTemplateEntry())
        {
            if (ReputationRank const* repRank = targetPlayerOwner->GetReputationMgr().GetForcedRankIfAny(selfFactionTemplateEntry))
                return *repRank;
        }
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
    {
        if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
        {
            if (selfPlayerOwner && targetPlayerOwner)
            {
                // always friendly to other unit controlled by player, or to the player himself
                if (selfPlayerOwner == targetPlayerOwner)
                    return REP_FRIENDLY;

                // duel - always hostile to opponent
                if (selfPlayerOwner->m_Duel && selfPlayerOwner->m_Duel->opponent == targetPlayerOwner && selfPlayerOwner->m_Duel->startTime != 0)
                    return REP_HOSTILE;

                // same group - checks dependant only on our faction - skip FFA_PVP for example
                if (selfPlayerOwner->IsInRaidWith(targetPlayerOwner))
                    return REP_FRIENDLY; // return true to allow config option AllowTwoSide.Interaction.Group to work
                    // however client seems to allow mixed group parties, because in 13850 client it works like:
                    // return GetFactionReactionTo(getFactionTemplateEntry(), target);
            }

            // check FFA_PVP
            if (GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP
                && target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
                return REP_HOSTILE;

            if (selfPlayerOwner)
            {
                if (FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry())
                {
                    if (ReputationRank const* repRank = selfPlayerOwner->GetReputationMgr().GetForcedRankIfAny(targetFactionTemplateEntry))
                        return *repRank;
                    if (!selfPlayerOwner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))
                    {
                        if (FactionEntry const* targetFactionEntry = sFactionStore.LookupEntry(targetFactionTemplateEntry->Faction))
                        {
                            if (targetFactionEntry->CanHaveReputation())
                            {
                                // check contested flags
                                if (targetFactionTemplateEntry->Flags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD
                                    && selfPlayerOwner->HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
                                    return REP_HOSTILE;

                                // if faction has reputation, hostile state depends only from AtWar state
                                if (selfPlayerOwner->GetReputationMgr().IsAtWar(targetFactionEntry))
                                    return REP_HOSTILE;
                                return REP_FRIENDLY;
                            }
                        }
                    }
                }
            }
        }
    }
    // do checks dependent only on our faction
    return GetFactionReactionTo(getFactionTemplateEntry(), target);
}

ReputationRank Unit::GetFactionReactionTo(FactionTemplateEntry const* factionTemplateEntry, Unit const* target)
{
    // always neutral when no template entry found
    if (!factionTemplateEntry)
        return REP_NEUTRAL;

    FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry();
    if (!targetFactionTemplateEntry)
        return REP_NEUTRAL;

    if (Player const* targetPlayerOwner = target->GetAffectingPlayer())
    {
        // check contested flags
        if (factionTemplateEntry->Flags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD
            && targetPlayerOwner->HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
            return REP_HOSTILE;
        if (ReputationRank const* repRank = targetPlayerOwner->GetReputationMgr().GetForcedRankIfAny(factionTemplateEntry))
            return *repRank;
        if (!target->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))
        {
            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplateEntry->Faction))
            {
                if (factionEntry->CanHaveReputation())
                {
                    // CvP case - check reputation, don't allow state higher than neutral when at war
                    ReputationRank repRank = targetPlayerOwner->GetReputationMgr().GetRank(factionEntry);
                    if (targetPlayerOwner->GetReputationMgr().IsAtWar(factionEntry))
                        repRank = std::min(REP_NEUTRAL, repRank);
                    return repRank;
                }
            }
        }
    }

    // common faction based check
    if (factionTemplateEntry->IsHostileTo(*targetFactionTemplateEntry))
        return REP_HOSTILE;
    if (factionTemplateEntry->IsFriendlyTo(*targetFactionTemplateEntry))
        return REP_FRIENDLY;
    if (targetFactionTemplateEntry->IsFriendlyTo(*factionTemplateEntry))
        return REP_FRIENDLY;
    if (factionTemplateEntry->Flags & FACTION_TEMPLATE_FLAG_HOSTILE_BY_DEFAULT)
        return REP_HOSTILE;
    // neutral by default
    return REP_NEUTRAL;
}

bool Unit::IsHostileTo(Unit const* unit) const
{
    return GetReactionTo(unit) <= REP_HOSTILE;
}

bool Unit::IsFriendlyTo(Unit const* unit) const
{
    return GetReactionTo(unit) >= REP_FRIENDLY;
}

bool Unit::IsHostileToPlayers() const
{
    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();
    if (!my_faction || !my_faction->Faction)
        return false;

    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->Faction);
    if (raw_faction && raw_faction->ReputationIndex >= 0)
        return false;

    return my_faction->IsHostileToPlayers();
}

bool Unit::IsNeutralToAll() const
{
    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();
    if (!my_faction || !my_faction->Faction)
        return true;

    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->Faction);
    if (raw_faction && raw_faction->ReputationIndex >= 0)
        return false;

    return my_faction->IsNeutralToAll();
}

bool Unit::IsMountDivineSteed() const
{
    std::vector<int32> l_DivineSteedIds = { 190784, 221883, 221885, 221886, 221887 };

    if (!IsMounted())
        return false;

    if (getClass() != CLASS_PALADIN)
        return false;

    AuraEffectList const& l_MountAuras = GetAuraEffectsByType(AuraType::SPELL_AURA_MOUNTED);

    for (AuraEffect* l_Effect : l_MountAuras)
    {
        Aura* l_Aura = l_Effect->GetBase();

        if (!l_Aura || !l_Aura->GetSpellInfo())
            continue;

        if (std::find(l_DivineSteedIds.begin(), l_DivineSteedIds.end(), l_Aura->GetSpellInfo()->Id) != std::end(l_DivineSteedIds))
            return true;
    }

    return false;
}


bool Unit::Attack(Unit* victim, bool meleeAttack)
{
    if (!victim || victim == this)
        return false;

    // dead units can neither attack nor be attacked
    if (!isAlive() || !victim->IsInWorld() || !victim->isAlive())
        return false;

    // player cannot attack in mount state
    if (IsPlayer() && IsMounted() && !IsMountDivineSteed())
        return false;

    // nobody can attack GM in GM-mode
    if (victim->IsPlayer())
    {
        if (victim->ToPlayer()->isGameMaster())
            return false;
    }
    else
    {
        if (!victim->ToCreature() || victim->ToCreature()->IsInEvadeMode())
            return false;
    }

    // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
    if (HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
        RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);

    if (m_attacking)
    {
        if (m_attacking == victim)
        {
            // switch to melee attack from ranged/magic
            if (meleeAttack)
            {
                if (!HasUnitState(UNIT_STATE_MELEE_ATTACKING))
                {
                    AddUnitState(UNIT_STATE_MELEE_ATTACKING);
                    SendMeleeAttackStart(victim);
                    return true;
                }
            }
            else if (HasUnitState(UNIT_STATE_MELEE_ATTACKING))
            {
                ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                SendMeleeAttackStop(victim);
                return true;
            }
            return false;
        }

        // switch target
        InterruptSpell(CURRENT_MELEE_SPELL);
        if (!meleeAttack)
            ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
    }

    if (m_attacking)
        m_attacking->_removeAttacker(this);

    m_attacking = victim;
    m_attacking->_addAttacker(this);

    // Set our target
    SetTarget(victim->GetGUID());

    if (meleeAttack)
        AddUnitState(UNIT_STATE_MELEE_ATTACKING);

    // set position before any AI calls/assistance
    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
    {
        // should not let player enter combat by right clicking target - doesn't helps
        SetInCombatWith(victim);
        if (victim->IsPlayer())
            victim->SetInCombatWith(this);
        AddThreat(victim, 0.0f);

        ToCreature()->SendAIReaction(AI_REACTION_HOSTILE);
        ToCreature()->CallAssistance();
    }

    if (IsPlayer())
        if (ToPlayer()->GetEmoteState())
            ToPlayer()->SetEmoteState(0);

    // delay offhand weapon attack to next attack time
    if (haveOffhandWeapon())
        resetAttackTimer(WeaponAttackType::OffAttack);

    if (meleeAttack)
        SendMeleeAttackStart(victim);

    // Let the pet know we've started attacking something. Handles melee attacks only
    // Spells such as auto-shot and others handled in WorldSession::HandleCastSpellOpcode
    if (this->IsPlayer())
    {
        Pet* playerPet = this->ToPlayer()->GetPet();

        if (playerPet && playerPet->isAlive())
            playerPet->AI()->OwnerAttacked(victim);
    }

    return true;
}

bool Unit::AttackStop()
{
    if (!m_attacking)
        return false;

    Unit* victim = m_attacking;

    m_attacking->_removeAttacker(this);
    m_attacking = NULL;

    // Clear our target
    SetTarget(0);

    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);

    InterruptSpell(CURRENT_MELEE_SPELL);

    // reset only at real combat stop
    if (Creature* creature = ToCreature())
    {
        creature->SetNoCallAssistance(false);

        if (creature->HasSearchedAssistance())
        {
            creature->SetNoSearchAssistance(false);
            UpdateSpeed(MOVE_RUN, false);
        }
    }

    SendMeleeAttackStop(victim);

    if (IsPlayer())
        if (ToPlayer()->GetEmoteState())
            ToPlayer()->SetEmoteState(0);

    return true;
}

void Unit::CombatStop(bool includingCast)
{
    if (includingCast && IsNonMeleeSpellCasted(false))
        InterruptNonMeleeSpells(false);

    AttackStop();
    RemoveAllAttackers();
    if (IsPlayer())
        ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
    ClearInCombat();
}

void Unit::CombatStopWithPets(bool includingCast)
{
    CombatStop(includingCast);

    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        (*itr)->CombatStop(includingCast);
}

bool Unit::isAttackingPlayer() const
{
    if (HasUnitState(UNIT_STATE_ATTACK_PLAYER))
        return true;

    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        if ((*itr)->isAttackingPlayer())
            return true;

    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
        if (m_SummonSlot[i])
            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
                if (summon->isAttackingPlayer())
                    return true;

    return false;
}

bool Unit::IsDealingFixedDamage() const
{
    enum eeMonkPets
    {
        FireSpirit  = 69791,
        EarthSpirit = 69792
    };

    return false;
    ///return (GetEntry() == eeMonkPets::FireSpirit || GetEntry() == eeMonkPets::EarthSpirit);
}

void Unit::RemoveAllAttackers()
{
    while (!m_attackers.empty())
    {
        AttackerSet::iterator iter = m_attackers.begin();
        if (!(*iter)->AttackStop())
            m_attackers.erase(iter);
    }

    m_PlayerSummonAttackers.clear();
}

void Unit::ModifyAuraState(AuraStateType flag, bool apply)
{
    if (apply)
    {
        if (!HasFlag(UNIT_FIELD_AURA_STATE, 1<<(flag-1)))
        {
            SetFlag(UNIT_FIELD_AURA_STATE, 1<<(flag-1));
            if (IsPlayer())
            {
                PlayerSpellMap const& sp_list = ToPlayer()->GetSpellMap();
                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
                {
                    if (!itr->second)
                        continue;

                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
                        continue;

                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);

                    if (!spellInfo || !spellInfo->IsPassive())
                        continue;

                    if (spellInfo->CasterAuraState == uint32(flag))
                        CastSpell(this, itr->first, true);
                }

                for (auto l_Spell : ToPlayer()->GetSpellFromItems())
                {
                    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Spell.second);
                    Item* l_Item = ToPlayer()->GetItemByGuid(l_Spell.first);

                    if (!l_SpellInfo || !l_SpellInfo->IsPassive() || !l_Item)
                        continue;

                    if (l_SpellInfo->CasterAuraState == uint32(flag))
                        CastSpell(this, l_Spell.second, true, l_Item);
                }
            }
            else if (Pet* pet = ToCreature()->ToPet())
            {
                for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
                {
                    if (itr->second.state == PETSPELL_REMOVED)
                        continue;
                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
                    if (!spellInfo || !spellInfo->IsPassive())
                        continue;
                    if (spellInfo->CasterAuraState == uint32(flag))
                        CastSpell(this, itr->first, true, NULL);
                }
            }
        }
    }
    else
    {
        if (HasFlag(UNIT_FIELD_AURA_STATE, 1<<(flag-1)))
        {
            RemoveFlag(UNIT_FIELD_AURA_STATE, 1<<(flag-1));

            if (flag)                  // enrage aura state triggering continues auras
            {
                Unit::AuraApplicationMap& tAuras = GetAppliedAuras();
                for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)
                {
                    SpellInfo const* spellProto = (*itr).second->GetBase()->GetSpellInfo();
                    if (!spellProto)
                        continue;
                    if (spellProto->CasterAuraState == uint32(flag))
                        RemoveAura(itr);
                    else
                        ++itr;
                }
            }
        }
    }
}

uint32 Unit::BuildAuraStateUpdateForTarget(Unit* target) const
{
    uint32 auraStates = GetUInt32Value(UNIT_FIELD_AURA_STATE) &~(PER_CASTER_AURA_STATE_MASK);
    for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.begin(); itr != m_auraStateAuras.end(); ++itr)
        if ((1<<(itr->first-1)) & PER_CASTER_AURA_STATE_MASK)
            if (itr->second->GetBase()->GetCasterGUID() == target->GetGUID())
                auraStates |= (1<<(itr->first-1));

    return auraStates;
}

bool Unit::HasAuraState(AuraStateType flag, SpellInfo const* spellProto, Unit const* Caster) const
{
    if (Caster)
    {
        if (spellProto)
        {
            AuraEffectList const& stateAuras = Caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
            for (AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
                if ((*j)->IsAffectingSpell(spellProto))
                    return true;
        }

        /// Fix Fingers of Frost (44544)
        if ((flag == AuraStateType::AURA_STATE_FROZEN) && Caster->HasAura(44544) && spellProto && (spellProto->Id == 228598 || spellProto->Id == 30455))
            return true;

        /// Fix Winter's Chill - 228358
        if ((flag == AuraStateType::AURA_STATE_FROZEN) && HasAura(228358, Caster->GetGUID()))
            return true;

        // Check per caster aura state
        // If aura with aurastate by caster not found return false
        if ((1<<(flag-1)) & PER_CASTER_AURA_STATE_MASK)
        {
            for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.lower_bound(flag); itr != m_auraStateAuras.upper_bound(flag); ++itr)
                if (itr->second->GetBase()->GetCasterGUID() == Caster->GetGUID())
                    return true;
            return false;
        }
    }

    return HasFlag(UNIT_FIELD_AURA_STATE, 1<<(flag-1));
}

void Unit::SetOwnerGUID(uint64 owner)
{
    if (GetOwnerGUID() == owner)
        return;

    SetGuidValue(UNIT_FIELD_SUMMONED_BY, owner);
    if (!owner)
        return;

    // Update owner dependent fields
    Player* player = ObjectAccessor::GetPlayer(*this, owner);
    if (!player || !player->HaveAtClient(this)) // if player cannot see this unit yet, he will receive needed data with create object
        return;

    SetFieldNotifyFlag(UF_FLAG_OWNER);

    UpdateData udata(GetMapId());
    WorldPacket packet;
    BuildValuesUpdateBlockForPlayer(&udata, player);
    if (udata.BuildPacket(&packet))
        player->SendDirectMessage(&packet);

    RemoveFieldNotifyFlag(UF_FLAG_OWNER);
}

bool Unit::IsOwnerOrSelf(Unit* p_Owner) const
{
    if (this == p_Owner)
        return true;
    if (GetOwnerGUID() == p_Owner->GetGUID())
        return true;
    if (GetCharmerGUID() == p_Owner->GetGUID())
        return true;
    return false;
}

Unit* Unit::GetOwner() const
{
    if (uint64 ownerid = GetOwnerGUID())
    {
        return ObjectAccessor::GetUnit(*this, ownerid);
    }
    return NULL;
}

Unit* Unit::GetAnyOwner() const
{
    if (GetCharmerGUID())
        return GetCharmer();
    else if (ToTempSummon())
        return ToTempSummon()->GetSummoner();
    else if (GetOwner())
        return GetOwner();

    return nullptr;
}

Unit* Unit::GetOwnerOrUnitItself() const
{
    if (Unit* l_Owner = GetOwner())
        return l_Owner;

    return const_cast<Unit*>(this);
}

Unit* Unit::GetCharmer() const
{
    if (uint64 charmerid = GetCharmerGUID())
        return ObjectAccessor::GetUnit(*this, charmerid);
    return NULL;
}

Player* Unit::GetCharmerOrOwnerPlayerOrPlayerItself() const
{
    uint64 guid = GetCharmerOrOwnerGUID();
    if (IS_PLAYER_GUID(guid))
        return ObjectAccessor::GetPlayer(*this, guid);

    return IsPlayer() ? (Player*)this : NULL;
}

Player* Unit::GetAffectingPlayer() const
{
    if (!GetCharmerOrOwnerGUID())
        return IsPlayer() ? (Player*)this : NULL;

    if (Unit* owner = GetCharmerOrOwner())
        return owner->GetCharmerOrOwnerPlayerOrPlayerItself();
    return NULL;
}

Minion *Unit::GetFirstMinion() const
{
    if (uint64 pet_guid = GetMinionGUID())
    {
        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
            if (pet->HasUnitTypeMask(UNIT_MASK_MINION))
                return (Minion*)pet;

        const_cast<Unit*>(this)->SetMinionGUID(0);
    }

    return NULL;
}

Minion* Unit::GetFirstMinionByEntry(uint32 p_Entry) const
{
    ControlList l_TempControlled = m_Controlled;
    for (auto l_Itr : l_TempControlled)
    {
        if (l_Itr->GetEntry() == p_Entry && l_Itr->isSummon() && l_Itr->HasUnitTypeMask(UnitTypeMask::UNIT_MASK_MINION))
            return (Minion*)l_Itr;
    }

    return NULL;
}

Guardian* Unit::GetGuardianPet() const
{
    if (uint64 pet_guid = GetPetGUID())
    {
        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
            if (pet->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
                return (Guardian*)pet;

        const_cast<Unit*>(this)->SetPetGUID(0);
    }

    return NULL;
}

Unit* Unit::GetCharm() const
{
    if (uint64 charm_guid = GetCharmGUID())
    {
        if (Unit* pet = ObjectAccessor::GetUnit(*this, charm_guid))
            return pet;

#ifdef CROSS
        if (Unit* creature = sObjectAccessor->FindCreature(charm_guid))
            return creature;

#endif /* CROSS */
        const_cast<Unit*>(this)->SetGuidValue(UNIT_FIELD_CHARM, 0);
    }

    return NULL;
}

void Unit::SetMinion(Minion *minion, bool apply, PetSlot slot, bool stampeded)
{
    if (apply)
    {
        if (minion->GetOwnerGUID())
            return;

        minion->SetOwnerGUID(GetGUID());

        m_Controlled.insert(minion);
        m_LastMinionSpawn = minion->GetGUID();

        if (IsPlayer())
        {
            minion->m_ControlledByPlayer = true;
            minion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
        }

        // Can only have one pet. If a new one is summoned, dismiss the old one.
        if (minion->IsGuardianPet())
        {
            if (Guardian* oldPet = GetGuardianPet())
            {
                if (oldPet != minion && (oldPet->isPet() || minion->isPet() || oldPet->GetEntry() != minion->GetEntry()) && !stampeded)
                {
                    // remove existing minion pet
                    if (oldPet->isPet())
                        oldPet->ToPet()->Remove(PET_SLOT_ACTUAL_PET_SLOT, false, oldPet->ToPet()->m_Stampeded);
                    else
                        oldPet->UnSummon();
                    SetPetGUID(minion->GetGUID());
                    SetMinionGUID(0);
                }
            }
            else
            {
                SetPetGUID(minion->GetGUID());
                SetMinionGUID(0);
            }
        }

        if (slot == PET_SLOT_UNK_SLOT)
            slot = PET_SLOT_OTHER_PET;

        if (IsPlayer())
        {
            if (!minion->isHunterPet() && getClass() != CLASS_HUNTER) // If its not a hunter pet, well lets not try to use it for hunter then
                ToPlayer()->m_currentPetSlot = slot;

            if (slot >= PET_SLOT_HUNTER_FIRST && slot <= PET_SLOT_HUNTER_LAST && !stampeded) // Always save thoose spots where hunter is correct
            {
                ToPlayer()->m_currentPetSlot = slot;
                ToPlayer()->setPetSlotUsed(slot, true);
            }
        }

        if (minion->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
            AddGuidValue(UNIT_FIELD_SUMMON, minion->GetGUID());

        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
            SetCritterGUID(minion->GetGUID());

        // PvP, FFAPvP
        minion->SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1));

        // Ghoul pets and Warlock's pets have energy instead of mana (is anywhere better place for this code?)
        if (minion->IsPetGhoulOrAbomination() || (minion->GetOwner() && minion->GetOwner()->getClass() == CLASS_WARLOCK))
            minion->setPowerType(POWER_ENERGY);

        if (IsPlayer())
        {
            // Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL));

            if (spellInfo && spellInfo->IsCooldownStartedOnEvent())
                ToPlayer()->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL, true);
        }
    }
    else
    {
        m_Controlled.erase(minion);

        if (minion->GetOwnerGUID() != GetGUID())
            return;

        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
        {
            if (GetCritterGUID() == minion->GetGUID())
                SetCritterGUID(0);
        }

        if (minion->IsGuardianPet())
        {
            if (GetPetGUID() == minion->GetGUID())
                SetPetGUID(0);
        }
        else if (minion->isTotem())
        {
            // All summoned by totem minions must disappear when it is removed.
            if (SpellInfo const* spInfo = sSpellMgr->GetSpellInfo(minion->ToTotem()->GetSpell()))
            {
                for (uint8 i = 0; i < spInfo->EffectCount; ++i)
                {
                    if (spInfo->Effects[i].Effect != SPELL_EFFECT_SUMMON)
                        continue;

                    RemoveAllMinionsByEntry(spInfo->Effects[i].MiscValue);
                }
            }

            if (minion->GetEntry() == 15439 && minion->GetOwner())
                RemoveAllMinionsByEntry(61029);
            else if (minion->GetEntry() == 15430 && minion->GetOwner())
                RemoveAllMinionsByEntry(61056);
            else if (minion->GetEntry() == 77934 && minion->GetOwner())
                RemoveAllMinionsByEntry(77942);
        }

        if (IsPlayer())
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL));
            // Remove infinity cooldown
            if (spellInfo && spellInfo->IsCooldownStartedOnEvent())
                ToPlayer()->SendCooldownEvent(spellInfo);

            sScriptMgr->OnMinionDespawn(ToPlayer(), minion);
        }

        //if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
        {
            if (RemoveGuidValue(UNIT_FIELD_SUMMON, minion->GetGUID()))
            {
                // Check if there is another minion
                for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
                {
                    // do not use this check, creature do not have charm guid
                    //if (GetCharmGUID() == (*itr)->GetGUID())
                    if (GetGUID() == (*itr)->GetCharmerGUID())
                        continue;

                    //ASSERT((*itr)->GetOwnerGUID() == GetGUID());
                    if ((*itr)->GetOwnerGUID() != GetGUID())
                    {
                        OutDebugInfo();
                        (*itr)->OutDebugInfo();
                        ASSERT(false);
                    }
                    ASSERT((*itr)->GetTypeId() == TYPEID_UNIT);

                    if (!(*itr)->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
                        continue;

                    if (AddGuidValue(UNIT_FIELD_SUMMON, (*itr)->GetGUID()))
                    {
                        // show another pet bar if there is no charm bar
                        if (IsPlayer() && !GetCharmGUID())
                        {
                            if ((*itr)->isPet())
                                ToPlayer()->PetSpellInitialize();
                            else
                                ToPlayer()->CharmSpellInitialize();
                        }
                    }
                    break;
                }
            }
        }
    }
}

void Unit::GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry)
{
    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
    {
        Unit* unit = *itr;
        ++itr;
        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
            && unit->ToCreature()->isSummon()) // minion, actually
            Minions.push_back(unit->ToCreature());
    }
}

void Unit::RemoveAllMinionsByEntry(uint32 entry)
{
    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
    {
        Unit* unit = *itr;
        ++itr;
        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
            && unit->ToCreature()->isSummon()) // minion, actually
            unit->ToTempSummon()->UnSummon();
        // i think this is safe because i have never heard that a despawned minion will trigger a same minion
    }
}

void Unit::SetCharm(Unit* charm, bool apply)
{
    if (apply)
    {
        if (IsPlayer())
        {
            if (!AddGuidValue(UNIT_FIELD_CHARM, charm->GetGUID()))
                sLog->outFatal(LOG_FILTER_UNITS, "Player %s is trying to charm unit %u, but it already has a charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());

            charm->m_ControlledByPlayer = true;
            // TODO: maybe we can use this flag to check if controlled by player
            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
        }
        else
            charm->m_ControlledByPlayer = false;

        // PvP, FFAPvP
        charm->SetByteValue(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, GetByteValue(UNIT_FIELD_BYTES_2, 1));

        /// Unk, but sniffed on retail on Blood Queen Lana'thel - Build 24461
        if (charm->IsPlayer())
            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);

        charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT | UNIT_FLAG_UNK_29);

        if (!charm->AddGuidValue(UNIT_FIELD_CHARMED_BY, GetGUID()))
            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is being charmed, but it already has a charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());

        _isWalkingBeforeCharm = charm->IsWalking();
        if (_isWalkingBeforeCharm)
            charm->SetWalk(false);

        m_Controlled.insert(charm);
    }
    else
    {
        if (IsPlayer())
        {
            if (!RemoveGuidValue(UNIT_FIELD_CHARM, charm->GetGUID()))
                sLog->outFatal(LOG_FILTER_UNITS, "Player %s is trying to uncharm unit %u, but it has another charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());
        }

        if (!charm->RemoveGuidValue(UNIT_FIELD_CHARMED_BY, GetGUID()))
            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is being uncharmed, but it has another charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());

        if (charm->IsPlayer())
        {
            charm->m_ControlledByPlayer = true;
            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
            charm->ToPlayer()->UpdatePvPState();
        }
        else if (Player* player = charm->GetCharmerOrOwnerPlayerOrPlayerItself())
        {
            charm->m_ControlledByPlayer = true;
            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
            charm->SetByteValue(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, player->GetByteValue(UNIT_FIELD_BYTES_2, 1));
        }
        else
        {
            charm->m_ControlledByPlayer = false;
            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
            charm->SetByteValue(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, 0);
        }

        if (charm->IsWalking() != _isWalkingBeforeCharm)
            charm->SetWalk(_isWalkingBeforeCharm);

        m_Controlled.erase(charm);

        /// Unk, but sniffed on retail on Blood Queen Lana'thel - Build 24461
        charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT | UNIT_FLAG_UNK_29);
    }
}

int32 Unit::DealHeal(Unit* victim, uint32 addhealth, SpellInfo const* spellProto)
{
    int32 gain = 0;

    if (victim->IsAIEnabled)
    {
        victim->GetAI()->HealReceived(this, addhealth);

        if (InstanceScript* l_Instance = GetInstanceScript())
        {
            if (l_Instance->CheckDamageManager())
                l_Instance->UpdateDamageManager(victim->GetGUID(), -int32(addhealth), true);
        }
    }

    if (IsAIEnabled)
        GetAI()->HealDone(victim, addhealth);

    if (addhealth)
        gain = victim->ModifyHealth(int32(addhealth), this);

    /// Health leech handling (Healing)
    if (GetTypeId() == TypeID::TYPEID_PLAYER && addhealth > 0 &&
        (spellProto && spellProto->Id != SPELL_PLAYER_LIFE_STEAL) && ///< don't trigger from own heal
        (victim && GetGUID() != victim->GetGUID())) ///< don't trigger from healing to ourselves
    {
        float l_Percentage = GetFloatValue(EPlayerFields::PLAYER_FIELD_LIFESTEAL);
        int32 l_Heal = CalculatePct(addhealth, (int32)l_Percentage);
        CastCustomSpell(this, SPELL_PLAYER_LIFE_STEAL, &l_Heal, nullptr, nullptr, true);
    }

    Unit* unit = this;

    if (GetTypeId() == TYPEID_UNIT && (ToCreature()->isTotem() || ToCreature()->GetEntry() == 60849))
        unit = GetOwner();

    if (Player* player = unit->ToPlayer())
    {
        if (Battleground* bg = player->GetBattleground())
            bg->UpdatePlayerScore(player, NULL, SCORE_HEALING_DONE, gain);

        // use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)
        if (gain)
            player->UpdateCriteria(CRITERIA_TYPE_HEALING_DONE, gain, 0, 0, victim);

        if (player->m_HighestHealCast < addhealth)
            player->m_HighestHealCast = addhealth;
    }

    if (Player* player = victim->ToPlayer())
    {
        player->m_TotalHealingReceived += gain;
        if (player->m_HighestHealingReceived < addhealth)
            player->m_HighestHealingReceived = addhealth;
    }

    ///< Velen's Future Sight
    if (unit->HasAura(235966) && spellProto && spellProto->IsHealingSpell() && spellProto->Id != 235967)
    {
        int32 l_OverHeal = int32(addhealth - gain);
        unit->m_SpellHelper.GetUint32(eSpellHelpers::VelensFutureSight) += l_OverHeal;
    }

    return gain;
}

Unit* Unit::GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)
{
    // Patch 1.2 notes: Spell Reflection no longer reflects abilities
    if (spellInfo->Attributes & SPELL_ATTR0_ABILITY || spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REDIRECTED || spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return victim;

    Unit::AuraEffectList const& magnetAuras = victim->GetAuraEffectsByType(SPELL_AURA_SPELL_MAGNET);
    for (Unit::AuraEffectList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)
    {
        if (Unit* magnet = (*itr)->GetBase()->GetCaster())
            if (spellInfo->CheckExplicitTarget(this, magnet) == SPELL_CAST_OK
                && (IsWithinLOSInMap(magnet)
                || magnet->isTotem()))
                return magnet;
    }
    return victim;
}

Unit* Unit::GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)
{
    AuraEffectList const& hitTriggerAuras = victim->GetAuraEffectsByType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER);
    for (AuraEffectList::const_iterator i = hitTriggerAuras.begin(); i != hitTriggerAuras.end(); ++i)
    {
        if (Unit* magnet = (*i)->GetBase()->GetCaster())
            if (_IsValidAttackTarget(magnet, spellInfo) && magnet->IsWithinLOSInMap(this)
                && (!spellInfo || (spellInfo->CheckExplicitTarget(this, magnet) == SPELL_CAST_OK
                && spellInfo->CheckTarget(this, magnet, false) == SPELL_CAST_OK)))
                if (roll_chance_i((*i)->GetAmount()))
                {
                    if (magnet != victim && magnet->IsPlayer())
                        sScriptMgr->OnMeleeHitRedirect(magnet, victim, (*i)->GetBase());
                    (*i)->GetBase()->DropCharge(AURA_REMOVE_BY_EXPIRE);
                    return magnet;
                }
    }
    return victim;
}

Unit* Unit::GetFirstControlled() const
{
    // Sequence: charmed, pet, other guardians
    Unit* unit = GetCharm();
    if (!unit)
        if (uint64 guid = GetMinionGUID())
            unit = ObjectAccessor::GetUnit(*this, guid);

    return unit;
}

void Unit::RemoveAllControlled()
{
    // possessed pet and vehicle
    if (IsPlayer())
        ToPlayer()->StopCastingCharm();

    while (!m_Controlled.empty())
    {
        Unit* target = *m_Controlled.begin();
        m_Controlled.erase(m_Controlled.begin());
        if (target->GetCharmerGUID() == GetGUID())
            target->RemoveCharmAuras();
        else if (target->GetOwnerGUID() == GetGUID() && target->isSummon())
            target->ToTempSummon()->UnSummon();
    }
}

Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
{
    Player* player = NULL;
    if (IsPlayer())
        player = ToPlayer();
    // Should we enable this also for charmed units?
    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())
        player = GetOwner()->ToPlayer();

    if (!player)
        return NULL;
    GroupPtr group = player->GetGroup();
    // When there is no group check pet presence
    if (!group)
    {
        // We are pet now, return owner
        if (player != this)
            return IsWithinDistInMap(player, radius) ? player : NULL;
        Unit* pet = GetGuardianPet();
        // No pet, no group, nothing to return
        if (!pet)
            return NULL;
        // We are owner now, return pet
        return IsWithinDistInMap(pet, radius) ? pet : NULL;
    }

    std::vector<Unit*> nearMembers;
    // reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)
    nearMembers.reserve(group->GetMembersCount() * 2);

    group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member) -> void
    {
        if (Player* Target = l_Member->player)
        {
            // IsHostileTo check duel and controlled by enemy
            if (Target != this && Target->isAlive() && IsWithinDistInMap(Target, radius) && !IsHostileTo(Target))
                nearMembers.push_back(Target);

            // Push player's pet to vector
            if (Unit* pet = Target->GetGuardianPet())
                if (pet != this && pet->isAlive() && IsWithinDistInMap(pet, radius) && !IsHostileTo(pet))
                    nearMembers.push_back(pet);
        }
    });

    if (nearMembers.empty())
        return NULL;

    uint32 randTarget = urand(0, nearMembers.size()-1);
    return nearMembers[randTarget];
}

// only called in Player::SetSeer
// so move it to Player?
void Unit::AddPlayerToVision(Player* player)
{
    if (m_sharedVision.empty())
    {
        setActive(true);
        SetWorldObject(true);
    }
    m_sharedVision.push_back(player);
}

// only called in Player::SetSeer
void Unit::RemovePlayerFromVision(Player* player)
{
    m_sharedVision.remove(player);
    if (m_sharedVision.empty())
    {
        setActive(false);
        SetWorldObject(false);
    }
}

void Unit::RemoveBindSightAuras()
{
    RemoveAurasByType(SPELL_AURA_BIND_SIGHT);
}

void Unit::RemoveCharmAuras()
{
    RemoveAurasByType(SPELL_AURA_MOD_CHARM);
    RemoveAurasByType(SPELL_AURA_MOD_POSSESS);
    RemoveAurasByType(SPELL_AURA_AOE_CHARM);
}

void Unit::UnsummonAllTotems()
{
    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
    {
        if (!m_SummonSlot[i])
            continue;

        if (Creature* OldTotem = GetMap()->GetCreature(m_SummonSlot[i]))
            if (OldTotem->isSummon())
                OldTotem->ToTempSummon()->UnSummon();
    }
}

void Unit::SendHealSpellLog(Unit* victim, uint32 SpellID, uint32 l_Health, uint32 l_OverHeal, uint32 Absorb, bool l_Critical /*= false*/)
{
    WorldPacket data(SMSG_SPELL_HEAL_LOG, 60);

    data.appendPackGUID(victim->GetGUID()); ///< TargetGUID
    data.appendPackGUID(GetGUID());         ///< CasterGUID
    data << uint32(SpellID);                ///< SpellID
    data << uint32(l_Health);               ///< Health
    data << uint32(l_OverHeal);             ///< OverHeal
    data << uint32(Absorb);                 ///< Absorbed

    data.WriteBit(l_Critical);              ///< Crit
    data.WriteBit(false);                   ///< HasCritRollMade
    data.WriteBit(false);                   ///< HasCritRollNeeded
    data.WriteBit(false);                   ///< HasLogData
    data.WriteBit(false);                   ///< HasLogData
    data.FlushBits();

    SendMessageToSet(&data, true);
}

int32 Unit::HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHealth, bool critical /*= false*/, uint32* p_Absrob)
{
    // Prevent some bugs when player revive heal when dead
    if (!victim->isAlive())
        return 0;

    uint32 absorb = 0;

    // calculate heal absorb and reduce healing
    CalcHealAbsorb(victim, spellInfo, addHealth, absorb);

    int32 gain = DealHeal(victim, addHealth, spellInfo);
    SendHealSpellLog(victim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);

    if (p_Absrob)
        *p_Absrob = absorb;

    return gain;
}

void Unit::SendEnergizeSpellLog(Unit* p_Victim, uint32 p_SpellID, uint32 p_Damage, int32 p_OverEnergize, Powers p_PowerType)
{
    WorldPacket l_Data(SMSG_SPELL_ENERGIZE_LOG, (3 * (16 + 2)) + 4 + 4 + 4 + 1);
    uint64 l_TargetGUID = p_Victim->GetGUID();
    uint64 l_CasterGUID = GetGUID();

    l_Data.appendPackGUID(l_TargetGUID);
    l_Data.appendPackGUID(l_CasterGUID);
    l_Data << uint32(p_SpellID);
    l_Data << uint32(p_PowerType);
    l_Data << uint32(p_Damage);
    l_Data << int32(p_OverEnergize);

    l_Data.WriteBit(false);                       ///< HasPowerData
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);
}

void Unit::EnergizeBySpell(Unit* p_Victim, uint32 p_SpellID, int32 p_Damage, Powers p_PowerType)
{
    int32 l_Gain = 0;

    if (p_PowerType == Powers::POWER_RUNES)
    {
        Player* l_Player = nullptr;
        if (!IsPlayer())
            return;

        l_Player = ToPlayer();
        std::deque<uint8> l_CooldownOrder = l_Player->GetRuneCooldownsOrder();

        if (l_CooldownOrder.empty())
            return;

        for (int32 l_Itr = 0; l_Itr < p_Damage; l_Itr++)
            l_Player->RestoreRune();
    }
    else
        l_Gain = p_Victim->ModifyPower(p_PowerType, p_Damage);

    int32 l_OverEnergize = p_Damage - l_Gain;

    ///SendEnergizeSpellLog(p_Victim, p_SpellID, p_Damage, l_OverEnergize, p_PowerType); Temporary commented because it overlapped with SMSG_POWER_UPDATE and if you gained 10 energy, visually the client made u gain 20 then lose 10 almost instantly (not smooth at all)

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    p_Victim->getHostileRefManager().threatAssist(this, float(p_Damage) * 0.5f, spellInfo);
}

uint32 Unit::SpellDamageBonusDone(Unit* victim, SpellInfo const *spellProto, uint32 pdamage, uint8 effIndex, DamageEffectType damagetype, uint32 stack /*= 1*/, std::ostringstream* p_DamageLogStream /*= nullptr*/)
{
    if (!spellProto || !victim || damagetype == DIRECT_DAMAGE || IsDealingFixedDamage())
        return pdamage;

    // Some spells don't benefit from done mods
    if (spellProto->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS) || spellProto->HasAttribute(SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS))
        return pdamage;

    // small exception for Echo of Light, can't find any general rule
    // should ignore ALL damage mods, they already calculated in trigger spell
    if (spellProto->Id == 77489 || spellProto->Id == 12654) // Echo of Light and Ignite
        return pdamage;

    /// small exception for Prismatic Crystal, can't find any general rule
    /// should ignore ALL damage mods, they already calculated in trigger spell
    if (spellProto->Id == 155152)
        return pdamage;

    // For totems get damage bonus from owner
    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())
        if (Unit* owner = GetOwner())
            return owner->SpellDamageBonusDone(victim, spellProto, pdamage, effIndex, damagetype, 1, p_DamageLogStream);

    if (GetEntry() == DeathKnightPet::DancingRuneWeapon)
    {
        if (Unit* owner = GetOwner())
            return owner->SpellDamageBonusDone(victim, spellProto, pdamage, effIndex, damagetype, 1, p_DamageLogStream);
    }

    float ApCoeffMod = 1.0f;
    int32 DoneTotal = 0;

    if (Unit* owner = GetOwner())
    {
        AuraEffectList const& mModPetStats = owner->GetAuraEffectsByType(SPELL_AURA_MOD_PET_STATS);
        float amount = 0;
        for (AuraEffectList::const_iterator i = mModPetStats.begin(); i != mModPetStats.end(); ++i)
        {
            if ((*i)->GetMiscValue() == INCREASE_MAGIC_DAMAGE_PERCENT)
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_PET_STATS (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                amount += float((*i)->GetAmount());
            }
        }

        DoneTotal += CalculatePct(pdamage, amount);
    }

    /// Legion 7.3.5 - build 26365
    /// Legion Rogue Legendary - Zodyck Family Training Shackles - 214569
    if (IsPlayer())
    {
        if (Aura const* l_Aura = GetAura(214569))
        {
            if (victim->GetHealthPct() <= l_Aura->GetEffect(SpellEffIndex::EFFECT_1)->GetAmount() &&
                (spellProto->IsLethalPoison() || spellProto->IsPoisonOrBleedSpell() ||
                spellProto->Id == 192660 || ///< Poison Bomb
                spellProto->Id == 192759)) ///< Kingsbane (dot)
            {
                if (p_DamageLogStream != nullptr)
                    *p_DamageLogStream << " Zodyck Family Training Shackles (" << l_Aura->GetEffect(SpellEffIndex::EFFECT_0)->GetAmount() << ")" << std::endl;
                DoneTotal += CalculatePct(pdamage, l_Aura->GetEffect(SpellEffIndex::EFFECT_0)->GetAmount());
            }
        }
    }

    /// 72219 Mastery: Master Demonologist
    if (isPet() && HasAura(193396))
    {
        float Mastery = GetOwner()->ToPlayer()->GetFloatValue(PLAYER_FIELD_MASTERY) * 1.8f;
        if (p_DamageLogStream)
            *p_DamageLogStream << " Master Demonologist (" << Mastery << ")" << std::endl;
        if (GetEntry() != 78158) ///< DoomGuard as pet get modifier with mastery later
            DoneTotal += CalculatePct(pdamage, Mastery);
    }

    ///< Apply 15% dmg modifier to destr warlock's pets and guardians (spells)
    if ((isPet() || isGuardian() || isSummon()) && GetOwner() && GetOwner()->ToPlayer() && GetOwner()->ToPlayer()->HasAura(137046))
    {
        if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(137046))
            DoneTotal += CalculatePct(pdamage, l_SpellInfo->Effects[EFFECT_0].BasePoints);
    }

    /// Chaos Bolt - 116858
    /// and Chaos Bolt - 215279 (from Chaos Tear)
    /// damage is increased by your critical strike chance
    if (IsPlayer() && spellProto && (spellProto->Id == 116858 || spellProto->Id == 215279))
    {
        /// Default is 5% of crit
        float crit_chance = GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
        if (p_DamageLogStream)
            *p_DamageLogStream << " Chaos Bolt  (" << crit_chance << ")" << std::endl;
        DoneTotal += CalculatePct(pdamage, crit_chance);
    }

    /// Balance Druid Starfall passive 'Stellar Empowerment' is a dummy effect, but should increase damage of Moonfire and Sunfire dots
    if (spellProto && (spellProto->Id == 164812 || spellProto->Id == 164815) && damagetype == DOT)
    {
        if (AuraEffect* l_AuraEffect = victim->GetAuraEffect(197637, EFFECT_0, GetGUID()))
            DoneTotal += CalculatePct(pdamage, l_AuraEffect->GetAmount());
    }

    /// Fingers of Frost - 112965
    if (IsPlayer() && pdamage != 0 && ToPlayer()->GetActiveSpecializationID() == SPEC_MAGE_FROST && spellProto && getLevel() >= 24 && !HasAura(198123))
    {
        int32 l_ProcChance = 0;

        if (spellProto->Id == 84721)    ///< Frozen Orb Damage
            l_ProcChance = 12;
        else if (spellProto->Id == 56936)                                                   ///< Blizzard
            l_ProcChance = 5;

        if (HasAura(205030))    ///< Frozen Touch
            l_ProcChance = AddPct(l_ProcChance, 40);

        /// Item - Mage T19 Frost 4P Bonus
        if (spellProto->Id == 84721)
            if (AuraEffect* l_AuraEffect = GetAuraEffect(211404, EFFECT_0))
                l_ProcChance += l_AuraEffect->GetAmount();

        if (roll_chance_i(l_ProcChance))
        {
            if (HasAura(44544))
                CastSpell(this, 126084, true); ///< Fingers of frost visual
            CastSpell(this, 44544, true);  ///< Fingers of frost proc
        }
    }

    /// Frost Orb should remove Polymorph
    if (IsPlayer() && spellProto && victim && spellProto->Id == 84721)
    {
        /// Polymorph
        if (victim->IsPolymorphed())
            victim->RemoveAurasDueToSpell(victim->getTransForm());
    }

    uint32 creatureTypeMask = victim->GetCreatureTypeMask(); ///> creatureTypeMask is unused

    // Check for table values
    float coeff = 0;

    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
    if (bonus && (spellProto->Effects[effIndex].BonusMultiplier == 0.0f && spellProto->Effects[effIndex].AttackPowerMultiplier == 0.0f))
    {
        if (damagetype == DOT)
        {
            if (bonus->ap_dot_bonus > 0)
            {
                WeaponAttackType attType = (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE && getClass() == CLASS_HUNTER) ? WeaponAttackType::RangedAttack : WeaponAttackType::BaseAttack;
                float APbonus = float(victim->GetTotalAuraModifier(attType == WeaponAttackType::BaseAttack ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));
                APbonus += GetTotalAttackPowerValue(attType);
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS  (" << GetTotalAttackPowerValue(attType) << "," << APbonus << ")" << std::endl;
                DoneTotal += int32(bonus->ap_dot_bonus * stack * ApCoeffMod * APbonus);
            }
        }
        else
        {
            if (bonus->ap_bonus > 0)
            {
                WeaponAttackType attType = (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE && getClass() == CLASS_HUNTER) ? WeaponAttackType::RangedAttack : WeaponAttackType::BaseAttack;
                float APbonus = float(victim->GetTotalAuraModifier(attType == WeaponAttackType::BaseAttack ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));
                APbonus += GetTotalAttackPowerValue(attType);
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS  (" << attType << "," << GetTotalAttackPowerValue(attType) << "," << APbonus << ")" << std::endl;
                DoneTotal += int32(bonus->ap_bonus * stack * ApCoeffMod * APbonus);
            }
        }
    }

    if (IsPlayer() && ToPlayer()->GetActiveSpecializationID() == SPEC_MONK_WINDWALKER && spellProto)
    {
        AuraEffect* l_AuraEffect = GetAuraEffect(115636, EFFECT_0);
        if (l_AuraEffect != nullptr)
        {
            uint32 l_PrecursorSpell;
            uint32 l_PrevSpell = ToPlayer()->m_SpellHelper.GetUint32(eSpellHelpers::HitComboLastSpellId);
            bool FistOfFury = false;
            bool wirlingDragon = false;

            switch (spellProto->Id)
            {
                case 185099:
                    l_PrecursorSpell = 107428;
                    break;
                case 117418:
                    l_PrecursorSpell = 113656;
                    FistOfFury = true;
                    break;
                case 158221:
                    wirlingDragon = true;
                default:
                    l_PrecursorSpell = spellProto->Id;
                    break;
            }

            bool isMonkAttackSpell = l_PrecursorSpell == 100780 || l_PrecursorSpell == 100784 || l_PrecursorSpell == 107428 || l_PrecursorSpell == 113656
                || l_PrecursorSpell == 222029 || l_PrecursorSpell == 205414 || l_PrecursorSpell == 158221;

            if (isMonkAttackSpell) 
            {
                ToPlayer()->m_SpellHelper.GetUint32(eSpellHelpers::HitComboLastSpellId) = l_PrecursorSpell;
            }

            /// Saving the proc of mastery for Storm Earth and Fire (137639) copied spells
            if (l_PrecursorSpell == l_PrevSpell && !FistOfFury && !wirlingDragon)
                ToPlayer()->m_SpellHelper.GetBool(eSpellHelpers::MasteryProc) = false;

            if (spellProto->Id == 117952) /// Crackling Jade Lightning
            {
                if (GetSpellModOwner() && (GetSpellModOwner()->m_SpellHelper.GetBool(eSpellHelpers::CJLBenefitFromMastery)))
                {
                    AddPct(pdamage, l_AuraEffect->GetAmount());
                    ToPlayer()->m_SpellHelper.GetBool(eSpellHelpers::MasteryProc) = true;
                }
            }
            else if (isMonkAttackSpell && (l_PrecursorSpell != l_PrevSpell || wirlingDragon))
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " Aura 115636  (" << l_AuraEffect->GetAmount() << ")" << std::endl;

                bool l_ApplyMastery = (spellProto->Id != 242556 && spellProto->Id != 242557) ///< Umbral Glaive Storm spells
                    && (spellProto->Id != 107270 || m_SpellHelper.GetBool(eSpellHelpers::SpinningCraneKickMastery)) ///< Spinning Crane Kick
                    && (spellProto->Id != 132467 || m_SpellHelper.GetBool(eSpellHelpers::ChiWaveMastery)); ///< Chi Wave

                if (l_ApplyMastery)
                {
                    DoneTotal += CalculatePct(l_PrecursorSpell == 113656 ? (uint32)DoneTotal : pdamage, l_AuraEffect->GetAmount());
                    ToPlayer()->m_SpellHelper.GetBool(eSpellHelpers::MasteryProc) = true; ///< Saving the proc of mastery for Storm Earth and Fire (137639) copied spells
                }

                if (Aura* l_ZenMomentAura = GetAura(201325))
                {
                    if (SpellInfo const* l_ZenMomentInfo = sSpellMgr->GetSpellInfo(201325))
                    {
                        if (AuraEffect* l_ZenMomentEffect0 = GetAuraEffect(201325, EFFECT_0))
                        {
                            l_ZenMomentEffect0->SetAmount(l_ZenMomentEffect0->GetAmount() + CalculatePct(0 - l_ZenMomentInfo->Effects[EFFECT_0].BasePoints, l_ZenMomentInfo->Effects[EFFECT_2].BasePoints));
                            if (l_ZenMomentEffect0->GetAmount() > 0)
                                l_ZenMomentEffect0->SetAmount(0);
                        }

                        if (AuraEffect* l_ZenMomentEffect1 = GetAuraEffect(201325, EFFECT_1))
                        {
                            l_ZenMomentEffect1->SetAmount(l_ZenMomentEffect1->GetAmount() - CalculatePct(l_ZenMomentInfo->Effects[EFFECT_1].BasePoints, l_ZenMomentInfo->Effects[EFFECT_2].BasePoints));
                            if (l_ZenMomentEffect1->GetAmount() < 0)
                                l_ZenMomentEffect1->SetAmount(0);
                        }
                    }
                }

                if (HasAura(196740) && !spellProto->Effects[effIndex].IsPeriodicEffect() && l_PrecursorSpell != l_PrevSpell) ///< Hit Combo
                {
                    if (l_PrecursorSpell != 205414 && !m_SpellHelper.GetBool(eSpellHelpers::TornadoKicks))
                    {
                        CastSpell(this, 196741, true);
                        std::set<uint64>& l_EarthAndFireSpirits = m_SpellHelper.GetUint64Set()[eSpellHelpers::EarthAndFireSpirit];
                        for (uint64 l_SpritGUID : l_EarthAndFireSpirits)
                        {
                            Unit* l_Spirit = sObjectAccessor->GetUnit(*this, l_SpritGUID);
                            if (!l_Spirit)
                                continue;

                            Creature* l_SpiritCreature = l_Spirit->ToCreature();
                            if (!l_SpiritCreature)
                                continue;

                            l_SpiritCreature->CastSpell(l_SpiritCreature, 196741, true);
                        }
                    }
                }
            }
            else if (isMonkAttackSpell && HasAura(196740) && spellProto->Id == l_PrecursorSpell
                && !wirlingDragon && l_PrecursorSpell != 222029 && l_PrecursorSpell != 205414) ///< Hit Combo
            {
                bool& l_TornadoKicks = m_SpellHelper.GetBool(eSpellHelpers::TornadoKicks);

                if (!l_TornadoKicks)
                {
                    RemoveAurasDueToSpell(196741);
                    std::set<uint64>& l_EarthAndFireSpirits = m_SpellHelper.GetUint64Set()[eSpellHelpers::EarthAndFireSpirit];
                    for (uint64 l_SpritGUID : l_EarthAndFireSpirits)
                    {
                        Unit* l_Spirit = sObjectAccessor->GetUnit(*this, l_SpritGUID);
                        if (!l_Spirit)
                            continue;

                        Creature* l_SpiritCreature = l_Spirit->ToCreature();
                        if (!l_SpiritCreature)
                            continue;

                        l_SpiritCreature->RemoveAurasDueToSpell(196741);
                    }
                }
            }
        }
    }

    // Done Percentage for DOT is already calculated, no need to do it again. The percentage mod is applied in Aura::HandleAuraSpecificMods.
    float l_Multiplier = damagetype == DOT ? 1.0f : SpellDamagePctDone(victim, spellProto, damagetype, effIndex, p_DamageLogStream);
    float tmpDamage = (int32(pdamage) + DoneTotal) * l_Multiplier;

    /// Checking the proc of mastery from the Monk for Storm Earth and Fire (137639) Spirits
    if (GetEntry() == 69791 || GetEntry() == 69792)
    {
        if (GetSpellModOwner() && GetSpellModOwner()->m_SpellHelper.GetBool(eSpellHelpers::MasteryProc))
        {
            AuraEffect* l_AuraEffect = GetSpellModOwner()->GetAuraEffect(115636, EFFECT_0);
            if (l_AuraEffect != nullptr)
                AddPct(tmpDamage, l_AuraEffect->GetAmount());
        }

        if (GetOwner() && GetOwner()->ToPlayer())
            if (AuraEffect* l_AuraEffect = GetSpellModOwner()->GetAuraEffect(247483, EFFECT_3))
                tmpDamage -= CalculatePct(tmpDamage, l_AuraEffect->GetAmount());

        if (spellProto->Id == 100784 && GetSpellModOwner() && GetSpellModOwner()->m_SpellHelper.GetBool(eSpellHelpers::T21Windwalker4P) == true)
        {
            SpellInfo const* l_T21Windwalker4PInfo = sSpellMgr->GetSpellInfo(251821);
            if (l_T21Windwalker4PInfo)
                AddPct(tmpDamage, l_T21Windwalker4PInfo->Effects[EFFECT_0].BasePoints);
        }
    }

    float tempTmpDamage = tmpDamage;

    // apply spellmod to Done damage (flat and pct)
    if (Player* modOwner = GetSpellModOwner())
        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage, nullptr, true, p_DamageLogStream);

    if (GetOwner() && GetEntry() == 99625) ///< Wind Spirit
    {
        if (Player* l_Player = GetOwner()->ToPlayer())
        {
            if (p_DamageLogStream)
                *p_DamageLogStream << " PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT (99625, " << l_Player->GetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT) << ")" << std::endl;
            tmpDamage *= l_Player->GetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT);
            if (ToCreature())
                this->ToCreature()->DespawnOrUnsummon(100);
        }
    }


    CalculateFromDummy(victim, tmpDamage, spellProto, (1 << effIndex));

    LOG_SPELL(this, spellProto->Id, "SpellDamageBonusDone(): Spell %s: ((%i + %i (DoneTotal)) * %f (SpellDamagePctDone)) = %f + %f (Mods) = %f", spellProto->GetNameForLogging().c_str(), pdamage, DoneTotal, l_Multiplier, tempTmpDamage, tmpDamage - tempTmpDamage, tmpDamage); ///< ISO C++11 does not allow conversion from string literal to 'char *'
    return uint32(std::max(tmpDamage, 0.0f));
}

float Unit::SpellDamagePctDone(Unit* victim, SpellInfo const* spellProto, DamageEffectType damagetype, uint8 p_EffIndex, std::ostringstream* p_DamageLogStream, bool p_ForSnapshottingCheck) const
{
    // Done total percent damage auras
    float l_DoneTotalMod = 1.0f;

    if (!spellProto || !victim || damagetype == DIRECT_DAMAGE || IsDealingFixedDamage())
        return l_DoneTotalMod;

    /// Challenger's Might should be taken in account for every damaging spell
    if (AuraEffect const* l_ChallengersMightDamage = GetAuraEffect(206150, EFFECT_1))
    {
        float l_Amount = l_ChallengersMightDamage->GetSpellInfo()->GetFloatAmount(l_ChallengersMightDamage->GetAmount(), l_ChallengersMightDamage->GetFloatAmount());
        l_Amount = std::max<float>(l_Amount, -99.99f);
        AddPct(l_DoneTotalMod, l_Amount);
    }

    // Some spells don't benefit from pct done mods
    if (spellProto->AttributesEx6 & SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS)
        return l_DoneTotalMod;

    // For totems pct done mods are calculated when its calculation is run on the player in SpellDamageBonusDone.
    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())
        return l_DoneTotalMod;

    // Pet damage?
    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
    {
        float l_SpellDamageMod = ToCreature()->GetSpellDamageMod(ToCreature()->GetCreatureTemplate()->rank);
        if (p_DamageLogStream && l_SpellDamageMod != 1.0f)
            *p_DamageLogStream << " GetSpellDamageMod(" << l_SpellDamageMod << ")" << std::endl;
        l_DoneTotalMod *= l_SpellDamageMod;
    }

    /// Apply Versatility damage bonus done
    if (GetSpellModOwner())
    {
        float l_VersabilityDamageBonusDone = GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_DONE) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT);
        if (p_DamageLogStream && l_VersabilityDamageBonusDone != 0.0f)
            *p_DamageLogStream << " CR_VERSATILITY_DAMAGE_DONE(" << l_VersabilityDamageBonusDone << ")" << std::endl;
        AddPct(l_DoneTotalMod, l_VersabilityDamageBonusDone);
    }

    /// Some spells damages are modify on pvp
    if (GetSpellModOwner() && victim->GetSpellModOwner())
    {
        if (p_DamageLogStream && GetSpellModOwner()->GetDiminishingPVPDamage(spellProto) != 0.0f)
            *p_DamageLogStream << " GetDiminishingPVPDamage(" << GetSpellModOwner()->GetDiminishingPVPDamage(spellProto) << ")" << std::endl;
        AddPct(l_DoneTotalMod, GetSpellModOwner()->GetDiminishingPVPDamage(spellProto));
    }

    AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
    for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
    {
        if ((*i)->GetId() == 206150) ///< Challenger's might
            continue;

        if (spellProto->EquippedItemClass == -1 && (*i)->GetSpellInfo()->EquippedItemClass != -1)    //prevent apply mods from weapon specific case to non weapon specific spells (Example: thunder clap and two-handed weapon specialization)
            continue;

        if (p_ForSnapshottingCheck && (*i)->GetSpellInfo()->IsNonSnapshottingAura())
            continue;

        /// Flames of the Pit only for player
        if ((*i)->GetId() == 215183 && (spellProto->Id == 3110 || spellProto->Id == 104318 || spellProto->Id == 22703 || spellProto->Id == 20153))
            continue;

        /// Hit combo vs Chi Orbit
        if ((*i)->GetId() == 196741 && spellProto->Id == 196748)
            continue;

        float l_Amount = (*i)->GetSpellInfo()->GetFloatAmount((*i)->GetAmount(), (*i)->GetFloatAmount());
        l_Amount = std::max<float>(l_Amount, -99.99f);

        if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())
        {
            if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/EquippedItemClass (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                AddPct(l_DoneTotalMod, l_Amount);
            }
            else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/EquippedItemSubClassMask (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                AddPct(l_DoneTotalMod, l_Amount);
            }
            else if (IsPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/HasItemFitToSpellRequirements (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                AddPct(l_DoneTotalMod, l_Amount);
            }
        }
    }

    /// DK pet benefit from Mastery: Dreadblade
    if ((isGuardian() || isPet()) && (spellProto->GetSchoolMask() & SpellSchoolMask::SPELL_SCHOOL_MASK_SHADOW))
    {
        if (Unit* l_Owner = GetOwner())
        {
            if (Player* l_Player = l_Owner->ToPlayer())
            {
                if (l_Player->GetActiveSpecializationID() == SpecIndex::SPEC_DK_UNHOLY)
                {
                    if (p_DamageLogStream)
                        *p_DamageLogStream << " Mastery: Dreadblade(" << l_Player->GetFloatValue(PLAYER_FIELD_MASTERY) * 2.25f << ")" << std::endl;
                    AddPct(l_DoneTotalMod, l_Player->GetFloatValue(PLAYER_FIELD_MASTERY) * 2.25f);
                }
            }
        }
    }

    AuraEffectList const& mModDamageFromPercentPower = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_FROM_PCT_POWER);
    for (AuraEffectList::const_iterator i = mModDamageFromPercentPower.begin(); i != mModDamageFromPercentPower.end(); ++i)
    {
        float l_Pct = (float(GetPower(getPowerType())) / float(GetMaxPower(getPowerType()))) * (*i)->GetAmount();
        if (p_DamageLogStream)
            *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_DONE_FROM_PCT_POWER (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
        AddPct(l_DoneTotalMod, l_Pct);
    }

    if ((isPet() || isGuardian()) && GetSpellModOwner())
    {
        AuraEffectList const& mModDamagePercentDone = GetSpellModOwner()->GetAuraEffectsByType(SPELL_AURA_MOD_PET_DAMAGE_DONE);
        for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
        {
            if (p_DamageLogStream)
                *p_DamageLogStream << " SPELL_AURA_MOD_PET_DAMAGE_DONE (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(l_DoneTotalMod, (*i)->GetAmount());
        }
    }

    uint32 creatureTypeMask = victim->GetCreatureTypeMask();

    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
    {
        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
        {
            if (p_DamageLogStream)
                *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_DONE_VERSUS (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(l_DoneTotalMod, (*i)->GetAmount());
        }
    }

    // bonus against aurastate
    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
    {
        if (victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))
        {
            if (p_DamageLogStream)
                *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(l_DoneTotalMod, (*i)->GetAmount());
        }
    }

    // Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
    float l_ModDamageDoneForMechanic = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC, spellProto->Effects[p_EffIndex].Mechanic ? spellProto->Effects[p_EffIndex].Mechanic : spellProto->Mechanic);
    if (l_ModDamageDoneForMechanic != 0.0f && p_DamageLogStream)
        *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC (" << l_ModDamageDoneForMechanic << ")" << std::endl;
    AddPct(l_DoneTotalMod, l_ModDamageDoneForMechanic);

    // Custom scripted damage
    switch (spellProto->SpellFamilyName)
    {
        case SPELLFAMILY_WARLOCK:
        {
            // Shadow Bite (30% increase from each dot)
            if (spellProto->SpellFamilyFlags[1] & 0x00400000 && isPet())
            {
                if (uint8 count = victim->GetDoTsByCaster(GetOwnerGUID()))
                {
                    if (p_DamageLogStream)
                        *p_DamageLogStream << " Shadow Bite (" << 30 * count << ")" << std::endl;
                    AddPct(l_DoneTotalMod, 30 * count);
                }
                break;
            }

            break;
        }
    }

    /// Custom Legion Script - Mastery: Unshackled Fury
    /// Updated as of 7.1.5 - Build 23420
    if (GetTypeId() == TYPEID_PLAYER && HasAura(76856) &&
        (HasAura(18499) || HasAura(184362))) ///< Berserker Rage and Enrage
    {
        Player const* l_Player = ToPlayer();
        if (AuraEffect const* l_MasteryUnshackledFury = l_Player->GetAuraEffect(76856, EFFECT_0))
        {
            float l_MasteryPct = l_Player->GetFloatValue(PLAYER_FIELD_MASTERY);
            float l_MasteryMultiplier = l_MasteryUnshackledFury->GetSpellEffectInfo()->BonusMultiplier;
            int32 l_MasteryValue = (int32)(l_MasteryMultiplier * l_MasteryPct);

            if (AuraEffect* l_RagingBerserker = l_Player->GetAuraEffect(200861, 0))
                l_MasteryValue += l_RagingBerserker->GetAmount();

            if (p_DamageLogStream)
                *p_DamageLogStream << " Mastery: Unshackled Fury (" << 30 * l_MasteryValue << ")" << std::endl;

            AddPct(l_DoneTotalMod, l_MasteryValue);
        }
    }

    /// Custom Legion Script - Entropic Embrace
    /// Updated as of 7.3.5 - Build 26365
    if (GetTypeId() == TYPEID_PLAYER || GetEntry() == 69791 || GetEntry() == 69792) /// Monk's Storm Earth and Fire's Spirits
    {
        if (AuraEffect* l_AuraEffect = GetSpellModOwner()->GetAuraEffect(256374, EFFECT_0))
            AddPct(l_DoneTotalMod, l_AuraEffect->GetAmount());
    }

    if (GetEntry() == 69791 || GetEntry() == 69792 || HasAura(137639)) ///< Monk's Storm earth and Fire spirits should deal 90% damage in pvp
    {
        if (GetSpellModOwner() && GetSpellModOwner()->CanApplyPvPSpellModifiers())
            l_DoneTotalMod *= 0.9f;
    }

    ///< Sin'dorei Spite
    if ((IsWarlockPet() || GetEntry() == 98035 /* Dreadstalkers */) && GetOwner())
        if (AuraEffect* l_AuraEff = GetOwner()->GetAuraEffect(208871, EFFECT_0))
            AddPct(l_DoneTotalMod, l_AuraEff->GetAmount());

    return l_DoneTotalMod;
}

uint32 Unit::SpellDamageBonusTaken(Unit* p_Caster, SpellInfo const* p_SpellProto, uint32 p_Damage, DamageEffectType p_DamageType, uint8 p_EffectIndex, uint32 /*p_Stack*/, std::ostringstream* p_DamageLogStream)
{
    if (!p_SpellProto || p_DamageType == DIRECT_DAMAGE || (p_Caster && p_Caster->IsDealingFixedDamage()))
        return p_Damage;

    /// Some spells don't benefit from done mods
    /// Thal'kiel's Consumption and Machinations of Aman'Thul must reduction damage
    /// Feedback - Foul Steps from Eonar the Lifebinder
    if (p_SpellProto->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS) && p_SpellProto->Id != 211715 && p_SpellProto->Id != 250097 && p_SpellProto->Id != 250139)
        return p_Damage;

    // small exception for Stagger Amount, can't find any general rules
    // Light Stagger, Moderate Stagger and Heavy Stagger ignore reduction mods
    if (p_SpellProto->Id == Stagger::LIGHT_STAGGER || p_SpellProto->Id == Stagger::MODERATE_STAGGER || p_SpellProto->Id == Stagger::HEAVY_STAGGER)
        return p_Damage;

    int32 TakenTotal = 0;
    float TakenTotalMod = 1.0f;
    float TakenTotalCasterMod = 0.0f;

    // from positive and negative SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN
    // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
    float l_ModDamagePercentTaken = GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, p_SpellProto->GetSchoolMask());
    if (l_ModDamagePercentTaken != 1.0f && p_DamageLogStream)
        *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN(" << l_ModDamagePercentTaken << ")" << std::endl;

    TakenTotalMod *= l_ModDamagePercentTaken;

    /// Apply Versatility damage bonus taken
    if (GetSpellModOwner())
    {
        float l_VersabilityDamageTaken = GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_TAKEN) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT);
        if (l_VersabilityDamageTaken != 0.0f && p_DamageLogStream)
            *p_DamageLogStream << " CR_VERSATILITY_DAMAGE_TAKEN(" << l_VersabilityDamageTaken << ")" << std::endl;
        p_Damage -= CalculatePct(p_Damage, l_VersabilityDamageTaken);
    }

    AuraEffectList const& l_AuraReduceDamageDealToCaster = p_Caster->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TO_CASTER);
    for (AuraEffectList::const_iterator l_Itr = l_AuraReduceDamageDealToCaster.begin(); l_Itr != l_AuraReduceDamageDealToCaster.end(); ++l_Itr)
    {
        if ((*l_Itr)->GetCasterGUID() == GetGUID())
        {
            if (p_DamageLogStream)
                *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_TO_CASTER(" << (*l_Itr)->GetId() << "," << (*l_Itr)->GetAmount() << ")" << std::endl;
            TakenTotalMod += CalculatePct(1.0f, (*l_Itr)->GetSpellInfo()->GetFloatAmount((*l_Itr)->GetAmount()));
        }
    }

    // From caster spells
    AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
    {
        if ((*i)->GetCasterGUID() == p_Caster->GetGUID())
        {
            switch ((*i)->GetId())
            {
                // Vendetta, should affect to all damage
                case 79140:
                    if (p_DamageLogStream)
                        *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                    TakenTotalMod += CalculatePct(1.0f, (*i)->GetAmount());
                    break;
                case 192425: ///< Surge of Toxins
                    if ((*i)->IsAffectingSpell(p_SpellProto) ||
                        p_SpellProto->Id == 192660 || ///< Poison Bomb
                        p_SpellProto->Id == 192759)   ///< Kingsbane (dot)
                    {
                        if (p_DamageLogStream)
                            *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                        TakenTotalMod += CalculatePct(1.0f, (*i)->GetAmount());
                    }
                    break;
                default:
                    if ((*i)->IsAffectingSpell(p_SpellProto))
                    {
                        if (p_DamageLogStream)
                            *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                        TakenTotalMod += CalculatePct(1.0f, (*i)->GetAmount());
                    }
                    break;
            }
        }
    }

    // From caster spells
    AuraEffectList const& mOwnerTakenSencond = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK);
    for (AuraEffectList::const_iterator i = mOwnerTakenSencond.begin(); i != mOwnerTakenSencond.end(); ++i)
    {
        switch ((*i)->GetSpellInfo()->Id)
        {
        case 196414: ///< Eradication shouldn't increase damage of spells of warlock's pets
            if (p_SpellProto->Id == 196657 || p_SpellProto->Id == 187394 || p_SpellProto->Id == 215279 || p_SpellProto->Id == 85692 || p_SpellProto->Id == 22703)
                continue;
            break;
        case 48181: ///< Haunt shouldn't increase damage of warlock's pets spells
        case 233494: ///< Contagion shouldn't increase damage of warlock's pets spells
            if (p_SpellProto->Id == 85692 || p_SpellProto->Id == 22703 || p_SpellProto->Id == 54049)
                continue;
            break;
        default:
            break;
        }

        if ((*i)->GetCasterGUID() == p_Caster->GetGUID() && ((*i)->GetMiscValue() & p_SpellProto->SchoolMask))
        {
            if (p_SpellProto && p_SpellProto->Id != 215537) ///< Benefiting to all dmg spells except Trauma
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                TakenTotalMod += CalculatePct(1.0f, (*i)->GetAmount());
            }
        }
    }
    // Mod damage from spell mechanic
    if (uint64 mechanicMask = p_SpellProto->GetEffectMechanicMask(p_EffectIndex))
    {
        AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
        for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
        {
            if (mechanicMask & (1LL << ((*i)->GetMiscValue())))
            {
                if (p_DamageLogStream)
                    *p_DamageLogStream << " SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                AddPct(TakenTotalMod, (*i)->GetAmount());
            }
        }
    }

    if (p_SpellProto->IsTargetingArea())
    {
        if (IsPlayer())
        {
            float l_Avoidance = ToPlayer()->GetRatingBonusValue(CR_AVOIDANCE);
            if (l_Avoidance != 0.0f && p_DamageLogStream)
                *p_DamageLogStream << " CR_AVOIDANCE(" << l_Avoidance << ")" << std::endl;
            AddPct(TakenTotalMod, -(l_Avoidance));
        }

        int32 mult = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE, p_SpellProto->SchoolMask);
        if (mult != 0 && p_DamageLogStream)
            *p_DamageLogStream << " SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE(" << mult << ")" << std::endl;

        AddPct(TakenTotalMod, mult);

        if (p_Caster->GetTypeId() != TYPEID_PLAYER)
        {
            int32 u_mult = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE, p_SpellProto->SchoolMask);
            if (u_mult != 0 && p_DamageLogStream)
                *p_DamageLogStream << " SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE(" << u_mult << ")" << std::endl;
            AddPct(TakenTotalMod, u_mult);
        }
    }

    int32 TakenAdvertisedBenefit = SpellBaseDamageBonusTaken(p_SpellProto->GetSchoolMask());

    // Check for table values
    float coeff = 0;
    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(p_SpellProto->Id);
    if (bonus)
        coeff = (p_DamageType == DOT) ? bonus->dot_damage : bonus->direct_damage;

    // Default calculation
    if (TakenAdvertisedBenefit)
    {
        if (Player* modOwner = GetSpellModOwner())
        {
            coeff *= 100.0f;
            modOwner->ApplySpellMod(p_SpellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff, nullptr, true, p_DamageLogStream);
            coeff /= 100.0f;
        }
        if (TakenAdvertisedBenefit && p_DamageLogStream)
            *p_DamageLogStream << " TakenAdvertisedBenefit " << TakenAdvertisedBenefit << " coeff bonus multiplier(" << coeff << ")" << std::endl;
        TakenTotal += int32(TakenAdvertisedBenefit * coeff);
    }

    float tmpDamage = 0.0f;

    if (TakenTotalCasterMod)
    {
        if (TakenTotal < 0)
        {
            if (TakenTotalMod < 1)
                tmpDamage = ((float(CalculatePct(p_Damage, TakenTotalCasterMod) + TakenTotal) * TakenTotalMod) + CalculatePct(p_Damage, TakenTotalCasterMod));
            else
                tmpDamage = ((float(CalculatePct(p_Damage, TakenTotalCasterMod) + TakenTotal) + CalculatePct(p_Damage, TakenTotalCasterMod)) * TakenTotalMod);
        }
        else if (TakenTotalMod < 1)
            tmpDamage = ((CalculatePct(float(p_Damage) + TakenTotal, TakenTotalCasterMod) * TakenTotalMod) + CalculatePct(float(p_Damage) + TakenTotal, TakenTotalCasterMod));
    }
    if (!tmpDamage)
        tmpDamage = (float(p_Damage) + TakenTotal) * TakenTotalMod;

    return uint32(std::max(tmpDamage, 0.0f));
}

int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask p_SchoolMask) const
{
    if (IsDealingFixedDamage())
        return 0;

    int32 l_DoneAdvertisedBenefit = 0;

    AuraEffectList const& l_DamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
    for (AuraEffectList::const_iterator i = l_DamageDone.begin(); i != l_DamageDone.end(); ++i)
    {
        if (((*i)->GetMiscValue() & p_SchoolMask) != 0
            && (*i)->GetSpellInfo()->EquippedItemClass == -1               ///< -1 == any item class (not wand then)
            && (*i)->GetSpellInfo()->EquippedItemInventoryTypeMask == 0)   ///< 0 == any inventory type (not wand then)
            l_DoneAdvertisedBenefit += (*i)->GetAmount();
    }

    if (HasUnitTypeMask(UNIT_MASK_GUARDIAN) && GetOwner())
    {
        if (Player* l_Owner = GetOwner()->ToPlayer())
        {
            if (isPet())
                l_DoneAdvertisedBenefit += l_Owner->GetUInt32Value(PLAYER_FIELD_PET_SPELL_POWER);
            else
                l_DoneAdvertisedBenefit += GetUInt32Value(UNIT_FIELD_STATS + STAT_INTELLECT);
        }
    }

    if (IsPlayer())
    {
        // Base value
        l_DoneAdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();

        if (GetPowerIndex(POWER_MANA, getClass()) != MAX_POWERS)
            l_DoneAdvertisedBenefit += std::max(0, int32(GetStat(STAT_INTELLECT)));

        /// Spell power from SPELL_AURA_MOD_SPELL_POWER_PCT
        l_DoneAdvertisedBenefit *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SPELL_POWER_PCT);

        // Damage bonus from stats
        AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);
        for (AuraEffectList::const_iterator i = mDamageDoneOfStatPercent.begin(); i != mDamageDoneOfStatPercent.end(); ++i)
        {
            if ((*i)->GetMiscValue() & p_SchoolMask)
            {
                // stat used stored in miscValueB for this aura
                Stats usedStat = Stats((*i)->GetMiscValueB());
                l_DoneAdvertisedBenefit += int32(CalculatePct(GetStat(usedStat), (*i)->GetAmount()));
            }
        }
        // ... and attack power
        AuraEffectList const& mDamageDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
        for (AuraEffectList::const_iterator i =mDamageDonebyAP.begin(); i != mDamageDonebyAP.end(); ++i)
            if ((*i)->GetMiscValue() & p_SchoolMask)
                l_DoneAdvertisedBenefit += int32(CalculatePct(GetTotalAttackPowerValue(WeaponAttackType::BaseAttack), (*i)->GetAmount()));

        AuraEffectList const& mOverrideSpellpower = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_SPELL_POWER_BY_AP_PCT);
        for (AuraEffectList::const_iterator i = mOverrideSpellpower.begin(); i != mOverrideSpellpower.end(); ++i)
        {
            if ((*i)->GetMiscValue() == 0 || (((*i)->GetMiscValue() & p_SchoolMask)))
            {
                int32 attackPower = GetTotalAttackPowerValue(WeaponAttackType::BaseAttack);
                l_DoneAdvertisedBenefit = (*i)->GetAmount() * attackPower / 100;
            }
        }
    }
    return l_DoneAdvertisedBenefit;
}

int32 Unit::SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask) const
{
    int32 TakenAdvertisedBenefit = 0;

    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
        if (((*i)->GetMiscValue() & schoolMask) != 0)
            TakenAdvertisedBenefit += (*i)->GetAmount();

    return TakenAdvertisedBenefit;
}

bool Unit::IsSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType, DamageEffectType damageType) const
{
    return roll_chance_f(GetUnitSpellCriticalChance(victim, spellProto, schoolMask, attackType, damageType));
}

bool Unit::IsAuraAbsorbCrit(SpellInfo const* p_SpellProto, SpellSchoolMask /*p_SchoolMask*/) const
{
    if ((p_SpellProto->AttributesEx2 & SPELL_ATTR2_CANT_CRIT))
        return false;

    switch (p_SpellProto->Id)
    {
        case 235450: ///< Prismatic Barrier
        case 235313: ///< Blazing Barrier
        case 108416: ///< Dark Pact
        case 48707: ///< Anti-Magic Shell
            return false;
            break;
    }

    float l_CritAbsorb = 0.0f;

    if (IsPlayer())
        l_CritAbsorb = GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE);
    else
    {
        l_CritAbsorb = 5.0f;
        l_CritAbsorb += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
        l_CritAbsorb += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
    }

    if (l_CritAbsorb <= 0.0f)
        return false;

    return roll_chance_f(l_CritAbsorb);
}

bool Unit::IsUnitAbleToCrit() const
{
    if (GetOwner() && GetOwner()->IsPlayer())
    {
        if (IsAnySummons())
            return true;

        if (Player* l_Owner = GetOwner()->ToPlayer())
        {
            if (l_Owner->getClass() == CLASS_WARLOCK)
                return true;
        }
    }

    uint32 l_Entry = GetEntry();
    switch (l_Entry)
    {
        case ShamanPet::FireElemental:
        case 95061: ///< Greather Fire Elemental
        case 63508:
        case DeathKnightPet::Gargoyle:
        case DeathKnightPet::DarkArbiter:
        case 77936:
        case 55659:
        case 73967: ///< Niuzao
        case 82927: ///< Inner Demon
        case eMonkPets::Fire:  ///< Fire Spirit
        case eMonkPets::Earth: ///< Earth Spirit
        case 31216: ///< Mirror Image
        case 105850: ///< Akaari's Soul
        case 100324: ///< Hati
        case 100820: ///< Doom Wolves
        case 121661: ///< Sneaky Snake
        case 97055: ///< Shambling Horror
        case DeathKnightPet::ArmyOfTheDead:
        case 97022: ///< Lightning Elemental
        case 60849: ///< Jade Serpent Statue
        case 104493: ///< Spitting Cobra
        case 76168: ///< Ravager
        case 98167: ///< Call To The Void (Void Tendril)
        case 99625: ///< Wind Spirit ( Crosswinds )
        case 100868: ///< Chi-Ji
            return true;
        default:
            return false;
    }
}

float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType, DamageEffectType damageType) const
{
    //! Mobs can't crit with spells. Player Totems can
    //! Fire Elemental (from totem) and Ebon Gargoyle can too - but this part is a hack and needs more research
    if (IS_CRE_OR_VEH_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && !IsUnitAbleToCrit() && spellProto->Id != 116858)
        return 0.0f;

    // not critting spell
    if ((spellProto->AttributesEx2 & SPELL_ATTR2_CANT_CRIT))
        return 0.0f;

    if (spellProto->AttributesCu & SPELL_ATTR0_CU_ALWAYS_CRITS)
        return 100.0f;

    if (IsDealingFixedDamage())
        return 0.0f;

    float crit_chance = 0.0f;
    switch (spellProto->DmgClass)
    {
        case SPELL_DAMAGE_CLASS_NONE:
        {
            // We need more spells to find a general way (if there is any)
            switch (spellProto->Id)
            {
                case 53353: ///< Chimera Shot - Healing can crit, other spells - not
                case 34428: ///< Victory Rush
                    break;
                default:
                    if (spellProto->HasEffect(SPELL_EFFECT_HEAL_PCT))
                        return 0.0f;
                    break;
            }
        }
        // Do not add a break here, case fallthrough is intentional! Adding a break will make above spells unable to crit.
        case SPELL_DAMAGE_CLASS_MAGIC:
        {
            if (schoolMask & SPELL_SCHOOL_MASK_NORMAL && schoolMask != SPELL_SCHOOL_MASK_ALL)
            {
                /// For physical damage, but spells with SPELL_SCHOOL_MASK_ALL should select crit here
                switch (spellProto->Id)
                {
                    case 213688: ///< Warlock Guardian Fel Lord's Fel Cleave
                        if (GetOwner())
                            crit_chance = GetOwner()->GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
                        break;
                    case 188089: ///< Shaman, Earthen Spike
                    case 185779: ///< Rogue, Cannonball Barrage
                    case 242712: ///< Hunter, Cyclonic Burst
                        crit_chance = GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
                        break;
                    default:
                        crit_chance = 0.0f;
                        break;
                }
            }
            // For other schools
            else if (IsPlayer())
                crit_chance = GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
            else if (GetOwner())
                crit_chance = GetOwner()->GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
            else
            {
                crit_chance = (float)m_baseSpellCritChance;
                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
            }

            // taken
            if (victim)
            {
                if (!spellProto->IsPositive())
                {
                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
                    crit_chance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);
                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
                    crit_chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
                }

                // scripted (increase crit chance ... against ... target by x%
                AuraEffectList const& mOverrideClassScript = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
                for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
                {
                    if (!((*i)->IsAffectingSpell(spellProto)))
                        continue;

                    switch ((*i)->GetMiscValue())
                    {
                        // Shatter
                        case  911:
                            if (!victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
                                break;
                            crit_chance *= 2; // double the critical chance against frozen targets
                            crit_chance += 50.0f; // plus an additional 50%
                            break;
                        default:
                            break;
                    }
                }

                ///< Infernal Cinders
                if (spellProto->Id == 242218)
                {
                    if (SpellInfo const* l_DancingFlames = sSpellMgr->GetSpellInfo(246654))
                    {
                        std::list<Unit*> l_AlliesList;
                        float l_Radius = l_DancingFlames->Effects[EFFECT_0].BasePoints;
                        JadeCore::AnyUnitHavingBuffInObjectRangeCheck l_Ucheck(this, this, l_Radius, 242215, true);
                        JadeCore::UnitListSearcher<JadeCore::AnyUnitHavingBuffInObjectRangeCheck> l_Searcher(this, l_AlliesList, l_Ucheck);
                        VisitNearbyObject(l_Radius, l_Searcher);

                        uint32 l_AlliesCount = 0;
                        if (!l_AlliesList.empty())
                        {
                            for (auto l_Ally : l_AlliesList)
                                if (l_Ally->IsFriendlyTo(this))
                                    ++l_AlliesCount;
                        }

                        if (l_AlliesCount > 0)
                            crit_chance += l_DancingFlames->Effects[EFFECT_0].BasePoints * l_AlliesCount;
                    }
                }

                /// Custom crit
                switch (spellProto->Id)
                {
                    case 25912: ///< Holy Shock (damage)
                    case 25914: ///< Holy Shock (heal)
                        crit_chance *= 2.0f;
                        break;
                    case 235999:///> Kil'jaeden's Burning Wish
                    case 232044: ///< Nighthold trinket Might of Krosus spell "Colossal Smash" should always crit
                        return 100.0f;
                    default:
                        break;
                }

                // Custom crit by class
                switch (spellProto->SpellFamilyName)
                {
                    case SPELLFAMILY_MAGE:
                    {
                        switch (spellProto->Id)
                        {
                            /// Fire Blast
                            case 108853:
                                return 100.0f;

                            /// Pheonix's Flames
                            case 194466:
                                return 100.0f;

                            case 2948: ///< Scorch
                            {
                                /// Koralon's burning touch (Legendary) 7.1.5 24320
                                SpellInfo const* l_KoralonsBurningTouch = sSpellMgr->GetSpellInfo(208099);
                                if (l_KoralonsBurningTouch && HasAura(208099) && victim && victim->GetHealthPct() < static_cast<float>(l_KoralonsBurningTouch->Effects[EFFECT_0].BasePoints))
                                    crit_chance = 100.0f;
                                break;
                            }

                            default:
                                break;
                        }
                    }
                    case SPELLFAMILY_DRUID:
                    {
                        switch (spellProto->Id)
                        {
                        case 8936: ///< Regrowth has a 40% increased chance to crit on the base heal
                        {
                            if (damageType == DamageEffectType::SPELL_DIRECT_DAMAGE)
                                if (AuraEffect const* l_AuraEffect = GetAuraEffect(231032, SpellEffIndex::EFFECT_0))
                                    crit_chance += l_AuraEffect->GetAmount();
                            break;
                        }
                        case 5185: ///< Healing Touch alwyas deals a critical hit if the caster has the honor talent Protector Of The Grove
                        {
                            if (HasAura(209730))
                                return 100.0f;
                            break;
                        }
                        default:
                            break;
                        }
                        break;
                    }
                    case SPELLFAMILY_PRIEST:
                    {
                        switch (spellProto->Id)
                        {
                        case 94472: ///< Atonement Heal Crit
                            return 100.0f;
                        case 2050: ///< Holy Word: Serenity
                            if (HasAura(77489)) /// Echo of Light
                                if (AuraEffect* l_AuraEffect = GetAuraEffect(211640, EFFECT_0)) /// Item - Priest T19 Holy 4P Bonus
                                    crit_chance += l_AuraEffect->GetAmount();
                            if (AuraEffect* l_AuraEffect = GetAuraEffect(196762, EFFECT_0)) /// Inner Focus
                                crit_chance += l_AuraEffect->GetAmount();
                            break;
                        case 2060: ///< Heal
                        case 2061: ///< Flash Heal
                        case 14914: ///< Holy Fire
                        case 585: ///< Smite
                            if (AuraEffect* l_AuraEffect = GetAuraEffect(196762, EFFECT_0)) /// Inner Focus
                                crit_chance += l_AuraEffect->GetAmount();
                            break;
                        case 15407: ///< Mind Flay
                        case 205448: ///< Void Bolt
                        case 8092: ///< Mind Blast
                            if (AuraEffect* l_AuraEff = GetAuraEffect(252909, EFFECT_1)) /// T21 Shadow 4P gives 0.5 crit per stack, but the spellmod gives twice this amount and affects too many spells, so changed it to a dummy and handling it here.
                                crit_chance += 0.5 * l_AuraEff->GetAmount();
                            break;
                        default:
                            break;
                        }
                        break;
                    }
                    case SPELLFAMILY_SHAMAN:
                    {
                        switch (spellProto->Id)
                        {
                            case 51505: ///< Lava Burst
                            case 77451: ///< Lava Burst Overload
                                if (victim && (victim->HasAura(188389, GetGUID()) || victim->HasAura(188838, GetGUID())))
                                    return 100.0f; ///< Always Crit if Flame Shock is on target
                                break;
                            default:
                                break;
                        }
                        break;
                    }
                    case SPELLFAMILY_WARLOCK:
                    {
                        switch (spellProto->Id)
                        {
                            case 116858: ///< Chaos Bolts...
                            case 215279: ///< And Chaos Bolt (from Chaos Tear) are always critical hit
                                return 100.0f;
                                break;
                                /// Hack fix for these spells - They deal Chaos damage, SPELL_SCHOOL_MASK_ALL
                        }
                        break;
                    }
                    case SPELLFAMILY_MONK:
                    {
                        switch (spellProto->Id)
                        {
                            case 198487: ///< Zen Pulse
                                return 0.0f;
                                break;
                        }
                        break;
                    }
                }
            }
            break;
        }
        case SPELL_DAMAGE_CLASS_MELEE:
        {
            if (victim)
            {
                if (!spellProto->IsPositive())
                {
                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
                    crit_chance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);
                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
                    crit_chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
                }

                crit_chance += GetUnitCriticalChance(attackType, victim);
                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);

                // Custom crit by class
                switch (spellProto->SpellFamilyName)
                {
                    case SPELLFAMILY_HUNTER:
                    {
                        switch (spellProto->Id)
                        {
                            case 16827: ///< Claw
                            case 17253: ///< Bite
                            case 49966: ///< Smack
                                /// Cobra Strikes - next spell will be critical
                                if (HasAura(53257) && !victim->HasAura(53480)) ///< Can't crit just if target has Roar of Sacrifice
                                    return 100.0f;
                                break;
                        }
                        break;
                    }
                    case SPELLFAMILY_DRUID:
                    {
                        switch (spellProto->Id)
                        {
                            case 5221:  ///< Shred
                                /// Incarnation: King of the Jungle increase crit of Shred as if player were stealth
                                if (m_SpellHelper.GetBool(eSpellHelpers::DruidSteath) || m_SpellHelper.GetBool(eSpellHelpers::DruidKingOfTheJungle))
                                    crit_chance *= 2.0f;
                                break;
                            case 1822: ///< If the caster has the honor talent Fresh Wound and the target doesn't already have Rake active, the caster's Rake has a 60% increased chance of a critical hit
                                if (HasAura(203224) && !victim->HasAura(155722))
                                    crit_chance += 60.0f;
                                break;
                        }

                        /// Blood Scent
                        if (AuraEffect const* l_BloodScentEffect = GetAuraEffect(202022, EFFECT_0))
                        {
                            if (victim->HasAuraState(AURA_STATE_BLEEDING))
                                crit_chance += (float)l_BloodScentEffect->GetAmount();
                        }

                        break;
                    }
                    case SPELLFAMILY_WARRIOR:
                    {
                        switch (spellProto->Id)
                        {
                            case 23881:///< Fresh Meat
                            {
                                AuraEffect* l_AuraEffectCrit = GetAuraEffect(215568, EFFECT_0);
                                AuraEffect* l_AuraEffectHealth = GetAuraEffect(215568, EFFECT_1);
                                if (l_AuraEffectCrit != nullptr && l_AuraEffectHealth != nullptr)
                                {
                                    if (victim->GetHealthPct() > l_AuraEffectHealth->GetAmount())
                                        crit_chance += (float)l_AuraEffectCrit->GetAmount();
                                }
                                break;
                            }
                            case 7384:///< Overpower
                            {
                                crit_chance += spellProto->Effects[EFFECT_2].BasePoints;
                                break;
                            }
                            case 118000:///< Dragon Roar ...
                                /// ... is always a critical hit
                                return 100.0f;
                                break;
                        }
                        break;
                    }
                    case SPELLFAMILY_DEATHKNIGHT:
                    {
                        switch (spellProto->Id)
                        {
                            case 66196:///< Frost Strike (Left hand)
                            case 222026:///< Frost Strike
                            {
                                if (HasAura(204132) && victim->HasAuraType(SPELL_AURA_MOD_ROOT))///< If the caster has the honor talent Tundra Stalker and the target is rooted, Frost Strike has a critical hit chance increased by 50%
                                    crit_chance += (sSpellMgr->GetSpellInfo(204132))->Effects[EFFECT_1].BasePoints;
                            }
                        }
                        break;
                    }
                    case SPELLFAMILY_DEMONHUNTER:
                    {
                        switch (spellProto->Id)
                        {
                            case 222031: ///< Chaos Strike Main Hand (This will set the crit chance of off hand (199547) cuz either both crit or none. to see how it's done search 'eSpellHelpers::ChaosStrike')
                            case 227518: ///< Annihilation Main Hand (same. OffHand: 201428)
                                if (AuraEffect* l_AuraEffect = GetAuraEffect(211074, EFFECT_0)) ///< Item - Demon Hunter T19 Havoc 4P
                                    crit_chance += l_AuraEffect->GetAmount();
                                break;
                        }
                    }
                }
            }
            break;
        }
        case SPELL_DAMAGE_CLASS_RANGED:
        {
            switch (spellProto->Id)
            {
                case 19434:  ///< Aimed Shot
                case 185358: ///< Arcane Shot
                case 185901: ///< Marked Shot
                case 2643:   ///< Multi-Shot
                {
                    /// Careful Aim - 53238
                    if (Aura* l_CarefulAim = GetAura(53238))
                    {
                        /// Aimed Shot, Arcane Shot, Marked Shot, and Multi-Shot have 20% increased critical strike chance against targets above 80% Health
                        if (victim->GetHealthPct() > l_CarefulAim->GetEffect(EFFECT_1)->GetAmount())
                            crit_chance += 20;
                    }

                    break;
                }
                default:
                    break;
            }

            if (victim)
            {
                crit_chance += GetUnitCriticalChance(attackType, victim);
                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
            }
            break;
        }
        default:
            return 0.0f;
    }

    if (victim)
    {
        AuraEffectList const& critAuras = victim->GetAuraEffectsByType(SPELL_AURA_MOD_CRIT_CHANCE_FOR_CASTER);
        for (AuraEffectList::const_iterator i = critAuras.begin(); i != critAuras.end(); ++i)
            if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectingSpell(spellProto) && (*i)->GetId() != 246729)
                crit_chance += (*i)->GetAmount();

        AuraEffectList const& l_CritHealthPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_CRITICAL_CHANCE_TARGET_HEALTH_PCT);
        for (AuraEffectList::const_iterator l_Itr = l_CritHealthPctAuras.begin(); l_Itr != l_CritHealthPctAuras.end(); ++l_Itr)
            if (victim->GetHealthPct() >= (*l_Itr)->GetMiscValueB())
                crit_chance += (*l_Itr)->GetAmount();

        ///< Tidal Force
        if (AuraEffect* l_AuraEffect = GetAuraEffect(246729, EFFECT_0, GetGUID()))
            if (l_AuraEffect->GetCasterGUID() == GetGUID() && l_AuraEffect->IsAffectingSpell(spellProto))
                crit_chance += l_AuraEffect->GetAmount();
    }

    // percent done
    // only players use intelligence for critical chance computations
    if (Player* modOwner = GetSpellModOwner())
    {
        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);

        ///< Hack for Winnowing with Deadwind harvester buff (for Agony, UA, Corruption and Siphon Life damage)
        if ((spellProto->IsUnstableAffliction() || spellProto->Id == 980 || spellProto->Id == 63106 || spellProto->Id == 146739) &&
            modOwner->HasAura(238072) && modOwner->HasAura(216708))
        {
            float l_BaseCritChance = modOwner->GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE);
            crit_chance -= l_BaseCritChance;
        }
    }

    CalculateFromDummy(victim, crit_chance, spellProto, 131071, SPELL_DUMMY_CRIT);

    return crit_chance > 0.0f ? crit_chance : 0.0f;
}

uint32 Unit::MeleeCriticalDamageBonus(SpellInfo const* p_SpellProto, uint32 p_Damage, Unit* p_Victim, WeaponAttackType p_AttackType, std::ostringstream* p_DamageStreamLog /*= nullptr*/)
{
    int32 l_BaseCritPct = 100; // 200% for all melee damage type...
    int32 l_CritPct = 0;
    Player* l_ModOwner = GetSpellModOwner();

    if (p_Victim == nullptr)
        return  p_Damage;

    int32 l_DamageTmp = p_Damage;
    float l_PctSpellMod = 0.0f;

    Player* l_ModVictimOwner = p_Victim->GetSpellModOwner();

    if (l_ModOwner != nullptr && l_ModVictimOwner != nullptr)
        l_BaseCritPct = 50; ////< 150% on pvp

    if (p_AttackType == WeaponAttackType::RangedAttack)
        l_CritPct += p_Victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
    else
        l_CritPct += p_Victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);

    if (p_DamageStreamLog)
        *p_DamageStreamLog << " crit pct SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE " << l_CritPct << std::endl;

    if (p_SpellProto)
    {
        l_CritPct += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, p_SpellProto->GetSchoolMask());
        /// adds additional damage to p_Damage (from talents)

        if (p_DamageStreamLog && GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, p_SpellProto->GetSchoolMask()))
            *p_DamageStreamLog << " crit pct SPELL_AURA_MOD_CRIT_DAMAGE_BONUS" << l_CritPct << std::endl;

        if (l_ModOwner)
            l_ModOwner->ApplySpellMod(p_SpellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, l_DamageTmp, nullptr, true, p_DamageStreamLog);
    }

    float l_Factor = static_cast<float> (100 + l_BaseCritPct) / 100; ///< 2.0f in PVE and 1.5f in PVP basically
    l_PctSpellMod = std::ceil(100.0f * (float)(l_DamageTmp - p_Damage) / (float)p_Damage) / l_Factor;

    p_Damage += CalculatePct(p_Damage, l_BaseCritPct);

    if (l_PctSpellMod != 0)
        p_Damage += CalculatePct(p_Damage, l_PctSpellMod);

    if (l_CritPct != 0)
        p_Damage += CalculatePct(p_Damage, l_CritPct);

    return p_Damage;
}

uint32 Unit::SpellCriticalDamageBonus(SpellInfo const* p_SpellProto, uint32 p_Damage, Unit* p_Victim, std::ostringstream* p_DamageStreamLog /*=nullptr*/)
{
    int32 l_CritPctBase = 100; ///< 200% for all spell damage type...
    int32 l_CritPctBonus = 0;
    Player* l_ModOwner = GetSpellModOwner();

    if (p_Victim == nullptr)
        return p_Damage;

    Player* l_ModVictimOwner = p_Victim->GetSpellModOwner();
    int32 l_Diff = 0;
    float l_PctSpellMod = 0.0f;

    if (l_ModOwner != nullptr && l_ModVictimOwner != nullptr)
        l_CritPctBase = 50; ///< 150% on pvp

    /// Special case for Prismatic Crystal - 150% crit
    if (l_ModOwner != nullptr && l_ModOwner->getClass() == CLASS_MAGE && p_Victim->GetTypeId() == TYPEID_UNIT && p_Victim->HasAura(155153))
        l_CritPctBase = 50;

    int32 l_DamageTmp = p_Damage;

    if (p_SpellProto)
    {
        l_CritPctBonus += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, p_SpellProto->GetSchoolMask());
        /// adds additional damage to p_Damage (from talents)

        if (p_DamageStreamLog)
            *p_DamageStreamLog << " crit pct " << l_CritPctBonus << std::endl;

        if (l_ModOwner)
            l_ModOwner->ApplySpellMod(p_SpellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, l_DamageTmp, nullptr, true, p_DamageStreamLog);

        float l_Factor = static_cast<float> (100 + l_CritPctBase) / 100; ///< 2.0f in PVE and 1.5f in PVP basically
        l_PctSpellMod = std::ceil(100.0f * (float)(l_DamageTmp - p_Damage) / (float)p_Damage) / l_Factor;
    }
    p_Damage += CalculatePct(p_Damage, l_CritPctBase);

    if (l_PctSpellMod != 0)
        p_Damage += CalculatePct(p_Damage, l_PctSpellMod);

    if (l_CritPctBonus != 0)
        p_Damage += CalculatePct(p_Damage, l_CritPctBonus);

    return p_Damage;
}

uint32 Unit::SpellCriticalHealingBonus(SpellInfo const* p_SpellProto, uint32 p_Damage, Unit* p_Victim)
{
    float l_CritPctBonus = 100.0f; ///< 200% for all healing...
    Player* l_ModOwner = GetSpellModOwner();

    if (p_Victim == nullptr)
        return  p_Damage;

    if (p_SpellProto->Id == 94472) ///< Atonement (No increase damage from crit)
        return p_Damage;

    Player* l_ModVictimOwner = p_Victim->GetSpellModOwner();

    if (l_ModOwner != nullptr && l_ModVictimOwner != nullptr && ((l_ModOwner->GetMap() && l_ModOwner->GetMap()->IsBattlegroundOrArena()) || l_ModOwner->IsInPvPCombat() || l_ModVictimOwner->IsInPvPCombat()))
        l_CritPctBonus = 50; ///< 150% on pvp

    l_CritPctBonus += CalculatePct(l_CritPctBonus, GetTotalAuraModifier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));

    if (p_SpellProto && l_ModOwner)
    {
        int32 l_DamageTmp = p_Damage;
        l_ModOwner->ApplySpellMod(p_SpellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, l_DamageTmp);

        l_CritPctBonus += 100.0f * (float)(l_DamageTmp - p_Damage) / (float)p_Damage;
    }

    p_Damage += CalculatePct(p_Damage, l_CritPctBonus);

    return p_Damage;
}

uint32 Unit::SpellCriticalAuraAbsorbBonus(SpellInfo const* /*p_SpellProto*/, uint32 p_Damage)
{
    int32 l_CritPctBonus = 100; ///< 200% for all absorb type...

    Player* l_ModOwner = GetSpellModOwner();

    if (l_ModOwner && ((GetMap() && GetMap()->IsBattlegroundOrArena()) || l_ModOwner->IsInPvPCombat()))
        l_CritPctBonus = 50; ///< 150% on pvp like healing

    /// Maybe some bonus of Aura to apply?
    /// l_CritPctBonus += CalculatePct(l_CritPctBonus, GetTotalAuraModifier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));
    p_Damage += CalculatePct(p_Damage, l_CritPctBonus);

    return p_Damage;
}

uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const *spellProto, uint32 healamount, uint8 effIndex, DamageEffectType damagetype, uint32 stack /*= 1*/)
{
    // For totems get healing bonus from owner (statue isn't totem in fact)
    if (GetTypeId() == TYPEID_UNIT && (isTotem() || (GetEntry() == 60849 && spellProto->Id == 115175)))
        if (Unit* owner = GetOwner())
            return owner->SpellHealingBonusDone(victim, spellProto, healamount, effIndex, damagetype, stack);

    if (spellProto->AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS)
        return healamount;

    // No bonus healing for potion spells
    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)
        return healamount;

    uint32 l_DampeningValue = 0;

    if (AuraEffect* l_DampeningEffect = victim->GetAuraEffect(110310, 0))
    {
        l_DampeningValue = l_DampeningEffect->GetAmount();
    }

    // No bonus for :
    if (spellProto->Id == 108447 || ///< Soul Link heal
        spellProto->Id == 48503  || ///< Living Seed
        spellProto->Id == 114911 || ///< Ancestral Guidance
        spellProto->Id == 145109 || ///< Ysera's Gift
        spellProto->Id == 146347)   ///< Life Steal
        return CalculatePct(healamount, 100 - l_DampeningValue);        ///< Fix 7.1.5 build 23420: those spells should still be affected by dampening !!!

    int32 DoneTotal = 0;

    // done scripted mod (take it from owner)
    Unit* owner = GetOwner() ? GetOwner() : this;
    AuraEffectList const& mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
    {
        if (!(*i)->IsAffectingSpell(spellProto))
            continue;

        switch ((*i)->GetMiscValue())
        {
            case 3736: // Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind
                DoneTotal += (*i)->GetAmount();
                break;
            default:
                break;
        }
    }

    /// Regrowth - Increase healing from Clearcasting
    if (healamount > 0 && spellProto->Id == 8936)
        if (HasAura(16870) && HasAura(155577))
            DoneTotal += CalculatePct(healamount, 15);

    /// last update : 7.3.5
    /// 77495 - Mastery : Harmony
    if (IsPlayer() && victim && ToPlayer()->GetActiveSpecializationID() == SPEC_DRUID_RESTORATION && HasAura(77495))
    {
        if (spellProto != nullptr && spellProto->IsHealingSpell() && spellProto->Id != 108238 && spellProto->SpellFamilyName == SPELLFAMILY_DRUID)
        {
            Aura* l_AuraHarmony = GetAura(77495);
            if (l_AuraHarmony != nullptr)
            {
                int32 l_NbPeriodicHealApply = 0;
                AuraEffectList const& l_HealEffectList = victim->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
                for (auto l_HealEffect : l_HealEffectList)
                {
                    if (!l_HealEffect || l_HealEffect->GetCasterGUID() != GetGUID())
                        continue;

                    SpellInfo const* l_SpellInfo = l_HealEffect->GetSpellInfo();
                    if (!l_SpellInfo || l_SpellInfo->SpellFamilyName != SPELLFAMILY_DRUID)
                        continue;

                    l_NbPeriodicHealApply++;
                }

                AuraEffect* l_AuraEffectAmount = l_AuraHarmony->GetEffect(EFFECT_0);
                if (l_AuraEffectAmount != nullptr)
                {
                    l_NbPeriodicHealApply = std::min(l_NbPeriodicHealApply, 7);
                    DoneTotal += (int) CalculatePct( (float) healamount, l_AuraEffectAmount->GetFloatAmount() * l_NbPeriodicHealApply);
                }
            }
        }
    }

    /// Mastery: Lightbringer
    /// Lightbringer: It's 100% effective at 10 yards, 0% effective at 40 yards, falling off linearly in between (e.g. it's 2 / 3 effective at 20 yards).
    if (healamount > 0  && IsPlayer() && ToPlayer()->ToPlayer()->GetActiveSpecializationID() == SPEC_PALADIN_HOLY && HasAura(183997) && spellProto->SpellFamilyName == SPELLFAMILY_PALADIN)
    {
        if (AuraEffect* l_AuraEffect = GetAuraEffect(183997, EFFECT_0))
        {
            float l_Distance = GetDistance(victim);

            if (HasAura(197446) && ToPlayer()->GetBeaconOfLightTarget()) ///< Beacon of the Lightbringer
            {
                Unit* l_Target = ObjectAccessor::FindUnit(ToPlayer()->GetBeaconOfLightTarget());
                if (l_Target != nullptr)
                    l_Distance = std::min(l_Distance, l_Target->GetDistance(victim));
            }

            uint8 l_MaxDistance = 40;
            if (HasAura(214202)) ///< Rule of Law : Increase the range of Mastery: Lightbring
                l_MaxDistance += 10;

            uint8 l_MinDistance = 10;
            if (l_Distance <= l_MinDistance)
                DoneTotal += CalculatePct((float) healamount, l_AuraEffect->GetFloatAmount());
            else
                DoneTotal += CalculatePct((float) healamount, CalculatePct(l_AuraEffect->GetFloatAmount(), (100 - ((l_Distance - l_MinDistance) / l_MaxDistance) * 100)));
        }
    }

    // Apply Power PvP healing bonus
    if (healamount > 0 && IsPlayer() && (victim->IsPlayer() || (victim->GetTypeId() == TYPEID_UNIT && victim->isPet() && victim->GetOwner() && victim->GetOwner()->ToPlayer())))
    {
        float PvPPower = GetFloatValue(PLAYER_FIELD_PVP_POWER_HEALING);
        DoneTotal += CalculatePct(healamount, PvPPower);
    }

    /// Apply Versatility healing bonus done on both the heal amount and the donetotal
    if (GetSpellModOwner())
        DoneTotal += CalculatePct(healamount + DoneTotal, GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_DONE) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT));

    // Done fixed damage bonus auras
    int32 DoneAdvertisedBenefit = SpellBaseHealingBonusDone(spellProto->GetSchoolMask());

    if (!DoneAdvertisedBenefit || (SpellBaseHealingBonusDone(spellProto->GetSchoolMask()) < SpellBaseDamageBonusDone(spellProto->GetSchoolMask())))
    {
        DoneAdvertisedBenefit = SpellBaseDamageBonusDone(spellProto->GetSchoolMask());

        AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
        for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
            if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & spellProto->GetSchoolMask()) != 0)
                DoneAdvertisedBenefit += (*i)->GetAmount();
    }

    // Check for table values
    float coeff = 0.0f;
    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
    if (bonus && (spellProto->Effects[effIndex].BonusMultiplier == 0.0f && spellProto->Effects[effIndex].AttackPowerMultiplier == 0.0f))
    {
        if (damagetype == DOT)
        {
            coeff = bonus->dot_damage; ///< coeff is never read 01/18/16
            if (bonus->ap_dot_bonus > 0)
                DoneTotal += int32(bonus->ap_dot_bonus * stack * GetTotalAttackPowerValue(
                    (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE) ? WeaponAttackType::RangedAttack : WeaponAttackType::BaseAttack));
        }
        else
        {
            coeff = bonus->direct_damage; ///< coef is never read 01/18/16
            if (bonus->ap_bonus > 0)
                DoneTotal += int32(bonus->ap_bonus * stack * GetTotalAttackPowerValue(WeaponAttackType::BaseAttack));
        }
    }
    else
    {
        ///< No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE
            && spellProto->Id != 200389     ///< Cultivation should benefit of Mastery: Harmony
            && spellProto->Id != 207386     ///< Spring Blossoms should benefit of Mastery: Harmony
            && spellProto->Id != 253432     ///< Dreamer (T21 2P) should benefit of Mastery: Harmony
            && spellProto->Id != 197997     ///< Hackfix for Shaman Wellspring Talent so it's affected by healing mods
            && spellProto->Id != 204290     ///< Earth Shield heal
            && spellProto->Id != 183811    ///< Judgment of Light
            && spellProto->Id != 22842	   ///< Frenzied Regeneration should benefit of Mastery: Harmony
            && spellProto->Id != 209069)   ///< Tidal Totem
            return healamount;
    }

    bool l_ApplySpellMod = true;

    for (uint8 i = 0; i < spellProto->EffectCount; ++i)
    {
        switch (spellProto->Effects[i].ApplyAuraName)
        {
            // Bonus healing does not apply to these spells
        case SPELL_AURA_PERIODIC_LEECH:
        case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
            DoneTotal = 0;
            l_ApplySpellMod = false;
            break;
        }

        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)
        {
            DoneTotal = 0;
            l_ApplySpellMod = false;
        }
    }

    // Done Percentage for DOT is already calculated, no need to do it again. The percentage mod is applied in Aura::HandleAuraSpecificMods.
    float heal = float(int32(healamount) + DoneTotal) * (damagetype == DOT ? 1.0f : SpellHealingPctDone(victim, spellProto));

    // apply spellmod to Done amount
    if (l_ApplySpellMod)
    {
        if (Player* modOwner = GetSpellModOwner())
            modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
    }

    CalculateFromDummy(victim, heal, spellProto, (1 << effIndex));

    return uint32(std::max(heal, 0.0f));
}

float Unit::SpellHealingPctDone(Unit* victim, SpellInfo const* spellProto, bool p_ForSnapshottingCheck) const
{
    // For totems pct done mods are calculated when its calculation is run on the player in SpellHealingBonusDone.
    if (GetTypeId() == TYPEID_UNIT && isTotem())
        if (GetOwner())
            return 1.0f;

    // No bonus healing for potion spells
    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)
        return 1.0f;

    // No bonus for Machinations of Aman'Thul
    if (spellProto->Id == 250097)
        return 1.0f;

    float DoneTotalMod = 1.0f;

    /// Some spells healing are modify on pvp
    if (GetSpellModOwner() && victim->GetSpellModOwner())
        AddPct(DoneTotalMod, GetSpellModOwner()->GetDiminishingPVPDamage(spellProto));

    // Healing done percent
    AuraEffectList const& mHealingDonePct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
    for (AuraEffectList::const_iterator i = mHealingDonePct.begin(); i != mHealingDonePct.end(); ++i)
    {
        if (p_ForSnapshottingCheck && (*i)->GetBase()->GetSpellInfo()->IsNonSnapshottingAura())
            continue;

        if (!((*i)->GetBase()->GetSpellInfo()->Id == 158298 && victim->GetGUID() != GetGUID())) ///< Resolve bonus healing only done to yourself ///< 7.0.3 deprecated
            AddPct(DoneTotalMod, (*i)->GetSpellInfo()->GetFloatAmount((*i)->GetAmount(), (*i)->GetFloatAmount()));
    }

    AuraEffectList const& mHealingDoneFromHealth = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_FROM_PCT_HEALTH);
    for (AuraEffectList::const_iterator i = mHealingDoneFromHealth.begin(); i != mHealingDoneFromHealth.end(); ++i)
    {
        float l_HealingPct = (*i)->GetAmount();
        switch ((*i)->GetId())
        {
            case 77226: ///< Mastery: Deep Healing // calculate % because it's not stored in aura effect
            {
                Unit* l_Owner = GetCharmerOrOwnerOrSelf();
                if (l_Owner == nullptr || spellProto->SpellFamilyName != SpellFamilyNames::SPELLFAMILY_SHAMAN)
                    continue;

                l_HealingPct = l_Owner->GetFloatValue(PLAYER_FIELD_MASTERY) * 3.0f;
                break;
            }
        }
        float l_Bonus = ((100.0f - victim->GetHealthPct()) * l_HealingPct / 100.0f);
        AddPct(DoneTotalMod, l_Bonus);
    }

    /// Custom Legion Script - Entropic Embrace
    /// Updated as of 7.3.5 - Build 26365
    if (GetTypeId() == TYPEID_PLAYER || GetEntry() == 69791 || GetEntry() == 69792) /// Monk's Storm Earth and Fire's Spirits
    {
        if (AuraEffect* l_AuraEffect = GetSpellModOwner()->GetAuraEffect(256374, EFFECT_0))
            AddPct(DoneTotalMod, l_AuraEffect->GetAmount());
    }

    return DoneTotalMod;
}

uint32 Unit::SpellHealingBonusTaken(Unit* caster, SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 /*stack*/)
{
    float TakenTotalMod = 1.0f;

    /// Dampening, must be calculated off the raw amount
    Unit* l_OwnerOrSelf = GetOwnerOrUnitItself();

    if (AuraEffect* l_AurEff = l_OwnerOrSelf->GetAuraEffect(110310, EFFECT_0))
        healamount = CalculatePct(healamount, 100 - l_AurEff->GetAmount());

    if (spellProto->AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS)
        return healamount;

    // No bonus for Living Seed
    if (spellProto->Id == 48503)
        return healamount;

    // No bonus for Lifebloom : Final heal
    if (spellProto->Id == 33778)
    {
        ///< but must have a bonus from Focused Growth
        if (HasAura(203553))
            if (Aura* l_FocusedGrowthAura = GetAura(203554))
                if (SpellInfo const* l_LifebloomFinalHeal = sSpellMgr->GetSpellInfo(203554))
                    AddPct(healamount, l_LifebloomFinalHeal->Effects[EFFECT_0].BasePoints * l_FocusedGrowthAura->GetStackAmount());

        return healamount;
    }

    /// 7.3.5 Build 26365: PVP QA told me that healing REDUCTION auras should be stackable on 1 target, but only the strongest effect must be taken (dampening is handled separately)
    int32 l_StrongestReducedHealingAura = 0;

    for (AuraEffect* l_Effect : GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_PCT))
    {
        int32 l_Value = l_Effect->GetAmount();
        if (l_Value > 0)
            AddPct(TakenTotalMod, l_Effect->GetAmount());
        else
            l_StrongestReducedHealingAura = std::min(l_StrongestReducedHealingAura, l_Value);
    }

    AddPct(TakenTotalMod, l_StrongestReducedHealingAura);

    // Tenacity increase healing % taken
    if (AuraEffect const* Tenacity = GetAuraEffect(58549, 0))
        AddPct(TakenTotalMod, Tenacity->GetAmount());

    // Healing Done
    int32 TakenTotal = 0;

    // Taken fixed damage bonus auras
    int32 TakenAdvertisedBenefit = SpellBaseHealingBonusTaken(spellProto->GetSchoolMask());

    // Check for table values
    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
    float coeff = 0;
    if (bonus)
        coeff = (damagetype == DOT) ? bonus->dot_damage : bonus->direct_damage;
    else
    {
        // No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)
        {
            healamount = uint32(std::max((int32(healamount) + TakenTotal) * TakenTotalMod, 0.0f));
            return healamount;
        }
    }

    // Default calculation
    if (TakenAdvertisedBenefit)
    {
        if (Player* modOwner = GetSpellModOwner())
        {
            coeff *= 100.0f;
            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
            coeff /= 100.0f;
        }

        TakenTotal += int32(TakenAdvertisedBenefit * coeff);
    }

    AuraEffectList const& mHealingGet= GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_RECEIVED);
    for (AuraEffectList::const_iterator i = mHealingGet.begin(); i != mHealingGet.end(); ++i)
    {
        if (caster->GetGUID() == (*i)->GetCasterGUID() && ((*i)->IsAffectingSpell(spellProto) || !((*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].SpellClassMask)))
            AddPct(TakenTotalMod, (*i)->GetAmount());
    }

    AuraEffectList const& mHotPct = GetAuraEffectsByType(SPELL_AURA_MOD_HOT_PCT);
    for (AuraEffectList::const_iterator i = mHotPct.begin(); i != mHotPct.end(); ++i)
        if (damagetype == DOT)
            AddPct(TakenTotalMod, (*i)->GetAmount());

    for (uint8 i = 0; i < spellProto->EffectCount; ++i)
    {
        switch (spellProto->Effects[i].ApplyAuraName)
        {
            // Bonus healing does not apply to these spells
            case SPELL_AURA_PERIODIC_LEECH:
            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                TakenTotal = 0;
                break;
        }
        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)
            TakenTotal = 0;
    }

    float heal = float(int32(healamount) + TakenTotal) * TakenTotalMod;
    return uint32(std::max(heal, 0.0f));
}

int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask)
{
    int32 AdvertisedBenefit = 0;

    AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
    for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
            AdvertisedBenefit += (*i)->GetAmount();

    AuraEffectList const& mHealingDone2 = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_2);
    for (AuraEffectList::const_iterator i = mHealingDone2.begin(); i != mHealingDone2.end(); ++i)
        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
            AdvertisedBenefit += (*i)->GetAmount();

    // Healing bonus of intellect and strength
    if (IsPlayer())
    {
        if (GetPowerIndex(POWER_MANA, getClass()) != MAX_POWERS)
            AdvertisedBenefit += std::max(0, int32(GetStat(STAT_INTELLECT)));

        // Base value
        AdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();

        // Healing bonus from stats
        AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);
        for (AuraEffectList::const_iterator i = mHealingDoneOfStatPercent.begin(); i != mHealingDoneOfStatPercent.end(); ++i)
        {
            // stat used dependent from misc value (stat index)
            Stats usedStat = Stats((*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].MiscValue);
            AdvertisedBenefit += int32(CalculatePct(GetStat(usedStat), (*i)->GetAmount()));
        }

        // ... and attack power
        AuraEffectList const& mHealingDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
        for (AuraEffectList::const_iterator i = mHealingDonebyAP.begin(); i != mHealingDonebyAP.end(); ++i)
            if ((*i)->GetMiscValue() & schoolMask)
                AdvertisedBenefit += int32(CalculatePct(GetTotalAttackPowerValue(WeaponAttackType::BaseAttack), (*i)->GetAmount()));

        /// Apply Versatility healing bonus
        if (GetSpellModOwner())
            AdvertisedBenefit += CalculatePct(AdvertisedBenefit, GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_DONE) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT));
    }

    return AdvertisedBenefit;
}

int32 Unit::SpellBaseHealingBonusTaken(SpellSchoolMask schoolMask)
{
    int32 AdvertisedBenefit = 0;

    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING);
    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
        if (((*i)->GetMiscValue() & schoolMask) != 0)
            AdvertisedBenefit += (*i)->GetAmount();

    return AdvertisedBenefit;
}

bool Unit::IsImmunedToDamage(SpellSchoolMask p_SchoolMask)
{
    /// If m_immuneToSchool type contain this school type, IMMUNE damage.
    SpellImmuneContainer const& l_SchoolMap = m_spellImmune[SpellImmunity::IMMUNITY_SCHOOL];
    for (SpellImmuneContainer::const_iterator l_Iter = l_SchoolMap.begin(); l_Iter != l_SchoolMap.end(); ++l_Iter)
    {
        if (l_Iter->first & p_SchoolMask)
            return true;
    }

    /// If m_immuneToDamage type contain magic, IMMUNE damage.
    SpellImmuneContainer const& l_DamageMap = m_spellImmune[SpellImmunity::IMMUNITY_DAMAGE];
    for (SpellImmuneContainer::const_iterator l_Iter = l_DamageMap.begin(); l_Iter != l_DamageMap.end(); ++l_Iter)
    {
        if (l_Iter->first & p_SchoolMask)
            return true;
    }

    return false;
}

bool Unit::IsImmunedToDamage(SpellInfo const* p_SpellInfo)
{
    if (p_SpellInfo->Attributes & SpellAttr0::SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return false;

    uint32 schoolMask = p_SpellInfo->GetSchoolMask();
    if (p_SpellInfo->IsNeedToCheckSchoolImmune())
    {
        /// If m_immuneToSchool type contain this school type, IMMUNE damage.
        SpellImmuneContainer const& l_SchoolMap = m_spellImmune[SpellImmunity::IMMUNITY_SCHOOL];
        unsigned int totalMask = 0;

        for (SpellImmuneContainer::const_iterator l_Iter = l_SchoolMap.begin(); l_Iter != l_SchoolMap.end(); ++l_Iter)
        {
            if (l_Iter->first & schoolMask && !p_SpellInfo->CanPierceImmuneAura(sSpellMgr->GetSpellInfo(l_Iter->second)))
            {
                /// Compute total flag value from all IMMUNE flags
                totalMask |= l_Iter->first;
                if (schoolMask == SpellSchoolMask::SPELL_SCHOOL_MASK_ALL && totalMask != SpellSchoolMask::SPELL_SCHOOL_MASK_ALL)
                    continue;
                return true;
            }
        }
    }

    /// If m_immuneToDamage type contain magic, IMMUNE damage.
    SpellImmuneContainer const& l_DamageMap = m_spellImmune[SpellImmunity::IMMUNITY_DAMAGE];
    for (SpellImmuneContainer::const_iterator l_Iter = l_DamageMap.begin(); l_Iter != l_DamageMap.end(); ++l_Iter)
    {
        if (l_Iter->first & schoolMask)
            return true;
    }

    return false;
}

bool Unit::IsImmunedToSpellEffect(uint32 p_EffectType) const
{
    SpellImmuneContainer const& l_EffectList = m_spellImmune[SpellImmunity::IMMUNITY_EFFECT];
    for (SpellImmuneContainer::const_iterator l_Iter = l_EffectList.begin(); l_Iter != l_EffectList.end(); ++l_Iter)
    {
        if (l_Iter->first == p_EffectType)
            return true;
    }

    return false;
}

bool Unit::IsImmunedToSpell(SpellInfo const* p_SpellInfo)
{
    if (!p_SpellInfo)
        return false;

    /// Diamond Ice vs Cyclone
    if (HasAura(209753) && p_SpellInfo->Id == 203337)
        return false;

    /// Single spell immunity.
    SpellImmuneContainer const& idList = m_spellImmune[SpellImmunity::IMMUNITY_ID];
    for (SpellImmuneContainer::const_iterator l_Iter = idList.begin(); l_Iter != idList.end(); ++l_Iter)
    {
        if (l_Iter->first == p_SpellInfo->Id)
            return true;
    }

    if (p_SpellInfo->Attributes & SpellAttr0::SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return false;

    if (p_SpellInfo->Dispel)
    {
        SpellImmuneContainer const& dispelList = m_spellImmune[SpellImmunity::IMMUNITY_DISPEL];
        for (SpellImmuneContainer::const_iterator l_Iter = dispelList.begin(); l_Iter != dispelList.end(); ++l_Iter)
        {
            if (l_Iter->first == p_SpellInfo->Dispel)
                return true;
        }
    }

    /// Fears and polymorphs should be immuned when target on flying mount
    if (p_SpellInfo->Mechanic & (Mechanics::MECHANIC_FEAR | Mechanics::MECHANIC_POLYMORPH))
        if ((HasAuraType(AuraType::SPELL_AURA_FLY) || HasAuraType(AuraType::SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)) && IsFlying())
            return true;

    /// Ice Block and Divine Shield should prevent damage from Ray of Hope or A Murder of Crows
    if ((p_SpellInfo->Id == 197341 || p_SpellInfo->Id == 131900) && (HasAura(642) || HasAura(45438)))
        return true;

    /// Psyfiend
    if (ToCreature() && ToCreature()->GetEntry() == 101398)
    {
        if (p_SpellInfo->IsAffectingArea())
            return true;

        if (p_SpellInfo->HasAreaAuraEffect())
            return true;
    }

    /// Jade Serpent Statue and Chi Wave
    if (GetEntry() == 60849 && p_SpellInfo->Id == 115098)
        return true;

    /// Jade Serpent Statue and Chi Wave
    if (GetEntry() == 60849 && p_SpellInfo->Id == 115098)
        return true;

    /// Spells that don't have effectMechanics.
    if (p_SpellInfo->Mechanic)
    {
        if (p_SpellInfo->Mechanic == Mechanics::MECHANIC_ROOT && HasAura(197003))
            return true;

        SpellImmuneContainer const& mechanicList = m_spellImmune[SpellImmunity::IMMUNITY_MECHANIC];
        for (SpellImmuneContainer::const_iterator l_Iter = mechanicList.begin(); l_Iter != mechanicList.end(); ++l_Iter)
        {
            if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Iter->second))
            {
                /// Flying mounts should make you immune to polymorphs only when not on ground
                if (l_SpellInfo->HasAura(AuraType::SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
                {
                    if (IsFlying())
                    {
                        if (l_Iter->first == p_SpellInfo->Mechanic)
                            return true;
                    }
                }
            }

            if (l_Iter->first == p_SpellInfo->Mechanic)
                return true;
        }
    }

    bool l_ImmuneToAllEffects = true;
    for (uint8 i = 0; i < p_SpellInfo->EffectCount; ++i)
    {
        /// State/effect immunities applied by aura expect full spell immunity
        /// Ignore effects with mechanic, they are supposed to be checked separately
        if (!p_SpellInfo->Effects[i].IsEffect())
            continue;
        if (!IsImmunedToSpellEffect(p_SpellInfo, i))
        {
            l_ImmuneToAllEffects = false;
            break;
        }
    }

    if (l_ImmuneToAllEffects) ///< Return immune only if the target is immune to all spell effects.
        return true;

    if (p_SpellInfo->IsNeedToCheckSchoolImmune())
    {
        SpellImmuneContainer const& schoolList = m_spellImmune[SpellImmunity::IMMUNITY_SCHOOL];
        for (SpellImmuneContainer::const_iterator l_Itr = schoolList.begin(); l_Itr != schoolList.end(); ++l_Itr)
        {
            uint32 l_SchoolMask = p_SpellInfo->GetSchoolMask();

            SpellInfo const* l_ImmuneSpellInfo = sSpellMgr->GetSpellInfo(l_Itr->second);
            if ((l_Itr->first & l_SchoolMask)
                && !(l_ImmuneSpellInfo && l_ImmuneSpellInfo->IsPositive() && p_SpellInfo->IsPositive())
                && !p_SpellInfo->CanPierceImmuneAura(l_ImmuneSpellInfo))
            {
                if (l_SchoolMask == SpellSchoolMask::SPELL_SCHOOL_MASK_ALL && l_Itr->first != SpellSchoolMask::SPELL_SCHOOL_MASK_ALL)
                    continue;

                return true;
            }
        }
    }

    return false;
}

uint32 Unit::GetSchoolImmunityMask() const
{
    uint32 l_Mask = 0;
    SpellImmuneContainer const& l_MechanicMap = m_spellImmune[SpellImmunity::IMMUNITY_SCHOOL];
    for (SpellImmuneContainer::const_iterator l_Itr = l_MechanicMap.begin(); l_Itr != l_MechanicMap.end(); ++l_Itr)
        l_Mask |= l_Itr->first;

    return l_Mask;
}

bool Unit::HasMechanicImmunityMask(uint32 p_Mechanic) const
{
    return (GetMechanicImmunityMask() & (1 << (p_Mechanic - 1)));
}

uint32 Unit::GetMechanicImmunityMask() const
{
    uint32 l_Mask = 0;
    SpellImmuneContainer const& l_MechanicMap = m_spellImmune[SpellImmunity::IMMUNITY_MECHANIC];
    for (SpellImmuneContainer::const_iterator l_Itr = l_MechanicMap.begin(); l_Itr != l_MechanicMap.end(); ++l_Itr)
        l_Mask |= (1 << l_Itr->first);

    //if (ToCreature())
     //   l_Mask |= ToCreature()->GetCreatureTemplate()->MechanicImmuneMask;

    return l_Mask;
}

bool Unit::IsImmunedToSpellEffect(SpellInfo const* p_SpellInfo, uint32 index) const
{
    if (!p_SpellInfo || !p_SpellInfo->Effects[index].IsEffect())
        return false;

    if (p_SpellInfo->Attributes & SpellAttr0::SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
        return false;

    if (p_SpellInfo->HasAttribute(SPELL_ATTR3_IGNORE_HIT_RESULT))
        return false;

    /// Imonar Pulse Grenade Hackfix - The EFFECT_1 Always hit
    if (p_SpellInfo->Id == 247388 && index == EFFECT_1)
        return false;

    /// If m_immuneToEffect type contain this effect type, IMMUNE effect.
    uint32 l_Effect = p_SpellInfo->Effects[index].Effect;
    SpellImmuneContainer const& l_EffectMap = m_spellImmune[SpellImmunity::IMMUNITY_EFFECT];
    for (SpellImmuneContainer::const_iterator l_Itr = l_EffectMap.begin(); l_Itr != l_EffectMap.end(); ++l_Itr)
    {
        if (l_Itr->first == l_Effect)
            return true;
    }

    if (uint32 l_Mechanic = p_SpellInfo->Effects[index].Mechanic)
    {
        SpellImmuneContainer const& l_MechanicMap = m_spellImmune[SpellImmunity::IMMUNITY_MECHANIC];
        for (SpellImmuneContainer::const_iterator l_Itr = l_MechanicMap.begin(); l_Itr != l_MechanicMap.end(); ++l_Itr)
        {
            if (l_Itr->first == l_Mechanic)
                return true;
        }
    }

    if (uint32 l_Aura = p_SpellInfo->Effects[index].ApplyAuraName)
    {
        SpellImmuneContainer const& l_StateMap = m_spellImmune[SpellImmunity::IMMUNITY_STATE];
        for (SpellImmuneContainer::const_iterator l_Itr = l_StateMap.begin(); l_Itr != l_StateMap.end(); ++l_Itr)
        {
            /// /!\ Hackfix /!\ Ice Form shouldn't makes you immune to Ice Block stun effect
            if (l_Itr->second == 198144 && p_SpellInfo->Id == 45438)
                continue;

            if (l_Itr->first == l_Aura)
                return true;
        }

        /// Check for immune to application of harmful magical effects
        AuraEffectList const& l_AuraList = GetAuraEffectsByType(AuraType::SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL);
        for (AuraEffectList::const_iterator l_Iter = l_AuraList.begin(); l_Iter != l_AuraList.end(); ++l_Iter)
        {
            if ((*l_Iter)->GetMiscValue() & p_SpellInfo->GetSchoolMask()) ///< Check school
            {
                if (!p_SpellInfo->IsPositiveEffect(index) && !p_SpellInfo->CanPierceImmuneAura((*l_Iter)->GetSpellInfo())) ///< Harmful
                {
                    if (!(p_SpellInfo->AttributesEx3 & SpellAttr3::SPELL_ATTR3_IGNORE_HIT_RESULT))
                        return true;
                }

                /// Hammer of Justice can be prevented by immune auras
                if (p_SpellInfo->Id == 853)
                    return true;

                /// Ignite has SPELL_ATTR3_IGNORE_HIT_RESULT , but should be immuned
                if (p_SpellInfo->Id == 12654)
                    return true;
            }
        }
    }

    return false;
}

uint32 Unit::MeleeDamageBonusDone(Unit* victim, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto, uint32 effectMask /*= 0*/, Spell* p_Spell/* = nullptr*/, std::ostringstream* p_DamageStreamLog /*= nullptr*/)
{
    if (pdamage == 0)
        return 0;

    if (GetEntry() == DeathKnightPet::DancingRuneWeapon && victim)
    {
        if (Unit* owner = GetOwner())
            return owner->MeleeDamageBonusDone(victim, pdamage, attType, spellProto, effectMask, p_Spell, p_DamageStreamLog);
    }

    uint32 creatureTypeMask = victim ? victim->GetCreatureTypeMask() : 0;

    // Done fixed damage bonus auras
    int32 DoneFlatBenefit = 0;

    // ..done
    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
    {
        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
        {
            if (p_DamageStreamLog)
                *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_DONE_CREATURE (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            DoneFlatBenefit += (*i)->GetAmount();
        }
    }

    // ..done
    // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage

    // ..done (base at attack power for marked target and base at attack power for creature type)
    int32 APbonus = 0;

    if (attType == WeaponAttackType::RangedAttack)
    {
        if (victim)
            APbonus += victim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
        if (APbonus && p_DamageStreamLog)
            *p_DamageStreamLog << " SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS " << APbonus << std::endl;

        // ..done (base at attack power and creature type)
        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
        {
            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
            {
                if (p_DamageStreamLog)
                    *p_DamageStreamLog << " SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                APbonus += (*i)->GetAmount();
            }
        }
    }
    else
    {
        if (victim)
            APbonus += victim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);

        if (APbonus && p_DamageStreamLog)
            *p_DamageStreamLog << " SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS " << APbonus;

        // ..done (base at attack power and creature type)
        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
        {
            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
            {
                if (APbonus && p_DamageStreamLog)
                    *p_DamageStreamLog << " SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                APbonus += (*i)->GetAmount();
            }
        }
    }

    if (APbonus != 0)                                       // Can be negative
    {
        bool normalized = false;
        if (spellProto)
        {
            for (uint8 i = 0; i < spellProto->EffectCount; ++i)
            {
                if (spellProto->Effects[i].Effect == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)
                {
                    normalized = true;
                    break;
                }
            }
        }
        DoneFlatBenefit += int32(APbonus/14.0f * GetAPMultiplier(attType, normalized));
        if (p_DamageStreamLog)
            *p_DamageStreamLog << " APbonus " << APbonus << " GetAPMultiplier " << GetAPMultiplier(attType, normalized) << std::endl;
    }

    // Done total percent damage auras
    float DoneTotalMod = 1.0f;

    if (Unit* owner = GetOwner())
    {
        AuraEffectList const& mModPetStats = owner->GetAuraEffectsByType(SPELL_AURA_MOD_PET_STATS);
        float amount = 0;
        for (AuraEffectList::const_iterator i = mModPetStats.begin(); i != mModPetStats.end(); ++i)
        {
            if ((*i)->GetMiscValue() == INCREASE_MELEE_DAMAGE_PERCENT)
            {
                if (p_DamageStreamLog)
                    *p_DamageStreamLog << " SPELL_AURA_MOD_PET_STATS/INCREASE_MELEE_DAMAGE_PERCENT (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                amount += float((*i)->GetAmount());
            }
        }

        AddPct(DoneTotalMod, amount);
    }

    /// Custom Legion Script - Mastery: Unshackled Fury
    /// Updated as of 7.1.5 - Build 23420
    if (GetTypeId() == TYPEID_PLAYER && HasAura(76856) &&
        (HasAura(18499) || HasAura(184362))) ///< Berserker Rage and Enrage
    {
        Player* l_Player = ToPlayer();
        if (AuraEffect* l_MasteryUnshackledFury = l_Player->GetAuraEffect(76856, EFFECT_0))
        {
            float l_MasteryPct = l_Player->GetFloatValue(PLAYER_FIELD_MASTERY);
            float l_MasteryMultiplier = l_MasteryUnshackledFury->GetSpellEffectInfo()->BonusMultiplier;
            int32 l_MasteryValue = (int32)(l_MasteryMultiplier * l_MasteryPct);

            if (AuraEffect* l_RagingBerserker = l_Player->GetAuraEffect(200861, 0))
                l_MasteryValue += l_RagingBerserker->GetAmount();

            if (p_DamageStreamLog)
                *p_DamageStreamLog << " Mastery: Unshackled Fury (" << l_MasteryValue << ")" << std::endl;

            AddPct(DoneTotalMod, l_MasteryValue);
        }
    }

    /// Custom Legion Script - Chaos Blades (211048) auto-attack bonus
    if (GetTypeId() == TYPEID_PLAYER && !spellProto)
    {
        /// While active, your auto attack deals 200% increased damage
        if (AuraEffect const* l_AurEff = GetAuraEffect(211048, EFFECT_0))
        {
            if (p_DamageStreamLog)
                *p_DamageStreamLog << " Chaos Blade (" << l_AurEff->GetBaseAmount() << ")" << std::endl;
            AddPct(DoneTotalMod, l_AurEff->GetBaseAmount());
        }
    }

    // Custom MoP Script
    // 76613 - Mastery : Frostburn for Water elemental Melee damage
    if (IsPlayer() && victim && pdamage != 0)
    {
        if (isPet())
        {
            Unit* owner = GetOwner();
            if (owner->HasAura(76613) && owner->IsPlayer())
            {
                float Mastery = owner->GetFloatValue(PLAYER_FIELD_MASTERY) * 2.25f;
                if (p_DamageStreamLog)
                    *p_DamageStreamLog << "  Mastery : Frostburn (" << Mastery << ")" << std::endl;
                AddPct(DoneTotalMod, Mastery);
            }
        }
    }

    /// Custom Legion Script - Entropic Embrace
    /// Updated as of 7.3.5 - Build 26365
    if (GetTypeId() == TYPEID_PLAYER || GetEntry() == 69791 || GetEntry() == 69792) /// Monk's Storm Earth and Fire's Spirits
    {
        if (AuraEffect* l_AuraEffect = GetSpellModOwner()->GetAuraEffect(256374, EFFECT_0))
            AddPct(DoneTotalMod, l_AuraEffect->GetAmount());
    }

    // Ghoul benefit from dmg pct mod from Shadow Infusion
    if (GetTypeId() == TYPEID_UNIT && HasAura(91342)) ///< 7.0.3 deprecated
    {
        if (Aura* stacks = GetAura(91342))
        {
            if (AuraEffect* shadowInfusion = stacks->GetEffect(0))
            {
                if (p_DamageStreamLog)
                    *p_DamageStreamLog << " Ghoul benefit from dmg pct mod from Shadow Infusion (" << shadowInfusion->GetAmount() << ")" << std::endl;
                AddPct(DoneTotalMod, shadowInfusion->GetAmount());
            }
        }
    }

    // DK pet benefit from Mastery: Dreadblade
    /// Ghoul's Claw and Sweeping Claw
    /// Abomination's Cleaver and Vile Gas
    if ((isGuardian() || isPet()) && spellProto && (spellProto->Id == 91776 || spellProto->Id == 91778 || spellProto->Id == 212335 || spellProto->Id == 212338))
    {
        if (Unit* l_Owner = GetOwner())
        {
            if (Player* l_Player = l_Owner->ToPlayer())
            {
                if (l_Player->GetActiveSpecializationID() == SpecIndex::SPEC_DK_UNHOLY)
                {
                    if (p_DamageStreamLog)
                        *p_DamageStreamLog << " Mastery: Dreadblade(" << l_Player->GetFloatValue(PLAYER_FIELD_MASTERY) * 2.25f << ")" << std::endl;
                    AddPct(DoneTotalMod, l_Player->GetFloatValue(PLAYER_FIELD_MASTERY) * 2.25f);
                }
            }
        }
    }

    /// Colossus Smash - 208086
    /// Updated as of 7.3.5 - Build 26365
    if (IsPlayer() && victim && !spellProto && !p_Spell)
    {
        if (AuraEffect* l_AuraEffect = victim->GetAuraEffect(208086, EFFECT_2, GetGUID()))
            AddPct(DoneTotalMod, l_AuraEffect->GetAmount());
    }

    /// Legion 7.3.5 - build 26365
    /// Legion Rogue Legendary - Zodyck Family Training Shackles - 214569
    if (IsPlayer() && spellProto != nullptr)
    {
        if (Aura const* l_Aura = GetAura(214569))
        {
            if (victim->GetHealthPct() <= l_Aura->GetEffect(SpellEffIndex::EFFECT_1)->GetAmount() &&
                (spellProto->Id == 222062 || ///< Kingsbane (main)
                 spellProto->Id == 192760)) ///< Kingsbane (off)
            {
                if (p_DamageStreamLog != nullptr)
                    *p_DamageStreamLog << " Zodyck Family Training Shackles (" << l_Aura->GetEffect(SpellEffIndex::EFFECT_0)->GetAmount() << ")" << std::endl;
                AddPct(DoneTotalMod, l_Aura->GetEffect(SpellEffIndex::EFFECT_0)->GetAmount());
            }
        }
    }

    if (spellProto)
    {
        AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
        for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
        {
            if ((*i)->GetMiscValue() & spellProto->GetSchoolMask() && !(spellProto->GetSchoolMask() & SPELL_SCHOOL_MASK_NORMAL)) ///< don't apply for SPELL_SCHOOL_MASK_NORMAL because it means it's a spell that uses weapon damage, and SPELL_AURA_MOD_DAMAGE_PERCENT_DONE is already applied in Player::CalculateMinMaxDamage
            {
                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
                    continue;

                float l_Amount = (*i)->GetSpellInfo()->GetFloatAmount((*i)->GetAmount(), (*i)->GetFloatAmount());
                l_Amount = std::max<float>(l_Amount, -99.99f);

                if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
                {
                    if (p_DamageStreamLog)
                        *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/EquippedItemClass  (" << (*i)->GetId() << "," << l_Amount << ")" << std::endl;
                    AddPct(DoneTotalMod, l_Amount);
                }
                else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
                {
                    if (p_DamageStreamLog)
                        *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK  (" << (*i)->GetId() << "," << l_Amount << ")" << std::endl;
                    AddPct(DoneTotalMod, l_Amount);
                }
                else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
                {
                    if (p_DamageStreamLog)
                        *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_PERCENT_DONE/HasItemFitToSpellRequirements (" << (*i)->GetId() << "," << l_Amount << ")" << std::endl;
                    AddPct(DoneTotalMod, l_Amount);
                }
            }
        }
    }

    if ((isPet() || isGuardian()) && GetSpellModOwner())
    {
        AuraEffectList const& mModDamagePercentDone = GetSpellModOwner()->GetAuraEffectsByType(SPELL_AURA_MOD_PET_DAMAGE_DONE);
        for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
        {
            if (p_DamageStreamLog)
                *p_DamageStreamLog << " SPELL_AURA_MOD_PET_DAMAGE_DONE (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(DoneTotalMod, (*i)->GetAmount());
        }
    }

    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
    {
        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
        {
            if (p_DamageStreamLog)
                *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_DONE_VERSUS (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(DoneTotalMod, (*i)->GetAmount());
        }
    }

    // bonus against aurastate
    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
    {
        if (victim && victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))
        {
            if (p_DamageStreamLog)
                *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            AddPct(DoneTotalMod, (*i)->GetAmount());
        }
    }

    /// Some spells damages are modify on pvp
    if (GetSpellModOwner() && victim && victim->GetSpellModOwner())
    {
        float l_PvpCoeff = GetSpellModOwner()->GetDiminishingPVPDamage(spellProto);
        if (p_DamageStreamLog && l_PvpCoeff != 0.0f)
            *p_DamageStreamLog << " GetDiminishingPVPDamage (" << l_PvpCoeff << ")" << std::endl;

        AddPct(DoneTotalMod, l_PvpCoeff);
    }

    if (GetSpellModOwner())
    {
        float l_VersabilityDamageDonePct = GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_DONE) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT);
        if (p_DamageStreamLog && l_VersabilityDamageDonePct != 0.0f)
            *p_DamageStreamLog << " CR_VERSATILITY_DAMAGE_DONE/SPELL_AURA_MOD_VERSATILITY_PCT (" << l_VersabilityDamageDonePct << ")" << std::endl;
        AddPct(DoneTotalMod, l_VersabilityDamageDonePct);
    }

    // Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
    if (spellProto)
    {
        float l_ModDamageDoneForMechanic = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC, spellProto->Mechanic);
        if (p_DamageStreamLog && l_ModDamageDoneForMechanic != 0.0f)
            *p_DamageStreamLog << " SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC (" << l_ModDamageDoneForMechanic << ")" << std::endl;
        AddPct(DoneTotalMod, l_ModDamageDoneForMechanic);
    }

    // done scripted mod (take it from owner)
    Unit* owner = GetOwner() ? GetOwner() : this; ///< owner is never read 01/18/16

    float tmpDamage = float(int32(pdamage) + DoneFlatBenefit) * DoneTotalMod;
    float preTmpDamage = tmpDamage;

    // apply spellmod to Done damage
    if (spellProto && victim)
    {
        if (Player* modOwner = GetSpellModOwner())
            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage, p_Spell, true, p_DamageStreamLog);

        CalculateFromDummy(victim, tmpDamage, spellProto, effectMask);
    }

    if (spellProto)
        LOG_SPELL(this, spellProto->Id, "MeeleDamageBonusDone(): Spell %s: ((%i + %i (DoneFlatBenefit)) * %f (DoneTotalMod)) = %f + %f (Mods) = %f", spellProto->GetNameForLogging().c_str(), pdamage, DoneFlatBenefit, DoneTotalMod, preTmpDamage, tmpDamage - preTmpDamage, tmpDamage); ///< ISO C++11 does not allow conversion from string literal to 'char *'

    // bonus result can be negative
    return uint32(std::max(tmpDamage, 0.0f));
}

uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto, std::ostringstream* p_LogDamageStream)
{
    if (pdamage == 0)
        return 0;

    int32 TakenFlatBenefit = 0;
    float TakenTotalCasterMod = 0.0f;

    // get all auras from caster that allow the spell to ignore resistance
    SpellSchoolMask attackSchoolMask = spellProto ? spellProto->GetSchoolMask() : SPELL_SCHOOL_MASK_NORMAL;
/*
    AuraEffectList const& IgnoreResistAuras = attacker->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
    for (AuraEffectList::const_iterator i = IgnoreResistAuras.begin(); i != IgnoreResistAuras.end(); ++i)
    {
        if ((*i)->GetMiscValue() & attackSchoolMask)
            TakenTotalCasterMod += (float((*i)->GetAmount()));
    }*/

    // ..taken
    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
    {
        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
        {
            if (p_LogDamageStream)
                *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_TAKEN (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            TakenFlatBenefit += (*i)->GetAmount();
        }
    }

    if (attType != WeaponAttackType::RangedAttack)
    {
        float l_ModMeleeDamageTaken = GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
        if (p_LogDamageStream)
            *p_LogDamageStream << " SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN (" << l_ModMeleeDamageTaken << ")" << std::endl;
        TakenFlatBenefit += l_ModMeleeDamageTaken;
    }
    else
    {
        float l_ModMeleeDamageTaken = GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
        if (p_LogDamageStream)
            *p_LogDamageStream << " SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN (" << l_ModMeleeDamageTaken << ")" << std::endl;
        TakenFlatBenefit += GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
    }

    // Taken total percent damage auras
    float TakenTotalMod = 1.0f;

    // ..taken
    float l_ModDamagePercentTaken = GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto ? spellProto->GetSchoolMask() : GetMeleeDamageSchoolMask());
    if (p_LogDamageStream && l_ModDamagePercentTaken != 0.0f)
        *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN (" << l_ModDamagePercentTaken << ")" << std::endl;

    TakenTotalMod *= l_ModDamagePercentTaken;

    // From caster damages
    AuraEffectList const& mOwnerTakenSencond = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK);
    for (AuraEffectList::const_iterator i = mOwnerTakenSencond.begin(); i != mOwnerTakenSencond.end(); ++i)
    {
        if ((*i)->GetCasterGUID() == attacker->GetGUID() && ((*i)->GetMiscValue() & (int32)attackSchoolMask))
        {
            if (spellProto && spellProto->Id != 215537) ///< Benefiting to all dmg spells except Trauma
            {
                if (p_LogDamageStream)
                *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
            }
        }
    }

    // .. taken pct (special attacks)
    if (spellProto)
    {
        // From caster spells
        AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
        for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
        {
            if ((*i)->GetCasterGUID() == attacker->GetGUID())
            {
                switch ((*i)->GetId())
                {
                    /// Vendetta, should affect to all damage
                case 79140:
                    if (p_LogDamageStream)
                        *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                    TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
                    break;
                    /// Executioner's Precision must multiply
                case 242188:
                    if ((*i)->IsAffectingSpell(spellProto))
                    {
                        if (p_LogDamageStream)
                            *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                        TakenTotalMod *= (1.0 + ((*i)->GetAmount() / 100.0));
                    }
                    break;
                case 192425: ///< Surge of Toxins
                    if ((*i)->IsAffectingSpell(spellProto) ||
                        spellProto->Id == 222062 || ///< Kingsbane (main)
                        spellProto->Id == 192760)   ///< Kingsbane (off)
                    {
                        if (p_LogDamageStream)
                            *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER(" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                        TakenTotalMod += CalculatePct(1.0f, (*i)->GetAmount());
                    }
                    break;
                default:
                    if ((*i)->IsAffectingSpell(spellProto))
                    {
                        if (p_LogDamageStream)
                            *p_LogDamageStream << " SPELL_AURA_MOD_DAMAGE_FROM_CASTER (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                        TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
                    }
                    break;
                }
            }
        }

        // Mod damage from spell mechanic
        uint64 mechanicMask = spellProto->GetAllEffectsMechanicMask();

        // Shred, Maul - "Effects which increase Bleed damage also increase Shred damage"
        if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[0] & 0x00008800)
            mechanicMask |= (1LL << MECHANIC_BLEED);

        if (mechanicMask)
        {
            AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
            for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
            {
                if (mechanicMask & (1LL << ((*i)->GetMiscValue())))
                {
                    if (p_LogDamageStream)
                        *p_LogDamageStream << " SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                    TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
                }
            }
        }
    }
    else
    {
        AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_AUTOATTACK_DAMAGE_TARGET);
        for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
        {
            if ((*i)->GetCaster() == attacker)
            {
                if (p_LogDamageStream)
                    *p_LogDamageStream << " SPELL_AURA_MOD_AUTOATTACK_DAMAGE_TARGET (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
                TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
            }
        }
        if (ToPlayer() && ToPlayer()->GetActiveSpecializationID() == SPEC_PALADIN_PROTECTION && attacker->HasAura(204301, GetGUID()))
        {
            if (AuraEffect* l_AuraEffect = attacker->GetAuraEffect(204301, EFFECT_1, GetGUID()))
            {
                if (p_LogDamageStream)
                    *p_LogDamageStream << " Aura 204301 (" << (l_AuraEffect)->GetId() << "," << (l_AuraEffect)->GetAmount() << ")" << std::endl;
                TakenTotalMod -= CalculatePct(1.0, l_AuraEffect->GetAmount());
                l_AuraEffect->GetBase()->Remove();
            }
        }
    }

    if (attType != WeaponAttackType::RangedAttack)
    {
        AuraEffectList const& mModMeleeDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
        for (AuraEffectList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
        {
            if (p_LogDamageStream)
                *p_LogDamageStream << " SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
        }
    }
    else
    {
        AuraEffectList const& mModRangedDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
        for (AuraEffectList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
        {
            if (p_LogDamageStream)
                *p_LogDamageStream << " SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT (" << (*i)->GetId() << "," << (*i)->GetAmount() << ")" << std::endl;
            TakenTotalMod += CalculatePct(1.0, (*i)->GetAmount());
        }
    }

    if (spellProto && spellProto->IsTargetingArea())
    {
        int32 mult = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE, spellProto->SchoolMask);
        TakenTotalMod += CalculatePct(1.0, mult);
        if (attacker->GetTypeId() != TYPEID_PLAYER)
        {
            int32 u_mult = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE, spellProto->SchoolMask);
            if (u_mult != 0)
            {
                if (p_LogDamageStream)
                    *p_LogDamageStream << " SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE (" << u_mult << ")" << std::endl;
            }
            TakenTotalMod += CalculatePct(1.0, u_mult);
        }
    }

    /// Apply Versatility damage bonus taken
    if (GetSpellModOwner())
    {
        float l_ModVersatility = GetSpellModOwner()->GetRatingBonusValue(CR_VERSATILITY_DAMAGE_TAKEN) + GetSpellModOwner()->GetTotalAuraModifier(SPELL_AURA_MOD_VERSATILITY_PCT);
        if (l_ModVersatility != 0.0f && p_LogDamageStream)
            *p_LogDamageStream << " CR_VERSATILITY_DAMAGE_TAKEN/SPELL_AURA_MOD_VERSATILITY_PCT " << l_ModVersatility << std::endl;
        TakenTotalMod -= CalculatePct(TakenTotalMod, l_ModVersatility);
    }

    float tmpDamage = 0.0f;
    if (TakenTotalCasterMod)
    {
        if (TakenFlatBenefit < 0)
        {
            if (TakenTotalMod < 1)
                tmpDamage = ((float(CalculatePct(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) * TakenTotalMod) + CalculatePct(pdamage, TakenTotalCasterMod));
            else
                tmpDamage = ((float(CalculatePct(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) + CalculatePct(pdamage, TakenTotalCasterMod)) * TakenTotalMod);
        }
        else if (TakenTotalMod < 1)
            tmpDamage = ((CalculatePct(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod) * TakenTotalMod) + CalculatePct(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod));
    }
    if (!tmpDamage)
        tmpDamage = (float(pdamage) + TakenFlatBenefit) * TakenTotalMod;

    // bonus result can be negative
    return uint32(std::max(tmpDamage, 0.0f));
}

void Unit::ApplyUberImmune(uint32 spellid, bool apply)
{
    if (apply)
        RemoveAurasWithMechanic(IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK, AURA_REMOVE_BY_DEFAULT, spellid);
    for (uint32 mech=MECHANIC_CHARM; mech!=MECHANIC_ENRAGED; ++mech)
    {
        if (mech == MECHANIC_DISARM)
            continue;
        if (1<<mech & IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK)
            ApplySpellImmune(spellid, IMMUNITY_MECHANIC, mech, apply);
    }
}

void Unit::ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply)
{
    if (apply)
    {
        /// Don't apply multiple instances of global immunities (not linked with a spell or aura)
        if (!spellId)
        {
            for (SpellImmuneContainer::const_iterator l_Iter = m_spellImmune[op].begin(); l_Iter != m_spellImmune[op].end(); ++l_Iter)
            {
                if (l_Iter->first == type && l_Iter->second == spellId)
                    return;
            }
        }

        m_spellImmune[op].emplace(type, spellId);
    }
    else
    {
        for (SpellImmuneContainer::const_iterator l_Iter = m_spellImmune[op].begin(); l_Iter != m_spellImmune[op].end(); ++l_Iter)
        {
            if (l_Iter->first == type && l_Iter->second == spellId)
            {
                m_spellImmune[op].erase(l_Iter);
                break;
            }
        }
    }
}

void Unit::ApplySpellDispelImmunity(const SpellInfo* spellProto, DispelType type, bool apply)
{
    ApplySpellImmune(spellProto->Id, IMMUNITY_DISPEL, type, apply);

    if (apply && spellProto->AttributesEx & SPELL_ATTR1_DISPEL_AURAS_ON_IMMUNITY)
    {
        // Create dispel mask by dispel type
        uint32 dispelMask = SpellInfo::GetDispelMask(type);
        // Dispel all existing auras vs current dispel type
        AuraApplicationMap& auras = GetAppliedAuras();
        for (AuraApplicationMap::iterator itr = auras.begin(); itr != auras.end();)
        {
            SpellInfo const* spell = itr->second->GetBase()->GetSpellInfo();
            if (spell->GetDispelMask() & dispelMask)
            {
                // Dispel aura
                RemoveAura(itr);
            }
            else
                ++itr;
        }
    }
}

float Unit::GetWeaponProcChance() const
{
    // normalized proc chance for weapon attack speed
    // (odd formula...)
    if (isAttackReady(WeaponAttackType::BaseAttack))
        return (GetAttackTime(WeaponAttackType::BaseAttack) * 1.8f / 1000.0f);
    else if (haveOffhandWeapon() && isAttackReady(WeaponAttackType::OffAttack))
        return (GetAttackTime(WeaponAttackType::OffAttack) * 1.6f / 1000.0f);
    return 0;
}

float Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellInfo* spellProto) const
{
    // proc per minute chance calculation
    if (PPM <= 0)
        return 0.0f;

    return (WeaponSpeed * PPM) / 600.0f;   // result is chance in percents (probability = Speed_in_sec * (PPM / 60))
}

void Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)
{
    if (mount)
        SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, mount);

    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);

    if (Player* player = ToPlayer())
    {
        if (player->GetEmoteState())
            player->SetEmoteState(0);

        player->SetFallInformation(0, GetPositionZ());

        // mount as a vehicle
        if (VehicleId)
        {
            if (CreateVehicleKit(VehicleId, creatureEntry))
            {
                GetVehicleKit()->Reset();

                WorldPacket l_Data(SMSG_MOVE_SET_VEHICLE_REC_ID, 16 + 2 + 4 + 4);
                l_Data.appendPackGUID(GetGUID());   ///< MoverGUID
                l_Data << uint32(m_movementCounter++);  ///< SequenceIndex
                l_Data << uint32(VehicleId);        ///< VehicleRecID
                SendMessageToSet(&l_Data, true);

                // Send others that we now have a vehicle
                l_Data.Initialize(SMSG_SET_VEHICLE_REC_ID, 16 + 2 + 4);
                l_Data.appendPackGUID(GetGUID());
                l_Data << uint32(VehicleId);
                ToPlayer()->GetSession()->SendPacket(&l_Data);

                // mounts can also have accessories
                GetVehicleKit()->InstallAllAccessories(false);
            }
        }

        // Remove subterfuge just after cast
        player->RemoveAura(115192);

        // don't unsummon pet but SetFlag UNIT_FLAG_STUNNED to disable pet's interface
        if (Pet* pet = player->GetPet())
            pet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);

        player->UnsummonCurrentBattlePetIfAny(true);
        player->SendMovementSetCollisionHeight(player->GetCollisionHeight(true));

        if ((mount == 19296 || mount == 19085 || mount == 31367 || mount == 31368 || mount == 8469 || mount == 14548 || mount == 30366 || mount == 30501 || mount == 28919) && player->HasAura(57958)) // TODO: we need to create a new trigger flag - on mount, to handle it properly
            player->AddAura(20217, player);

        ///< DH's Metamorphosis + mount
        if (player->HasAura(162264) || player->HasAura(187827))
            player->DeMorph();

        sScriptMgr->OnPlayerMount(player, creatureEntry);
    }

    ///< Divine Steed is not really a mount
    if (creatureEntry != 14565)
        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOUNT);
}

void Unit::Dismount()
{
    if (!IsMounted())
        return;

    SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, 0);
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);

    if (Player* thisPlayer = ToPlayer())
    {
        thisPlayer->SendMovementSetCollisionHeight(thisPlayer->GetCollisionHeight(false));
        thisPlayer->RemoveAurasDueToSpell(143314);
    }

    uint64 l_Guid = GetGUID();
    // Dismount as a vehicle
    if (IsPlayer() && GetVehicleKit())
    {
        // Remove vehicle from player
        RemoveVehicleKit(true);

        WorldPacket l_Data(SMSG_MOVE_SET_VEHICLE_REC_ID, 16 + 2 + 4 + 4);
        l_Data.appendPackGUID(l_Guid);
        l_Data << uint32(0);
        l_Data << uint32(0);
        ToPlayer()->SendMessageToSet(&l_Data, true);

        l_Data.Initialize(SMSG_SET_VEHICLE_REC_ID, 8 + 4);
        l_Data.appendPackGUID(l_Guid);
        l_Data << uint32(0);
        ToPlayer()->GetSession()->SendPacket(&l_Data);

        /// Switch to the right zone-map if needed
        if (GetMap() && GetMap()->GetEntry()->instanceType == InstanceTypes::MAP_COMMON)
        {
            ToPlayer()->AddMapTask(eTaskType::TaskSwitchToPhasedMap, [this]() -> void
            {
                ToPlayer()->SwitchToPhasedMap(GetMapId());
            });
        }
    }

    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);

    // only re summon old pet if the player is already added to a map
    // this prevents adding a pet to a not created map which would otherwise cause a crash
    // (it could probably happen when logging in after a previous crash)
    if (Player* player = ToPlayer())
    {
        player->SetFallInformation(0, GetPositionZ());

        if (Pet* pPet = player->GetPet())
        {
            if (pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->HasUnitState(UNIT_STATE_STUNNED))
                pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
        }
        else
        {
            player->ResummonPetTemporaryUnSummonedIfAny();
            player->SummonLastSummonedBattlePet();
        }

        ///< DH's Metamorphosis + mount
        if (player->HasAura(162264))
            player->SetDisplayId(68670);

        ///< DH's Metamorphosis + mount
        if (player->HasAura(187827))
            player->SetDisplayId(68671);

        sScriptMgr->OnPlayerDismount(player);
    }
}

MountCapabilityEntry const* Unit::GetMountCapability(uint32 mountType) const
{
    if (!mountType)
        return nullptr;

    MountTypeXCapabilitySet const* capabilities = GetMountCapabilities(mountType);
    if (!capabilities)
        return nullptr;

    uint32 l_ZoneId;
    uint32 l_AreaId;
    GetZoneAndAreaId(l_ZoneId, l_AreaId);

    uint32 l_RidingSkill = 5000;
    if (IsPlayer())
        l_RidingSkill = ToPlayer()->GetSkillValue(SKILL_RIDING);

    for (MountTypeXCapabilityEntry const* mountTypeXCapability : *capabilities)
    {
        MountCapabilityEntry const* l_MountCapability = sMountCapabilityStore.LookupEntry(mountTypeXCapability->CapabilityID);
        if (!l_MountCapability)
            continue;

        if (l_RidingSkill < l_MountCapability->RequiredRidingSkill)
            continue;

        if (HasExtraUnitMovementFlag(MOVEMENTFLAG2_FULL_SPEED_PITCHING))
        {
            if (!(l_MountCapability->Flags & MOUNT_FLAG_CAN_PITCH))
                continue;
        }
        else if (HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
        {
            if (!(l_MountCapability->Flags & MOUNT_FLAG_CAN_SWIM))
                continue;
        }

        if (l_MountCapability->RequiredMap != -1 && int32(GetMapId()) != l_MountCapability->RequiredMap)
        {
            bool l_ByPass = false;

            /// Blasted Lands, level 90
            if (l_MountCapability->RequiredMap == 1 && GetMapId() == 1190)
                l_ByPass = true;

            if (!l_ByPass)
                continue;
        }

        if (l_MountCapability->RequiredArea && (l_MountCapability->RequiredArea != l_ZoneId && l_MountCapability->RequiredArea != l_AreaId))
            continue;

        if (l_MountCapability->RequiredAura && !HasAura(l_MountCapability->RequiredAura))
            continue;

        if (l_MountCapability->RequiredSpell && (GetTypeId() != TYPEID_PLAYER || !ToPlayer()->HasSpell(l_MountCapability->RequiredSpell)))
            continue;

        bool l_Continue = false;
        SpellInfo const* l_Spell = sSpellMgr->GetSpellInfo(l_MountCapability->SpeedModSpell);
        if (l_Spell && IsPlayer() && sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE))
        {
            for (int l_I = 0; l_I < l_Spell->EffectCount; l_I++)
            {
                if (l_Spell->Effects[l_I].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
                {
                    uint32 l_ZoneId = GetZoneId();

                    switch (l_ZoneId)
                    {
                        case 1637:  ///< Orgrimmar
                        case 1519:  ///< Stormwind
                            l_Continue = true;
                            break;;
                        case 5287:
                            if (GetAreaId() == 1741 || GetAreaId() == 2177)
                                l_Continue = true;
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        if (l_Continue)
            continue;

        return l_MountCapability;
    }

    return nullptr;
}

void Unit::SendMountResult(MountResult p_Error)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data(SMSG_MOUNT_RESULT, 4);
    l_Data << uint32(p_Error);
    ToPlayer()->SendDirectMessage(&l_Data);
}

void Unit::SetInCombatWith(Unit* enemy)
{
    Unit* eOwner = enemy->GetCharmerOrOwnerOrSelf();
    if (eOwner->IsPvP() || (sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE) && GetAreaId() == 2177)) /// in gurubahi ring battle
    {
        SetInCombatState(true, enemy);
        return;
    }

    // check for duel
    if (eOwner->IsPlayer() && eOwner->ToPlayer()->m_Duel)
    {
        Unit const* myOwner = GetCharmerOrOwnerOrSelf();
        if (((Player const*)eOwner)->m_Duel->opponent == myOwner)
        {
            SetInCombatState(true, enemy);
            return;
        }
    }
    SetInCombatState(false, enemy);
}

void Unit::CombatStart(Unit* target, bool initialAggro)
{
    if (initialAggro)
    {
        if (!target->IsStandState())
            target->SetStandState(UNIT_STAND_STATE_STAND);

        if (!target->isInCombat() && target->GetTypeId() != TYPEID_PLAYER
            && !target->ToCreature()->HasReactState(REACT_PASSIVE) && target->ToCreature()->IsAIEnabled)
        {
            target->ToCreature()->AI()->AttackStart(this);
        }

        SetInCombatWith(target);
        target->SetInCombatWith(this);
    }
    Unit* who = target->GetCharmerOrOwnerOrSelf();
    if (who->IsPlayer())
      SetContestedPvP(who->ToPlayer());

    Player* me = GetCharmerOrOwnerPlayerOrPlayerItself();
    if (me && who->IsPvP()
        && (who->GetTypeId() != TYPEID_PLAYER
        || !me->m_Duel || me->m_Duel->opponent != who))
    {
        me->UpdatePvP(true);
        me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);
    }

    RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_ENTER_COMBAT);
}

void Unit::SetInCombatState(bool p_IsPVP, Unit* p_Enemy, bool p_IsControlled)
{
    /// Only alive units can be in combat
    if (!isAlive())
        return;

    m_LongSoulShardTimer = 0;
    m_ShortSoulShardTimer = 0;

    if (p_Enemy)
    {
        if (Creature* l_Creature = p_Enemy->ToCreature())
        {
            if (l_Creature->GetEntry() == 114832 || l_Creature->GetScriptName() == "npc_pvp_training_dummy") ///< Training dummy hack
                p_IsPVP = true;
        }
    }

    if (p_IsPVP)
    {
        if (Player* l_Player = ToPlayer())
        {
            l_Player->SetPvPTimer(15000); ///< 5 + 10 secs

            if (!l_Player->IsInPvPCombat())
                l_Player->SetInPvPCombat(true);
        }

        m_CombatTimer = 5000;
    }

    if (isInCombat() || HasUnitState(UNIT_STATE_EVADE))
        return;

    if (Creature* l_Creature = ToCreature())
    {
        if (IsAIEnabled && l_Creature->AI()->IsPassived())
            return;
    }

    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);

    if (p_IsControlled)
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);

    for (Unit::ControlList::iterator l_Iter = m_Controlled.begin(); l_Iter != m_Controlled.end(); ++l_Iter)
    {
        if ((*l_Iter) != nullptr)
            (*l_Iter)->SetInCombatState(p_IsPVP, p_Enemy, true);
    }

    RemoveAura(121308); ///< Glyph of Disguise, only out of combat

    if (Creature* l_Creature = ToCreature())
    {
        /// Set home position at place of engaging combat for escorted creatures
        if ((IsAIEnabled && l_Creature->AI()->IsEscorted()) ||
            (GetMotionMaster() && (GetMotionMaster()->GetCurrentMovementGeneratorType() == WAYPOINT_MOTION_TYPE ||
            GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)))
            l_Creature->SetHomePosition(GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());

        if (p_Enemy)
        {
            p_Enemy->RemoveAura(121308); ///< Glyph of Disguise, only out of combat

            if (IsAIEnabled)
            {
                /// Clear emote state / anim kit id before enter in combat
                if (l_Creature->GetUInt32Value(EUnitFields::UNIT_FIELD_EMOTE_STATE))
                {
                    l_Creature->SetUInt32Value(EUnitFields::UNIT_FIELD_EMOTE_STATE, 0);
                    ForceSendUpdate();
                }

                l_Creature->SetAIAnimKitId(0);

                if (l_Creature->GetUInt32Value(UNIT_FIELD_BYTES_1) && !l_Creature->CanFly())
                    l_Creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);

                l_Creature->AI()->EnterCombat(p_Enemy);

                if (l_Creature->isWorldBoss())
                {
                    if (InstanceScript* l_Instance = l_Creature->GetInstanceScript())
                    {
                        l_Instance->StartEncounter(l_Instance->GetEncounterIDForBoss(l_Creature), l_Creature);
                        l_Instance->SendEncounterUnit(EncounterFrameType::ENCOUNTER_FRAME_START, l_Creature->ToUnit());

                        l_Creature->SetEncounterStartTime(time(nullptr));
                        l_Creature->DumpGroup();
                    }
                }

                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); ///< Unit has engaged in combat, remove immunity so players can fight back
            }

            if (l_Creature->GetFormation() && l_Creature->GetEntry() != 116823)
                l_Creature->GetFormation()->MemberAttackStart(l_Creature, p_Enemy);

            if (m_zoneScript)
                m_zoneScript->EnterCombatForScript(l_Creature, p_Enemy);
        }

        if (isPet())
        {
            UpdateSpeed(MOVE_RUN, true);
            UpdateSpeed(MOVE_SWIM, true);
            UpdateSpeed(MOVE_FLIGHT, true);
        }

        if (!(l_Creature->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_MOUNTED_COMBAT_ALLOWED))
            Dismount();
    }
    else if (Player* l_Player = ToPlayer())
        sScriptMgr->OnPlayerEnterInCombat(l_Player);

    if (IsPlayer() && !ToPlayer()->IsInWorgenForm() && ToPlayer()->CanSwitch())
        ToPlayer()->SwitchToWorgenForm();
}

void Unit::ClearInCombat()
{
    m_CombatTimer = 0;
    m_LongSoulShardTimer = 0;
    m_ShortSoulShardTimer = 0;
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
    SetLastAbilityID(0);

    // Reset rune flags after combat
    if (GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_DEATH_KNIGHT)
    {
        for (uint8 i = 0; i < MAX_RUNES; ++i)
        {
            ToPlayer()->SetRuneTimer(i, 0xFFFFFFFF);
            ToPlayer()->SetLastRuneGraceTimer(i, 0);
        }
    }

    // Player's state will be cleared in Player::UpdateContestedPvP
    if (Creature* creature = ToCreature())
    {
        if (creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->UnitFlags1 & UNIT_FLAG_IMMUNE_TO_PC)
            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // set immunity state to the one from db on evade

        ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
        if (HasFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))
            SetUInt32Value(OBJECT_FIELD_DYNAMIC_FLAGS, creature->GetCreatureTemplate()->dynamicflags);

        if (creature->isPet() && !creature->isHunterPet()) ///< fix a problem with hunter pets , that their speed is wrong
        {
            if (Unit* owner = GetOwner())
                for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
                    if (owner->GetSpeedRate(UnitMoveType(i)) > GetSpeedRate(UnitMoveType(i)))
                        SetSpeed(UnitMoveType(i), owner->GetSpeedRate(UnitMoveType(i)), true);
        }
        else if (!isCharmed())
            return;
    }
    else
    {
        if (Player* l_Player = ToPlayer())
        {
            l_Player->UpdatePotionCooldown();
            sScriptMgr->OnPlayerLeaveCombat(l_Player);
        }
    }

    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LEAVE_COMBAT);
}

bool Unit::isTargetableForAttack(bool checkFakeDeath) const
{
    if (!isAlive())
        return false;

    if (HasFlag(UNIT_FIELD_FLAGS,
        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC) && GetEntry() != 62983)
        return false;

    if (IsPlayer() && ToPlayer()->isGameMaster())
        return false;

    return !HasUnitState(UNIT_STATE_UNATTACKABLE) && (!checkFakeDeath || !HasUnitState(UNIT_STATE_DIED));
}

bool Unit::IsValidAttackTarget(Unit const* target) const
{
    return _IsValidAttackTarget(target, NULL);
}

// function based on function Unit::CanAttack from 13850 client
bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, WorldObject const* obj /*= nullptr*/, bool p_CanHitInvisible /*= false*/) const
{
    /// Pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to false
    if (target == nullptr)
        return false;

    bool areaSpell = false;
    if (bySpell)
        areaSpell = bySpell->IsAffectingArea();

    // can't attack self
    if (this == target)
        return false;

    // Sha of anger mind control and Maddening Shout and Soul Effigy
    if (target->HasAura(119626) || target->HasAura(117708) || target->GetEntry() == 103679)
        return true;

    /// Prismatic Crystal should be attackable only by summoner
    if (target->GetEntry() == 76933 && target->ToTempSummon() && target->ToTempSummon()->GetSummoner() && target->ToTempSummon()->GetSummoner()->GetGUID() != GetGUID())
        return false;

    // Blingtron 4000 and Blingtron 5000
    if (GetEntry() == 77789 && (target->GetEntry() == 43929 || target->GetEntry() == 77789))
        return true;

    // can't attack unattackable units or GMs
    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
        || (target->IsPlayer() && target->ToPlayer()->isGameMaster()))
        return false;

    // can't attack own vehicle or passenger
    if (m_vehicle)
    {
        if (IsOnVehicle(target) || (m_vehicle->GetBase() && m_vehicle->GetBase()->IsOnVehicle(target)))
        {
            /// Allow players to attack their own vehicle if it is hostile to them
            if (!IsHostileTo(target))
                return false;
        }
    }

    if (!p_CanHitInvisible)
    {
        // can't attack invisible (ignore stealth for aoe spells) also if the area being looked at is from a spell use the dynamic object created instead of the casting unit.
        if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && (obj ? !obj->canSeeOrDetect(target, areaSpell, false, areaSpell) : !canSeeOrDetect(target, areaSpell, false, areaSpell)))
            return false;
    }

    /// Can't attack unselectable units with non AoE spells
    if (!areaSpell && target->HasFlag(EUnitFields::UNIT_FIELD_FLAGS_2, eUnitFlags2::UNIT_FLAG2_SELECTION_DISABLED))
        return false;

    // can't attack dead
    if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())
        return false;

    // can't attack untargetable
    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))
        && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE) && target->GetEntry() != 62983)
        return false;

    if (Player const* playerAttacker = ToPlayer())
    {
        if (playerAttacker->HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_UBER))
            return false;
    }

    // check flags
    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)
        || (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
        || (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC)))
        return false;

    if ((!bySpell || !(bySpell->AttributesEx8 & SPELL_ATTR8_ATTACK_IGNORE_IMMUNE_TO_PC_FLAG))
        && (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
        // check if this is a world trigger cast - GOs are using world triggers to cast their spells, so we need to ignore their immunity flag here, this is a temp workaround, needs removal when go cast is implemented properly
        && GetEntry() != WORLD_TRIGGER)
        return false;

    // CvC case - can attack each other only when one of them is hostile
    if (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
        return GetReactionTo(target) <= REP_HOSTILE || target->GetReactionTo(this) <= REP_HOSTILE;

    // PvP, PvC, CvP case
    // can't attack friendly targets
    if (GetReactionTo(target) > REP_NEUTRAL
        || target->GetReactionTo(this) > REP_NEUTRAL)
        return false;

    // Not all neutral creatures can be attacked
    if (GetReactionTo(target) == REP_NEUTRAL &&
        target->GetReactionTo(this) == REP_NEUTRAL)
    {
        if (!(target->IsPlayer() && IsPlayer()) &&
            !(target->GetTypeId() == TYPEID_UNIT && GetTypeId() == TYPEID_UNIT))
        {
            Player const* player = target->IsPlayer() ? target->ToPlayer() : ToPlayer();
            Unit const* creature = target->GetTypeId() == TYPEID_UNIT ? target : this;
            {
                if (FactionTemplateEntry const* factionTemplate = creature->getFactionTemplateEntry())
                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplate->Faction))
                        if (FactionState const* repState = player->GetReputationMgr().GetState(factionEntry))
                            if (!(repState->Flags & FACTION_FLAG_AT_WAR))
                                return false;
            }
        }
    }

    Creature const* creatureAttacker = ToCreature();
    if (creatureAttacker && creatureAttacker->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT)
        return false;

    Player const* playerAffectingAttacker = HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? GetAffectingPlayer() : NULL;
    Player const* playerAffectingTarget = target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? target->GetAffectingPlayer() : NULL;

    // check duel - before sanctuary checks
    if (playerAffectingAttacker && playerAffectingTarget)
        if (playerAffectingAttacker->m_Duel && playerAffectingAttacker->m_Duel->opponent == playerAffectingTarget && playerAffectingAttacker->m_Duel->startTime != 0)
            return true;

    // PvP case - can't attack when attacker or target are in sanctuary
    // however, 13850 client doesn't allow to attack when one of the unit's has sanctuary flag and is pvp
    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)
        && ((target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_SANCTUARY) || (GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_SANCTUARY)))
        return false;

    // additional checks - only PvP case
    if (playerAffectingAttacker && playerAffectingTarget)
    {
        if (target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_PVP
            && GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_PVP)
            return true;

        if (GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP
            && target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
            return true;

        return (GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_UNK1)
            || (target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_UNK1);
    }

    // Check if the Unit can be attacked by Players
    if (IsAIEnabled)
        return GetAI()->CanBeSelectedAsTarget(target, bySpell);

    // Check if the target can attack the target
    if (target->IsAIEnabled && IsPlayer())
        return target->GetAI()->CanBeAttacked(this, bySpell);

    return true;
}

bool Unit::IsValidAssistTarget(Unit const* target) const
{
    return _IsValidAssistTarget(target, NULL);
}

// function based on function Unit::CanAssist from 13850 client
bool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell, bool duelFlag) const
{
    ASSERT(target);

    // can assist to self
    if (this == target)
        return true;

    /// on duel, the healing spells should not proc on other target than caster
    if (duelFlag && GetSpellModOwner() && GetSpellModOwner()->m_Duel)
    {
        if (target->GetSpellModOwner() == nullptr)
            return false;

        if (GetSpellModOwner()->GetGUID() != target->GetSpellModOwner()->GetGUID())
            return false;
    }

    // can't assist unattackable units or GMs
    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
        || (target->IsPlayer() && target->ToPlayer()->isGameMaster()))
        return false;

    // can't assist own vehicle or passenger
    if (m_vehicle)
        if (IsOnVehicle(target) || (m_vehicle->GetBase() && m_vehicle->GetBase()->IsOnVehicle(target)))
            return false;

    // can't assist invisible
    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()))
        return false;

    // can't assist dead
    if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())
       return false;

    // can't assist untargetable
    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))
        && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
        return false;

    if (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_ASSIST_IGNORE_IMMUNE_FLAG))
    {
        if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
        {
            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
                return false;
        }
        else
        {
            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
                return false;
        }
    }

    // can't assist non-friendly targets
    if (GetReactionTo(target) < REP_NEUTRAL
        && target->GetReactionTo(this) < REP_NEUTRAL
        && (!ToCreature() || !(ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT)))
        return false;

    // PvP case
    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
    {
        Player const* targetPlayerOwner = target->GetAffectingPlayer();
        if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
        {
            Player const* selfPlayerOwner = GetAffectingPlayer();
            if (selfPlayerOwner && targetPlayerOwner)
            {
                // can't assist player which is dueling someone
                if (selfPlayerOwner != targetPlayerOwner
                    && targetPlayerOwner->m_Duel)
                    return false;
            }
            // can't assist player in ffa_pvp zone from outside
            if ((target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
                && !(GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_FFA_PVP))
                return false;
            // can't assist player out of sanctuary from sanctuary if has pvp enabled
            if (target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_PVP)
                if ((GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_SANCTUARY) && !(target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_SANCTUARY))
                    return false;
        }
    }
    // PvC case - player can assist creature only if has specific type flags
    // !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) &&
    else if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)
        && (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_ASSIST_IGNORE_IMMUNE_FLAG))
        && !((target->GetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1) & UNIT_BYTE2_FLAG_PVP)))
    {
        if (Creature const* creatureTarget = target->ToCreature())
            return creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT || creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_CAN_ASSIST;
    }
    return true;
}

int64 Unit::ModifyHealth(int64 dVal, Unit* victim)
{
    int64 gain = 0;

    if (dVal == 0)
        return 0;

    // Part of Evade mechanics. Only track health lost, not gained
    if (dVal < 0 && !IsPlayer() && !isPet())
        SetLastDamagedTime(time(NULL));

    int64 curHealth = (int64)GetHealth(victim);
    float l_CurHealthPct = GetHealthPct();

    int64 val = dVal + curHealth;
    if (val <= 0)
    {
        SetHealth(0);
        return -curHealth;
    }

    int64 maxHealth = (int64)GetMaxHealth(victim);

    if (val < maxHealth)
    {
        SetHealthScal(val, victim);
        gain = val - curHealth;
    }
    else if (curHealth != maxHealth)
    {
        SetHealthScal(maxHealth, victim);
        gain = maxHealth - curHealth;
    }

    std::vector<uint32> l_SpellTriggers;
    std::vector<std::pair<uint32 /*spellId*/, uint64 /*itemGuid*/> > l_SpellTriggersWithItems;

    AuraEffectList const& l_AuraTriggerPct = GetAuraEffectsByType(AuraType::SPELL_AURA_TRIGGER_AT_HEALTH_PCT);
    for (AuraEffect* l_AuraEffect : l_AuraTriggerPct)
    {
        uint32 l_AuraId = l_AuraEffect->GetBase()->GetId();
        uint32 l_TriggerSpell = l_AuraEffect->GetTriggerSpell();
        int32 l_AuraAmount = l_AuraEffect->GetAmount();

        ///Spells needs proc above pct and not under
        switch (l_AuraId)
        {
            case 211903: ///< Faiths Armor
            case 237187: ///< Fel Corruption (End of the Risen Threat)
            {
                if ((int32)l_CurHealthPct < l_AuraAmount &&
                    (int32)GetHealthPct() >= l_AuraAmount)
                    l_SpellTriggers.push_back(l_TriggerSpell);
                break;
            }
            case 218567:
            {
                if (l_AuraEffect->GetEffIndex() == EFFECT_1)
                {
                    if ((int32)l_CurHealthPct < l_AuraAmount &&
                        (int32)GetHealthPct() >= l_AuraAmount)
                        l_SpellTriggers.push_back(l_TriggerSpell);
                }
                else
                {
                    if ((int32)l_CurHealthPct > l_AuraAmount &&
                        (int32)GetHealthPct() <= l_AuraAmount)
                        l_SpellTriggers.push_back(l_TriggerSpell);
                }
                break;
            }
            default:
                if ((int32)l_CurHealthPct > l_AuraAmount &&
                    (int32)GetHealthPct() <= l_AuraAmount)
                {
                    if (l_AuraId == 214622) ///< Warlord's Fortitude
                    {
                        if (HasAura(214648)) ///< Warlord's Exhaustion
                            break;

                        l_SpellTriggersWithItems.push_back({ l_TriggerSpell, l_AuraEffect->GetBase()->GetCastItemGUID() });
                    }
                    else
                        l_SpellTriggers.push_back(l_TriggerSpell);
                }
                break;
        }
    }

    for (uint32 l_SpellId : l_SpellTriggers)
        CastSpell(this, l_SpellId, false);

    for (auto l_SpellWithItem : l_SpellTriggersWithItems)
    {
        Player* l_Player = ToPlayer();
        if (l_Player)
        {
            if (Item* l_Item = l_Player->GetItemByGuid(l_SpellWithItem.second))
            {
                CastSpell(this, l_SpellWithItem.first, true, l_Item);
            }
        }
    }

    return gain;
}

int64 Unit::GetHealthGain(int64 dVal)
{
    int64 gain = 0;

    if (dVal == 0)
        return 0;

    int64 curHealth = (int64)GetHealth();

    int64 val = dVal + curHealth;
    if (val <= 0)
        return -curHealth;

    int64 maxHealth = (int64)GetMaxHealth();

    if (val < maxHealth)
        gain = dVal;
    else if (curHealth != maxHealth)
        gain = maxHealth - curHealth;

    return gain;
}

uint64 Unit::GetHealth(Unit* p_Victim) const
{
    Creature const* l_Creature = ToCreature();
    if (!p_Victim || !l_Creature)
        return GetHealth();

    CreatureTemplate const* l_Template = l_Creature->GetCreatureTemplate();
    if (!l_Template->ScaleLevelMin || !l_Template->ScaleLevelMax)
        return GetHealth();

    uint8 l_Level = getLevelForTarget(p_Victim);
    CreatureLevelStat const* l_ScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_Level);
    if (!l_ScaleStat)
        return GetHealth();

    uint8 l_MaxLevel = getLevel();
    CreatureLevelStat const* l_MaxScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_MaxLevel);
    if (!l_MaxScaleStat)
        return GetHealth();

    float l_ActualHealthModifier = float(GetMaxHealth()) / float(std::max(uint32(1), l_MaxScaleStat->healthMax));

    return CalculatePct(l_ScaleStat->healthMax, GetHealthPct()) * l_ActualHealthModifier;
}

uint64 Unit::GetMaxHealth(Unit* p_Victim) const
{
    Creature const* l_Creature = ToCreature();
    if (!p_Victim || !l_Creature)
        return GetMaxHealth();

    CreatureTemplate const* l_Template = l_Creature->GetCreatureTemplate();
    if (!l_Template->ScaleLevelMin || !l_Template->ScaleLevelMax)
        return GetMaxHealth();

    uint8 l_Level = getLevelForTarget(p_Victim);
    CreatureLevelStat const* l_ScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_Level);
    if (!l_ScaleStat)
        return GetMaxHealth();

    uint8 l_MaxLevel = getLevel();
    CreatureLevelStat const* l_MaxScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_MaxLevel);
    if (!l_MaxScaleStat)
        return GetMaxHealth();

    float l_ActualHealthModifier = float(GetMaxHealth()) / float(std::max((uint32)1, l_MaxScaleStat->healthMax));

    return l_ScaleStat->healthMax * l_ActualHealthModifier;
}

uint32 Unit::GetArmor(Unit* p_Victim) const
{
    Creature const* l_Creature = ToCreature();
    if (!p_Victim || !l_Creature)
        return GetArmor();

    CreatureTemplate const* l_Template = l_Creature->GetCreatureTemplate();
    if (!l_Template->ScaleLevelMin || !l_Template->ScaleLevelMax)
        return GetArmor();

    uint8 l_Level = getLevelForTarget(p_Victim);
    CreatureLevelStat const* l_ScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_Level);
    if (!l_ScaleStat)
        return GetArmor();

    uint8 l_MaxLevel = getLevel();
    CreatureLevelStat const* l_MaxScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_MaxLevel);
    if (!l_MaxScaleStat)
        return GetArmor();

    float l_ActualArmorModifier = float(GetArmor()) / float(std::max(uint32(1), l_MaxScaleStat->BaseArmor));

    return l_ScaleStat->BaseArmor * l_ActualArmorModifier;
}

void Unit::SetHealthScal(uint64 p_Value, Unit* p_Victim)
{
    Creature const* l_Creature = ToCreature();
    if (!p_Victim || !l_Creature)
    {
        SetHealth(p_Value);
        return;
    }

    CreatureTemplate const* l_Template = l_Creature->GetCreatureTemplate();
    if (!l_Template->ScaleLevelMin || !l_Template->ScaleLevelMax)
    {
        SetHealth(p_Value);
        return;
    }

    CreatureLevelStat const* l_ScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(getLevelForTarget(p_Victim));
    if (!l_ScaleStat)
    {
        SetHealth(p_Value);
        return;
    }

    uint8 l_MaxLevel = getLevel();
    CreatureLevelStat const* l_MaxScaleStat = const_cast<Creature*>(l_Creature)->GetScaleLevelStat(l_MaxLevel);
    if (!l_MaxScaleStat)
    {
        SetHealth(p_Value);
        return;
    }

    float l_ActualHealthModifier = float(GetMaxHealth()) / float(std::max(uint32(1), l_MaxScaleStat->baseHP));

    SetHealth(CalculatePct(GetMaxHealth(), 100.0f * p_Value / (l_ScaleStat->healthMax * l_ActualHealthModifier)));
}

// returns negative amount on power reduction
int32 Unit::ModifyPower(Powers power, int32 dVal)
{
    int32 gain = 0;

    if (dVal == 0 && power != POWER_ENERGY) // The client will always regen energy if we don't send him the actual value
        return 0;

    ///< Hack fix for Death From Above. Combo points shouldn't be consumed when Eviscerate or Run Through triggered from Death from Above
    if (power == POWER_COMBO_POINT && dVal < 0 && m_SpellHelper.GetBool(eSpellHelpers::BlockCPGain))
        return 0;

    // There are auras for POWER_INSANITY and POWER_RUNIC_POWER only now
    if (dVal > 0 && IsPlayer() && (power == POWER_INSANITY || power == POWER_RUNIC_POWER))
    {
        int32 l_AddPct = 0;
        AuraEffectList l_IncreasePowerRegenAuras = GetAuraEffectsByType(SPELL_AURA_MOD_POWER_GAIN_PCT);
        for (AuraEffect* l_AuraEffect : l_IncreasePowerRegenAuras)
            if (l_AuraEffect->GetSpellInfo()->Id != 248296)
                l_AddPct += l_AuraEffect->GetAmount();

        AddPct(dVal, l_AddPct);
    }

    int32 curPower = GetPower(power);

    int32 val = dVal + curPower;
    if (val <= GetMinPower(power))
    {
        SetPower(power, GetMinPower(power));
        /// Reset passive soul shard when one is used
        if (power == POWER_SOUL_SHARDS)
        {
            if (dVal == 10)
                m_LongSoulShardTimer = 0;
            if (dVal == -10)
                m_ShortSoulShardTimer = 0;
        }

        return -curPower;
    }

    int32 maxPower = GetMaxPower(power);

    if (val < maxPower)
    {
        SetPower(power, val);
        gain = val - curPower;
    }
    else if (curPower != maxPower)
    {
        SetPower(power, maxPower);
        gain = maxPower - curPower;
    }
    else if (power == Powers::POWER_ARCANE_CHARGES && IsPlayer() && val > maxPower) ///< Arcane Mage, when you gain a charge when already at max power, the T21 4P should be able to proc (aura ID: 251862)
        sScriptMgr->OnModifyPower(ToPlayer(), power, maxPower, maxPower, false, true);

    if (ToCreature() && ToCreature()->IsAIEnabled)
        ToCreature()->AI()->PowerModified(getPowerType(), GetPower(getPowerType()));

    return gain;
}

void Unit::AddComboPoints(int8 p_Count)
{
    if (!p_Count)
        return;

    /// Without combo points lost (duration checked in aura)
    RemoveAurasByType(AuraType::SPELL_AURA_RETAIN_COMBO_POINTS);
    ModifyPower(Powers::POWER_COMBO_POINT, p_Count);
}

void Unit::ClearComboPoints()
{
    /// Without combopoints lost (duration checked in aura)
    RemoveAurasByType(SPELL_AURA_RETAIN_COMBO_POINTS);
    SetPower(Powers::POWER_COMBO_POINT, 0);
}

// returns negative amount on power reduction
int32 Unit::ModifyPowerPct(Powers power, float pct, bool apply)
{
    float amount = (float)GetMaxPower(power);
    ApplyPercentModFloatVar(amount, pct, apply);

    return ModifyPower(power, (int32)amount - GetMaxPower(power));
}

bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
{
    if (WorldObject::IsAlwaysVisibleFor(seer))
        return true;

    // Always seen by owner
    if (uint64 guid = GetCharmerOrOwnerGUID())
        if (seer->GetGUID() == guid)
            return true;

    if (Player const* seerPlayer = seer->ToPlayer())
        if (Unit* owner =  GetOwner())
            if (Player* ownerPlayer = owner->ToPlayer())
                if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                    return true;

    return false;
}

bool Unit::IsAlwaysDetectableFor(WorldObject const* seer) const
{
    if (WorldObject::IsAlwaysDetectableFor(seer))
        return true;

    if (HasAuraTypeWithCaster(SPELL_AURA_MOD_STALKED, seer->GetGUID()))
        return true;

    return false;
}

void Unit::SetVisible(bool x)
{
    if (!x)
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_GAMEMASTER);
    else
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);

    UpdateObjectVisibility();
}

void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
{
    //if (this->ToPlayer())
    //    sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());

    float main_speed_mod  = 1.0f;
    float stack_bonus     = 1.0f;
    float non_stack_bonus = 1.0f;

    switch (mtype)
    {
        // Only apply debuffs
        case MOVE_FLIGHT_BACK:
        case MOVE_RUN_BACK:
        case MOVE_SWIM_BACK:
            break;
        case MOVE_WALK:
            return;
        case MOVE_RUN:
        {
            if (IsMounted()) // Use on mount auras
            {
                main_speed_mod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);
                non_stack_bonus = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK);
            }
            else
            {
                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SPEED);
                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_SPEED_ALWAYS);
                non_stack_bonus = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_SPEED_NOT_STACK);

            }
            break;
        }
        case MOVE_SWIM:
        {
            main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SWIM_SPEED);
            break;
        }
        case MOVE_FLIGHT:
        {
            if (GetTypeId() == TYPEID_UNIT && IsControlledByPlayer()) // not sure if good for pet
            {
                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);

                // for some spells this mod is applied on vehicle owner
                float owner_speed_mod = 0.0f;

                if (Unit* owner = GetCharmer())
                    owner_speed_mod = owner->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);

                main_speed_mod = std::max(main_speed_mod, owner_speed_mod);
            }
            else if (IsMounted())
            {
                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);
            }
            else             // Use not mount (shapeshift for example) auras (should stack)
                main_speed_mod  = GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED) + GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);

            non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK) / 100.0f;

            // Update speed for vehicle if available
            if (IsPlayer() && GetVehicle())
                GetVehicleBase()->UpdateSpeed(MOVE_FLIGHT, true);
            break;
        }
        default:
            return;
    }

    /// Now we ready for speed calculation
    float total_non_stack_bonus = main_speed_mod + non_stack_bonus;
    float speed = stack_bonus + (total_non_stack_bonus / 100);

    if (IsPlayer() && !IsMounted() && !IsTravelForm(ToPlayer()->GetShapeshiftForm()))
        speed += CalculatePct(speed, ToPlayer()->GetFloatValue(PLAYER_FIELD_SPEED));

    switch (mtype)
    {
        case MOVE_RUN:
        case MOVE_SWIM:
        case MOVE_FLIGHT:
        {
            // Set creature speed rate
            if (GetTypeId() == TYPEID_UNIT)
            {
                Unit* pOwner = GetCharmerOrOwner();
                if ((isPet() || isGuardian()) && !isInCombat() && pOwner) // Must check for owner or crash on "Tame Beast"
                {
                    // For every yard over 5, increase speed by 0.01
                    //  to help prevent pet from lagging behind and despawning
                    float dist = GetDistance(pOwner);
                    float base_rate = 1.00f; // base speed is 100% of owner speed

                    if (dist < 1.0f)
                        dist = 1.0f;

                    float mult = base_rate + (dist >= 1.0f ? std::min(0.5f, ((dist - 1.0f) * 0.05f)) : 0.0f);

                    speed *= pOwner->GetSpeedRate(mtype) * mult; // pets derive speed from owner when not in combat
                    speed *= 1.1f;  ///< increase the speed by 10% the base pet follow speed to prevent the pet lagging behind and despawning
                }
                else
                    speed *= ToCreature()->GetCreatureTemplate()->speed_run;    // at this point, MOVE_WALK is never reached
            }
            // Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need
            // TODO: possible affect only on MOVE_RUN
            if (int32 normalization = GetMaxPositiveAuraModifier(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED))
            {
                // Use speed from aura
                float max_speed = normalization / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
                if (speed > max_speed)
                    speed = max_speed;
            }
            break;
        }
        default:
            break;
    }

    /// In the case of Fel Rush (DH spell - 197922), SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED is supposed to override speed instead to act like a speed limitor according to blizz sniff
    /// That fix the fel rush distance
    if (auto l_FelRushSpeedEffect = GetAuraEffect(197922, EFFECT_4))
    {
        if (mtype == MOVE_RUN || mtype == MOVE_RUN_BACK || mtype == MOVE_WALK)
            speed = l_FelRushSpeedEffect->GetAmount() / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
    }

    // for creature case, we check explicit if mob searched for assistance
    if (GetTypeId() == TYPEID_UNIT)
    {
        if (ToCreature()->HasSearchedAssistance())
            speed *= 0.66f;                                 // best guessed value, so this will be 33% reduction. Based off initial speed, mob can then "run", "walk fast" or "walk".
    }

    // Apply strongest slow aura mod to speed
    int32 slow = GetMaxNegativeAuraModifier(SPELL_AURA_MOD_DECREASE_SPEED);

    ///< Roll, Chi Torpedo
    if (HasAura(115008) || HasAura(107427))
        slow = 0;

    if (slow)
        AddPct(speed, slow);

    if (float minSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MINIMUM_SPEED))
    {
        float min_speed = minSpeedMod / 100.0f;
        if (speed < min_speed && mtype != MOVE_SWIM)
            speed = min_speed;
    }

    if (mtype == MOVE_SWIM)
    {
        if (float minSwimSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_INCREASE_MIN_SWIM_SPEED))
        {
            float min_speed = minSwimSpeedMod / 100.0f;
            if (speed < min_speed)
                speed = min_speed;
        }
    }

    if (speed > roundf(speed * 100))
        speed += 0.01f;

    if (G3D::fuzzyNe(GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE), 0.0f))
        speed /= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);
    else
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE, 1.0f);

    SetSpeed(mtype, speed, forced);
}

void Unit::SetSpeed(UnitMoveType p_MovementType, float rate, bool forced)
{
    if (HasAura(191719)) ///< Gravitation Pull : reduce speed by 50%
        rate = AddPct(rate, -50);

    if (HasAura(212610)) ///< Walking Dead : unable to move faster than normal movement speed
        rate = 1.0f;

    if (fabs(rate) <= 0.00000023841858) // From client
        rate = 0.01f;

    // Update speed only on change
    if (m_speed_rate[p_MovementType] == rate)
        return;

    /// Walk speed can't be faster then run speed
    if (m_speed_rate[MOVE_WALK] > m_speed_rate[MOVE_RUN])
        m_speed_rate[MOVE_WALK] = m_speed_rate[MOVE_RUN];

    m_speed_rate[p_MovementType] = rate;

    propagateSpeedChange();

    // Don't build packets because we've got noone to send
    // them to except self, and self is not created at client.
    if (!IsInWorld())
        return;

    uint64 l_Guid = GetGUID();
    if (!forced && GetTypeId() != TYPEID_PLAYER)
    {
        WorldPacket l_Data;

        switch (p_MovementType)
        {
            case MOVE_WALK:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_WALK_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_RUN:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_RUN_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_RUN_BACK:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_RUN_BACK_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_SWIM:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_SWIM_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_SWIM_BACK:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_SWIM_BACK_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_TURN_RATE:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_TURN_RATE, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_FLIGHT:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_FLIGHT_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_FLIGHT_BACK:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_FLIGHT_BACK_SPEED, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_PITCH_RATE:
            {
                l_Data.Initialize(SMSG_SPLINE_MOVE_SET_PITCH_RATE, 16 + 2 + 4);
                l_Data.appendPackGUID(l_Guid);
                l_Data << float(GetSpeed(p_MovementType));
                break;
            }
            default:
                return;
        }

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        if (Player* l_Player = ToPlayer())
        {
            // register forced speed changes for WorldSession::HandleForceSpeedChangeAck
            // and do it only for real sent packets and use run for run/mounted as client expected
            ++l_Player->m_forced_speed_changes[p_MovementType];

            if (!isInCombat())
                for (std::set<Unit*>::iterator l_Itr = l_Player->m_Controlled.begin(); l_Itr != l_Player->m_Controlled.end(); ++l_Itr)
                {
                    (*l_Itr)->SetSpeed(p_MovementType, m_speed_rate[p_MovementType], forced);
                }
        }

        WorldPacket l_SelfPacket;

        switch (p_MovementType)
        {
            case MOVE_WALK:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_WALK_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_RUN:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_RUN_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_RUN_BACK:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_RUN_BACK_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_SWIM:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_SWIM_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_SWIM_BACK:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_SWIM_BACK_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_TURN_RATE:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_TURN_RATE, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_FLIGHT:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_FLIGHT_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_FLIGHT_BACK:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_FLIGHT_BACK_SPEED, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            case MOVE_PITCH_RATE:
            {
                l_SelfPacket.Initialize(SMSG_MOVE_SET_PITCH_RATE, 16 + 2 + 4 + 4);
                l_SelfPacket.appendPackGUID(GetGUID());
                l_SelfPacket << uint32(m_movementCounter++);
                l_SelfPacket << float(GetSpeed(p_MovementType));
                break;
            }
            default:
                return;
        }
        SendMessageToSet(&l_SelfPacket, true);
    }
}

void Unit::UpdateMovementForceSpeed()
{
    if (!IsPlayer())
        return;

    float l_Modifier = 1.0f;

    AuraEffectList const& l_ModSpeed = GetAuraEffectsByType(AuraType::SPELL_AURA_MOD_MOVEMENT_FORCE_SPEED);
    for (AuraEffectList::const_iterator l_Iter = l_ModSpeed.begin(); l_Iter != l_ModSpeed.end(); ++l_Iter)
        AddPct(l_Modifier, (*l_Iter)->GetAmount());

    /// Safety modifier for -100% auras
    if (l_Modifier < 0.01f)
        l_Modifier = 0.01f;

    WorldPacket l_Data(Opcodes::SMSG_MOVE_SET_MOVEMENT_FORCE_SPEED);
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(m_movementCounter++);
    l_Data << l_Modifier;
    SendMessageToSet(&l_Data, true);
}

void Unit::SendAdjustSplineDuration(float p_Scale)
{
    WorldPacket l_Data(Opcodes::SMSG_ADJUST_SPLINE_DURATION);
    l_Data.appendPackGUID(GetGUID());
    l_Data << float(p_Scale);
    SendMessageToSet(&l_Data, false);
}

void Unit::SendFlightSplineSync(float p_SplineDist)
{
    WorldPacket l_Data(Opcodes::SMSG_FLIGHT_SPLINE_SYNC);
    l_Data.appendPackGUID(GetGUID());
    l_Data << float(p_SplineDist);
    SendMessageToSet(&l_Data, false);
}

void Unit::setDeathState(DeathState s)
{
    /// Death state needs to be updated before RemoveAllAurasOnDeath() is called, to prevent entering combat
    m_deathState = s;

    if (s != ALIVE && s != JUST_RESPAWNED)
    {
        CombatStop();
        DeleteThreatList();
        getHostileRefManager().deleteReferences();

        if (IsNonMeleeSpellCasted(false))
            InterruptNonMeleeSpells(false);

        ExitVehicle();

        UnsummonAllTotems();
        RemoveAllControlled();
        RemoveAllAurasOnDeath();
    }

    if (s == JUST_DIED)
    {
        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
        ModifyAuraState(AURA_STATE_HEALTHLESS_25_PERCENT, false);
        // remove aurastates allowing special moves
        ClearAllReactives();
        ClearDiminishings();
        if (IsInWorld())
        {
            // Only clear MotionMaster for entities that exists in world
            // Avoids crashes in the following conditions :
            //  * Using 'call pet' on dead pets
            //  * Using 'call stabled pet'
            //  * Logging in with dead pets
            GetMotionMaster()->Clear(false);
            GetMotionMaster()->MoveIdle();
        }

        StopMoving();
        DisableSpline();
        // without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
        // do not why since in IncreaseMaxHealth currenthealth is checked
        SetHealth(0);
        SetPower(getPowerType(), 0);

        /// Clear emote state at death, prevent some wow error.
        SetUInt32Value(EUnitFields::UNIT_FIELD_EMOTE_STATE, 0);

        // Druid: Fungal Growth
        switch (GetEntry())
        {
            case 1964:
            case 47649:
                if (Unit* owner = GetOwner())
                {
                    if (owner->GetTypeId() != TYPEID_PLAYER
                        || owner->ToPlayer()->HasSpellCooldown(81291)
                        || owner->ToPlayer()->HasSpellCooldown(81283))
                        break;

                    uint32 spellId = 0;
                    if (owner->HasAura(78788))
                        spellId = 81291;
                    else if (owner->HasAura(78789))
                        spellId = 81283;

                    if (spellId)
                        owner->ToPlayer()->AddSpellCooldown(spellId, 0, sSpellMgr->GetSpellInfo(spellId)->RecoveryTime);
                }
                break;
        }

        // players in instance don't have ZoneScript, but they have InstanceScript
        if (ZoneScript* zoneScript = GetZoneScript() ? GetZoneScript() : (ZoneScript*)GetInstanceScript())
            zoneScript->OnUnitDeath(this);

    }
    else if (s == JUST_RESPAWNED)
        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE); // clear skinnable for creature and player (at battleground)

    /// Remove pvp bonuses from items, if we have it
    if (s == JUST_DIED && ToPlayer())
        ToPlayer()->RescaleAllItemsIfNeeded();
}

/*########################################
########                          ########
########       AGGRO SYSTEM       ########
########                          ########
########################################*/
bool Unit::CanHaveThreatList() const
{
    // only creatures can have threat list
    if (GetTypeId() != TYPEID_UNIT)
        return false;

    // only alive units can have threat list
    if (!isAlive() || isDying())
        return false;

    // totems can not have threat list
    if (ToCreature()->isTotem())
        return false;

    // vehicles can not have threat list
    //if (ToCreature()->IsVehicle())
    //    return false;

    // summons can not have a threat list, unless they are controlled by a creature
    if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
        return false;

    if (ToCreature()->IsAIEnabled && !ToCreature()->AI()->CanHaveThreatList())
        return false;

    return true;
}

//======================================================================

float Unit::ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask)
{
    if (!HasAuraType(SPELL_AURA_MOD_THREAT) || fThreat < 0)
        return fThreat;

    SpellSchools school = GetFirstSchoolInMask(schoolMask);

    return fThreat * m_threatModifier[school];
}

//======================================================================

void Unit::AddThreat(Unit* victim, float fThreat, SpellSchoolMask schoolMask, SpellInfo const* threatSpell)
{
    if (this->GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
        this->ToCreature()->AI()->OnAddThreat(victim, fThreat, schoolMask, threatSpell);

    if (victim && victim->IsPlayer())
    {
        Player* l_PlrVictim = victim->ToPlayer();
        if (l_PlrVictim->IsActiveSpecTankSpec())
            fThreat *= 2.0f;
        else
            fThreat *= 0.75f;
    }

    // Only mobs can manage threat lists
    if (CanHaveThreatList())
        m_ThreatManager.addThreat(victim, fThreat, schoolMask, threatSpell);
}

//======================================================================

void Unit::DeleteThreatList()
{
    if (CanHaveThreatList() && !m_ThreatManager.isThreatListEmpty())
        SendClearThreatListOpcode();
    m_ThreatManager.clearReferences();
    ClearSaveThreatTarget();
}

//======================================================================

void Unit::TauntApply(Unit* taunter)
{
    ASSERT(GetTypeId() == TYPEID_UNIT);

    if (!taunter || (taunter->IsPlayer() && taunter->ToPlayer()->isGameMaster()))
        return;

    if (!CanHaveThreatList())
        return;

    Creature* creature = ToCreature();

    if (creature->HasReactState(REACT_PASSIVE))
        return;

    Unit* target = getVictim();
    if (target && target == taunter)
        return;

    SetInFront(taunter);

    /// Don't schedule movement if casting, should be handled after the cast with the threat update
    if (creature->IsAIEnabled && !creature->HasUnitState(UnitState::UNIT_STATE_CASTING))
        creature->AI()->AttackStart(taunter);

    //m_ThreatManager.tauntApply(taunter);
}

//======================================================================

void Unit::TauntFadeOut(Unit* taunter)
{
    ASSERT(GetTypeId() == TYPEID_UNIT);

    if (!taunter || (taunter->IsPlayer() && taunter->ToPlayer()->isGameMaster()))
        return;

    if (!CanHaveThreatList())
        return;

    Creature* creature = ToCreature();

    if (creature->HasReactState(REACT_PASSIVE))
        return;

    Unit* target = getVictim();
    if (!target || target != taunter)
        return;

    if (m_ThreatManager.isThreatListEmpty())
    {
        if (creature->IsAIEnabled)
            creature->AI()->EnterEvadeMode();
        return;
    }

    target = creature->SelectVictim();  // might have more taunt auras remaining

    if (target && target != taunter)
    {
        SetInFront(target);
        if (creature->IsAIEnabled)
            creature->AI()->AttackStart(target);
    }
}

std::vector<Unit*> Unit::GetThreatUnitsVector(TypeID p_UnitType)
{
    std::vector<Unit*> l_Targets;

    std::list<HostileReference*> const& l_Threats = m_ThreatManager.getThreatList();

    l_Targets.reserve(l_Threats.size());

    for (HostileReference* const& l_Itr : l_Threats)
    {
        Unit* l_Target = l_Itr->getTarget();

        if (l_Target && l_Target->GetTypeId() == p_UnitType)
            l_Targets.push_back(l_Target);
    }

    return l_Targets;
}

std::list<Unit*> Unit::GetThreatUnitsList(TypeID p_UnitType)
{
    std::list<Unit*> l_Targets;

    std::list<HostileReference*> const& l_Threats = m_ThreatManager.getThreatList();

    for (HostileReference* const& l_Itr : l_Threats)
    {
        Unit* l_Target = l_Itr->getTarget();

        if (l_Target && l_Target->GetTypeId() == p_UnitType)
            l_Targets.push_back(l_Target);
    }

    return l_Targets;
}

//======================================================================

Unit* Creature::SelectVictim()
{
    // function provides main threat functionality
    // next-victim-selection algorithm and evade mode are called
    // threat list sorting etc.

    Unit* target = NULL;
    // First checking if we have some taunt on us
    AuraEffectList const& tauntAuras = GetAuraEffectsByType(SPELL_AURA_MOD_TAUNT);
    if (!tauntAuras.empty())
    {
        Unit* caster = tauntAuras.back()->GetCaster();

        // The last taunt aura caster is alive an we are happy to attack him
        if (caster && caster->isAlive())
            return getVictim();
        else if (tauntAuras.size() > 1)
        {
            // We do not have last taunt aura caster but we have more taunt auras,
            // so find first available target

            // Auras are pushed_back, last caster will be on the end
            AuraEffectList::const_iterator aura = --tauntAuras.end();
            do
            {
                --aura;
                caster = (*aura)->GetCaster();
                if (caster && canSeeOrDetect(caster, true) && IsValidAttackTarget(caster) && caster->isInAccessiblePlaceFor(ToCreature()))
                {
                    target = caster;
                    break;
                }
            }
            while
                (aura != tauntAuras.begin());
        }
        else
            target = getVictim();
    }

    if (CanHaveThreatList())
    {
        if (!target && !m_ThreatManager.isThreatListEmpty())
            // No taunt aura or taunt aura caster is dead standard target selection
            target = m_ThreatManager.getHostilTarget();
    }
    else if (!HasReactState(REACT_PASSIVE))
    {
        // We have player pet probably
        target = getAttackerForHelper();
        if (!target && isSummon())
        {
            if (Unit* owner = ToTempSummon()->GetOwner())
            {
                if (owner->isInCombat())
                    target = owner->getAttackerForHelper();
                if (!target)
                {
                    for (ControlList::const_iterator itr = owner->m_Controlled.begin(); itr != owner->m_Controlled.end(); ++itr)
                    {
                        if ((*itr)->isInCombat())
                        {
                            target = (*itr)->getAttackerForHelper();
                            if (target)
                                break;
                        }
                    }
                }
            }
        }
    }
    else
        return NULL;

    if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))
    {
        SetInFront(target);
        return target;
    }

    // Case where mob is being kited.
    // Mob may not be in range to attack or may have dropped target. In any case,
    //  don't evade if damage received within the last 10 seconds
    // Does not apply to world bosses to prevent kiting to cities
    if (!isWorldBoss() && !GetInstanceId())
        if (time(NULL) - GetLastDamagedTime() <= MAX_AGGRO_RESET_TIME)
            return target;

    // last case when creature must not go to evade mode:
    // it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list
    // for example at owner command to pet attack some far away creature
    // Note: creature does not have targeted movement generator but has attacker in this case
    for (AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
    {
        if ((*itr) && !canCreatureAttack(*itr) && (*itr)->GetTypeId() != TYPEID_PLAYER
        && !(*itr)->ToCreature()->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
            return NULL;
    }

    // TODO: a vehicle may eat some mob, so mob should not evade, except for dungeons/raids bosses
    if ((!IsDungeonBoss() && GetVehicle()) || isStatue())
        return NULL;

    // search nearby enemy before enter evade mode
    if (HasReactState(REACT_AGGRESSIVE))
    {
        target = SelectNearestTargetInAttackDistance(m_CombatDistance ? m_CombatDistance : ATTACK_DISTANCE);

        if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))
            return target;
    }

    Unit::AuraEffectList const& iAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
    if (!iAuras.empty())
    {
        for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
        {
            if ((*itr)->GetBase()->IsPermanent())
            {
                AI()->EnterEvadeMode();
                break;
            }
        }
        return NULL;
    }

    // enter in evade mode in other case
    AI()->EnterEvadeMode();

    return NULL;
}

bool Unit::GetThreatTarget(uint64 const& p_TargetGuid)
{
    for (RealGuidList::const_iterator l_Itr = m_savethreatlist.begin(); l_Itr != m_savethreatlist.end(); ++l_Itr)
        if ((*l_Itr) == p_TargetGuid)
            return true;

    return false;
}

//======================================================================
//======================================================================
//======================================================================

float Unit::ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index, float value) const
{
    if (Player* modOwner = GetSpellModOwner())
    {
        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_ALL_EFFECTS, value);

        switch (effect_index)
        {
            case EFFECT_0:
                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT1, value);
                break;
            case EFFECT_1:
                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT2, value);
                break;
            case EFFECT_2:
                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT3, value);
                break;
            case EFFECT_3:
                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT4, value);
                break;
            case EFFECT_4:
                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT5, value);
                break;
            default:
                break;
        }
    }
    return value;
}

bool Unit::HasAuraLinkedSpell(Unit* caster, Unit* target, uint8 type, int32 hastalent, int32 param /*= 0*/)
{
    switch (type)
    {
        case LINK_HAS_AURA_ON_CASTER: // 0
        {
            if (!caster)
                return true;
            if (hastalent > 0)
                return !caster->HasAura(hastalent);
            else if (hastalent < 0)
                return caster->HasAura(abs(hastalent));
        }
        case LINK_HAS_AURA_ON_TARGET: // 1
        {
            if (hastalent > 0)
                return target ? !target->HasAura(hastalent) : true ;
            else if (hastalent < 0)
                return target ? target->HasAura(abs(hastalent)) : true ;
        }
        case LINK_HAS_SPELL_ON_CASTER: // 2
        {
            if (!caster)
                return true;
            if (hastalent > 0)
                return !caster->HasSpell(hastalent);
            else if (hastalent < 0)
                return caster->HasSpell(abs(hastalent));
        }
        case LINK_HAS_AURA_ON_OWNER: // 3
        {
            if (!caster)
                return true;
            if (hastalent > 0)
                return caster->GetOwner() ? !caster->GetOwner()->HasAura(hastalent) : true;
            else if (hastalent < 0)
                return caster->GetOwner() ? caster->GetOwner()->HasAura(abs(hastalent)) : true;
        }
        case LINK_HAS_AURATYPE: // 4
            return target ? !target->HasAuraTypeWithCaster(AuraType(hastalent), caster ? caster->GetGUID() : 0) : true;
        case LINK_HAS_MY_AURA_ON_CASTER: // 5
        {
            if (!caster)
                return false;
            if (hastalent > 0)
                return !caster->HasAura(hastalent, caster->GetGUID());
            else if (hastalent < 0)
                return caster->HasAura(abs(hastalent), caster->GetGUID());
        }
        case LINK_HAS_MY_AURA_ON_TARGET: // 6
        {
            if (hastalent > 0)
                return target ? !target->HasAura(hastalent, caster ? caster->GetGUID() : 0) : true;
            else if (hastalent < 0)
                return target ? target->HasAura(abs(hastalent), caster ? caster->GetGUID() : 0) : true;
        }
        case LINK_HAS_AURA_STATE: // 7
        {
            if (hastalent > 0)
                return target ? !target->HasAuraState(AuraStateType(hastalent)) : true;
            else if (hastalent < 0)
                return target ? target->HasAuraState(AuraStateType(abs(hastalent))) : true;
        }
        case LINK_HAS_SPECID: // 8
        {
            if (!caster)
                return true;
            Player* _player = caster->ToPlayer();
            if (!_player)
                return true;
            if (hastalent > 0)
                return _player->GetActiveSpecializationID() != hastalent;
            else if (hastalent < 0)
                return _player->GetActiveSpecializationID() == hastalent;
        }
        case LINK_HAS_OBJECT_TYPE: // 9
        {
            if (!target)
                return true;
            if (hastalent > 0)
                return target->GetTypeId() != hastalent;
            else if (hastalent < 0)
                return target->GetTypeId() == hastalent;
        }
        case LINK_HAS_FRIEND: // 10
        {
            if (!target || !caster)
                return true;
            if (hastalent > 0)
                return !target->IsFriendlyTo(caster);
            else if (hastalent < 0)
                return target->IsFriendlyTo(caster);
        }
        case LINK_HAS_ATTACKABLE: // 11
        {
            if (!target || !caster)
                return true;
            if (hastalent > 0)
                return !caster->IsValidAttackTarget(target);
            else if (hastalent < 0)
                return caster->IsValidAttackTarget(target);
        }
        case LINK_HAS_DISTANCE: // 12
        {
            if (!target || !caster)
                return true;
            if (hastalent > 0)
                return int32(caster->GetDistance(target)) < hastalent;
            else if (hastalent < 0)
                return int32(caster->GetDistance(target)) > abs(hastalent);
        }
    }
    return true;
}

// function uses real base points (typically value - 1)
int32 Unit::CalculateSpellDamage(Unit const* p_Target, SpellInfo const* p_SpellProto, uint8 p_EffectIndex, int32 const* p_BasePoints, Item const* p_CastItem, bool p_Log /* = false */, std::ostringstream* p_LogDamageStream /*= nullptr*/) const
{
    return p_SpellProto->Effects[p_EffectIndex].CalcValue(this, p_BasePoints, p_Target, p_CastItem, p_Log, p_LogDamageStream);
}

int32 Unit::CalcSpellDuration(SpellInfo const* p_SpellInfo)
{
    int32 l_Combo = m_movedPlayer ? m_movedPlayer->GetPower(Powers::POWER_COMBO_POINT) : 0;

    if (l_Combo == 0 && GetEntry() == 77726) ///< Shadow Reflection
        l_Combo = GetPower(Powers::POWER_COMBO_POINT);

    int32 l_MinDur = p_SpellInfo->GetDuration();
    int32 l_MaxDur = p_SpellInfo->GetMaxDuration();

    int32 l_Dur = 0;

    if (l_Combo && l_MinDur != -1 && l_MinDur != l_MaxDur)
    {
        int32 l_MaxCombo = m_movedPlayer ? m_movedPlayer->GetMaxPower(Powers::POWER_COMBO_POINT) : 0;
        l_Dur = l_MaxCombo ? l_MinDur + int32((l_MaxDur - l_MinDur) * l_Combo / l_MaxCombo) : l_MinDur;
    }
    else
        l_Dur = l_MinDur;

    return l_Dur;
}

int32 Unit::ModSpellDuration(SpellInfo const* spellProto, Unit const* target, int32 duration, bool positive, uint32 effectMask)
{
    // don't mod permanent auras duration
    if (duration < 0)
        return duration;

    // Channeled spells does not affected by modifer duration
    if (spellProto->HasAttribute(SPELL_ATTR1_CHANNELED_1))
        return duration;

    // some auras are not affected by duration modifiers
    if (spellProto->AttributesEx7 & SPELL_ATTR7_IGNORE_DURATION_MODS)
        return duration;

    // cut duration only of negative effects
    if (!positive)
    {
        uint64 mechanic = spellProto->GetSpellMechanicMaskByEffectMask(effectMask);

        int32 durationMod;
        int32 durationMod_always = 0;
        int32 durationMod_not_stack = 0;

        for (uint8 i = 1; i <= MECHANIC_ENRAGED; ++i)
        {
            if (!(mechanic & 1LL << i))
                continue;
            // Find total mod value (negative bonus)
            int32 new_durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD, i);
            // Find max mod (negative bonus)
            int32 new_durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK, i);
            // Check if mods applied before were weaker
            if (new_durationMod_always < durationMod_always)
                durationMod_always = new_durationMod_always;
            if (new_durationMod_not_stack < durationMod_not_stack)
                durationMod_not_stack = new_durationMod_not_stack;
        }

        // Select strongest negative mod
        if (durationMod_always > durationMod_not_stack)
            durationMod = durationMod_not_stack;
        else
            durationMod = durationMod_always;

        if (durationMod != 0)
            AddPct(duration, durationMod);

        // there are only negative mods currently
        durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL, spellProto->Dispel);
        durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK, spellProto->Dispel);

        durationMod = 0;
        if (durationMod_always > durationMod_not_stack)
            durationMod += durationMod_not_stack;
        else
            durationMod += durationMod_always;

        if (durationMod != 0)
            AddPct(duration, durationMod);
    }
    else
    {
        // else positive mods here, there are no currently
        // when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue

        // Mixology - duration boost
        if (target->IsPlayer())
        {
            if (spellProto->SpellFamilyName == SPELLFAMILY_POTION && (
                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_BATTLE) ||
                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_GUARDIAN)))
            {
                if (target->HasAura(53042) && target->HasSpell(spellProto->Effects[0].TriggerSpell))
                    duration *= 2;
            }
        }

        // Item - Druid T13 Restoration 4P Bonus (Rejuvenation)
        if (AuraEffect* eff = GetAuraEffect(105770, 0))
        {
            if (roll_chance_i(eff->GetAmount()) && eff->IsAffectingSpell(spellProto))
                duration *= 2;
        }
    }

    // Glyphs which increase duration of selfcasted buffs
    if (target == this)
    {
        switch (spellProto->SpellFamilyName)
        {
            case SPELLFAMILY_DRUID:
            {
                if (spellProto->SpellFamilyFlags[0] & 0x100)
                {
                    // Glyph of Thorns
                    if (AuraEffect* aurEff = GetAuraEffect(57862, 0))
                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
                }
                break;
            }
        }
    }
    else
    {
        if (spellProto->GetSpellSpecific() == SpellSpecificType::SpellSpecificMagePolymorph)
             if (AuraEffect* eff = GetAuraEffect(56382, 0)) /// Glyph of Crittermorph
                 if (target->ToCreature() && target->ToCreature()->GetCreatureType() == CREATURE_TYPE_CRITTER)
                     duration = 86400000;
    }

    return std::max(duration, 0);
}

void Unit::ModSpellCastTime(SpellInfo const* spellProto, int32& castTime, Spell* spell)
{
    if (!spellProto || castTime < 0)
        return;

    if (spellProto->Id == 198013 && IsPlayer()) ///< Eye Beam
    {
        castTime = int32(castTime * std::max<float>(GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED), 0.5f));
        return;
    }

    if (spellProto->Id == 120360 && IsPlayer()) ///< Barrage
    {
        castTime = int32(castTime * std::max<float>(GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED), 0.4f));
        return;
    }

    if (spellProto->IsChanneled() && !(spellProto->HasAttribute(SpellAttr5::SPELL_ATTR5_HASTE_AFFECT_DURATION) || spellProto->HasAttribute(SpellAttr8::SPELL_ATTR8_HASTE_AFFECT_DURATION)))
        return;

    if (spellProto->Id == 198590 && m_SpellHelper.GetUint32(eSpellHelpers::DrainSoul)
        && spell && spell->GetUnitTarget() && (m_SpellHelper.GetUint64(eSpellHelpers::DrainSoul) == spell->GetUnitTarget()->GetGUID()))
    {
        castTime = m_SpellHelper.GetUint32(eSpellHelpers::DrainSoul);
        return;
    }

    // called from caster
    Player* modOwner = GetSpellModOwner();

    if (modOwner != nullptr)
        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);

    float l_TotalMod = 0.0f;
    AuraEffectList const& l_AuraModCastSpeed = GetAuraEffectsByType(SPELL_AURA_MOD_CAST_SPEED);
    for (AuraEffectList::const_iterator l_Itr = l_AuraModCastSpeed.begin(); l_Itr != l_AuraModCastSpeed.end(); ++l_Itr)
        l_TotalMod -= (*l_Itr)->GetAmount();

    AddPct(castTime, l_TotalMod);

    uint16 l_VisualID = 0;

    if (SpellXSpellVisualEntry const* l_VisualEntry = sSpellXSpellVisualStore.LookupEntry(spellProto->GetSpellXSpellVisualId(this)))
        l_VisualID = l_VisualEntry->VisualID;

    if (!((spellProto->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_TRADESPELL)) || (spellProto->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS))) &&
        ((IsPlayer() && spellProto->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
    {
        if (modOwner != nullptr)
        {
            /// Demonic Empowerment - Haste is only applied to summons, but we only scale summon's haste with owner's
            if (AuraEffect const* l_Empowerment = GetAuraEffect(193396, EFFECT_1))
            {
                float l_HastePct = modOwner->GetHastePct();

                l_HastePct *= (1.0f + l_Empowerment->GetAmount() / 100.0f);
                l_HastePct += l_Empowerment->GetAmount();

                float l_Haste = 100.0f / (std::abs(l_HastePct) + 100.0f);

                if (l_HastePct < 0.0f)
                    l_Haste = 1.0f / l_Haste;

                castTime = int32(float(castTime) * l_Haste * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));
            }
            else
                castTime = int32(float(castTime) * modOwner->GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED) * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));
        }
        else
            castTime = int32(float(castTime) * GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED) * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));
    }
    else if (spellProto->Attributes & SPELL_ATTR0_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG))
        castTime = int32(float(castTime) * m_modAttackSpeedPct[WeaponAttackType::RangedAttack] * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));
    else if (l_VisualID == 3881 && HasAura(67556)) // cooking with Chef Hat.
        castTime = 500;

    CalculateCastTimeFromDummy(castTime, spellProto);
}

DiminishingLevels Unit::GetDiminishing(DiminishingGroup group)
{
    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
    {
        if (i->DRGroup != group)
            continue;

        if (!i->hitCount)
            return DIMINISHING_LEVEL_1;

        if (!i->hitTime)
            return DIMINISHING_LEVEL_1;

        // If last spell was casted more than 18 seconds ago - reset the count.
        if (i->stack == 0 && GetMSTimeDiffToNow(i->hitTime) > (18 * TimeConstants::IN_MILLISECONDS))
        {
            if (IsPlayer() && sSpellMgr->IsInDRDebug())
            {
                if (Player* l_Player = ToPlayer())
                    ChatHandler(l_Player).PSendSysMessage("Diminishing level reset for : %d", group);
            }
            i->hitCount = DIMINISHING_LEVEL_1;
            i->hitTime = getMSTime();
            return DIMINISHING_LEVEL_1;
        }
        // or else increase the count.
        else
            return DiminishingLevels(i->hitCount);
    }
    return DIMINISHING_LEVEL_1;
}

void Unit::IncrDiminishing(DiminishingGroup group)
{
    if (IsPlayer() && ToPlayer()->GetCommandStatus(CHEAT_NO_DR))
        return;

    if (IsPlayer() && sSpellMgr->IsInDRDebug())
    {
        if (Player* l_Player = ToPlayer())
            ChatHandler(l_Player).PSendSysMessage("Diminishing level increased for : %d", group);
    }

    // Checking for existing in the table
    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
    {
        if (i->DRGroup != group)
            continue;
        if (int32(i->hitCount) < GetDiminishingReturnsMaxLevel(group))
            i->hitCount += 1;
        return;
    }
    m_Diminishing.push_back(DiminishingReturn(group, getMSTime(), DIMINISHING_LEVEL_2));
}

float Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration, Unit* caster, DiminishingLevels Level, int32 limitduration)
{
    if (duration == -1 || group == DIMINISHING_NONE)
        return 1.0f;

    // test pet/charm masters instead pets/charmeds
    Unit const* targetOwner = GetCharmerOrOwner();
    Unit const* casterOwner = caster->GetCharmerOrOwner();

    if (limitduration > 0 && duration > limitduration)
    {
        Unit const* target = targetOwner ? targetOwner : this;
        Unit const* source = casterOwner ? casterOwner : caster;

        if ((target->IsPlayer()
            || (target->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_ALL_DIMINISH))
            && source->IsPlayer())
            duration = limitduration;
    }

    float mod = 1.0f;

    switch (group)
    {
        case DIMINISHING_TAUNT:
        {
            if (GetTypeId() == TYPEID_UNIT && (ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_TAUNT_DIMINISH))
            {
                DiminishingLevels diminish = Level;
                switch (diminish)
                {
                    case DIMINISHING_LEVEL_1: break;
                    case DIMINISHING_LEVEL_2: mod = 0.65f; break;
                    case DIMINISHING_LEVEL_3: mod = 0.4225f; break;
                    case DIMINISHING_LEVEL_4: mod = 0.274625f; break;
                    case DIMINISHING_LEVEL_TAUNT_IMMUNE: mod = 0.0f; break;
                    default: break;
                }
            }
            break;
        }
        case DIMINISHING_AOE_KNOCKBACK:
        {
            if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER && (((targetOwner ? targetOwner : this)->ToPlayer())
                                                                            || (ToCreature() && (ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_ALL_DIMINISH))))
                || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)
            {
                DiminishingLevels diminish = Level;
                switch (diminish)
                {
                    case DIMINISHING_LEVEL_1: break;
                    case DIMINISHING_LEVEL_2: mod = 0.0f; break;
                    default: break;
                }
            }
            break;
        }
        default:
        {
            if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER && (((targetOwner ? targetOwner : this)->ToPlayer())
                                                                            || (ToCreature() && (ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_ALL_DIMINISH))))
                || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)
            {
                DiminishingLevels diminish = Level;
                switch (diminish)
                {
                    case DIMINISHING_LEVEL_1: break;
                    case DIMINISHING_LEVEL_2: mod = 0.5f; break;
                    case DIMINISHING_LEVEL_3: mod = 0.25f; break;
                    case DIMINISHING_LEVEL_IMMUNE: mod = 0.0f; break;
                    default: break;
                }
            }
            break;
        }
    }

    duration = int32(duration * mod);
    return mod;
}

void Unit::ApplyDiminishingAura(DiminishingGroup group, bool apply)
{
    // Checking for existing in the table
    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
    {
        if (i->DRGroup != group)
            continue;

        if (apply)
            i->stack += 1;
        else if (i->stack)
        {
            i->stack -= 1;
            // Remember time after last aura from group removed
            if (i->stack == 0)
                i->hitTime = getMSTime();
        }
        break;
    }
}

void Unit::ClearDiminishingsForGroup(DiminishingGroup p_Group)
{
    m_Diminishing.remove_if([p_Group](DiminishingReturn p_DR) -> bool
    {
        if (p_DR.DRGroup == p_Group)
            return true;

        return false;
    });
}

float Unit::GetSpellMaxRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const
{
    if (!spellInfo->RangeEntry)
        return 0;

    if (spellInfo->RangeEntry->maxRangeFriend == spellInfo->RangeEntry->maxRangeHostile)
        return spellInfo->GetMaxRange();

    if (!target)
        return spellInfo->RangeEntry->maxRangeFriend;

    return spellInfo->GetMaxRange(!IsHostileTo(target));
}

float Unit::GetSpellMinRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const
{
    if (!spellInfo->RangeEntry)
        return 0;
    if (spellInfo->RangeEntry->minRangeFriend == spellInfo->RangeEntry->minRangeHostile)
        return spellInfo->GetMinRange();
    return spellInfo->GetMinRange(!IsHostileTo(target));
}

Unit* Unit::GetUnit(WorldObject const& object, uint64 guid)
{
    return ObjectAccessor::GetUnit(object, guid);
}

Player* Unit::GetPlayer(WorldObject const& object, uint64 guid)
{
    return ObjectAccessor::GetPlayer(object, guid);
}

Creature* Unit::GetCreature(WorldObject const& object, uint64 guid)
{
    return object.GetMap()->GetCreature(guid);
}

uint32 Unit::GetCreatureType() const
{
    if (IsPlayer())
    {
        ShapeshiftForm form = GetShapeshiftForm();
        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
        if (ssEntry && ssEntry->CreatureType > 0)
            return ssEntry->CreatureType;
        else
            return CREATURE_TYPE_HUMANOID;
    }
    else
        return ToCreature()->GetCreatureTemplate()->type;
}

bool Unit::IsInDisallowedMountForm() const
{
    if (HasAura(208535))
        return false;

    if (ShapeshiftForm l_Form = GetShapeshiftForm())
    {
        SpellShapeshiftFormEntry const* l_Shapeshift = sSpellShapeshiftFormStore.LookupEntry(l_Form);
        if (!l_Shapeshift)
            return true;

        if (!(l_Shapeshift->Flags & SHAPESHIFT_FORM_IS_NOT_A_SHAPESHIFT))
            return true;

        if (l_Form == FORM_MOONKIN_FORM)
            return false;
    }

    if (GetDisplayId() == GetNativeDisplayId())
        return false;

    CreatureDisplayInfoEntry const* l_Display = sCreatureDisplayInfoStore.LookupEntry(GetDisplayId());
    if (!l_Display)
        return true;

    /// HACK:
    /// There is no ExtendedDisplayInfoID
    /// Need to find the correct way
    switch (l_Display->ID)
    {
        case 7550: ///< Noggenfogger Elixir
        case 35107: ///< Guardian of the ancient Kings
        case 67158: ///< Branded
        case 68670: ///< Metamorphosis Havoc
        case 68671: ///< Metamorphosis Vengeance
        case 66592: ///< Masquerade (spell id 213213)
        case 66276: ///< Masquerade (spell id 213213)
            return false;
    }

    CreatureDisplayInfoExtraEntry const* l_DisplayExtra = sCreatureDisplayInfoExtraStore.LookupEntry(l_Display->ExtendedDisplayInfoID);
    if (!l_DisplayExtra)
        return true;

    CreatureModelDataEntry const* l_Model = sCreatureModelDataStore.LookupEntry(l_Display->ModelID);
    ChrRacesEntry const* l_Race = sChrRacesStore.LookupEntry(l_DisplayExtra->DisplayRaceID);

    if (l_Model && !(l_Model->Flags & 0x80))
        if (l_Race && !(l_Race->Flags & 0x4))
            return true;

    return false;
}

/*#######################################
########                         ########
########       STAT SYSTEM       ########
########                         ########
#######################################*/

bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply)
{
    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
        return false;

    switch (modifierType)
    {
        case BASE_VALUE:
        case BASE_PCT_EXCLUDE_CREATE:
        case TOTAL_VALUE:
            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount : -amount;
            break;
        case BASE_PCT:
        case TOTAL_PCT:
            ApplyPercentModFloatVar(m_auraModifiersGroup[unitMod][modifierType], amount, apply);
            break;
        default:
            break;
    }

    if (!CanModifyStats())
        return false;

    switch (unitMod)
    {
        case UNIT_MOD_STAT_STRENGTH:
        case UNIT_MOD_STAT_AGILITY:
        case UNIT_MOD_STAT_STAMINA:
        case UNIT_MOD_STAT_INTELLECT:
            UpdateStats(GetStatByAuraGroup(unitMod));
            break;
        case UNIT_MOD_ARMOR:
        case UNIT_MOD_BONUS_ARMOR:
            UpdateArmor();
            break;
        case UNIT_MOD_HEALTH:
            UpdateMaxHealth();
            break;
        case UNIT_MOD_ECLIPSE:
        case UNIT_MOD_MANA:
        case UNIT_MOD_RAGE:
        case UNIT_MOD_FOCUS:
        case UNIT_MOD_ENERGY:
        case UNIT_MOD_RUNE:
        case UNIT_MOD_RUNIC_POWER:
        case UNIT_MOD_CHI:
        case UNIT_MOD_BURNING_EMBERS:
        case UNIT_MOD_SOUL_SHARDS:
        case UNIT_MOD_DEMONIC_FURY:
        case UNIT_MOD_SHADOW_ORB:
        case UNIT_MOD_MAELSTORM:
            UpdateMaxPower(GetPowerTypeByAuraGroup(unitMod));
            break;
        case UNIT_MOD_RESISTANCE_HOLY:
        case UNIT_MOD_RESISTANCE_FIRE:
        case UNIT_MOD_RESISTANCE_NATURE:
        case UNIT_MOD_RESISTANCE_FROST:
        case UNIT_MOD_RESISTANCE_SHADOW:
        case UNIT_MOD_RESISTANCE_ARCANE:
            UpdateResistances(GetSpellSchoolByAuraGroup(unitMod));
            break;
        case UNIT_MOD_ATTACK_POWER:
            UpdateAttackPowerAndDamage();
            break;
        case UNIT_MOD_ATTACK_POWER_RANGED:
            UpdateAttackPowerAndDamage(true);
            break;
        case UNIT_MOD_DAMAGE_MAINHAND:
            UpdateDamagePhysical(WeaponAttackType::BaseAttack);
            break;
        case UNIT_MOD_DAMAGE_OFFHAND:
            UpdateDamagePhysical(WeaponAttackType::OffAttack);
            break;
        case UNIT_MOD_DAMAGE_RANGED:
            UpdateDamagePhysical(WeaponAttackType::RangedAttack);
            break;
        default:
            break;
    }

    return true;
}

void Unit::UpdateStatBuffFields(Stats stat)
{
    float value = GetUInt32Value(UNIT_FIELD_STATS + stat);
    if (value >= GetCreateStat(stat))
    {
        SetFloatValue(UNIT_FIELD_STAT_NEG_BUFF + stat, 0.0f);
        SetFloatValue(UNIT_FIELD_STAT_POS_BUFF + stat, value - GetCreateStat(stat));
    }
    if (value <= GetCreateStat(stat))
    {
        SetFloatValue(UNIT_FIELD_STAT_POS_BUFF + stat, 0.0f);
        SetFloatValue(UNIT_FIELD_STAT_NEG_BUFF + stat, GetCreateStat(stat) - value);
    }
}

float Unit::GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const
{
    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
        return 0.0f;

    if (modifierType == TOTAL_PCT && m_auraModifiersGroup[unitMod][modifierType] <= 0.0f)
        return 0.0f;

    return m_auraModifiersGroup[unitMod][modifierType];
}

float Unit::GetTotalStatValue(Stats stat, bool l_IncludeCreateStat /*= true*/) const
{
    UnitMods unitMod = UnitMods(UNIT_MOD_STAT_START + stat);

    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
        return 0.0f;

    // value = ((base_value * base_pct) + total_value) * total_pct
    float value = CalculatePct(m_auraModifiersGroup[unitMod][BASE_VALUE], std::max(m_auraModifiersGroup[unitMod][BASE_PCT_EXCLUDE_CREATE], -100.0f));
    value += GetCreateStat(stat);

    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];

    if (!l_IncludeCreateStat)
        value -= GetCreateStat(stat);

    return value;
}

float Unit::GetTotalAuraModValue(UnitMods unitMod) const
{
    if (unitMod >= UNIT_MOD_END)
        return 0.0f;

    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
        return 0.0f;

    float value = CalculatePct(m_auraModifiersGroup[unitMod][BASE_VALUE], std::max(m_auraModifiersGroup[unitMod][BASE_PCT_EXCLUDE_CREATE], -100.0f));

    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];

    return value;
}

SpellSchools Unit::GetSpellSchoolByAuraGroup(UnitMods unitMod) const
{
    SpellSchools school = SPELL_SCHOOL_NORMAL;

    switch (unitMod)
    {
        case UNIT_MOD_RESISTANCE_HOLY:     school = SPELL_SCHOOL_HOLY;          break;
        case UNIT_MOD_RESISTANCE_FIRE:     school = SPELL_SCHOOL_FIRE;          break;
        case UNIT_MOD_RESISTANCE_NATURE:   school = SPELL_SCHOOL_NATURE;        break;
        case UNIT_MOD_RESISTANCE_FROST:    school = SPELL_SCHOOL_FROST;         break;
        case UNIT_MOD_RESISTANCE_SHADOW:   school = SPELL_SCHOOL_SHADOW;        break;
        case UNIT_MOD_RESISTANCE_ARCANE:   school = SPELL_SCHOOL_ARCANE;        break;

        default:
            break;
    }

    return school;
}

Stats Unit::GetStatByAuraGroup(UnitMods unitMod) const
{
    Stats stat = STAT_STRENGTH;

    switch (unitMod)
    {
        case UNIT_MOD_STAT_STRENGTH:    stat = STAT_STRENGTH;      break;
        case UNIT_MOD_STAT_AGILITY:     stat = STAT_AGILITY;       break;
        case UNIT_MOD_STAT_STAMINA:     stat = STAT_STAMINA;       break;
        case UNIT_MOD_STAT_INTELLECT:   stat = STAT_INTELLECT;     break;

        default:
            break;
    }

    return stat;
}

Powers Unit::GetPowerTypeByAuraGroup(UnitMods unitMod) const
{
    switch (unitMod)
    {
        case UNIT_MOD_RAGE:
            return POWER_RAGE;
        case UNIT_MOD_FOCUS:
            return POWER_FOCUS;
        case UNIT_MOD_ENERGY:
            return POWER_ENERGY;
        case UNIT_MOD_RUNE:
            return POWER_RUNES;
        case UNIT_MOD_RUNIC_POWER:
            return POWER_RUNIC_POWER;
        case UNIT_MOD_CHI:
            return POWER_CHI;
        case UNIT_MOD_HOLY_POWER:
            return POWER_HOLY_POWER;
        case UNIT_MOD_SHADOW_ORB:
            return POWER_INSANITY;
        case UNIT_MOD_SOUL_SHARDS:
            return POWER_SOUL_SHARDS;
        case UNIT_MOD_ARCANE_CHARGES:
            return POWER_ARCANE_CHARGES;
        case UNIT_MOD_MAELSTORM:
            return POWER_MAELSTROM;
        case UNIT_MOD_ECLIPSE:
            return POWER_LUNAR_POWER;
        case UNIT_MOD_MANA:
        default:
            return POWER_MANA;
    }
}

float Unit::GetTotalAttackPowerValue(WeaponAttackType attType) const
{
    if (attType == WeaponAttackType::RangedAttack)
    {
        int32 ap = GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER);
        if (ap < 0)
            return 0.0f;
        return ap * (1.0f + GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER));
    }
    else
    {
        int32 ap = GetInt32Value(UNIT_FIELD_ATTACK_POWER);
        if (ap < 0)
            return 0.0f;
        return ap * (1.0f + GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER));
    }
}

float Unit::GetBaseWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange type) const
{
    if (attType == WeaponAttackType::OffAttack && !haveOffhandWeapon())
        return 0.0f;

    return m_baseWeaponDamage[attType][type];
}

void Unit::SetLevel(uint8 lvl)
{
    SetUInt32Value(UNIT_FIELD_LEVEL, lvl);

    // group update
    if (IsPlayer() && ToPlayer()->GetGroup())
        ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_LEVEL);

#ifndef CROSS
    if (IsPlayer())
        sWorld->UpdateCharacterInfoLevel(ToPlayer()->GetGUIDLow(), lvl);
#endif
}

uint8 Unit::getRace(bool p_ForceMercenary) const
{
    if (!IsPlayer())
        return GetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE);

    if (ToPlayer()->IsMercenary() && !p_ForceMercenary)
        return ToPlayer()->GetOriginalRace();

    return GetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE);
}

void Unit::SetHealth(uint64 val)
{
    if (getDeathState() == JUST_DIED)
        val = 0;
    else if (IsPlayer() && getDeathState() == DEAD)
        val = 1;
    else
    {
        uint64 maxHealth = GetMaxHealth();
        if (maxHealth < val)
            val = maxHealth;
    }

    uint64 l_prevValue = GetUInt64Value(UNIT_FIELD_HEALTH);

    SetUInt64Value(UNIT_FIELD_HEALTH, val);

    // group update
    if (Player* player = ToPlayer())
    {
        if (player->GetGroup())
            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);

        // Hook playerScript OnModifyHealth
        if (IsPlayer())
            sScriptMgr->OnModifyHealth(this->ToPlayer(), val, l_prevValue);
    }
    else if (Pet* l_Pet = ToCreature()->ToPet())
    {
        if (l_Pet->isControlled())
        {
            Unit* owner = GetOwner();
            if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
            if (owner && (owner->IsPlayer()) && owner->HasAura(171393))
            {
                if (l_Pet->GetHealthPct() < 20.0f && l_Pet->GetHealthPct() > 0.0f)
                    owner->CastSpell(owner, 171397, true);
                if ((l_Pet->GetHealthPct() >= 20.0f && owner->GetHealthPct() >= 20.0f) || l_Pet->GetHealthPct() == 0.0f)
                    owner->RemoveAura(171397);
            }
        }
    }
}

void Unit::SetMaxHealth(uint64 val)
{
    if (!val)
        val = 1;

    float percent = GetHealthPct();
    SetUInt64Value(UNIT_FIELD_MAX_HEALTH, val);

    // Unit will keep hp% after MaxHealth is changed if unit is alive. (7.3.5 - Build 26365)
    if (isAlive())
        SetHealth(CountPctFromMaxHealth(percent));

    // group update
    if (IsPlayer())
    {
        if (ToPlayer()->GetGroup())
            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
    }
    else if (Pet* pet = ToCreature()->ToPet())
    {
        if (pet->isControlled())
        {
            Unit* owner = GetOwner();
            if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
        }
    }
}

Unit::PowerTypeSet Unit::GetUsablePowers() const
{
    PowerTypeSet l_Powers;
    for (uint32 l_I = 0; l_I <= sChrClassXPowerTypesStore.GetNumRows(); ++l_I)
    {
        ChrClassXPowerTypesEntry const* powerEntry = sChrClassXPowerTypesStore.LookupEntry(l_I);
        if (!powerEntry)
            continue;

        if (powerEntry->classId != getClass())
            continue;

        l_Powers.insert(Powers(powerEntry->power));
    }

    // POWER_RUNES isn't in ChrClassesXPowerTypes.db2
    if (getClass() == CLASS_DEATH_KNIGHT)
        l_Powers.insert(POWER_RUNES);

    return l_Powers;
}

uint32 Unit::GetPowerIndex(uint32 powerId, uint32 classId) const
{

    // See CGUnit_C::GetPowerSlot
    if (GetTypeId() != TYPEID_PLAYER)
    {
        Powers l_DisplayPower = getPowerType();
        if (l_DisplayPower == (Powers)powerId)
            return 0;
        else if (powerId == Powers::POWER_ALTERNATE_POWER)
            return 1;
        else if (powerId == Powers::POWER_COMBO_POINT)
            return 2;
        else
            return Powers::MAX_POWERS;
    }

    return GetPowerIndexByClass(classId, powerId);
};

int32 Unit::GetPower(Powers p_Power) const
{
    uint32 l_PowerIndex = GetPowerIndex(p_Power, getClass());
    if (l_PowerIndex == MAX_POWERS)
        return 0;

    return m_powers[l_PowerIndex];
}

int32 Unit::GetMaxPower(Powers power) const
{
    uint32 powerIndex = GetPowerIndex(power, getClass());
    if (powerIndex == MAX_POWERS)
        return 0;

    return GetInt32Value(UNIT_FIELD_MAX_POWER + powerIndex);
}

int32 Unit::GetPowerCoeff(Powers p_PowerType) const
{
    if (PowerTypeEntry const* l_PowerType = sPowerTypeStore.LookupEntry(p_PowerType))
        return l_PowerType->UIModifier;

    return 1;
}

namespace EclipsePower
{
    enum
    {
        CycleDuration = 40000
    };
}

void Unit::SetPower(Powers p_PowerType, int32 p_PowerValue, bool p_Regen /*=false*/)
{
    uint32 l_PowerIndex = GetPowerIndex(p_PowerType, getClass());

    if (l_PowerIndex == MAX_POWERS)
        return;

    int32 l_MaxPower = int32(GetMaxPower(p_PowerType));

    if (p_PowerValue > l_MaxPower)
        p_PowerValue = l_MaxPower;

    if (ToCreature() && ToCreature()->IsAIEnabled)
        ToCreature()->AI()->SetPower(p_PowerType, p_PowerValue);

    /// Hook playerScript OnModifyPower
    if (IsPlayer())
        sScriptMgr->OnModifyPower(ToPlayer(), p_PowerType, m_powers[l_PowerIndex], p_PowerValue, p_Regen, false);

    uint32 l_OldPower = m_powers[l_PowerIndex];

    m_powers[l_PowerIndex] = p_PowerValue;

    uint32 l_RegenDiff = getMSTime() - m_lastRegenTime[l_PowerIndex];

    if (!p_Regen || l_RegenDiff > 2000)
        SetInt32Value(UNIT_FIELD_POWER + l_PowerIndex, p_PowerValue);

    if (IsInWorld() && (!p_Regen || l_RegenDiff > 2000 || (p_PowerValue == l_MaxPower)))
    {
        int l_PowerCount = 1;

        WorldPacket l_Data(SMSG_POWER_UPDATE, 2 + 16 + 4 + 4 + 1);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(l_PowerCount);

        l_Data << int32(p_PowerValue);
        l_Data << uint8(p_PowerType);

        SendMessageToSet(&l_Data, IsPlayer() ? true : false);

        m_lastRegenTime[l_PowerIndex] = getMSTime();
    }

    std::list<AuraEffect*> const l_AuraEffectList = GetAuraEffectsByType(SPELL_AURA_TRIGGER_ON_MODIFY_POWER);
    for (AuraEffect* l_AuraEffect : l_AuraEffectList)
    {
        int32 l_Cap = l_AuraEffect->GetAmount();
        Aura* l_Aura = l_AuraEffect->GetBase();
        SpellInfo const* l_AuraInfo = nullptr;

        if (l_AuraEffect->GetMiscValueB() == 0)
        {
            if (l_Aura->GetId() == 190427) ///< Arcane Charge
            {
                if (l_AuraEffect->GetMiscValue() == p_PowerType && GetPower(p_PowerType) == l_Cap)
                    CastSpell(this, l_AuraEffect->GetTriggerSpell(), true);
            }
            else
            {
                if (l_AuraEffect->GetMiscValue() == p_PowerType && int32(GetPower(p_PowerType)) >= l_Cap)
                    CastSpell(this, l_AuraEffect->GetTriggerSpell(), true);
            }
        }
        else
        {
            if (l_AuraEffect->GetMiscValue() == p_PowerType && int32(GetPower(p_PowerType)) <= l_Cap)
                CastSpell(this, l_AuraEffect->GetTriggerSpell(), true);
        }
    }

    if (IsPlayer())
        sScriptMgr->OnModifyPower(ToPlayer(), p_PowerType, l_OldPower, p_PowerValue, p_Regen, true);

    /// Custom MoP Script
    /// Pursuit of Justice - 26023
    if (Player * l_Player = ToPlayer())
    {
        if (l_Player->HasAura(26023))
        {
            Aura* l_Aura = l_Player->GetAura(26023);
            if (l_Aura)
            {
                int32 l_HolyPower = l_Player->GetPower(POWER_HOLY_POWER) >= 3 ? 3 : l_Player->GetPower(POWER_HOLY_POWER);
                int32 l_AddValue = (5 * l_HolyPower) + l_Aura->GetSpellInfo()->Effects[EFFECT_0].BasePoints;

                l_Aura->GetEffect(0)->ChangeAmount(l_AddValue);

                Aura* l_SecondAura = l_Player->AddAura(114695, l_Player);

                if (l_SecondAura)
                    l_SecondAura->GetEffect(0)->ChangeAmount(l_AddValue);
            }
        }
        else if (l_Player->HasAura(114695))
            l_Player->RemoveAura(114695);
    }

    /// group update
    if (Player * l_Player = ToPlayer())
    {
        if (l_Player->GetGroup())
            l_Player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
    }
    else if (Pet * l_Pet = ToCreature()->ToPet())
    {
        if (l_Pet->isControlled())
        {
            Unit * l_Owner = GetOwner();
            if (l_Owner && (l_Owner->IsPlayer()) && l_Owner->ToPlayer()->GetGroup())
                l_Owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
        }
    }
}

void Unit::SetMaxPower(Powers power, int32 val)
{
    uint32 powerIndex = GetPowerIndex(power, getClass());
    if (powerIndex == MAX_POWERS)
        return;

    int32 cur_power = GetPower(power);
    SetInt32Value(UNIT_FIELD_MAX_POWER + powerIndex, val);

    // group update
    if (IsPlayer())
    {
        if (ToPlayer()->GetGroup())
            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
    }
    else if (Pet* pet = ToCreature()->ToPet())
    {
        if (pet->isControlled())
        {
            Unit* owner = GetOwner();
            if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
        }
    }

    if (val < cur_power)
        SetPower(power, val);
}

int32 Unit::GetDefaultValuePower(Powers p_Power) const
{
    if (p_Power == POWER_MANA)
        return GetMaxPower(POWER_MANA);

    if (p_Power == POWER_SOUL_SHARDS)
        return 30;

    if (PowerTypeEntry const* l_PowerType = sPowerTypeStore.LookupEntry(p_Power))
        return l_PowerType->RegenerationPeace > 0.0f ? GetMaxPower(p_Power) : 0;

    return 0;
}

int32 Unit::GetCreatePowers(Powers power) const
{
    switch (power)
    {
        case POWER_MANA:
        {
            return GetCreateMana();
        }
        case POWER_FOCUS:
        {
            if (IsPlayer() && getClass() != CLASS_HUNTER)
                return 0;
            if (isPet())
            {
                if (ToPet()->getPetType() != HUNTER_PET)
                    return 0;
            }
        }
        default:
            break;
    }

    if (PowerTypeEntry const* l_PowerType = sPowerTypeStore.LookupEntry(power))
        return l_PowerType->MaxPower;

    return 0;
}

void Unit::AddToWorld()
{
    if (!IsInWorld())
    {
        WorldObject::AddToWorld();
    }
}

void Unit::RemoveFromWorld()
{
    // cleanup
    ASSERT(GetGUID());

    if (IsInWorld())
    {
        m_duringRemoveFromWorld = true;
#ifndef CROSS
        if (IsVehicle())
#else /* CROSS */
        if (IsVehicle() && GetMapSwitchDestination() == -1)
#endif /* CROSS */
            GetVehicleKit()->Uninstall();

        RemoveCharmAuras();
        RemoveBindSightAuras();
        RemoveNotOwnSingleTargetAuras();

        RemoveAllGameObjects();
        RemoveAllDynObjects();
        RemoveAllAreasTrigger();

#ifndef CROSS
        ExitVehicle();  // Remove applied auras with SPELL_AURA_CONTROL_VEHICLE
#else /* CROSS */
        if (GetMapSwitchDestination() == -1)
            ExitVehicle();  // Remove applied auras with SPELL_AURA_CONTROL_VEHICLE
#endif /* CROSS */
        UnsummonAllTotems();
        RemoveAllControlled();

        RemoveAreaAurasDueToLeaveWorld();

        getHostileRefManager().deleteReferences();

        if (GetCharmerGUID())
        {
            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u has charmer guid when removed from world", GetEntry());
            ASSERT(false);
        }

        if (Unit* owner = GetOwner())
        {
            if (owner->m_Controlled.find(this) != owner->m_Controlled.end())
            {
                sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is in controlled list of %u when removed from world", GetEntry(), owner->GetEntry());
                ASSERT(false);
            }
        }

        WorldObject::RemoveFromWorld();
        m_duringRemoveFromWorld = false;
    }
}

void Unit::CleanupBeforeRemoveFromMap(bool finalCleanup)
{
    // This needs to be before RemoveFromWorld to make GetCaster() return a valid pointer on aura removal
    InterruptNonMeleeSpells(true);

    if (IsInWorld())
        RemoveFromWorld();

    ASSERT(GetGUID());

    // A unit may be in removelist and not in world, but it is still in grid
    // and may have some references during delete
    RemoveAllAuras();
    RemoveAllGameObjects();

    if (finalCleanup)
        m_cleanupDone = true;

    m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
    CombatStop();
    ClearComboPoints();

    DeleteThreatList();
    getHostileRefManager().setOnlineOfflineState(false);
    GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.

    if (GetTypeId() == TYPEID_UNIT)
    {
        if (Map* l_Map = GetMap())
            l_Map->RemoveCreatureFromMoveList(ToCreature(), true);
    }
}

void Unit::CleanupsBeforeDelete(bool finalCleanup)
{
    CleanupBeforeRemoveFromMap(finalCleanup);

    if (Creature* thisCreature = ToCreature())
        if (GetTransport())
            GetTransport()->RemovePassenger(thisCreature);
}

void Unit::UpdateCharmAI()
{
    if (IsPlayer())
        return;

    if (i_disabledAI) // disabled AI must be primary AI
    {
        if (!isCharmed())
        {
            delete i_AI;
            i_AI = i_disabledAI;
            i_disabledAI = NULL;
        }
    }
    else
    {
        if (isCharmed())
        {
            i_disabledAI = i_AI;
            if (isPossessed() || IsVehicle())
                i_AI = new PossessedAI(ToCreature());
            else
                i_AI = new PetAI(ToCreature());
        }
    }
}

CharmInfo* Unit::InitCharmInfo()
{
    if (!m_charmInfo)
        m_charmInfo = new CharmInfo(this);

    return m_charmInfo;
}

void Unit::DeleteCharmInfo()
{
    if (!m_charmInfo)
        return;

    m_charmInfo->RestoreState();
    delete m_charmInfo;
    m_charmInfo = NULL;
}

CharmInfo::CharmInfo(Unit* unit)
#ifndef CROSS
: m_unit(unit), m_CommandState(COMMAND_FOLLOW), m_petnumber(0), m_barInit(false), m_CharmType(CharmType::CHARM_TYPE_CHARM),
#else /* CROSS */
: m_unit(unit), m_CommandState(COMMAND_FOLLOW), m_petnumber(0), m_barInit(false), m_CharmType(CharmType::CHARM_TYPE_CHARM), m_RealmPetNumber(0),
#endif /* CROSS */
  m_isCommandAttack(false), m_isAtStay(false), m_isFollowing(false), m_isReturning(false), m_IsMoveTo(false), m_IsMoveToStay(false),
  m_stayX(0.0f), m_stayY(0.0f), m_stayZ(0.0f)
{
    for (uint8 i = 0; i < MAX_SPELL_CHARM; ++i)
        m_charmspells[i].SetActionAndType(0, ACT_DISABLED);

    if (m_unit->GetTypeId() == TYPEID_UNIT)
    {
        m_oldReactState = m_unit->ToCreature()->GetReactState();
        m_unit->ToCreature()->SetReactState(REACT_PASSIVE);
    }
}

CharmInfo::~CharmInfo()
{
}

void CharmInfo::RestoreState()
{
    if (m_unit->GetTypeId() == TYPEID_UNIT)
        if (Creature* creature = m_unit->ToCreature())
            creature->SetReactState(m_oldReactState);
}

void CharmInfo::InitPetActionBar()
{
    // the first 3 SpellOrActions are attack, follow and move-to
    CommandStates l_Commands[] = { COMMAND_ATTACK, COMMAND_FOLLOW, COMMAND_MOVE_TO };
    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_START - ACTION_BAR_INDEX_START; ++i)
        SetActionBar(ACTION_BAR_INDEX_START + i, l_Commands[i], ACT_COMMAND);

    // middle 4 SpellOrActions are spells/special attacks/abilities
    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_END-ACTION_BAR_INDEX_PET_SPELL_START; ++i)
        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_START + i, 0, ACT_PASSIVE);

    // last 3 SpellOrActions are reactions
    ReactStates l_Reactions[] = { REACT_HELPER, REACT_DEFENSIVE, REACT_PASSIVE };
    for (uint32 i = 0; i < ACTION_BAR_INDEX_END - ACTION_BAR_INDEX_PET_SPELL_END; ++i)
        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + i, l_Reactions[i], ACT_REACTION);

    m_CharmType = CharmType::CHARM_TYPE_CHARM;
}

void CharmInfo::InitEmptyActionBar(bool withAttack)
{
    if (withAttack)
        SetActionBar(ACTION_BAR_INDEX_START, COMMAND_ATTACK, ACT_COMMAND);
    else
        SetActionBar(ACTION_BAR_INDEX_START, 0, ACT_PASSIVE);
    for (uint32 x = ACTION_BAR_INDEX_START+1; x < ACTION_BAR_INDEX_END; ++x)
        SetActionBar(x, 0, ACT_PASSIVE);

    m_CharmType = CharmType::CHARM_TYPE_CHARM;
}

void CharmInfo::InitPossessCreateSpells()
{
    InitEmptyActionBar();
    if (m_unit->GetTypeId() == TYPEID_UNIT)
    {
        for (uint32 i = 0; i < MAX_CREATURE_SPELLS; ++i)
        {
            uint32 spellId = m_unit->ToCreature()->m_spells[i];
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
            if (spellInfo && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD))
            {
                if (spellInfo->IsPassive())
                    m_unit->CastSpell(m_unit, spellInfo, true);
                else
                    AddSpellToActionBar(spellInfo, ACT_PASSIVE);
            }
        }
    }

    m_CharmType = CharmType::CHARM_TYPE_POSSESS;
}

void CharmInfo::InitCharmCreateSpells()
{
    if (m_unit->IsPlayer())                // charmed players don't have spells
    {
        InitEmptyActionBar();
        return;
    }

    InitPetActionBar();

    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
    {
        uint32 spellId = m_unit->ToCreature()->m_spells[x];
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);

        if (!spellInfo || spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD)
        {
            m_charmspells[x].SetActionAndType(spellId, ACT_DISABLED);
            continue;
        }

        if (spellInfo->IsPassive())
        {
            m_unit->CastSpell(m_unit, spellInfo, true);
            m_charmspells[x].SetActionAndType(spellId, ACT_PASSIVE);
        }
        else
        {
            m_charmspells[x].SetActionAndType(spellId, ACT_DISABLED);

            ActiveStates newstate = ACT_PASSIVE;

            if (!spellInfo->IsAutocastable())
                newstate = ACT_PASSIVE;
            else
            {
                if (spellInfo->NeedsExplicitUnitTarget())
                {
                    newstate = ACT_ENABLED;
                    ToggleCreatureAutocast(spellInfo, true);
                }
                else
                    newstate = ACT_DISABLED;
            }

            AddSpellToActionBar(spellInfo, newstate);
        }
    }
}

bool CharmInfo::AddSpellToActionBar(SpellInfo const* spellInfo, ActiveStates newstate)
{
    uint32 spell_id = spellInfo->Id;
    uint32 first_id = spellInfo->GetFirstRankSpell()->Id;

    // new spell rank can be already listed
    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
    {
        if (uint32 action = PetActionBar[i].GetAction())
        {
            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)
            {
                PetActionBar[i].SetAction(spell_id);
                return true;
            }
        }
    }

    // or use empty slot in other case
    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
    {
        if (!PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
        {
            SetActionBar(i, spell_id, newstate == ACT_DECIDE ? spellInfo->IsAutocastable() ? ACT_DISABLED : ACT_PASSIVE : newstate);
            return true;
        }
    }
    return false;
}

bool CharmInfo::RemoveSpellFromActionBar(uint32 spell_id)
{
    uint32 first_id = sSpellMgr->GetFirstSpellInChain(spell_id);

    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
    {
        if (uint32 action = PetActionBar[i].GetAction())
        {
            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)
            {
                SetActionBar(i, 0, ACT_PASSIVE);
                return true;
            }
        }
    }

    return false;
}

void CharmInfo::ToggleCreatureAutocast(SpellInfo const* spellInfo, bool apply)
{
    if (spellInfo->IsPassive())
        return;

    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
        if (spellInfo->Id == m_charmspells[x].GetAction())
            m_charmspells[x].SetType(apply ? ACT_ENABLED : ACT_DISABLED);
}

void CharmInfo::SetPetNumber(uint32 petnumber, bool statwindow)
{
#ifndef CROSS
    m_petnumber = petnumber;
#else /* CROSS */
    m_RealmPetNumber = petnumber;

    m_petnumber = sObjectMgr->GeneratePetNumber();
#endif /* CROSS */
    if (statwindow)
        m_unit->SetUInt32Value(UNIT_FIELD_PET_NUMBER, m_petnumber);
    else
        m_unit->SetUInt32Value(UNIT_FIELD_PET_NUMBER, 0);
}

void CharmInfo::LoadPetActionBar(const std::string& data)
{
    InitPetActionBar();

    Tokenizer tokens(data, ' ');

    if (tokens.size() != (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START) * 2)
        return;                                             // non critical, will reset to default

    uint8 index = ACTION_BAR_INDEX_START;
    Tokenizer::const_iterator iter = tokens.begin();
    for (; index < ACTION_BAR_INDEX_END; ++iter, ++index)
    {
        // use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion
        ActiveStates type  = ActiveStates(atol(*iter));
        ++iter;
        uint32 action = uint32(atol(*iter));

        PetActionBar[index].SetActionAndType(action, type);

        // check correctness
        if (PetActionBar[index].IsActionBarForSpell())
        {
            SpellInfo const* spelInfo = sSpellMgr->GetSpellInfo(PetActionBar[index].GetAction());
            if (!spelInfo)
                SetActionBar(index, 0, ACT_PASSIVE);
            else if (!spelInfo->IsAutocastable())
                SetActionBar(index, PetActionBar[index].GetAction(), ACT_PASSIVE);
        }
    }
}

void CharmInfo::BuildActionBar(WorldPacket* data)
{
    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(PetActionBar[i].packedData & 0x00FFFFFF);
        if (!spellInfo)
        {
            // Pet actions are not spell ID
            *data << uint32(PetActionBar[i].packedData);
            continue;
        }

        // This prevent to add spells with no cooldown - cheating !
        if (!spellInfo->CannotBeAddedToCharm())
        {
            *data << uint32(0x00FFFFFF);
            continue;
        }

        *data << uint32(PetActionBar[i].packedData);
    }
}

void CharmInfo::SetSpellAutocast(SpellInfo const* spellInfo, bool state)
{
    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
    {
        if (spellInfo->Id == PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
        {
            PetActionBar[i].SetType(state ? ACT_ENABLED : ACT_DISABLED);
            break;
        }
    }
}

bool Unit::isFrozen() const
{
    return HasAuraState(AURA_STATE_FROZEN);
}

struct ProcTriggeredData
{
    ProcTriggeredData(Aura* _aura)
        : aura(_aura)
    {
        effMask = 0;
        spellProcEvent = NULL;
    }
    SpellProcEventEntry const* spellProcEvent;
    Aura* aura;
    uint32 effMask;
};

typedef std::list< ProcTriggeredData > ProcTriggeredList;

// List of auras that CAN be trigger but may not exist in spell_proc_event
// in most case need for drop charges
// in some types of aura need do additional check
// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
bool InitTriggerAuraData()
{
    for (uint16 i = 0; i < TOTAL_AURAS; ++i)
    {
        isTriggerAura[i] = false;
        isNonTriggerAura[i] = false;
        isAlwaysTriggeredAura[i] = false;
    }
    isTriggerAura[SPELL_AURA_PROC_ON_POWER_AMOUNT] = true;
    isTriggerAura[SPELL_AURA_TRIGGER_ON_MODIFY_POWER] = true;
    isTriggerAura[SPELL_AURA_DUMMY] = true;
    isTriggerAura[SPELL_AURA_PERIODIC_DUMMY] = true;
    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;
    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;
    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura does not have charges but needs to be removed on trigger
    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;
    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;
    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;
    isTriggerAura[SPELL_AURA_MOD_STEALTH] = true;
    isTriggerAura[SPELL_AURA_MOD_FEAR] = true; // Aura does not have charges but needs to be removed on trigger
    isTriggerAura[SPELL_AURA_MOD_FEAR_2] = true; // Aura does not have charges but needs to be removed on trigger
    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;
    isTriggerAura[SPELL_AURA_MOD_ROOT_2] = true;
    isTriggerAura[SPELL_AURA_TRANSFORM] = true;
    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;
    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;
    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;
    isTriggerAura[SPELL_AURA_PROC_MELEE_TRIGGER_SPELL] = true;
    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;
    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK] = true;
    isTriggerAura[SPELL_AURA_SCHOOL_ABSORB] = true; // Savage Defense untested
    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;
    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;
    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;
    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;
    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;
    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;
    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;
    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;
    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;
    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;
    isTriggerAura[SPELL_AURA_MOD_MELEE_HASTE] = true;
    isTriggerAura[SPELL_AURA_MOD_MELEE_HASTE_3] = true;
    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE] = true;
    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE] = true;
    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE] = true;
    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER] = true;
    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK] = true;
    isTriggerAura[SPELL_AURA_MOD_SPELL_CRIT_CHANCE] = true;
    isTriggerAura[SPELL_AURA_ABILITY_IGNORE_AURASTATE] = true;
    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_COPY] = true;
    isTriggerAura[SPELL_AURA_HASTE_SPELLS] = true;
    isTriggerAura[SPELL_AURA_MOD_COOLDOWN] = true;
    isTriggerAura[SPELL_AURA_PERIODIC_DAMAGE] = true;
    isTriggerAura[SPELL_AURA_MOD_DECREASE_SPEED] = true;

    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN] = true;
    isNonTriggerAura[SPELL_AURA_REDUCE_PUSHBACK] = true;

    isAlwaysTriggeredAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR_2] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT_2] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_STUN] = true;
    isAlwaysTriggeredAura[SPELL_AURA_TRANSFORM] = true;
    isAlwaysTriggeredAura[SPELL_AURA_SPELL_MAGNET] = true;
    isAlwaysTriggeredAura[SPELL_AURA_SCHOOL_ABSORB] = true;
    isAlwaysTriggeredAura[SPELL_AURA_MOD_STEALTH] = true;

    return true;
}

uint32 createProcExtendMask(SpellNonMeleeDamage& l_DamageInfo, SpellMissInfo l_MissCondition)
{
    uint32 l_ProcEx = PROC_EX_NONE;
    // Check victim state
    if (l_MissCondition != SPELL_MISS_NONE)
        switch (l_MissCondition)
        {
            case SPELL_MISS_MISS:    l_ProcEx|=PROC_EX_MISS;   break;
            case SPELL_MISS_RESIST:  l_ProcEx|=PROC_EX_RESIST; break;
            case SPELL_MISS_DODGE:   l_ProcEx|=PROC_EX_DODGE;  break;
            case SPELL_MISS_PARRY:   l_ProcEx|=PROC_EX_PARRY;  break;
            case SPELL_MISS_BLOCK:   l_ProcEx|=PROC_EX_BLOCK;  break;
            case SPELL_MISS_EVADE:   l_ProcEx|=PROC_EX_EVADE;  break;
            case SPELL_MISS_IMMUNE:  l_ProcEx|=PROC_EX_IMMUNE; break;
            case SPELL_MISS_IMMUNE2: l_ProcEx|=PROC_EX_IMMUNE; break;
            case SPELL_MISS_DEFLECT: l_ProcEx|=PROC_EX_DEFLECT;break;
            case SPELL_MISS_ABSORB:  l_ProcEx|=PROC_EX_ABSORB; break;
            case SPELL_MISS_REFLECT: l_ProcEx|=PROC_EX_REFLECT;break;
            default:
                break;
        }
    else
    {
        // On block
        if (l_DamageInfo.GetBlock())
            l_ProcEx|=PROC_EX_BLOCK;
        // On absorb
        if (l_DamageInfo.GetAbsorb())
            l_ProcEx|=PROC_EX_ABSORB;
        // On crit
        if (l_DamageInfo.HitInfo & SPELL_HIT_TYPE_CRIT)
            l_ProcEx|=PROC_EX_CRITICAL_HIT;
        else
            l_ProcEx|=PROC_EX_NORMAL_HIT;
    }
    return l_ProcEx;
}

void Unit::ProcDamageAndSpellFor(bool p_IsVictim, Unit* p_Target, uint32 p_ProcFlag, uint32 p_ProcExtra, DamageInfo& p_DamageInfo, SpellInfo const* p_ProcAura, Aura const* p_ProcEffect)
{
    // Player is loaded now - do not allow passive spell casts to proc
    if (IsPlayer() && ToPlayer()->GetSession()->PlayerLoading())
        return;

    WeaponAttackType p_AttackType = p_DamageInfo.GetAttackType();
    SpellInfo const* p_ProcSpell = p_DamageInfo.GetSpellInfo();
    uint32 const p_Absorb = p_DamageInfo.GetAbsorb();
    uint32 const p_Damage = p_DamageInfo.GetAmount();

    // For melee/ranged based attack need update skills and set some Aura states if victim present
    if (p_ProcFlag & MELEE_BASED_TRIGGER_MASK && p_Target)
    {
        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)
        if (p_ProcExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))
        {
            // for victim
            if (p_IsVictim)
            {
                // if victim and dodge attack
                if (p_ProcExtra & PROC_EX_DODGE)
                {
                    // Update AURA_STATE on dodge
                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte
                    {
                        ModifyAuraState(AURA_STATE_DEFENSE, true);
                        StartReactiveTimer(REACTIVE_DEFENSE);
                    }
                }
                // if victim and parry attack
                if (p_ProcExtra & PROC_EX_PARRY)
                {
                    // For Hunters only Counterattack (skip Mongoose bite)
                    if (getClass() == CLASS_HUNTER)
                    {
                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
                        StartReactiveTimer(REACTIVE_HUNTER_PARRY);
                    }
                    else
                    {
                        ModifyAuraState(AURA_STATE_DEFENSE, true);
                        StartReactiveTimer(REACTIVE_DEFENSE);
                    }
                }
                // if and victim block attack
                if (p_ProcExtra & PROC_EX_BLOCK)
                {
                    ModifyAuraState(AURA_STATE_DEFENSE, true);
                    StartReactiveTimer(REACTIVE_DEFENSE);
                }
            }
        }
    }

    Unit* l_Actor = p_IsVictim ? p_Target : this;
    Unit* l_ActionTarget = !p_IsVictim ? p_Target : this;

    ProcEventInfo l_EventInfo = ProcEventInfo(l_Actor, l_ActionTarget, p_Target, p_ProcFlag, 0, 0, p_ProcExtra, &p_DamageInfo);

    uint32 l_Now = getMSTime();

    ProcTriggeredList l_ProcTriggered;
    // Fill procTriggered list
    for (AuraApplicationMap::const_iterator l_Itr = GetAppliedAuras().begin(); l_Itr!= GetAppliedAuras().end(); ++l_Itr)
    {
        // Do not allow auras to proc from effect triggered by itself
        if (p_ProcAura && p_ProcAura->Id == l_Itr->first)
            continue;
        ProcTriggeredData l_TriggerData(l_Itr->second->GetBase());

        // Defensive procs are active on absorbs (so absorption effects are not a hindrance)
        bool l_Active = (p_Damage + p_Absorb) || (p_ProcExtra & PROC_EX_BLOCK && p_IsVictim);
        if (p_IsVictim)
            p_ProcExtra &= ~PROC_EX_INTERNAL_REQ_FAMILY;

        // only auras that has triggered spell should proc from fully absorbed damage
        SpellInfo const* l_SpellProto = l_Itr->second->GetBase()->GetSpellInfo();
        if ((p_ProcExtra & PROC_EX_ABSORB && p_IsVictim) || (p_ProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG))
        {
            bool l_TriggerSpell = false;
            for (int l_SecondItr = 0; l_SecondItr < l_SpellProto->EffectCount; ++l_SecondItr)
                if (l_SpellProto->Effects[l_SecondItr].TriggerSpell)
                    l_TriggerSpell = true;

            if ((p_Damage + p_Absorb) || l_TriggerSpell)
                l_Active = true;
        }

        if (l_SpellProto->Id == 77606 && p_ProcSpell && p_ProcSpell->IsCanBeStolen())  ///< Dark Simulacrum
            l_Active = true;

        switch (l_SpellProto->Id)
        {
            case 167714: ///< Item - Druid T17 Restoration 4P Bonus - 167714
            case 214027: ///< Adaptation
            case 198020: ///< Turn The Tables
            case 212580: ///< Eye Of The Observer
            case 193539: ///< Alacrity
            case 193640: ///< Elaborate Planning
            case 137639: ///< Storm, Earth, and Fire
            case 212219: ///< Control is King
            case 208997: ///< Counterstrike Totem
            case 201472: ///< Rage Of The Illidari
            case 206902: ///< Petrichor Lagniappe
            case 233396: ///< Frost Strike
            case 208892: ///< Denial of the Half-Giants
            case 208436: ///< Shadow Satyr's Walk
            case 214147: ///< Spiritual Journey
            case 210867: ///< Runemaster's Pauldrons
            case 236478: ///< Oakheart's Puny Quods
            case 213680: ///< Guardian of Elune
            case 257470: ///< Eonar's Verdant Embrace
            case 257471: ///< Eonar's Verdant Embrace
            case 257472: ///< Eonar's Verdant Embrace
            case 257473: ///< Eonar's Verdant Embrace
            case 257474: ///< Eonar's Verdant Embrace
            case 257475: ///< Eonar's Verdant Embrace
                l_Active = true;
                break;
            case 205039: ///< Erosion (Mage)
                l_Active = (p_Damage + p_Absorb) > 0;
                break;
            default:
                break;
        }

        if (!IsTriggeredAtSpellProcEvent(p_Target, l_TriggerData.aura, p_ProcSpell, p_ProcFlag, p_ProcExtra, p_AttackType, p_IsVictim, l_Active, l_TriggerData.spellProcEvent))
            continue;

        // do checks using conditions table
        if (!sConditionMgr->IsObjectMeetingNotGroupedConditions(CONDITION_SOURCE_TYPE_SPELL_PROC, l_SpellProto->Id, l_EventInfo.GetActor(), l_EventInfo.GetActionTarget()))
            continue;

        // AuraScript Hook
        if (!l_TriggerData.aura->CallScriptCheckProcHandlers(l_Itr->second, l_EventInfo))
            continue;

        bool l_ProcSuccess = RollProcResult(p_Target, l_TriggerData.aura, l_EventInfo, p_IsVictim, l_TriggerData.spellProcEvent);
        l_TriggerData.aura->SetLastProcAttemptTime(l_Now);

        if (!l_ProcSuccess)
            continue;

        // Triggered spells not triggering additional spells
        bool l_Triggered = !(l_SpellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED) ?
            (p_ProcExtra & PROC_EX_INTERNAL_TRIGGERED && !(p_ProcFlag & PROC_FLAG_DONE_TRAP_ACTIVATION)) : false;

        for (uint8 l_SecondItr = 0; l_SecondItr < l_Itr->second->GetEffectCount(); ++l_SecondItr)
        {
            if (l_Itr->second->HasEffect(l_SecondItr))
            {
                AuraEffect* l_AuraEff = l_Itr->second->GetBase()->GetEffect(l_SecondItr);
                if (!l_AuraEff)
                    continue;

                if (l_AuraEff->GetAuraType() >= TOTAL_AURAS)
                {
                    sLog->outAshran("l_AuraEff->GetAuraType() >= TOTAL_AURAS spell %u", l_AuraEff->GetId());
                    continue;
                }

                bool l_Result = l_TriggerData.aura->CallScriptCheckEffectProcHandlers(l_AuraEff, l_Itr->second, l_EventInfo);

                if (l_Result)
                    l_TriggerData.effMask |= 1 << l_SecondItr;
                else
                {
                    // Skip this auras
                    if (isNonTriggerAura[l_AuraEff->GetAuraType()])
                        continue;
                    // If not trigger by default and spellProcEvent == NULL - skip
                    if (!isTriggerAura[l_AuraEff->GetAuraType()] && l_TriggerData.spellProcEvent == nullptr)
                        continue;
                    // Some spells must always trigger
                    if (!l_Triggered || isAlwaysTriggeredAura[l_AuraEff->GetAuraType()])
                        l_TriggerData.effMask |= 1 << l_SecondItr;
                }
            }
        }

        if (l_TriggerData.effMask)
            l_ProcTriggered.push_front(l_TriggerData);
    }

    // Nothing found
    if (l_ProcTriggered.empty())
        return;

    // Note: must SetCantProc(false) before return
    if (p_ProcExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
        SetCantProc(true);

    // Handle effects proceed this time
    for (ProcTriggeredList::const_iterator l_Itr = l_ProcTriggered.begin(); l_Itr != l_ProcTriggered.end(); ++l_Itr)
    {
        // look for aura in auras list, it may be removed while proc event processing
        if (l_Itr->aura->IsRemoved())
            continue;

        bool l_UseCharges  = l_Itr->aura->IsUsingCharges();
        // no more charges to use, prevent proc
        if (l_UseCharges && !l_Itr->aura->GetCharges())
            continue;

        bool l_TakeCharges = false;
        SpellInfo const* l_SpellInfo = l_Itr->aura->GetSpellInfo();

        AuraApplication const* l_AuraApplication = l_Itr->aura->GetApplicationOfTarget(GetGUID());

        bool l_Prepare = l_Itr->aura->CallScriptPrepareProcHandlers(l_AuraApplication, l_EventInfo);

        bool l_SkipCooldownCheck = false;
        if (l_SpellInfo->Id == 14190 && (p_ProcSpell && (p_ProcSpell->Id == 5374 || p_ProcSpell->Id == 27576))) ///< Seal Fate Has 0 cooldown to proc with mutilate)
            l_SkipCooldownCheck =  true;

        // For players set spell cooldown if need
        uint32 l_Cooldown = l_SpellInfo->InternalCooldown;
        if (l_Prepare && IsPlayer() && l_Itr->spellProcEvent && l_Itr->spellProcEvent->cooldown)
            l_Cooldown = l_Itr->spellProcEvent->cooldown * IN_MILLISECONDS;

        if (Player* l_Player = ToPlayer())
            l_Player->ApplySpellMod(l_SpellInfo->Id, SPELLMOD_PROC_COOLDOWN, l_Cooldown);

        if (!l_SkipCooldownCheck && (l_Now - l_Itr->aura->GetLastProcSuccessTime() < l_Cooldown))
            continue;

        l_Itr->aura->SetLastProcSuccessTime(l_Now);

        // Hack Fix : Stealth is not removed on absorb damage
        if (l_SpellInfo->HasAura(SPELL_AURA_MOD_STEALTH) && p_ProcExtra & PROC_EX_ABSORB && p_IsVictim)
            l_UseCharges = false;

        /// Hack Fix : Subterfuge aura can't be removed by any action
        if (l_SpellInfo->Id == 115191)
        {
            if (((!p_IsVictim && p_ProcExtra & PROC_EX_NORMAL_HIT) || p_IsVictim || p_ProcExtra & PROC_EX_INTERNAL_DOT) && !HasAura(115192) && !HasAura(131361) && !(p_ProcExtra & PROC_EX_ABSORB) && ((p_ProcSpell && p_ProcSpell->Id != 146347) || !p_ProcSpell))
            {
                /// Doesn't call Subterfuge from Drain Life and Touch of the Grave spells
                if ((p_ProcSpell && p_ProcSpell->Id != 146347 && p_ProcSpell->Id != 127802) || !p_ProcSpell)
                    CastSpell(this, 115192, true);
            }
        }

        // Note: must SetCantProc(false) before return
        if (l_SpellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)
            SetCantProc(true);

        l_Itr->aura->CallScriptProcHandlers(l_AuraApplication, l_EventInfo);


        // This bool is needed till separate aura effect procs are still here
        bool l_Handled = false;
        if (HandleAuraProc(p_Target, p_Damage, l_Itr->aura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown, &l_Handled))
            l_TakeCharges = true;

        if (!l_Handled)
        {
            for (uint8 l_EffectIndex = 0; l_EffectIndex < l_Itr->aura->GetEffectCount(); ++l_EffectIndex)
            {
                if (!(l_Itr->effMask & (1<<l_EffectIndex)))
                    continue;

                AuraEffect* l_TriggeredByAura = l_Itr->aura->GetEffect(l_EffectIndex);
                ASSERT(l_TriggeredByAura);

                bool l_Prevented = l_Itr->aura->CallScriptEffectProcHandlers(l_TriggeredByAura, l_AuraApplication, l_EventInfo);
                if (l_Prevented)
                {
                    l_TakeCharges = true;
                    continue;
                }

                bool l_IsCrowControlAura = false;
                bool l_DontContinue = false;

                switch (l_TriggeredByAura->GetAuraType())
                {
                    /// crowd control auras
                    case SPELL_AURA_MOD_FEAR:
                    case SPELL_AURA_MOD_STUN:
                    case SPELL_AURA_MOD_ROOT:
                    case SPELL_AURA_TRANSFORM:
                    case SPELL_AURA_MOD_FEAR_2:
                    case SPELL_AURA_MOD_ROOT_2:
                        l_IsCrowControlAura = true;
                        break;
                    default:
                        break;
                }

                if (!l_IsCrowControlAura && (l_TriggeredByAura->GetSpellInfo()->AuraInterruptFlags & SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_TAKE_DAMAGE_AMOUNT ||
                                             l_TriggeredByAura->GetSpellInfo()->Attributes & SpellAttr0::SPELL_ATTR0_BREAKABLE_BY_DAMAGE))
                {
                    l_IsCrowControlAura = true;
                    l_DontContinue      = true;
                }

                if (l_IsCrowControlAura)
                {
                    // CC Auras which use their amount amount to drop
                    // Are there any more auras which need this?
                    if (IsNoBreakingCC(p_IsVictim, p_Target, p_ProcFlag, p_ProcExtra, p_AttackType, p_ProcSpell, p_Damage, p_Absorb, p_ProcAura, l_SpellInfo))
                        continue;

                    uint32 l_CrowdControlTaken = p_Damage + p_Absorb;

                    // chargeable mods are breaking on hit
                    // Spell own direct damage at apply wont break the CC
                    if (p_ProcSpell && (p_ProcSpell->Id == l_TriggeredByAura->GetId()))
                    {
                        Aura* l_Aura = l_TriggeredByAura->GetBase();
                        // called from spellcast, should not have ticked yet
                        if (l_Aura->GetDuration() == l_Aura->GetMaxDuration())
                            continue;
                    }

                    // chargeable mods are breaking on hit
                    if (l_UseCharges)
                        l_TakeCharges = true;
                    else if (p_IsVictim && l_CrowdControlTaken)
                    {
                        int32 l_DamageLeft = l_TriggeredByAura->GetCrowdControlDamage();
                        // No damage left
                        if (l_DamageLeft <= int32(l_CrowdControlTaken) && l_TriggeredByAura->GetId() != 114052)
                        {
                            l_Itr->aura->Remove();
                            l_DontContinue = false;
                        }
                        else if (l_TriggeredByAura->GetId() != 114052)
                            l_TriggeredByAura->SetCrowdControlDamage(l_DamageLeft - l_CrowdControlTaken);
                    }

                    if (!l_DontContinue)
                        continue;
                }

                switch (l_TriggeredByAura->GetAuraType())
                {
                    case SPELL_AURA_PROC_MELEE_TRIGGER_SPELL:
                    {
                        // Don`t drop charge or add cooldown for not started trigger
                        if (HandleProcMeleeTriggerSpell(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_PROC_TRIGGER_SPELL:
                    {
                        // Don`t drop charge or add cooldown for not started trigger
                        if (HandleProcTriggerSpell(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_PROC_TRIGGER_DAMAGE:
                    {
                        // target has to be valid
                        if (!p_Target)
                            break;

                        uint32 l_NewDamage = p_Target->SpellDamageBonusTaken(this, l_SpellInfo, l_TriggeredByAura->GetAmount(), SPELL_DIRECT_DAMAGE, l_EffectIndex);
                        SpellNonMeleeDamage l_DamageInfo(this, p_Target, l_NewDamage, l_SpellInfo, SPELL_DIRECT_DAMAGE, l_Itr->aura->GetSpellXSpellVisualID());

                        CalculateSpellDamageTaken(l_DamageInfo);
                        DealDamageMods(l_DamageInfo);

                        SendSpellNonMeleeDamageLog(l_DamageInfo);
                        DealSpellDamage(l_DamageInfo, true);
                        l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_MANA_SHIELD:
                    case SPELL_AURA_DUMMY:
                    case SPELL_AURA_PROC_TRIGGER_SPELL_COPY:
                    {
                        if (p_IsVictim && p_ProcSpell && p_ProcSpell->Id == 108853 && l_TriggeredByAura->GetId() == 44448)
                            break;

                        if (SpellProcTriggered(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;

                        if (HandleDummyAuraProc(p_Target, &p_DamageInfo, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;

                        break;
                    }
                    case SPELL_AURA_PROC_ON_POWER_AMOUNT:
                    case SPELL_AURA_TRIGGER_ON_MODIFY_POWER:
                    {
                        if (HandleAuraProcOnPowerAmount(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_OBS_MOD_POWER:
                        if (HandleObsModEnergyAuraProc(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
                        if (HandleModDamagePctTakenAuraProc(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_MELEE_HASTE:
                    case SPELL_AURA_MOD_MELEE_HASTE_3:
                    {
                        if (HandleHasteAuraProc(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:
                    {
                        if (HandleOverrideClassScriptAuraProc(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_RAID_PROC_FROM_CHARGE:
                    {
                        HandleAuraRaidProcFromCharge(l_TriggeredByAura);
                        l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE:
                    {
                        if (HandleProcTriggerSpell(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK:
                        // Skip melee hits or instant cast spells
                        if (p_ProcSpell && p_ProcSpell->CalcCastTime() != 0)
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_REFLECT_SPELLS_SCHOOL:
                        // Skip Melee hits and spells ws wrong school
                        if (p_ProcSpell && (l_TriggeredByAura->GetMiscValue() & p_ProcSpell->SchoolMask))         // School check
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_SPELL_MAGNET:
                        // Skip Melee hits and targets with magnet aura
                        if (p_ProcSpell && (l_TriggeredByAura->GetBase()->GetUnitOwner()->ToUnit() == ToUnit()))         // Magnet
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:
                    case SPELL_AURA_MOD_POWER_COST_SCHOOL:
                        // Skip melee hits and spells ws wrong school or zero cost
                        if (p_ProcSpell &&
                            (p_ProcSpell->ManaCost != 0 || p_ProcSpell->ManaCostPercentage != 0) && // Cost check
                            (l_TriggeredByAura->GetMiscValue() & p_ProcSpell->SchoolMask))          // School check
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MECHANIC_IMMUNITY:
                        // Compare mechanic
                        if (p_ProcSpell && p_ProcSpell->Mechanic == uint32(l_TriggeredByAura->GetMiscValue()))
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_MECHANIC_RESISTANCE:
                        // Compare mechanic
                        if (p_ProcSpell && p_ProcSpell->Mechanic == uint32(l_TriggeredByAura->GetMiscValue()))
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_DAMAGE_FROM_CASTER:
                    case SPELL_AURA_MOD_DAMAGE_FROM_CASTER_BY_SCHOOLMASK:
                        // Compare casters
                        if (p_Target && l_TriggeredByAura->GetCasterGUID() == p_Target->GetGUID())
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
                        if (p_ProcSpell && HandleSpellCritChanceAuraProc(p_Target, p_Damage, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    case SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS:
                    case SPELL_AURA_ALLOW_CAST_WHILE_IN_COOLDOWN:
                    case SPELL_AURA_MOD_HEALING_RECEIVED:
                    {
                        if (!l_TriggeredByAura->IsAffectingSpell(p_ProcSpell) && !l_TriggeredByAura->IsAffectingSpell(p_ProcAura))
                            break;

                        SpellProcTriggered(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown);
                        l_TakeCharges = true;
                        break;
                    }
                    case SPELL_AURA_PERIODIC_HEAL:
                    {
                        if (SpellProcTriggered(p_Target, &p_DamageInfo, l_TriggeredByAura, p_ProcSpell, p_ProcFlag, p_ProcExtra, l_Cooldown))
                            l_TakeCharges = true;
                        break;
                    }
                    default:
                        // nothing do, just charges counter
                        l_TakeCharges = true;
                        break;
                } // switch (triggeredByAura->GetAuraType())

                l_Itr->aura->CallScriptAfterEffectProcHandlers(l_TriggeredByAura, l_AuraApplication, l_EventInfo);
            } // for (uint8 effIndex = 0; effIndex < SpellEffIndex::MAX_EFFECTS; ++effIndex)
        } // if (!handled)

        if (l_Itr->aura->GetId() == 79808 || l_Itr->aura->GetId() == 170571 || l_Itr->aura->GetId() == 170572)
            l_UseCharges = false;

        // Remove charge (aura can be removed by triggers)
        if (l_Prepare && l_UseCharges && l_TakeCharges && !l_Itr->aura->GetSpellInfo()->IsCustomCharged(p_ProcSpell, this))
        {
            l_Itr->aura->DropCharge();
        }
        l_Itr->aura->CallScriptAfterProcHandlers(l_AuraApplication, l_EventInfo);

        if (l_SpellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)
            SetCantProc(false);
    }

    // Cleanup proc requirements
    if (p_ProcExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
        SetCantProc(false);
}

bool Unit::IsNoBreakingCC(bool /*isVictim*/, Unit* target, uint32 procFlag, uint32 /*procExtra*/, WeaponAttackType /*attType*/, SpellInfo const* procSpell,
                          uint32 /*damage*/, uint32 /*absorb*/ /* = 0 */, SpellInfo const* /*procAura*/ /* = NULL */, SpellInfo const* spellInfo ) const
{
    // don't break on positive procs (heals, etc.)
    if (procFlag & POSITIVE_PROC_FLAG_MASK)
        return true;

    // Dragon Breath & Living Bomb
    if (spellInfo->GetCategory() == 1215 && procSpell &&
        procSpell->SpellFamilyName == SPELLFAMILY_MAGE && procSpell->SpellFamilyFlags[1] == 0x00010000)
        return true;

    // Main Gauche & Gouge
    if (procSpell && procSpell->Id == 86392 && spellInfo->Id == 1776)
        return true;

    /// Damage caused by Soul Rip, Shadow Nova, On the Trail, and Shadowy Apparition should no longer break control effects
    /// Eg. https://worldofwarcraft.com/en-us/news/20457825/patch-notes-world-of-warcraft-patch-7-1-5
    if (procSpell && (procSpell->Id == 220893 || procSpell->Id == 197800 || procSpell->Id == 204081 || procSpell->Id == 148859))
        return true;

    return false;
}

void Unit::GetProcAurasTriggeredOnEvent(std::list<AuraApplication*>& aurasTriggeringProc, std::list<AuraApplication*>* procAuras, ProcEventInfo eventInfo)
{
    // use provided list of auras which can proc
    if (procAuras)
    {
        for (std::list<AuraApplication*>::iterator itr = procAuras->begin(); itr!= procAuras->end(); ++itr)
        {
            ASSERT((*itr)->GetTarget() == this);
            if (!(*itr)->GetRemoveMode())
                if ((*itr)->GetBase()->IsProcTriggeredOnEvent(*itr, eventInfo))
                {
                    (*itr)->GetBase()->PrepareProcToTrigger(*itr, eventInfo);
                    aurasTriggeringProc.push_back(*itr);
                }
        }
    }
    // or generate one on our own
    else
    {
        for (AuraApplicationMap::iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)
        {
            if (itr->second->GetBase()->IsProcTriggeredOnEvent(itr->second, eventInfo))
            {
                itr->second->GetBase()->PrepareProcToTrigger(itr->second, eventInfo);
                aurasTriggeringProc.push_back(itr->second);
            }
        }
    }
}

void Unit::TriggerAurasProcOnEvent(CalcDamageInfo& p_DamageInfo)
{
    TriggerAurasProcOnEvent(NULL, NULL, p_DamageInfo.GetTarget(), p_DamageInfo.procAttacker, p_DamageInfo.procVictim, 0, 0, p_DamageInfo.procEx, NULL, &p_DamageInfo);
}

void Unit::TriggerAurasProcOnEvent(std::list<AuraApplication*>* p_MyProcAuras, std::list<AuraApplication*>* p_TargetProcAuras, Unit* p_ActionTarget, uint32 p_TypeMaskActor, uint32 p_TypeMaskActionTarget, uint32 p_SpellTypeMask, uint32 p_SpellPhaseMask, uint32 p_HitMask, Spell* p_Spell, DamageInfo* p_DamageInfo)
{
    // prepare data for self trigger
    ProcEventInfo l_MyProcEventInfo = ProcEventInfo(this, p_ActionTarget, p_ActionTarget, p_TypeMaskActor, p_SpellTypeMask, p_SpellPhaseMask, p_HitMask, p_DamageInfo);
    std::list<AuraApplication*> l_MyAurasTriggeringProc;
    GetProcAurasTriggeredOnEvent(l_MyAurasTriggeringProc, p_MyProcAuras, l_MyProcEventInfo);

    // prepare data for target trigger
    ProcEventInfo l_TargetProcEventInfo = ProcEventInfo(this, p_ActionTarget, this, p_TypeMaskActionTarget, p_SpellTypeMask, p_SpellPhaseMask, p_HitMask, p_DamageInfo);
    std::list<AuraApplication*> l_TargetAurasTriggeringProc;
    if (p_TypeMaskActionTarget)
        GetProcAurasTriggeredOnEvent(l_TargetAurasTriggeringProc, p_TargetProcAuras, l_TargetProcEventInfo);

    TriggerAurasProcOnEvent(l_MyProcEventInfo, l_MyAurasTriggeringProc);

    if (p_TypeMaskActionTarget)
        TriggerAurasProcOnEvent(l_TargetProcEventInfo, l_TargetAurasTriggeringProc);
}

void Unit::TriggerAurasProcOnEvent(ProcEventInfo& eventInfo, std::list<AuraApplication*>& aurasTriggeringProc)
{
    for (std::list<AuraApplication*>::iterator itr = aurasTriggeringProc.begin(); itr != aurasTriggeringProc.end(); ++itr)
    {
        if (!(*itr)->GetRemoveMode())
            (*itr)->GetBase()->TriggerProcOnEvent(*itr, eventInfo);
    }
}

SpellSchoolMask Unit::GetMeleeDamageSchoolMask() const
{
    return SPELL_SCHOOL_MASK_NORMAL;
}

bool Unit::IsWarlockPet() const
{
    uint32 l_Entry = GetEntry();
    return l_Entry == WarlockPet::Infernal ||
        l_Entry == WarlockPet::Abyssal ||
        l_Entry == WarlockPet::Imp ||
        l_Entry == WarlockPet::FellImp ||
        l_Entry == WarlockPet::VoidWalker ||
        l_Entry == WarlockPet::VoidLord ||
        l_Entry == WarlockPet::Succubus ||
        l_Entry == WarlockPet::Shivarra ||
        l_Entry == WarlockPet::FelHunter ||
        l_Entry == WarlockPet::Observer ||
        l_Entry == WarlockPet::FelGuard ||
        l_Entry == WarlockPet::WrathGuard ||
        l_Entry == WarlockPet::DoomGuard ||
        l_Entry == WarlockPet::TerrorGuard;
}

Player* Unit::GetSpellModOwner() const
{
    if (IsPlayer())
        return (Player*)this;
    if (ToCreature()->isPet() || ToCreature()->isTotem() || ToCreature()->isSummon() || ToCreature()->isGuardian())
    {
        Unit* owner = GetOwner();
        if (owner && owner->IsPlayer())
            return (Player*)owner;
    }
    return NULL;
}

///----------Pet responses methods-----------------

void Unit::SendPetCastFail(uint32 p_SpellID, SpellCastResult p_Result, uint8 p_CastCount, Guid128 p_CastId)
{
    if (p_Result == SPELL_CAST_OK)
        return;

    Unit * l_Owner = GetCharmerOrOwner();

    if (!l_Owner || l_Owner->GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data(SMSG_PET_CAST_FAILED, 16 + 4 + 4 + 4 + 4);
    l_Data.appendGuid128(p_CastId);                         ///< CastID
    l_Data << uint32(p_SpellID);                            ///< SpellID
    l_Data << uint32(p_Result);                             ///< Reason
    l_Data << uint32(0);                                    ///< FailedArg1
    l_Data << uint32(0);                                    ///< FailedArg2

    l_Owner->ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendPetActionFeedback(uint32 p_SpellID, uint8 p_Response)
{
    Unit* l_Owner = GetOwner();
    if (!l_Owner || l_Owner->GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data(SMSG_PET_ACTION_FEEDBACK, 1);
    l_Data << uint32(p_SpellID);
    l_Data << uint8(p_Response);

    l_Owner->ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendPetTalk(uint32 p_Action)
{
    Unit* l_Owner = GetOwner();
    if (!l_Owner || l_Owner->GetTypeId() != TYPEID_PLAYER)
        return;

    uint64 l_UnitGUID = GetGUID();

    WorldPacket l_Data(SMSG_PET_ACTION_SOUND, 16 + 2 + 4);
    l_Data.appendPackGUID(l_UnitGUID);      ///< UnitGUID
    l_Data << uint32(p_Action);             ///< Action
    l_Owner->ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendPetAIReaction(uint64 p_Guid)
{
    Unit * l_Owner = GetOwner();
    if (!l_Owner || l_Owner->GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data(SMSG_AI_REACTION, 16 + 2 + 4);
    l_Data.appendPackGUID(p_Guid);
    l_Data << uint32(AI_REACTION_HOSTILE);

    l_Owner->ToPlayer()->GetSession()->SendPacket(&l_Data);
}

///----------End of Pet responses methods----------

void Unit::StopMoving()
{
    ClearUnitState(UNIT_STATE_MOVING);

    // not need send any packets if not in world or not moving
    if (!IsInWorld() || movespline->Finalized())
        return;

    // Update position using old spline
    UpdateSplinePosition();
    Movement::MoveSplineInit l_Init(this);
    l_Init.Stop();
}

bool Unit::IsSitState() const
{
    uint8 s = getStandState();
    return
        s == UNIT_STAND_STATE_SIT_CHAIR        || s == UNIT_STAND_STATE_SIT_LOW_CHAIR  ||
        s == UNIT_STAND_STATE_SIT_MEDIUM_CHAIR || s == UNIT_STAND_STATE_SIT_HIGH_CHAIR ||
        s == UNIT_STAND_STATE_SIT;
}

bool Unit::IsStandState() const
{
    uint8 s = getStandState();
    return !IsSitState() && s != UNIT_STAND_STATE_SLEEP && s != UNIT_STAND_STATE_KNEEL;
}

void Unit::SetStandState(uint8 p_State)
{
    SetByteValue(UNIT_FIELD_ANIM_TIER, UNIT_BYTES_1_OFFSET_STAND_STATE, p_State);

    if (IsStandState())
       RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_SEATED);

    if (IsPlayer())
    {
        WorldPacket l_Update(SMSG_STANDSTATE_UPDATE, 5);
        l_Update << uint32(0);                              ///< AnimKit
        l_Update << (uint8)p_State;
        ToPlayer()->GetSession()->SendPacket(&l_Update);
    }
}

bool Unit::IsPolymorphed() const
{
    uint32 transformId = getTransForm();
    if (!transformId)
        return false;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(transformId);
    if (!spellInfo)
        return false;

    return spellInfo->GetSpellSpecific() == SpellSpecificType::SpellSpecificMagePolymorph;
}

void Unit::SetDisplayId(uint32 modelId)
{

    SetUInt32Value(UNIT_FIELD_DISPLAY_ID, modelId);

    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())
    {
        Pet* pet = ToPet();
        if (!pet->isControlled())
            return;
        Unit* owner = GetOwner();
        if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
            owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MODEL_ID);
    }
}

void Unit::RestoreDisplayId()
{
    AuraEffect* handledAura = nullptr;
    // try to receive model from transform auras
    Unit::AuraEffectList const& transforms = GetAuraEffectsByType(SPELL_AURA_TRANSFORM);
    if (!transforms.empty())
    {
        // iterate over already applied transform auras - from newest to oldest
        for (Unit::AuraEffectList::const_reverse_iterator i = transforms.rbegin(); i != transforms.rend(); ++i)
        {
            if (AuraApplication const* aurApp = (*i)->GetBase()->GetApplicationOfTarget(GetGUID()))
            {
                if (!handledAura)
                    handledAura = (*i);
                // prefer negative auras
                if (!aurApp->IsPositive())
                {
                    handledAura = (*i);
                    break;
                }
            }
        }
    }
    // transform aura was found
    if (handledAura)
        handledAura->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
    // we've found shapeshift
    else if (uint32 modelId = GetModelForForm(GetShapeshiftForm()))
        SetDisplayId(modelId);
    // no auras found - set modelid to default
    else
        SetDisplayId(GetNativeDisplayId());
}

void Unit::ClearAllReactives()
{
    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
        m_reactiveTimer[i] = 0;

    if (HasAuraState(AURA_STATE_DEFENSE))
        ModifyAuraState(AURA_STATE_DEFENSE, false);

    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);

    if (getClass() == CLASS_WARRIOR)
        ClearComboPoints();
}

void Unit::UpdateReactives(uint32 p_time)
{
    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
    {
        ReactiveType reactive = ReactiveType(i);

        if (!m_reactiveTimer[reactive])
            continue;

        if (m_reactiveTimer[reactive] <= p_time)
        {
            m_reactiveTimer[reactive] = 0;

            switch (reactive)
            {
                case REACTIVE_DEFENSE:
                    if (HasAuraState(AURA_STATE_DEFENSE))
                        ModifyAuraState(AURA_STATE_DEFENSE, false);
                    break;
                case REACTIVE_HUNTER_PARRY:
                    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
                    break;
                case REACTIVE_OVERPOWER:
                    if (getClass() == CLASS_WARRIOR)
                        ClearComboPoints();
                    break;
                default:
                    break;
            }
        }
        else
        {
            m_reactiveTimer[reactive] -= p_time;
        }
    }
}

void Unit::UpdateStackOnDuration(uint32 p_Time)
{
    for (AuraStackOnDurationMap::iterator l_Iter = m_StackOnDurationMap.begin(); l_Iter != m_StackOnDurationMap.end();)
    {
        StackOnDuration* l_Stack = GetStackOnDuration(l_Iter->first);

        std::vector<std::pair<uint64, int32>> l_StackDuration = l_Stack->GetStackDuration();

        bool l_MustContinue = false;
        uint8 l_Count = 0;
        for (std::pair<uint64, int32> l_StackParam : l_StackDuration)
        {
            if (l_StackParam.first <= p_Time)
            {
                if (l_StackDuration.size() <= 1)
                {
                    l_Iter = m_StackOnDurationMap.erase(l_Iter);
                    l_MustContinue = true;
                    break;
                }

                l_Stack->m_StackDuration.erase(l_Stack->m_StackDuration.begin() + l_Count);
                continue;
            }
            else
                l_Stack->DecreaseDuration(l_Count, p_Time);

            ++l_Count;
        }

        if (l_MustContinue)
            continue;

        ++l_Iter;
    }
}

void Unit::GetAreaTriggerListWithSpellIDInRange(std::list<AreaTrigger*>& p_List, uint32 p_SpellID, float p_Range, bool p_ClearOthers /*= true*/) const
{
    CellCoord l_Coords(JadeCore::ComputeCellCoord(GetPositionX(), GetPositionY()));
    Cell l_Cell(l_Coords);
    l_Cell.SetNoCreate();

    JadeCore::AnyAreatriggerInObjectRangeCheck l_Check(this, p_Range);
    JadeCore::AreaTriggerListSearcher<JadeCore::AnyAreatriggerInObjectRangeCheck> searcher(this, p_List, l_Check);

    TypeContainerVisitor<JadeCore::AreaTriggerListSearcher<JadeCore::AnyAreatriggerInObjectRangeCheck>, WorldTypeMapContainer> l_WorldSearcher(searcher);
    TypeContainerVisitor<JadeCore::AreaTriggerListSearcher<JadeCore::AnyAreatriggerInObjectRangeCheck>, GridTypeMapContainer>  l_GridSearcher(searcher);

    l_Cell.Visit(l_Coords, l_WorldSearcher, *GetMap(), *this, p_Range);
    l_Cell.Visit(l_Coords, l_GridSearcher, *GetMap(), *this, p_Range);

    if (!p_List.empty() && p_ClearOthers)
    {
        p_List.remove_if([p_SpellID](AreaTrigger* p_AreaTrigger) -> bool
        {
            if (p_AreaTrigger == nullptr || p_AreaTrigger->GetSpellId() != p_SpellID)
                return true;

            return false;
        });
    }

    return;
}

Unit* Unit::SelectNearbyTarget(Unit* exclude /*= NULL*/, float dist /*= NOMINAL_MELEE_RANGE*/, uint32 p_ExludeAuraID /*= 0*/, bool p_ExcludeVictim /*= true*/, bool p_Alive /*= true*/, bool p_ExcludeStealthVictim /*=false*/, bool p_CheckValidAttack /*= false*/) const
{
    std::list<Unit*> l_Targets;
    JadeCore::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);
    JadeCore::UnitListSearcher<JadeCore::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, l_Targets, u_check);
    VisitNearbyObject(dist, searcher);

    // remove current target
    if (!p_ExcludeVictim)
    {
        if (getVictim())
            l_Targets.remove(getVictim());
    }

    if (exclude)
        l_Targets.remove(exclude);

    // remove not LoS targets
    for (std::list<Unit*>::iterator tIter = l_Targets.begin(); tIter != l_Targets.end();)
    {
        if (!IsWithinLOSInMap(*tIter) || (*tIter)->isTotem() || (*tIter)->isSpiritService() || (*tIter)->GetCreatureType() == CREATURE_TYPE_CRITTER)
            l_Targets.erase(tIter++);
        else if (p_ExcludeStealthVictim && (*tIter)->HasStealthAura()) ///< Remove Stealth victim
            l_Targets.erase(tIter++);
        else if (p_CheckValidAttack && !IsValidAttackTarget(*tIter))
            l_Targets.erase(tIter++);
        else
            ++tIter;
    }

    // no appropriate targets
    if (l_Targets.empty())
        return nullptr;

    if (p_ExludeAuraID)
        l_Targets.remove_if(JadeCore::UnitAuraCheck(true, p_ExludeAuraID));

    // no appropriate targets
    if (l_Targets.empty())
        return nullptr;

    if (p_Alive)
    {
        l_Targets.remove_if([this](Unit* p_Unit) -> bool
        {
            if (!p_Unit)
                return true;

            if (p_Unit->isAlive())
                return false;

            return true;
        });
    }

    // no appropriate targets
    if (l_Targets.empty())
        return nullptr;

    // select random
    return JadeCore::Containers::SelectRandomContainerElement(l_Targets);
}

Unit* Unit::SelectNearbyAlly(Unit* exclude, float dist, bool p_CheckValidAssist /*= false*/) const
{
    std::list<Unit*> targets;
    JadeCore::AnyFriendlyUnitInObjectRangeCheck u_check(this, this, dist);
    JadeCore::UnitListSearcher<JadeCore::AnyFriendlyUnitInObjectRangeCheck> searcher(this, targets, u_check);
    VisitNearbyObject(dist, searcher);

    if (exclude)
        targets.remove(exclude);

    // remove not LoS targets
    for (std::list<Unit*>::iterator tIter = targets.begin(); tIter != targets.end();)
    {
        if (!IsWithinLOSInMap(*tIter) || (*tIter)->isTotem() || (*tIter)->isSpiritService() || (*tIter)->GetCreatureType() == CREATURE_TYPE_CRITTER)
            targets.erase(tIter++);
        else if (p_CheckValidAssist && !IsValidAssistTarget(*tIter))
            targets.erase(tIter++);
        else
            ++tIter;
    }

    // no appropriate targets
    if (targets.empty())
        return NULL;

    // select random
    return JadeCore::Containers::SelectRandomContainerElement(targets);
}

Unit* Unit::SelectNearbyMostInjuredAlly(Unit* p_Exclude /*= nullptr*/, float p_Dist /*= NOMINAL_MELEE_RANGE*/, uint32 p_ExcludeEntry /*= 0*/) const
{
    std::list<Unit*> l_Targets;
    JadeCore::AnyFriendlyUnitInObjectRangeCheck l_Check(this, this, p_Dist);
    JadeCore::UnitListSearcher<JadeCore::AnyFriendlyUnitInObjectRangeCheck> l_Searcher(this, l_Targets, l_Check);
    VisitNearbyObject(p_Dist, l_Searcher);

    if (p_Exclude)
        l_Targets.remove(p_Exclude);

    /// No appropriate targets
    if (l_Targets.empty())
        return nullptr;

    l_Targets.remove_if([this, p_ExcludeEntry](Unit* p_Unit) -> bool
    {
        if (p_Unit == nullptr)
            return true;

        if (!IsWithinLOSInMap(p_Unit) || p_Unit->isTotem() || p_Unit->isSpiritService())
            return true;

        if (p_Unit->GetCreatureType() == CreatureType::CREATURE_TYPE_CRITTER)
            return true;

        if (p_Unit->GetEntry() == p_ExcludeEntry)
            return true;

        return false;
    });

    /// No appropriate targets
    if (l_Targets.empty())
        return nullptr;

    l_Targets.sort(JadeCore::HealthPctOrderPred(true));

    /// Select most injured
    return l_Targets.front();
}

void Unit::ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply)
{
    float remainingTimePct = (float)m_attackTimer[att] / (GetAttackTime(att) * m_modAttackSpeedPct[att]);
    if (val > 0)
    {
        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], val, !apply);
        ApplyPercentModFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME+att, val, !apply);
    }
    else
    {
        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], -val, apply);
        ApplyPercentModFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME+att, -val, apply);
    }

    m_attackTimer[att] = uint32(GetAttackTime(att) * m_modAttackSpeedPct[att] * remainingTimePct);
}

void Unit::ApplyCastTimePercentMod(float val, bool apply)
{
    if (val > 0)
        ApplyPercentModFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, val, !apply);
    else
        ApplyPercentModFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, -val, apply);
}

float Unit::GetHastePct() const
{
    float l_HastePct = 0.0f;
    float l_ModHaste = GetFloatValue(UNIT_FIELD_MOD_HASTE);

    float l_Value = (l_ModHaste > 1.0f) ? (1.0f / l_ModHaste) : l_ModHaste;

    l_HastePct = 100.0f / l_Value - 100.0f;

    if (l_ModHaste > 1.0f)
        l_HastePct = -l_HastePct;

    return l_HastePct;
}

uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectType damagetype, uint32 CastingTime) const
{
    // Not apply this to creature casted spells with casttime == 0
    if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
        return 3500;

    if (CastingTime > 7000) CastingTime = 7000;
    if (CastingTime < 1500) CastingTime = 1500;

    if (damagetype == DOT && !spellProto->IsChanneled())
        CastingTime = 3500;

    int32 overTime    = 0;
    uint8 effects     = 0;
    bool DirectDamage = false;
    bool AreaEffect   = false;

    for (uint8 i = 0; i < spellProto->EffectCount; i++)
    {
        switch (spellProto->Effects[i].Effect)
        {
            case SPELL_EFFECT_SCHOOL_DAMAGE:
            case SPELL_EFFECT_POWER_DRAIN:
            case SPELL_EFFECT_HEALTH_LEECH:
            case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
            case SPELL_EFFECT_POWER_BURN:
            case SPELL_EFFECT_HEAL:
                DirectDamage = true;
                break;
            case SPELL_EFFECT_APPLY_AURA:
            case SPELL_EFFECT_APPLY_AURA_2:
            case SPELL_EFFECT_APPLY_AURA_ON_PET:
                switch (spellProto->Effects[i].ApplyAuraName)
                {
                    case SPELL_AURA_PERIODIC_DAMAGE:
                    case SPELL_AURA_PERIODIC_SCHOOL_DAMAGE:
                    case SPELL_AURA_PERIODIC_HEAL:
                    case SPELL_AURA_PERIODIC_LEECH:
                        if (spellProto->GetDuration())
                            overTime = spellProto->GetDuration();
                        break;
                    default:
                        // -5% per additional effect
                        ++effects;
                        break;
                }
            default:
                break;
        }

        if (spellProto->Effects[i].IsTargetingArea())
            AreaEffect = true;
    }

    // Combined Spells with Both Over Time and Direct Damage
    if (overTime > 0 && CastingTime > 0 && DirectDamage)
    {
        // mainly for DoTs which are 3500 here otherwise
        uint32 OriginalCastTime = spellProto->CalcCastTime();
        if (OriginalCastTime > 7000) OriginalCastTime = 7000;
        if (OriginalCastTime < 1500) OriginalCastTime = 1500;
        // Portion to Over Time
        float PtOT = (overTime / 15000.0f) / ((overTime / 15000.0f) + (OriginalCastTime / 3500.0f));

        if (damagetype == DOT)
            CastingTime = uint32(CastingTime * PtOT);
        else if (PtOT < 1.0f)
            CastingTime  = uint32(CastingTime * (1 - PtOT));
        else
            CastingTime = 0;
    }

    // Area Effect Spells receive only half of bonus
    if (AreaEffect)
        CastingTime /= 2;

    // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
    for (uint8 j = 0; j < spellProto->EffectCount; ++j)
    {
        if (spellProto->Effects[j].Effect == SPELL_EFFECT_HEALTH_LEECH ||
            ((spellProto->Effects[j].IsApplyingAura()) && spellProto->Effects[j].ApplyAuraName == SPELL_AURA_PERIODIC_LEECH))
        {
            CastingTime /= 2;
            break;
        }
    }

    // -5% of total per any additional effect
    for (uint8 i = 0; i < effects; ++i)
        CastingTime *= 0.95f;

    return CastingTime;
}

void Unit::UpdateAuraForGroup(uint8 p_Slot, bool p_Apply)
{
    if (p_Slot >= MAX_AURAS)                        // slot not found, return
        return;

    if (Player* player = ToPlayer())
    {
        if (player->GetGroup())
        {
            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AURAS);
            player->SetAuraUpdateMaskForRaid(p_Slot, p_Apply);
        }
    }
    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())
    {
        Pet* pet = ((Pet*)this);
        if (pet->isControlled())
        {
            Unit* owner = GetOwner();
            if (owner && (owner->IsPlayer()) && owner->ToPlayer()->GetGroup())
            {
                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);
                pet->SetAuraUpdateMaskForRaid(p_Slot, p_Apply);
            }
        }
    }
}

float Unit::CalculateDefaultCoefficient(SpellInfo const *spellInfo, DamageEffectType damagetype) const
{
    // Damage over Time spells bonus calculation
    float DotFactor = 1.0f;
    if (damagetype == DOT)
    {

        int32 DotDuration = spellInfo->GetDuration();
        if (!spellInfo->IsChanneled() && DotDuration > 0)
            DotFactor = DotDuration / 15000.0f;

        if (uint32 DotTicks = spellInfo->GetMaxTicks())
            DotFactor /= DotTicks;
    }

    int32 CastingTime = spellInfo->IsChanneled() ? spellInfo->GetDuration() : spellInfo->CalcCastTime();
    // Distribute Damage over multiple effects, reduce by AoE
    CastingTime = GetCastingTimeForBonus(spellInfo, damagetype, CastingTime);

    // As wowwiki says: C = (Cast Time / 3.5)
    return (CastingTime / 3500.0f) * DotFactor;
}

float Unit::GetAPMultiplier(WeaponAttackType attType, bool normalized)
{
    if (!normalized || GetTypeId() != TYPEID_PLAYER)
        return float(GetAttackTime(attType)) / 1000.0f;

    Item* Weapon = ToPlayer()->GetWeaponForAttack(attType, true);
    if (!Weapon)
        return 2.4f;                                         // fist attack

    switch (Weapon->GetTemplate()->InventoryType)
    {
        case INVTYPE_2HWEAPON:
            return 3.3f;
        case INVTYPE_RANGED:
        case INVTYPE_RANGEDRIGHT:
        case INVTYPE_THROWN:
            return 2.8f;
        case INVTYPE_WEAPON:
        case INVTYPE_WEAPONMAINHAND:
        case INVTYPE_WEAPONOFFHAND:
        default:
            return Weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ? 1.7f : 2.4f;
    }
}

void Unit::SetContestedPvP(Player* attackedPlayer)
{
    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();

    if (!player || (attackedPlayer && (attackedPlayer == player || (player->m_Duel && player->m_Duel->opponent == attackedPlayer))))
        return;

    player->SetContestedPvPTimer(30000);
    if (!player->HasUnitState(UNIT_STATE_ATTACK_PLAYER))
    {
        player->AddUnitState(UNIT_STATE_ATTACK_PLAYER);
        player->SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
        // call MoveInLineOfSight for nearby contested guards
        UpdateObjectVisibility();
    }
    if (!HasUnitState(UNIT_STATE_ATTACK_PLAYER))
    {
        AddUnitState(UNIT_STATE_ATTACK_PLAYER);
        // call MoveInLineOfSight for nearby contested guards
        UpdateObjectVisibility();
    }
}

void Unit::AddPetAura(PetAura const* petSpell)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    m_petAuras.insert(petSpell);
    if (Pet* pet = ToPlayer()->GetPet())
        pet->CastPetAura(petSpell);
}

void Unit::RemovePetAura(PetAura const* petSpell)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    m_petAuras.erase(petSpell);
    if (Pet* pet = ToPlayer()->GetPet())
        pet->RemoveAurasDueToSpell(petSpell->GetAura(pet->GetEntry()));
}

Pet* Unit::CreateTamedPetFrom(Creature* creatureTarget, uint32 spell_id)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return NULL;

    Pet* pet = new Pet((Player*)this, HUNTER_PET);

    auto& l_Phases = GetPhases();
    if (!pet->CreateBaseAtCreature(creatureTarget, l_Phases))
    {
        pet->CleanBeforeGC();
        sGarbageCollector->Add(pet);
        return NULL;
    }

    uint8 level = creatureTarget->getLevel() + 5 < getLevel() ? (getLevel() - 5) : creatureTarget->getLevel();

    InitTamedPet(pet, level, spell_id);

    return pet;
}

Pet* Unit::CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return NULL;

    CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(creatureEntry);
    if (!creatureInfo)
        return NULL;

    Pet* pet = new Pet((Player*)this, HUNTER_PET);

    if (!pet->CreateBaseAtCreatureInfo(creatureInfo, this) || !InitTamedPet(pet, getLevelForTarget(pet), spell_id))
    {
        pet->CleanBeforeGC();
        sGarbageCollector->Add(pet);
        return NULL;
    }

    return pet;
}

bool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)
{
    pet->SetCreatorGUID(GetGUID());
    pet->setFaction(getFaction());
    pet->SetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL, spell_id);

    if (IsPlayer())
        pet->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);

    if (!pet->InitStatsForLevel(level))
    {
        sLog->outError(LOG_FILTER_UNITS, "Pet::InitStatsForLevel() failed for creature (Entry: %u)!", pet->GetEntry());
        return false;
    }

#ifndef CROSS
    pet->GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);
#else /* CROSS */
    uint32 l_PetNumber = InterRealmClient::GetIRClient(pet->GetOwner())->GenerateLocalRealmLowGuid(HIGHGUID_PET_NUMBER);
    if (l_PetNumber == 0)
        return false;

    pet->GetCharmInfo()->SetPetNumber(l_PetNumber, true);
#endif /* CROSS */
    // this enables pet details window (Shift+P)
    pet->InitPetCreateSpells();
    //pet->InitLevelupSpellsForLevel();
    pet->SetFullHealth();
    return true;
}

void Unit::CalculateFromDummy(Unit* victim, float &amount, SpellInfo const* spellProto, uint32 mask, SpellAuraDummyType type) const
{
    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Unit::CalculateFromDummy start GetId %i, amount %f, mask %i type %u", spellProto->Id, amount, mask, type);

    if (std::vector<SpellAuraDummy> const* spellAuraDummy = sSpellMgr->GetSpellAuraDummy(spellProto->Id))
    {
        for (std::vector<SpellAuraDummy>::const_iterator itr = spellAuraDummy->begin(); itr != spellAuraDummy->end(); ++itr)
        {
            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Unit::CalculateFromDummy spellDummyId %i, effectmask %i, option %i, aura %i, type %i", itr->SpellDummyID, itr->EffectMask, itr->Options, itr->Aura, itr->Type);

            if (itr->Type != type) // default 0, damage 1, crit 2, time 3, proc 4, duration 5
                continue;

            if (!(itr->EffectMask & mask))
                continue;

            Unit* _caster = const_cast<Unit*>(this);
            Unit* _targetAura = const_cast<Unit*>(this);
            Unit* _target = victim;
            bool check = false;

            if (itr->Caster == 1 && victim) //get caster as target
                _caster = victim;

            if (itr->TargetAura == 2 && victim) //get target aura
                _targetAura = victim;

            if (itr->Caster == 3) //get caster owner
                if (Unit* owner = GetOwner())
                    _caster = owner;

            if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                continue;
            if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                continue;

            Aura* _aura = _caster->GetAura(abs(itr->SpellDummyID), _targetAura->GetGUID());

            switch (itr->Options)
            {
                case SPELL_DUMMY_CRIT_RESET: //5
                {
                    if (itr->SpellDummyID > 0 && !_aura)
                    {
                        amount = 0.0f;
                        check = true;
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        amount = 0.0f;
                        check = true;
                    }
                    break;
                }
                case SPELL_DUMMY_CRIT_ADD_PERC: //6
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount += CalculatePct(amount, bp);
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount -= CalculatePct(amount, bp);
                            check = true;
                        }
                    }
                    break;
                }
                case SPELL_DUMMY_CRIT_ADD_VALUE: //7
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount += bp;
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount -= bp;
                            check = true;
                        }
                    }
                    break;
                }
                case SPELL_DUMMY_DAMAGE_ADD_PERC: //9
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount += CalculatePct(amount, bp);
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount -= CalculatePct(amount, bp);
                            check = true;
                        }
                    }
                    break;
                }
                case SPELL_DUMMY_DAMAGE_ADD_VALUE: //10
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount += bp;
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (AuraEffect const* dummyEff = _aura->GetEffect(itr->EffectDummy))
                        {
                            float bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyEff->GetAmount();
                            amount -= bp;
                            check = true;
                        }
                    }
                    break;
                }
            }

            if (check && itr->RemoveAura)
                _caster->RemoveAurasDueToSpell(itr->RemoveAura);
        }
    }

    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Unit::CalculateFromDummy end GetId %i, amount %f", spellProto->Id, amount);
}

void Unit::CalculateCastTimeFromDummy(int32& castTime, SpellInfo const* spellProto)
{
    if (std::vector<SpellAuraDummy> const* spellAuraDummy = sSpellMgr->GetSpellAuraDummy(spellProto->Id))
    {
        for (std::vector<SpellAuraDummy>::const_iterator itr = spellAuraDummy->begin(); itr != spellAuraDummy->end(); ++itr)
        {
            if (itr->Type != SPELL_DUMMY_TIME) // type = 3
                continue;

            Unit* _caster = this;
            Unit* _targetAura = this;
            bool check = false;

            if (itr->Caster == 2 && _caster->ToPlayer()) //get target pet
            {
                if (Pet* pet = _caster->ToPlayer()->GetPet())
                    _caster = (Unit*)pet;
            }
            if (itr->Caster == 3) //get target owner
            {
                if (Unit* owner = _caster->GetOwner())
                    _caster = owner;
            }

            if (itr->TargetAura == 1 && _caster->ToPlayer()) //get target pet
            {
                if (Pet* pet = _caster->ToPlayer()->GetPet())
                    _targetAura = (Unit*)pet;
            }
            if (itr->TargetAura == 2) //get target owner
            {
                if (Unit* owner = _caster->GetOwner())
                    _targetAura = owner;
            }

            if (itr->Aura > 0 && !_targetAura->HasAura(itr->Aura))
                continue;
            if (itr->Aura < 0 && _targetAura->HasAura(abs(itr->Aura)))
                continue;

            Aura* _aura = _caster->GetAura(abs(itr->EffectDummy), _targetAura->GetGUID());

            switch (itr->Options)
            {
                case SPELL_DUMMY_CASTTIME_ADD_PERC: //13
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (SpellInfo const* dummyInfo = sSpellMgr->GetSpellInfo(itr->SpellDummyID))
                        {
                            int32 bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyInfo->Effects[itr->EffectDummy].BasePoints;

                            castTime += CalculatePct(castTime, bp);
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (SpellInfo const* dummyInfo = sSpellMgr->GetSpellInfo(abs(itr->SpellDummyID)))
                        {
                            int32 bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyInfo->Effects[itr->EffectDummy].BasePoints;
                            castTime -= CalculatePct(castTime, bp);
                            check = true;
                        }
                    }
                    break;
                }
                case SPELL_DUMMY_CASTTIME_ADD_VALUE: //14
                {
                    if (itr->SpellDummyID > 0 && _aura)
                    {
                        if (SpellInfo const* dummyInfo = sSpellMgr->GetSpellInfo(itr->SpellDummyID))
                        {
                            int32 bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyInfo->Effects[itr->EffectDummy].BasePoints;
                            castTime += bp;
                            check = true;
                        }
                    }
                    if (itr->SpellDummyID < 0 && _aura)
                    {
                        if (SpellInfo const* dummyInfo = sSpellMgr->GetSpellInfo(abs(itr->SpellDummyID)))
                        {
                            int32 bp = itr->CustomBP;
                            if (!bp)
                                bp = dummyInfo->Effects[itr->EffectDummy].BasePoints;
                            castTime -= bp;
                            check = true;
                        }
                    }
                    break;
                }
            }

            if (check && itr->RemoveAura)
                _caster->RemoveAurasDueToSpell(itr->RemoveAura);
        }
    }
}

bool Unit::IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const* & spellProcEvent)
{
    SpellInfo const* spellProto = aura->GetSpellInfo();

    // let the aura be handled by new proc system if it has new entry
    if (sSpellMgr->GetSpellProcEntry(spellProto->Id))
        return false;

    // Get proc Event Entry
    spellProcEvent = sSpellMgr->GetSpellProcEvent(spellProto->Id);

    // Get EventProcFlag
    uint32 EventProcFlag;
    if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags
        EventProcFlag = spellProcEvent->procFlags;
    else
        EventProcFlag = spellProto->ProcFlags;       // else get from spell proto
    // Continue if no trigger exist
    if (!EventProcFlag)
        return false;

    // Additional checks for triggered spells (ignore trap casts)
    if (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION))
    {
        /// HACK:
        /// There are triggered damage spells that should trigger CC auras
        /// Need to find out more spells (maybe all damaging?)
        bool l_ProcByTriggeredDamage = procSpell != nullptr
            && procSpell->Id == 209885 ///< Premonition
            && spellProto->_IsCrowdControl();

        if (!l_ProcByTriggeredDamage && !(spellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED))
            return false;
    }

    // Check spellProcEvent data requirements
    if (!sSpellMgr->IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, active, spellProto))
    {
        if (!spellProto)
            return false;

        if (!procSpell)
        {
            switch (spellProto->Id)
            {
                case 213602: ///< Greater Fade
                    return true;
                case 207278: ///< Arcane Lockdown (Patrol Captain Gerdo - Court of Stars)
                case 212993: ///< Shimmering Feather (Elerethe Renferal - Emerald Nightmare)
                {
                    /// Must proc only from jumps
                    if (!(procFlag & PROC_FLAG_JUMP))
                        return false;

                    return true;
                }
                case 239932: ///< Felclaws - Kil'jaeden
                    if (procFlag & ProcFlags::PROC_FLAG_DONE_MAINHAND_ATTACK)
                        return true;
                    return false;
                default:
                    return false;
            }
        }

        switch (spellProto->Id)
        {
            case 238092: /// < Fragile Echoes - 225298
                if (procSpell->Id == 84714)
                    return true;
                return false;
            case 225298: /// < Fragile Echoes - 225298
                if (procSpell->Id == 17 || procSpell->Id == 124682 || procSpell->Id == 8536)
                    return true;
                return false;
            case 214027:
                if (procSpell->Id == 2094 || procSpell->Id == 187650)
                    return true;
                return false;
            case 157504:
                if (procSpell->Id == 208981)
                    return true;
                return false;
            case 216519:
                if ((procFlag & PROC_FLAG_TAKEN_PERIODIC) && (procExtra & PROC_EX_INTERNAL_HOT))
                    return true;
                return false;
            case 53651:
            case 177173:
                if ((procSpell->Id == 223306 || procSpell->Id == 119952) && isVictim)  ///< Hack fix Bestow Faith and Light's Hammer (Arcing Light) should proc Beacon of Light or Beacon of Faith. adding a check on isVictim to avoid double procs
                    return true;
                return false;
            case 206397:
                if (procSpell->Id == 44614) ///< Hack fix Flurry can always Trigger Zann'esu Journey
                    return true;
                return false;
            case 44448:
                if (procSpell->Id == 108853 || procSpell->Id == 11366) ///< Fire Blast, Combustion and Pyroblast can Trigger Pyroblast!
                    return true;
                return false;
            case 121152:
                if (procSpell->Id == 1329) ///< Hack fix Mutilate can Trigger Blindside
                    return true;
                return false;
            case 193884:
                if (procSpell->Id == 116694 && !isVictim) ///< Effuse with shooting mist, adding a check on isVictim to avoid double procs
                    return true;
                return false;
            case 76669:
                if (procSpell->Id == 156322) ///< Eternal flame dot should proc on Illuminated healing
                    return true;
                return false;
            case 108446:
                if (!procSpell->IsPositive()) ///< Soul link should proc on every damage that warlock deal
                    return true;
                return false;
            case 197160:
                if (procSpell->Id == 186265) ///< Mimiron's Shell with Aspect of the Turtle
                    return true;
                return false;
            case 198807:
                if (procSpell->Id == 100) ///< Charge should trigger Shadow of the Colossus
                    return true;
                return false;
            case 209566:
                if (procSpell->Id == 1719 && (victim->GetGUID() == this->GetGUID())) ///< Battle Cry Should trigger Corrupted Blood of Zakajz OF THE SAME PLAYER (7.1.5 - Build 23420)
                    return true;
                return false;
            case 202746:
                if (procSpell->Id == 5384) ///< Feign Death should trigger Survival Tactics
                    return true;
                return false;
            case 198265:
                if (procSpell->Id == 193316) /// Roll The Bones should trigger Take Your Cut
                    return true;
                return false;
            case 197406:
                if (procSpell->Id == 195452) ///Nightblade should trigger Finality: Nightblade
                    return true;
                return false;
            case 213981:
                if (procSpell->Id == 1833) /// Cheap shot should trigger Cold Blood
                    return true;
                return false;
            case 193213:
                if (procSpell->Id == 55233) /// Vampire Blood should trigger Umbilicus Eternus
                    return true;
                return false;
            case 215068:
                if (procSpell->Id == 63560) /// Dark Transformation should trigger Tak'theritrix's Command
                    return true;
                return false;
            case 165459: ///< Pyroblast! must make T17 fire 4P bonus procs!
                if (procSpell->Id == 48108)
                    break; ///< Should be calculated in PPM calculation
                return false;
            case 165476: ///< Arcane Charge must make T17 arcane 4P bonus procs!
                if (procSpell->Id != 36032)
                    break; ///< Should be calculated in PPM calculation
                return false;
            case 213610: ///< Holy ward must proc with Imprison and cyclone
                if (procSpell->Id == 221527 || procSpell->Id == 33786)
                    return true;
                return true;
            case 200986: ///< Whirlwind, Rampage, Raging Blow should proc Odyns Champion but only once
                if ((procSpell->Id == 190411 && !isVictim) || procSpell->Id == 184367 || procSpell->Id == 85288)
                    return true;
                return false;
            case 194310: ///< Crypt Fever should proc on HOT
                if ((procFlag & PROC_FLAG_TAKEN_PERIODIC) && (procExtra & PROC_EX_INTERNAL_HOT))
                {
                    if (time(NULL) - m_SpellHelper.GetUint32(eSpellHelpers::CryptFever) < 3)
                        return false;

                    return true;
                }
                return false;
            case 225128: ///< Nightwell Tranquility
            case 229670: ///< Nightwell Tranquility
                /// It should proc by casting HoTs
                if ((procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) && procSpell->HasAura(AuraType::SPELL_AURA_PERIODIC_HEAL))
                    return true;
                return false;
            case 41635: ///< Hackfix Prayer of Mending vs Varimathras torment
                if (procSpell->Id == 243967 || procSpell->Id == 243976 || procSpell->Id == 243979)
                    return true;
                return false;
            case 242541: ///< Chalice of Moonlight
                if ((procFlag & ProcFlags::PROC_FLAG_TAKEN_PERIODIC) && (procExtra & ProcFlagsExLegacy::PROC_EX_INTERNAL_HOT))
                    return true;
                return false;
            case 242269: ///< Priest Tos 4p T20 must proc on PW : Shield
                if (procSpell->Id == 17)
                    return true;
                return false;
            case 242271: ///< Priest Tos 4p T20 Holy must proc on HW: Sanctify even if it hits 0 ally
                if (procSpell->Id == 34861)
                    return true;
                return false;
            case 155783: ///< Mastery: Nature's Guardian
                if (procSpell->IsPositive())
                    return true;
                return false;
            default:
                return false;
        }
    }

    // In most cases req get honor or XP from kill
    if (EventProcFlag & PROC_FLAG_KILL && IsPlayer())
    {
        bool allow = false;
        if (victim)
        {
            allow = ToPlayer()->isHonorOrXPTarget(victim);
            if (spellProto->Id == 216722) ///< Souls of the Damned (on kill proc) doesn't need honor or XP target
                allow = true;
            if (spellProto->Id == 201350) ///< Well Fed (on kill proc) doesn't need honor or XP target
            {
                if (victim->GetTypeId() == TYPEID_UNIT)
                {
                    if (!victim->ToCreature()->isTotem() &&
                        !victim->ToCreature()->isStatue() &&
                        !(victim->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL))
                        allow = true;
                }
            }
        }

        if (!allow)
            return false;
    }
    // Aura added by spell can`t trigger from self (prevent drop charges/do triggers)
    // But except periodic and kill triggers (can triggered from self)
    if (procSpell && procSpell->Id == spellProto->Id
        && !(spellProto->ProcFlags&(PROC_FLAG_TAKEN_PERIODIC | PROC_FLAG_KILL)))
        return false;

    // Check if current equipment allows aura to proc
    if (!isVictim && IsPlayer())
    {
        Player* player = ToPlayer();
        if (spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)
        {
            Item* item = NULL;
            if (attType == WeaponAttackType::BaseAttack || attType == WeaponAttackType::RangedAttack)
                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
            else if (attType == WeaponAttackType::OffAttack)
                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

            if (player->IsInFeralForm())
                return false;

            if (!item || item->CantBeUse() || item->GetTemplate()->Class != ITEM_CLASS_WEAPON || (spellProto->EquippedItemSubClassMask != 0 && !((1 << item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask)))
                return false;
        }
        else if (spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)
        {
            // Check if player is wearing shield
            Item* item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
            if (!item || item->CantBeUse() || item->GetTemplate()->Class != ITEM_CLASS_ARMOR || (spellProto->EquippedItemSubClassMask != 0 && !((1 << item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask)))
                return false;
        }

        // Check if you can proc on this target
        if (victim && IsPlayer() && victim->IsPlayer() && (procFlag & EventProcFlag & DONE_NEGATIVE_PROC_FLAG_MASK))
        {
            if ((procExtra & (PROC_EX_NORMAL_HIT | PROC_EX_CRITICAL_HIT)) && active && victim->ToPlayer()->IsFriendlyTo(this))
            {
                if (!(((procFlag & EventProcFlag & DONE_NEGATIVE_PROC_FLAG_MASK) == PROC_FLAG_DONE_PERIODIC) && procSpell->IsPositive()))
                    return false;
            }
        }
    }

    return true;
}

bool Unit::RollProcResult(Unit* victim, Aura* aura, ProcEventInfo & p_ProcEventInfo, bool isVictim, SpellProcEventEntry const* spellProcEvent)
{
    SpellInfo const* spellInfo = aura->GetSpellInfo();

    // Get chance from spell
    float chance = float(spellInfo->ProcChance);
    // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
    if (spellProcEvent && spellProcEvent->customChance)
        chance = spellProcEvent->customChance;
    // If PPM exist calculate chance from PPM
    float procsPerMinute = spellInfo->ProcBasePPM;
    if (spellProcEvent && spellProcEvent->ppmRate != 0.0f)
        procsPerMinute = spellProcEvent->ppmRate;

    if (procsPerMinute != 0.0f)
    {
        // Apply chance modifer aura
        if (spellInfo)
            if (Player* l_ModOwner = GetSpellModOwner())
                l_ModOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_PROC_PER_MINUTE, procsPerMinute);

        aura->CallScriptCalcPPMRate(procsPerMinute, p_ProcEventInfo);

        chance = aura->CalcPPMProcChance(procsPerMinute, this);
    }

    // Apply chance modifer aura
    if (Player* modOwner = GetSpellModOwner())
        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);

    aura->CallScriptCalcProcChance(chance, p_ProcEventInfo);

    return roll_chance_f(chance);
}

bool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)
{
    // aura can be deleted at casts
    SpellInfo const* spellProto = triggeredByAura->GetSpellInfo();

    uint32 damageSpellId;
    switch (spellProto->Id)
    {
        case 57949:            // shiver
            damageSpellId = 57952;
            //animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
            break;
        case 59978:            // shiver
            damageSpellId = 59979;
            break;
        case 43593:            // Cold Stare
            damageSpellId = 43594;
            break;
        default:
            return false;
    }

    uint64 caster_guid = triggeredByAura->GetCasterGUID();

    // jumps
    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;

    // current aura expire
    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease

    // next target selection
    if (jumps > 0)
    {
        if (Unit* caster = triggeredByAura->GetCaster())
        {
            float radius = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcRadius(caster);
            if (Unit* target = GetNextRandomRaidMemberOrPet(radius))
            {
                CastSpell(target, spellProto, true, NULL, triggeredByAura, caster_guid);
                Aura* aura = target->GetAura(spellProto->Id, caster->GetGUID());
                if (aura != nullptr)
                    aura->SetCharges(jumps);
            }
        }
    }

    CastSpell(this, damageSpellId, true, NULL, triggeredByAura, caster_guid);

    return true;
}

void Unit::SendDurabilityLoss(Player* p_Receiver, uint32 p_Percent)
{
    WorldPacket l_Data(SMSG_DURABILITY_DAMAGE_DEATH, 4);
    l_Data << uint32(p_Percent);

    p_Receiver->GetSession()->SendPacket(&l_Data);
}

void Unit::PlayOneShotAnimKitId(uint32 id)
{
    WorldPacket l_Data(SMSG_PLAY_ONE_SHOT_ANIM_KIT, 7 + 2);
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint16(id);
    SendMessageToSet(&l_Data, true);
}

void Unit::PlayOrphanSpellVisual(G3D::Vector3 p_Source, G3D::Vector3 p_Orientation, G3D::Vector3 p_Target, int32 p_Visual, float p_TravelSpeed /*= 1.0f*/, uint64 p_TargetGuid /*= 0*/, bool p_SpeedAsTime /*= true*/, float p_UnkFloat /*= 0.0f*/)
{
    WorldPacket l_Data(Opcodes::SMSG_PLAY_ORPHAN_SPELL_VISUAL, 100);

    l_Data.WriteVector3(p_Source);
    l_Data.WriteVector3(p_Orientation);
    l_Data.WriteVector3(p_Target);
    l_Data.appendPackGUID(p_TargetGuid);

    l_Data << int32(p_Visual);
    l_Data << float(p_TravelSpeed);
    l_Data << float(p_UnkFloat);

    l_Data.WriteBit(p_SpeedAsTime);
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);
}

void Unit::CancelOrphanSpellVisual(int32 p_SpellVisualID)
{
    WorldPacket l_Data(Opcodes::SMSG_CANCEL_ORPHAN_SPELL_VISUAL, 4);
    l_Data << int32(p_SpellVisualID);
    SendMessageToSet(&l_Data, false);
}

void Unit::Kill(Unit* p_KilledVictim, bool p_DurabilityLoss, SpellInfo const* p_SpellProto)
{
    Map* l_ThreadMap = Map::GetCurrentMapThread();
    if (!l_ThreadMap || l_ThreadMap != GetMap() || l_ThreadMap != p_KilledVictim->GetMap())
    {
        ACE_Stack_Trace l_Stack;
        sLog->outExtChat("#jarvis", "danger", true, "Threadguard triggered in Unit::Kill %u %u %u", p_SpellProto ? p_SpellProto->Id : 0, GetEntry(), p_KilledVictim->GetEntry());
        sLog->outExtChat("#jarvis", "danger", true, "%s", l_Stack.c_str());
    }

    /// Prevent killing unit twice (and giving reward from kill twice)
    if (!p_KilledVictim->GetHealth(this) || p_KilledVictim->m_IsInKillingProcess)
        return;

    /// Spirit of Redemption can't be killed twice
    if (p_KilledVictim->HasAura(27827) || p_KilledVictim->HasAura(215769))
        return;

    if (auto creature = p_KilledVictim->ToCreature())
        if (creature->IsAIEnabled)
            creature->AI()->BeforeJustDied(this);

    /// Gaze of the Val'kyr
    if (Player* p_KilledPlayer = p_KilledVictim->ToPlayer())
    {
        if (p_KilledPlayer->GetActiveSpecializationID() == SPEC_WARRIOR_FURY)
        {
            Item* l_Weapon = p_KilledPlayer->GetItemByPos(INVENTORY_SLOT_BAG_0, EquipmentSlots::EQUIPMENT_SLOT_MAINHAND);

            if (l_Weapon && (l_Weapon->GetEntry() == 128908 || l_Weapon->GetEntry() == 134553))   ///< Has the artifact weapon equipped (hidden ability)
            {
                if (p_KilledVictim->HasAura(218836))    /// Is under invulnerability
                    return;

                if (p_KilledVictim != this && !p_KilledVictim->HasAura(218822) && roll_chance_i(2)) /// Doesn't have unable to use debuff
                {
                    p_KilledVictim->CastSpell(p_KilledVictim, 218836, true);    /// Apply Gaze of the Val'kyr 8 seconds timer
                    p_KilledVictim->CastSpell(p_KilledVictim, 218826, true);    /// Visual
                    p_KilledVictim->CastSpell(p_KilledVictim, 218850, true);    /// Areatrigger
                    p_KilledVictim->CastSpell(this, 218877, true);              /// Apply Gaze of the Val'kyr marker
                    return;
                }
            }
        }
    }

    p_KilledVictim->m_IsInKillingProcess = true;

    if (Player* p_KilledPlayer = p_KilledVictim->ToPlayer())
    {
        // Ancestral Protection Totem
        if (Aura* l_TotemAura = p_KilledPlayer->GetAura(207498))
        {
            if (Unit* l_Caster = l_TotemAura->GetCaster())
            {
                if (Unit* l_Owner = l_Caster->GetOwner())
                {
                    l_Caster->Kill(l_Caster);

                    uint64 l_OwnerGuid = l_Owner->GetGUID();
                    p_KilledPlayer->AddDelayedEvent([p_KilledPlayer, l_OwnerGuid]() -> void
                    {
                        if (Unit* l_Owner = Unit::GetUnit(*p_KilledPlayer, l_OwnerGuid))
                            l_Owner->CastSpell(p_KilledPlayer, 207553); ///< Totem Revival
                    }, 1000);
                }
            }
        }

        // Cheat Death
        if (p_KilledPlayer->HasAura(45181))
            p_KilledPlayer->RemoveAura(45181);
    }

    /// 130736 Soul Reaper
    /// When an enemy dies with Soul Reaper, it must add 3 stack of 215711 (buff of haste 7%/stack)
    if (Aura const* l_Aura = p_KilledVictim->GetAura(130736))
    {
        if (Unit* l_Caster = l_Aura->GetCaster())
        {
            l_Caster->AddAura(215711, l_Caster);
            if (l_Caster->HasAura(215711))
                l_Caster->GetAura(215711)->SetStackAmount(3);
        }
    }

    /// Killed unit was under Gaze of the Val'kyr marker
    if (HasAura(218836) && p_KilledVictim->HasAura(218877, GetGUID()))
        RemoveAurasDueToSpell(218836);

    /// Find player: owner of controlled `this` or `this` itself maybe
    Player* l_KillerPlayer = GetCharmerOrOwnerPlayerOrPlayerItself();
    Creature* l_KilledCreature = p_KilledVictim->ToCreature();

    bool l_Disabled = false;
    if (l_KilledCreature != nullptr)
    {
        if (InstanceScript* l_Instance = GetInstanceScript())
            l_Disabled = sObjectMgr->IsDisabledEncounter(l_Instance->GetEncounterIDForBoss(l_KilledCreature), GetMap()->GetDifficultyID());

        if (!l_Disabled)
        {
            l_Disabled = sObjectMgr->IsDisabledMap(GetMapId(), GetMap()->GetDifficultyID());

            /// Reenable loots if an ItemContext is specified for override
            if (l_Disabled && sObjectMgr->GetItemContextOverride(GetMapId(), GetMap()->GetDifficultyID()) != ItemContext::None)
                l_Disabled = false;
        }
    }

    /// Reward player, his pets, and group/raid members
    /// call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
    if (l_KillerPlayer && l_KillerPlayer != p_KilledVictim)
    {
        WorldPacket l_Data(SMSG_PARTY_KILL_LOG);
        l_Data.appendPackGUID(l_KillerPlayer->GetGUID());
        l_Data.appendPackGUID(p_KilledVictim->GetGUID());

        Player* l_Looter = l_KillerPlayer;
        if (GroupPtr l_Group = l_KillerPlayer->GetGroup())
        {
#ifndef CROSS
            if (p_KilledVictim->ToPlayer() && (l_KillerPlayer->GetMapId() == 1116 || l_KillerPlayer->GetMapId() == 1191)) ///< Gladiator's Sanctum
            {
                if (p_KilledVictim->ToPlayer())
                {
                    l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr) -> void
                    {
                        Player* l_RefPlayer = l_Itr->player;

                        if (!l_RefPlayer)
                            return;

                        if (l_RefPlayer->GetDistance2d(p_KilledVictim) < 100.0f)
                        {
                            if (auto* l_Garr = l_RefPlayer->GetDraenorGarrison())
                            {
                                if (l_Garr->HasBuildingType(MS::Garrison::GDraenor::Building::Type::SparringArena))
                                    l_RefPlayer->CastSpell(l_RefPlayer, 173417, true);
                            }
                        }
                    });
                }
            }
#endif
            l_Group->BroadcastPacket(&l_Data, l_Group->GetMemberGroup(l_KillerPlayer->GetGUID()));

            if (l_KilledCreature)
            {
                l_Group->UpdateLooterGuid(l_KilledCreature, true);
                if (l_Group->GetLooterGuid())
                {
                    l_Looter = ObjectAccessor::FindPlayer(l_Group->GetLooterGuid());
                    if (l_Looter)
                        l_Group->SendLooter(l_KilledCreature, l_Looter);
                    else
                        l_Group->SendLooter(l_KilledCreature, NULL);
                }
                else
                    l_Group->SendLooter(l_KilledCreature, NULL);

                l_Group->UpdateLooterGuid(l_KilledCreature);
            }
        }
        else
        {
            l_KillerPlayer->SendDirectMessage(&l_Data);

#ifndef CROSS
            if (p_KilledVictim->ToPlayer() && (l_KillerPlayer->GetMapId() == 1116 || l_KillerPlayer->GetMapId() == 1191))
            {
                if (l_KillerPlayer->GetDistance2d(p_KilledVictim) < 100.0f)
                {
                    if (auto l_Garr = l_KillerPlayer->GetDraenorGarrison())
                    {
                        if (l_Garr->HasBuildingType(MS::Garrison::GDraenor::Building::Type::SparringArena))
                            l_KillerPlayer->CastSpell(l_KillerPlayer, 173417, true);
                    }
                }
            }
#endif
            if (l_KilledCreature)
            {
                uint64 l_LootGuid = MAKE_NEW_GUID(GUID_LOPART(l_KilledCreature->GetGUID()), 0, HIGHGUID_LOOT);

                WorldPacket l_LootListPacket(SMSG_LOOT_LIST);

                l_LootListPacket.appendPackGUID(l_KilledCreature->GetGUID());
                l_LootListPacket.appendPackGUID(l_LootGuid);

                l_LootListPacket.WriteBit(false); // RoundRobinWinnerGuid
                l_LootListPacket.WriteBit(false); // MasterGuid
                l_LootListPacket.FlushBits();

                l_KillerPlayer->SendMessageToSet(&l_LootListPacket, true);
            }
        }

        l_KillerPlayer->RewardPersonnalCurrencies(p_KilledVictim);

        if (l_KilledCreature && !l_Disabled)
        {
            l_KilledCreature->m_LootContainers.clear();

            if (l_KilledCreature->lootForPickPocketed)
                l_KilledCreature->lootForPickPocketed = false;

            std::set<Player*> l_AllowedLooters;

            uint32 l_TrackingQuestID    = Vignette::GetTrackingQuestIdFromWorldObject(l_KilledCreature);

            uint32 l_PlayerConditionID  = 0;
            if (VignetteEntry const* l_VignetteEntry = Vignette::GetVignetteEntryFromWorldObject(l_KilledCreature))
                l_PlayerConditionID = l_VignetteEntry->PlayerConditionID;

            uint32 l_QuestBit           = l_TrackingQuestID ? GetQuestUniqueBitFlag(l_TrackingQuestID) : 0;

            if (!l_KilledCreature->GetMap()->IsChallengeMode())
            {
                if ((!l_TrackingQuestID || (l_QuestBit && (!l_KillerPlayer->IsQuestBitFlaged(l_QuestBit) || l_KilledCreature->IsAllowedTrackingQuestLooter(l_KillerPlayer->GetGUID())))) &&
                    (!l_KillerPlayer->BossAlreadyLooted(l_KilledCreature)) &&
                    (!l_PlayerConditionID || l_KillerPlayer->EvalPlayerCondition(l_PlayerConditionID).first))
                    l_AllowedLooters.insert(l_KillerPlayer);

                for (HostileReference* l_Ref : l_KilledCreature->getThreatManager().GetThreatList())
                {
                    Unit* l_Unit = l_Ref->getTarget();
                    if (!l_Unit || !l_Unit->IsPlayer())
                        continue;

                    Player* l_Player = l_Unit->ToPlayer();
                    if (!l_Player)
                        continue;

                    GroupPtr l_Group = l_Player->GetGroup();

                    /// Player in raid group under the sentinax at broken shore can't loot
                    if (l_Group && l_Group->isRaidGroup() && l_Player->GetZoneId() == 7543 && l_Player->HasAura(240640))
                        continue;

                    if ((!l_TrackingQuestID || (l_QuestBit && (!l_Player->IsQuestBitFlaged(l_QuestBit) || l_KilledCreature->IsAllowedTrackingQuestLooter(l_Player->GetGUID())))) &&
                        !l_Player->BossAlreadyLooted(l_KilledCreature))
                        l_AllowedLooters.insert(l_Player);

                    if (!l_Group)
                        continue;

                    l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr) -> void
                    {
                        Player* l_GroupGuy = l_Itr->player;
                        if (!l_GroupGuy)
                            return;

                        if (l_GroupGuy && l_GroupGuy->IsAtGroupRewardDistance(l_KilledCreature))
                        {
                            if ((!l_TrackingQuestID || (l_QuestBit && !l_GroupGuy->IsQuestBitFlaged(l_QuestBit))) &&
                                !l_GroupGuy->BossAlreadyLooted(l_KilledCreature))
                                l_AllowedLooters.insert(l_GroupGuy);
                        }
                    });
                }

                uint32 lootCounter = 0;
                std::set<uint64> l_LootContainers;
                std::list<Player*> allowedLooters;
                allowedLooters.insert(allowedLooters.begin(), l_AllowedLooters.begin(), l_AllowedLooters.end());
                JadeCore::Containers::RandomShuffleList(allowedLooters);
                for (Player* l_Player : allowedLooters)
                {
                    if (!l_Player)
                        continue;

                    l_Player->AddTrackingQuestIfNeeded(l_KilledCreature->GetGUID());

                    ItemContext l_Context = ItemContext::None;

                    /// For world boss only (outside dungeons/raids)
                    if (!l_Player->GetMap()->IsDungeon() && l_KilledCreature->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS && l_KilledCreature->GetCreatureTemplate()->expansion == Expansion::EXPANSION_LEGION)
                    {
                        if (!l_Player->GetMap()->IsHeroicOrMythic())
                            l_Player->CompleteLegendaryActivity(LegendaryActivity::NormalRaidBoss);

                        l_Player->AddBossLooted(l_KilledCreature);

                        l_Context = ItemContext::RaidNormal;
                    }

                    if (uint32 l_SpellID = l_KilledCreature->GetBonusLootSpell())
                    {
                        if (l_KilledCreature->GetMap()->IsDungeon() && !l_KilledCreature->GetMap()->IsRaid())
                        {
                            if (l_KilledCreature->GetMap()->IsMythic() && !l_KilledCreature->GetMap()->IsChallengeMode())
                                l_KilledCreature->CastSpell(l_Player, l_SpellID, true);
                        }
                        else
                            l_KilledCreature->CastSpell(l_Player, l_SpellID, true);
                    }

                    Loot*  l_Loot = nullptr;
                    uint64 l_LootContainerGuid = l_Player->GetGUID();

                    bool l_IsPersonalLoot = true;
                    GroupPtr l_Group = l_Player->GetGroup();

                    /// Generate the group loot container if loot method isn't personal loot
                    if (l_Group && l_Group->GetLootMethod() != LootMethod::PERSONAL_LOOT)
                    {
                        l_LootContainerGuid = l_Group->GetGUID();
                        l_IsPersonalLoot = false;

                        /// Group loot container already generate
                        if (l_LootContainers.count(l_LootContainerGuid))
                            continue;

                        l_LootContainers.insert(l_LootContainerGuid);
                    }

                    l_Loot = &l_KilledCreature->m_LootContainers[l_LootContainerGuid];
                    l_Loot->m_PersonalLootFilter = l_IsPersonalLoot && (l_KilledCreature->isWorldBoss() || GetMap()->IsDungeon());
                    l_Loot->SetSource(l_KilledCreature->GetGUID());
                    l_Loot->Context = l_Context == ItemContext::None ? GetMap()->GetLootItemContext(l_Player) : l_Context;
                    l_Loot->SpawnMode = GetMap()->GetSpawnMode();

                    if (uint32 l_LootID = l_KilledCreature->GetCreatureTemplate()->lootid)
                        l_Loot->FillLoot(l_LootID, LootTemplates_Creature, l_Player, false, lootCounter, false, l_KilledCreature->GetLootMode());

                    uint32 l_MinGold = l_KilledCreature->GetCreatureTemplate()->mingold;
                    uint32 l_MaxGold = l_KilledCreature->GetCreatureTemplate()->maxgold;

                    /// Generate min and max gold with quest money reward data ...
                    /// The formula is custom made and not blizzlike but it seems to generate retail like amount
                    if (l_KilledCreature->GetCreatureTemplate()->ScaleLevelMin != 0 && l_MinGold != 0)
                    {
                        if (QuestMoneyRewardEntry const* l_Money = sQuestMoneyRewardStore.LookupEntry(l_KilledCreature->getLevelForTarget(l_Player)))
                        {
                            l_MinGold = l_Money->Money[2] / 10;
                            l_MaxGold = l_Money->Money[4] / 10;
                        }
                    }

                    l_KilledCreature->GenerateMinMaxGold(l_MinGold, l_MaxGold);
                    l_Loot->generateMoneyLoot(l_MinGold, l_MaxGold);
                }
            }

            l_KilledCreature->HandleKillRewarderWithAggroList(l_KillerPlayer);
        }

        if (Player* l_KilledPlayer = p_KilledVictim->ToPlayer())
        {
            GuidSet l_Guids;
            l_KillerPlayer->RewardPlayerAndGroupAtKill(l_KilledPlayer, false, l_Guids);
        }
    }

    /// Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim
    DamageInfo l_DamageInfo(this, p_KilledVictim, 0, p_SpellProto, DIRECT_DAMAGE, WeaponAttackType::BaseAttack);

    if (isPet() || isTotem())
    {
        if (Unit* l_Owner = GetOwner())
            l_Owner->ProcDamageAndSpell(p_KilledVictim, PROC_FLAG_KILL, PROC_FLAG_NONE, PROC_EX_NONE, l_DamageInfo);
    }

    if (p_KilledVictim->GetCreatureType() != CREATURE_TYPE_CRITTER)
    {
        if (p_KilledVictim->GetEntry() != 19833 && p_KilledVictim->GetEntry() != 19921) // snake trap can't trigger PROC_FLAG_KILL
            ProcDamageAndSpell(p_KilledVictim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, l_DamageInfo);
    }

    /// Proc auras on death - must be before aura/combat remove
    p_KilledVictim->ProcDamageAndSpell(NULL, PROC_FLAG_DEATH, PROC_FLAG_NONE, PROC_EX_NONE, l_DamageInfo);

    /// update get killing blow achievements, must be done before setDeathState to be able to require auras on target
    /// and before Spirit of Redemption as it also removes auras
    if (l_KillerPlayer)
        l_KillerPlayer->UpdateCriteria(CRITERIA_TYPE_GET_KILLING_BLOWS, 1, 0, 0, p_KilledVictim);

    /// if talent known but not triggered (check priest class for speedup check)
    bool l_SpiritOfRedemption = false;

    if (p_KilledVictim->IsPlayer() && p_KilledVictim->getClass() == CLASS_PRIEST)
    {
        bool l_IsFalling = p_KilledVictim->IsFalling() && p_KilledVictim->m_movementInfo.fallTime > 5 * IN_MILLISECONDS;
        if (!p_KilledVictim->HasAura(211319) && !l_IsFalling)   ///< Archbishop Benedictus Restitution debuff
        {
            if (p_KilledVictim->HasAura(20711) && !p_KilledVictim->HasAura(215982))    ///< Spirit of Redemmption
            {
                // save value before aura remove
                uint32 l_RessSpellId = p_KilledVictim->ToPlayer()->GetFirstDescriptorRessurectSpell();

                if (!l_RessSpellId)
                    l_RessSpellId = p_KilledVictim->ToPlayer()->GetResurrectionSpellId();

                /// Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)
                if (!p_KilledVictim->HasAura(211317))    ///< Archbishop Benedictus Restituion allow to keep auras
                    p_KilledVictim->RemoveAllAurasOnDeath();
                else
                {
                    p_KilledVictim->RemoveAurasByType(SPELL_AURA_TRANSFORM);
                    p_KilledVictim->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
                    p_KilledVictim->RemoveAurasWithMechanic(MECHANIC_POLYMORPH);
                }

                /// restore for use at real death
                p_KilledVictim->ToPlayer()->SetResurectSpell(l_RessSpellId);

                /// FORM_SPIRIT_OF_REDEMPTION and related auras
                p_KilledVictim->CastSpell(p_KilledVictim, 27827, true);
                p_KilledVictim->CastSpell(p_KilledVictim, 27795, true);
                p_KilledVictim->CastSpell(p_KilledVictim, 62371, true);
                p_KilledVictim->CastSpell(p_KilledVictim, 25100, true); ///< Visual
                p_KilledVictim->CastSpell(p_KilledVictim, 27792, true);

                l_SpiritOfRedemption = true;
            }
        }
    }

    /// Light's Reckoning
    if (p_KilledVictim->IsPlayer())
        if (p_KilledVictim->HasAura(255652))
            if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(255652))
                p_KilledVictim->CastSpell(p_KilledVictim, l_SpellInfo->Effects[EFFECT_0].TriggerSpell, true);

    /// Preparation for resummoning the pet on resurection
    if (Player* l_PlayerVictim = p_KilledVictim->ToPlayer())
    {
        if (l_PlayerVictim->getClass() == CLASS_WARLOCK)
        {
            if (Pet* l_VictimPet = l_PlayerVictim->GetPet())
            {
                l_PlayerVictim->SetActiveSummonOnDeath(l_VictimPet->GetEntry());
            }
        }
    }

    if (Player* l_PlayerVictim = p_KilledVictim->ToPlayer())
    {
        if (l_KillerPlayer)
        {
            if (GroupPtr l_Group = l_KillerPlayer->GetGroup())
            {
                const float l_MaxRange = 30.f;
                l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr) -> void
                {
                    Player* l_Member = l_Itr->player;
                    if (!l_Member || !l_Member->isAlive() || !l_Member->IsWithinDistInMap(l_PlayerVictim, l_MaxRange))
                        return;

                    sScriptMgr->OnKillReward(l_PlayerVictim, l_Member);
                });
            }
            else
            {
                sScriptMgr->OnKillReward(l_PlayerVictim, l_KillerPlayer);
            }
        }
    }
    else
    {

        std::list<Unit*> l_Targets;
        for (HostileReference* l_Reference : p_KilledVictim->getThreatManager().getThreatList())
        {
            if (Unit* l_Target = l_Reference->getTarget())
            {
                if (!l_Target->IsInMap(p_KilledVictim))
                    continue;

                l_Targets.push_back(l_Target);
            }
        }

        for (auto l_Target : l_Targets)
            sScriptMgr->OnKillReward(p_KilledVictim, l_Target);
    }

    if (Player* l_KillerPlayer = ToPlayer())
    {
        sScriptMgr->OnKill(l_KillerPlayer, p_KilledVictim, true);
    }

    if (!l_SpiritOfRedemption)
        p_KilledVictim->setDeathState(JUST_DIED);

    /// Inform pets (if any) when player kills target)
    /// MUST come after victim->setDeathState(JUST_DIED); or pet next target
    /// selection will get stuck on same target and break pet react state
    if (l_KillerPlayer)
    {
        Pet* l_Pet = l_KillerPlayer->GetPet();

        if (l_Pet && l_Pet->isAlive() && l_Pet->isControlled())
            l_Pet->AI()->KilledUnit(p_KilledVictim);
    }

    /// 10% durability loss on death
    /// clean InHateListOf
    if (Player* l_PlayerVictim = p_KilledVictim->ToPlayer())
    {
        /// Remember victim PvP death for corpse type and corpse reclaim delay
        /// at original death (not at SpiritOfRedemtionTalent timeout)
        l_PlayerVictim->SetPvPDeath(l_KillerPlayer != NULL);

        /// There is no durability loss in challenge dungeons
        if (l_PlayerVictim->GetMap()->IsChallengeMode())
            p_DurabilityLoss = false;

        /// Only if not player and not controlled by player pet. And not at BG
        if (((p_DurabilityLoss && !l_KillerPlayer && !p_KilledVictim->ToPlayer()->InBattleground()) || (l_KillerPlayer && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP))) && !l_PlayerVictim->GetSession()->IsPremium())
        {
            double l_BaseLoss = sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH);
            uint32 l_Loss = uint32(l_BaseLoss - (l_BaseLoss * l_PlayerVictim->GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS)));

            /// Durability loss is calculated more accurately again for each item in Player::DurabilityLoss
            l_PlayerVictim->DurabilityLossAll(l_BaseLoss, false);
            /// Durability lost message
            SendDurabilityLoss(l_PlayerVictim, l_Loss);
        }

        /// Call KilledUnit for creatures
        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)
            ToCreature()->AI()->KilledUnit(p_KilledVictim);

        /// last damage from non duel opponent or opponent controlled creature
        if (l_PlayerVictim->m_Duel)
        {
            l_PlayerVictim->m_Duel->opponent->CombatStopWithPets(true);
            l_PlayerVictim->CombatStopWithPets(true);
            l_PlayerVictim->DuelComplete(DUEL_INTERRUPTED);
        }

        if (InstanceScript* script = l_PlayerVictim->GetInstanceScript())
            script->OnPlayerDiesForScript(l_PlayerVictim);

        l_PlayerVictim->SendClearLossOfControl();
    }
    /// Creature died
    else if (l_KilledCreature)
    {
        if (!l_KilledCreature->isPet())
        {
            l_KilledCreature->DeleteThreatList();

            CreatureTemplate const* l_CreatureTemplate = l_KilledCreature->GetCreatureTemplate();
            if (l_CreatureTemplate && (l_CreatureTemplate->lootid || l_CreatureTemplate->maxgold > 0) && !l_Disabled)
                l_KilledCreature->SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
        }

        /// Call KilledUnit for creatures, this needs to be called after the lootable flag is set
        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)
            ToCreature()->AI()->KilledUnit(p_KilledVictim);

        /// Call creature just died function
        if (l_KilledCreature->IsAIEnabled)
            l_KilledCreature->AI()->JustDied(this);

        if (TempSummon* l_TemSummon = l_KilledCreature->ToTempSummon())
        {
            if (Unit* l_Summoner = l_TemSummon->GetSummoner())
            {
                if (l_Summoner->ToCreature() && l_Summoner->IsAIEnabled)
                    l_Summoner->ToCreature()->AI()->SummonedCreatureDies(l_KilledCreature, this);
            }
        }

         // Call instance script.
        if (ZoneScript* script = l_KilledCreature->GetZoneScript())
            script->CreatureDiesForScript(l_KilledCreature, this);

        // Call instance script.
        if (auto script = l_KilledCreature->GetInstanceScript())
            script->CreatureDies(l_KilledCreature, this);

        /// Dungeon specific stuff, only applies to players killing creatures
        if (l_KilledCreature->GetInstanceId() && l_KillerPlayer && !l_Disabled)
        {
            Map* l_InstanceMap = l_KilledCreature->GetMap();

            if (l_InstanceMap->IsLFR())
            {
                Map::PlayerList const& l_PlayerList = l_InstanceMap->GetPlayers();
                if (l_PlayerList.isEmpty())
                    return;

                /// Handle end of dungeon rewarding for LFR
                if (l_KilledCreature->GetNativeTemplate()->flags_extra & CreatureFlagsExtra::CREATURE_FLAG_EXTRA_DUNGEON_END_BOSS)
                {
                    for (Map::PlayerList::const_iterator l_Itr = l_PlayerList.begin(); l_Itr != l_PlayerList.end(); ++l_Itr)
                    {
                        if (Player* l_Player = l_Itr->getSource())
                        {
                            GroupPtr l_Group = l_Player->GetGroup();
                            uint32 l_DungeonID = l_Group ? sLFGMgr->GetDungeon(l_Group->GetGUID()) : 0;
                            if (!l_KilledCreature || l_Player->IsAtGroupRewardDistance(l_KilledCreature))
                                sLFGMgr->RewardDungeonDoneFor(l_DungeonID, l_Player);
                        }
                    }
                }

                /// Handle loot assignation for LFR (previous to Legion)
                Player* l_Player = l_PlayerList.begin()->getSource();
                if (l_Player && l_Player->GetGroup() && l_InstanceMap->Expansion() < Expansion::EXPANSION_LEGION)
                    sLFGMgr->AutomaticLootAssignation(l_KilledCreature, l_Player->GetGroup());
            }

            /// @TODO: do instance binding anyway if the charmer/owner is offline
            if (l_InstanceMap->IsDungeon() && l_KillerPlayer)
            {
                if (InstanceScript* l_InstanceScript = l_KilledCreature->GetInstanceScript())
                    l_InstanceScript->OnCreatureKilled(l_KilledCreature, l_KillerPlayer);

                /// There is no lockout scheduled in challenge mode
                if (l_InstanceMap->IsRaidOrHeroicDungeon() && !l_InstanceMap->IsChallengeMode())
                {
                    if (l_KilledCreature->GetFlagsExtra() & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
                        ((InstanceMap*)l_InstanceMap)->PermBindAllPlayers(l_KillerPlayer);
                }
                else
                {
                    /// the reset time is set but not added to the scheduler
                    /// until the players leave the instance
                    time_t l_ResetTime = l_KilledCreature->GetRespawnTimeEx() + 2 * HOUR;

                    if (InstanceSavePtr l_Save = sInstanceSaveMgr->GetInstanceSave(l_KilledCreature->GetInstanceId()))
                        if (l_Save->GetResetTime() < l_ResetTime) l_Save->SetResetTime(l_ResetTime);
                }
            }
        }

        float l_GroundZ = l_KilledCreature->GetMap()->GetHeight(l_KilledCreature->m_positionX, l_KilledCreature->m_positionY, l_KilledCreature->m_positionZ, true, 200.0f);

        /// Don't fall if the mob is in water
        if (!l_KilledCreature->IsInWater() && l_KilledCreature->IsFlying() && l_GroundZ != INVALID_HEIGHT && l_GroundZ != l_KilledCreature->m_positionZ)
        {
            Position l_Position = *l_KilledCreature;
            l_Position.m_positionZ = l_GroundZ;

            l_KilledCreature->GetMotionMaster()->Clear();
            l_KilledCreature->GetMotionMaster()->MoveLand(EventId::EVENT_FALL_TO_GROUND, l_Position);
        }
    }

    /// Outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
    /// handle player kill only if not suicide (spirit of redemption for example)
    if (l_KillerPlayer && this != p_KilledVictim)
    {
        if (OutdoorPvP* l_OutdoorPVP = l_KillerPlayer->GetOutdoorPvP())
            l_OutdoorPVP->HandleKill(l_KillerPlayer, p_KilledVictim);

        if (Battlefield* l_Battlefield = sBattlefieldMgr->GetBattlefieldToZoneId(l_KillerPlayer->GetZoneId()))
            l_Battlefield->HandleKill(l_KillerPlayer, p_KilledVictim);
    }

    if (this != p_KilledVictim && p_KilledVictim->IsPlayer())
    {
        if (OutdoorPvP* l_OutdoorPvP = p_KilledVictim->ToPlayer()->GetOutdoorPvP())
            l_OutdoorPvP->HandlePlayerKilled(p_KilledVictim->ToPlayer());
        else if (InstanceScript* l_InstanceScript = p_KilledVictim->GetInstanceScript())
            l_InstanceScript->HandlePlayerKilled(p_KilledVictim->ToPlayer());
    }

    /// Battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
    if (l_KillerPlayer && l_KillerPlayer->InBattleground())
    {
        if (Battleground* l_Battleground = l_KillerPlayer->GetBattleground())
        {
            if (p_KilledVictim->IsPlayer())
                l_Battleground->HandleKillPlayer((Player*)p_KilledVictim, l_KillerPlayer);
            else
                l_Battleground->HandleKillUnit(p_KilledVictim->ToCreature(), l_KillerPlayer);
        }
    }

    /// Achievement stuff
    if (p_KilledVictim->IsPlayer())
    {
        if (GetTypeId() == TYPEID_UNIT)
            p_KilledVictim->ToPlayer()->UpdateCriteria(CRITERIA_TYPE_KILLED_BY_CREATURE, GetEntry());
        else if (IsPlayer() && p_KilledVictim != this)
            p_KilledVictim->ToPlayer()->UpdateCriteria(CRITERIA_TYPE_KILLED_BY_PLAYER, 1, ToPlayer()->GetTeam());
    }

    /// Hook for OnPVPKill Event
    if (Player* l_KillerPlayer = ToPlayer())
    {
        sScriptMgr->OnKill(l_KillerPlayer, p_KilledVictim);
        if (Player* l_KilledPlayer = p_KilledVictim->ToPlayer())
            sScriptMgr->OnPVPKill(l_KillerPlayer, l_KilledPlayer);
        else if (Creature* l_KilledCreature = p_KilledVictim->ToCreature())
            sScriptMgr->OnCreatureKill(l_KillerPlayer, l_KilledCreature);
    }
    else if (Creature* l_KilledCreature = ToCreature())
    {
        if (Player* l_KilledPlayer = p_KilledVictim->ToPlayer())
            sScriptMgr->OnPlayerKilledByCreature(l_KilledCreature, l_KilledPlayer);
    }

    p_KilledVictim->m_IsInKillingProcess = false;
}

void Unit::HandleKillRewarderWithAggroList(Unit* p_Killer)
{
    std::set<uint64> l_RewardedPlayers;
    std::list<uint64> l_ThreatListPlayerGuids;

    for (HostileReference* l_Ref : getThreatManager().GetThreatList())
    {
        if (Unit* l_Unit = l_Ref->getTarget())
        {
            if (Player* l_Player = l_Unit->ToPlayer())
                l_ThreatListPlayerGuids.push_back(l_Player->GetGUID());
        }
    }

    for (uint64 l_PlayerGuid : l_ThreatListPlayerGuids)
    {
        Player* l_Player = sObjectAccessor->GetPlayer(*this, l_PlayerGuid);
        if (!l_Player)
            continue;

        l_Player->RewardPlayerAndGroupAtKill(this, false, l_RewardedPlayers);
        l_RewardedPlayers.insert(l_Player->GetGUID());

        /// as the guid is used to check if players have already been rewarded in the killrewarder, we must add the group members GUID next to the process.
        if (GroupPtr l_Group = l_Player->GetGroup())
        {
            l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr) -> void
            {
                if (Player* l_GroupGuy = l_Itr->player)
                    l_RewardedPlayers.insert(l_GroupGuy->GetGUID());
            });
        }
    }

    if (Player* l_Player = p_Killer->ToPlayer())
    {
        l_Player->RewardPlayerAndGroupAtKill(this, false, l_RewardedPlayers);
        l_RewardedPlayers.insert(l_Player->GetGUID());

        /// as the guid is used to check if players have already been rewarded in the killrewarder, we must add the group members GUID next to the process.
        if (GroupPtr l_Group = l_Player->GetGroup())
        {
            l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr) -> void
            {
                if (Player* l_GroupGuy = l_Itr->player)
                    l_RewardedPlayers.insert(l_GroupGuy->GetGUID());
            });
        }
    }
}

/// Get interpolated player position based on last received movement informations
/// @p_AtClientScreen : Interpolated with client network delay ?
/// @p_ProjectTime    : Time target of prediction
Position Unit::GetInterpolatedPosition(bool p_AtClientScreen, uint32 p_ProjectTime)
{
    if (!IsMoving())
        return *this;

    if ((m_movementInfo.GetMovementFlags() & (MOVEMENTFLAG_MASK_MOVING_FLY | MOVEMENTFLAG_MASK_TURNING | MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN | MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR | MOVEMENTFLAG_SPLINE_ELEVATION)) != 0)
        return *this;

    Position l_InterpolatedPosition;

    uint32 l_LastMoveTimeStamp = m_movementInfoLastTime;
    uint32 l_CurrentTime = getMSTime() + p_ProjectTime;

    if (p_AtClientScreen && GetTypeId() == TYPEID_PLAYER)
        l_CurrentTime += ToPlayer()->GetSession()->GetLatency();

    float l_Orientation = m_movementInfo.pos.m_orientation;
    float l_Distance = (l_CurrentTime - l_LastMoveTimeStamp) / 1000.0f;

    uint32 l_MovementFlags = m_movementInfo.GetMovementFlags();

    if ((l_MovementFlags & MOVEMENTFLAG_STRAFE_LEFT) != 0)
        l_Orientation += M_PI / 2.0f;
    else if ((l_MovementFlags & MOVEMENTFLAG_STRAFE_RIGHT) != 0)
        l_Orientation -= M_PI / 2.0f;
    else if ((l_MovementFlags & MOVEMENTFLAG_BACKWARD) != 0)
        l_Orientation -= M_PI;

    l_Orientation = NormalizeOrientation(l_Orientation);

    bool l_IsBackward = ((l_MovementFlags & MOVEMENTFLAG_BACKWARD) != 0);

    if ((l_MovementFlags & MOVEMENTFLAG_WALKING) != 0)
        l_Distance *= GetSpeed(MOVE_WALK);
    else if ((l_MovementFlags & MOVEMENTFLAG_FLYING) != 0)
        l_Distance *= GetSpeed(l_IsBackward ? MOVE_FLIGHT_BACK : MOVE_FLIGHT);
    else if ((l_MovementFlags & MOVEMENTFLAG_SWIMMING) != 0)
        l_Distance *= GetSpeed(l_IsBackward ? MOVE_SWIM_BACK : MOVE_SWIM);
    else if ((l_MovementFlags & MOVEMENTFLAG_MASK_TURNING) == 0)
        l_Distance *= GetSpeed(l_IsBackward ? MOVE_RUN_BACK : MOVE_RUN);

    l_InterpolatedPosition.m_positionX = m_movementInfo.pos.m_positionX + (std::cos(l_Orientation) * l_Distance);
    l_InterpolatedPosition.m_positionY = m_movementInfo.pos.m_positionY + (std::sin(l_Orientation) * l_Distance);
    l_InterpolatedPosition.m_positionZ = GetMap()->GetHeight(l_InterpolatedPosition.m_positionX, l_InterpolatedPosition.m_positionY, MAX_HEIGHT);
    l_InterpolatedPosition.m_orientation = m_movementInfo.pos.m_orientation;

    return l_InterpolatedPosition;
}

void Unit::SetControlled(bool apply, UnitState state)
{
    if (apply)
    {
        if (HasUnitState(state))
            return;

        AddUnitState(state);
        switch (state)
        {
            case UNIT_STATE_STUNNED:
                SetStunned(true);
                CastStop();
                break;
            case UNIT_STATE_ROOT:
                if (!HasUnitState(UNIT_STATE_STUNNED))
                    SetRooted(true);
                break;
            case UNIT_STATE_CONFUSED:
                if (!HasUnitState(UNIT_STATE_STUNNED))
                {
                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                    SendMeleeAttackStop();
                    // SendAutoRepeatCancel ?
                    SetConfused(true);
                    CastStop();
                }
                break;
            case UNIT_STATE_FLEEING:
                if (!HasUnitState(UNIT_STATE_STUNNED | UNIT_STATE_CONFUSED))
                {
                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                    SendMeleeAttackStop();
                    // SendAutoRepeatCancel ?
                    SetFeared(true);
                    CastStop();
                }
                break;
            default:
                break;
        }
    }
    else
    {
        switch (state)
        {
            case UNIT_STATE_STUNNED:
                if (HasAuraType(SPELL_AURA_MOD_STUN))
                    return;
                else
                    SetStunned(false);
                break;
            case UNIT_STATE_ROOT:
                if (HasAuraType(SPELL_AURA_MOD_ROOT) || HasAuraType(SPELL_AURA_MOD_ROOT_2) || GetVehicle())
                    return;
                else
                    SetRooted(false);
                break;
            case UNIT_STATE_CONFUSED:
                if (HasAuraType(SPELL_AURA_MOD_CONFUSE))
                    return;
                else
                    SetConfused(false);
                break;
            case UNIT_STATE_FLEEING:
                if (isFeared())
                    return;
                else
                    SetFeared(false);
                break;
            default:
                return;
        }

        ClearUnitState(state);

        /// Fix problems with CC when character is not available for control in 1-2 seconds after breaking CC
        /// After ClearUnitState player should receive control on his character, if char is still moving - we need to stop him
        StopMoving();

        if (HasUnitState(UNIT_STATE_STUNNED))
            SetStunned(true);
        else
        {
            if (HasUnitState(UNIT_STATE_ROOT))
                SetRooted(true);

            if (HasUnitState(UNIT_STATE_CONFUSED))
                SetConfused(true);
            else if (HasUnitState(UNIT_STATE_FLEEING))
                SetFeared(true);
        }
    }
}

/// Control Alert
void Unit::SendLossOfControlAuraUpdate(AuraApplication const* p_AurApp, Mechanics p_Mechanic, SpellEffIndex p_EffIndex, LossOfControlType p_Type)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    if (p_AurApp->GetBase()->GetSpellInfo()->Attributes & SPELL_ATTR0_HIDE_IN_COMBAT_LOG)
        return;

    WorldPacket l_Data(SMSG_LOSS_OF_CONTROL_AURA_UPDATE);
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(1);
    l_Data << uint8(p_AurApp->GetSlot());
    l_Data << uint8(p_EffIndex);
    l_Data << uint8(p_Type);
    l_Data << uint8(p_Mechanic);
    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendClearLossOfControl()
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data(SMSG_CLEAR_LOSS_OF_CONTROL);
    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendAddLossOfControl(AuraApplication const* p_AurApp, Mechanics p_Mechanic, LossOfControlType p_Type)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    Aura* l_Aura = p_AurApp->GetBase();
    if (l_Aura == nullptr)
        return;

    WorldPacket l_Data(SMSG_ADD_LOSS_OF_CONTROL);
    l_Data << uint8(p_Type);
    l_Data << uint8(p_Mechanic);
    l_Data << int32(l_Aura->GetSpellInfo()->Id);
    l_Data.appendPackGUID(l_Aura->GetCasterGUID());
    l_Data << uint32(l_Aura->GetDuration());
    l_Data << uint32(0);    ///< DurationRemainingLockoutSchoolMask
    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendRemoveLossOfControl(AuraApplication const* p_AurApp, LossOfControlType p_Type)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    Aura* l_Aura = p_AurApp->GetBase();
    if (l_Aura == nullptr)
        return;

    WorldPacket l_Data(SMSG_REMOVE_LOSS_OF_CONTROL);
    l_Data << uint8(p_Type);
    l_Data << int32(l_Aura->GetSpellInfo()->Id);
    l_Data.appendPackGUID(l_Aura->GetCasterGUID());
    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::SendMoveRoot(uint32 value)
{
    WorldPacket data(SMSG_MOVE_ROOT, 16 + 2 + 4);

    data.appendPackGUID(GetGUID());
    data << uint32(m_movementCounter++);

    SendMessageToSet(&data, true);
}

void Unit::SendMoveUnroot(uint32 value)
{
    WorldPacket data(SMSG_MOVE_UNROOT, 16 + 2 + 4);

    data.appendPackGUID(GetGUID());
    data << uint32(m_movementCounter++);

    SendMessageToSet(&data, true);
}

void Unit::SetStunned(bool apply)
{
    if (apply)
    {
        SetTarget(0);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);

        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)
        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before
        // setting MOVEMENTFLAG_ROOT
        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);
        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);

        // Creature specific
        if (GetTypeId() != TYPEID_PLAYER)
            ToCreature()->StopMoving();
        else
            SetStandState(UNIT_STAND_STATE_STAND);

        SendMoveRoot(0);

        CastStop();
    }
    else
    {
        if (isAlive() && getVictim())
            SetTarget(getVictim()->GetGUID());

        // don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)
        Unit* owner = GetOwner();
        if (!owner || !owner->IsPlayer() || !owner->ToPlayer()->IsMounted())
            RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);

        if (!HasUnitState(UNIT_STATE_ROOT))         // prevent moving if it also has root effect
        {
            SendMoveUnroot(0);
            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
        }
    }
}

void Unit::SetRooted(bool apply)
{
    if (apply)
    {
        if (m_rootTimes > 0) // blizzard internal check?
            m_rootTimes++;

        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)
        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before
        // setting MOVEMENTFLAG_ROOT
        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);
        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);

        if (IsPlayer())
            SendMoveRoot(m_rootTimes);
        else
        {
            ObjectGuid guid = GetGUID();
            WorldPacket data(SMSG_SPLINE_MOVE_ROOT, 16 + 2);
            data.appendPackGUID(guid);
            SendMessageToSet(&data, true);
            StopMoving();
        }
    }
    else
    {
        if (!HasUnitState(UNIT_STATE_STUNNED))      // prevent moving if it also has stun effect
        {
            if (IsPlayer())
                SendMoveUnroot(++m_rootTimes);
            else
            {
                ObjectGuid guid = GetGUID();
                WorldPacket data(SMSG_SPLINE_MOVE_UNROOT, 16 + 2);
                data.appendPackGUID(guid);
                SendMessageToSet(&data, true);
            }

            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
        }
    }
}

void Unit::SetFeared(bool apply)
{
    if (apply)
    {
        SetTarget(0);

        uint64 mechanic_mask = (1LL << MECHANIC_FEAR) | (1LL << MECHANIC_HORROR) | (1LL << MECHANIC_TURN);

        Unit* caster = NULL;
        Unit::AuraEffectList const& fearAuras = GetAuraEffectsByMechanic(mechanic_mask);
        if (!fearAuras.empty())
            caster = ObjectAccessor::GetUnit(*this, fearAuras.front()->GetCasterGUID());
        if (!caster)
            caster = getAttackerForHelper();
        GetMotionMaster()->MoveFleeing(caster, fearAuras.empty() ? sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY) : 0);             // caster == NULL processed in MoveFleeing
    }
    else
    {
        if (isAlive())
        {
            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == FLEEING_MOTION_TYPE)
                GetMotionMaster()->MovementExpired();
            if (getVictim())
                SetTarget(getVictim()->GetGUID());
        }
    }

    if (Player* player = ToPlayer())
        if (!player->HasUnitState(UNIT_STATE_POSSESSED))
            player->SetClientControl(this, !apply);
}

void Unit::SetConfused(bool apply)
{
    if (apply)
    {
        SetTarget(0);
        GetMotionMaster()->MoveConfused();
    }
    else
    {
        if (isAlive())
        {
            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == CONFUSED_MOTION_TYPE)
                GetMotionMaster()->MovementExpired();
            if (getVictim())
                SetTarget(getVictim()->GetGUID());
        }
    }

    if (Player* player = ToPlayer())
        if (!player->HasUnitState(UNIT_STATE_POSSESSED))
            player->SetClientControl(this, !apply);
}

bool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* aurApp)
{
    if (!charmer)
        return false;

    // dismount players when charmed
    if (IsPlayer())
        Dismount();

    ASSERT(type != CHARM_TYPE_POSSESS || charmer->IsPlayer());
    ASSERT((type == CHARM_TYPE_VEHICLE) == IsVehicle());

    if (this == charmer)
    {
        sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetCharmedBy: Unit %u (GUID %u) is trying to charm itself!", GetEntry(), GetGUIDLow());
        return false;
    }

    //if (HasUnitState(UNIT_STATE_UNATTACKABLE))
    //    return false;

    if (IsPlayer() && ToPlayer()->GetTransport())
        return false;

    // Already charmed
    if (GetCharmerGUID())
        return false;

    CastStop();

    if (!IsPlayer() || !charmer->IsPlayer()) ///< in PVP, don't clear combat
        CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)

    DeleteThreatList();

    // Charmer stop charming
    if (charmer->IsPlayer())
    {
        charmer->ToPlayer()->StopCastingCharm();
        charmer->ToPlayer()->StopCastingBindSight();
    }

    // Charmed stop charming
    if (IsPlayer())
    {
        ToPlayer()->StopCastingCharm();
        ToPlayer()->StopCastingBindSight();
    }

    // StopCastingCharm may remove a possessed pet?
    if (!IsInWorld())
        return false;

    // charm is set by aura, and aura effect remove handler was called during apply handler execution
    // prevent undefined behaviour
    if (aurApp && aurApp->GetRemoveMode())
        return false;

    // Set charmed
    Map* map = GetMap();
    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))
        setFaction(charmer->getFaction());

    charmer->SetCharm(this, true);

    if (GetTypeId() == TYPEID_UNIT)
    {
        ToCreature()->AI()->OnCharmed(true);
        GetMotionMaster()->MoveIdle();
    }
    else
    {
        Player* player = ToPlayer();
        if (player->isAFK())
            player->ToggleAFK();
        player->SetClientControl(this, 0);
    }

    // charm is set by aura, and aura effect remove handler was called during apply handler execution
    // prevent undefined behaviour
    if (aurApp && aurApp->GetRemoveMode())
        return false;

    // Pets already have a properly initialized CharmInfo, don't overwrite it.
    if (type != CHARM_TYPE_VEHICLE && !GetCharmInfo())
        InitCharmInfo();

    if (type != CHARM_TYPE_VEHICLE)
    {
        if (type == CHARM_TYPE_POSSESS)
            GetCharmInfo()->InitPossessCreateSpells();
        else
            GetCharmInfo()->InitCharmCreateSpells();
    }

    if (charmer->IsPlayer())
    {
        switch (type)
        {
            case CHARM_TYPE_VEHICLE:
                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
                charmer->ToPlayer()->SetClientControl(this, 1);
                charmer->ToPlayer()->SetMover(this);
                charmer->ToPlayer()->SetViewpoint(this, true);
                charmer->ToPlayer()->VehicleSpellInitialize();
                break;
            case CHARM_TYPE_POSSESS:
                AddUnitState(UNIT_STATE_POSSESSED);
                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
                charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL);
                charmer->ToPlayer()->SetClientControl(this, 1);
                charmer->ToPlayer()->SetMover(this);
                charmer->ToPlayer()->SetViewpoint(this, true);
                charmer->ToPlayer()->PossessSpellInitialize();
                break;
            case CHARM_TYPE_CHARM:
                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
                {
#ifdef CROSS
                    uint32 l_PetNumber = InterRealmClient::GetIRClient(charmer->ToPlayer())->GenerateLocalRealmLowGuid(HIGHGUID_PET_NUMBER);
                    if (!l_PetNumber)
                        return false;

#endif /* CROSS */
                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();
                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
                    {
                        // to prevent client crash
                        SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_CLASS, (uint8)CLASS_MAGE);

                        // just to enable stat window
                        if (GetCharmInfo())
#ifndef CROSS
                            GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);
#else /* CROSS */
                            GetCharmInfo()->SetPetNumber(l_PetNumber, true);
#endif /* CROSS */

                        // if charmed two demons the same session, the 2nd gets the 1st one's name
                        SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped
                    }
                }
                charmer->ToPlayer()->CharmSpellInitialize();
                break;
            default:
            case CHARM_TYPE_CONVERT:
                break;
        }
    }
    else if (type == CHARM_TYPE_CONVERT && IsPlayer())
    {
        ToPlayer()->SetClientControl(charmer, true);
        ToPlayer()->SetMover(charmer);
    }

    return true;
}

void Unit::RemoveCharmedBy(Unit* charmer)
{
    if (!isCharmed())
        return;

    if (!charmer)
        charmer = GetCharmer();
    if (charmer != GetCharmer()) // one aura overrides another?
    {
//        sLog->outFatal(LOG_FILTER_UNITS, "Unit::RemoveCharmedBy: this: " UI64FMTD " true charmer: " UI64FMTD " false charmer: " UI64FMTD,
//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());
//        ASSERT(false);
        return;
    }

    CharmType type;
    if (HasUnitState(UNIT_STATE_POSSESSED))
        type = CHARM_TYPE_POSSESS;
    else if (charmer && charmer->IsOnVehicle(this))
        type = CHARM_TYPE_VEHICLE;
    else
        type = CHARM_TYPE_CHARM;
#ifdef CROSS

    if (type == CHARM_TYPE_VEHICLE && GetMapSwitchDestination() != -1)
        return;
#endif /* CROSS */

    CastStop();
    CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)
    AttackStop();
    getHostileRefManager().deleteReferences();
    DeleteThreatList();
    Map* map = GetMap();
    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))
        RestoreFaction();
    GetMotionMaster()->Clear(true);
    GetMotionMaster()->InitDefault();

    if (type == CHARM_TYPE_POSSESS)
    {
        ClearUnitState(UNIT_STATE_POSSESSED);
        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
    }

    if (Creature* creature = ToCreature())
    {
        if (creature->AI())
            creature->AI()->OnCharmed(false);

        if (type != CHARM_TYPE_VEHICLE) // Vehicles' AI is never modified
        {
            if (creature->AI() && charmer && charmer->isAlive())
                creature->AI()->AttackStart(charmer);
        }
    }
    else
        ToPlayer()->SetClientControl(this, 1);

    // If charmer still exists
    if (!charmer)
        return;

    ASSERT(type != CHARM_TYPE_POSSESS || charmer->IsPlayer());
    ASSERT(type != CHARM_TYPE_VEHICLE || (GetTypeId() == TYPEID_UNIT && IsVehicle()));

    charmer->SetCharm(this, false);

    if (charmer->IsPlayer())
    {
        switch (type)
        {
            case CHARM_TYPE_VEHICLE:
                charmer->ToPlayer()->SetClientControl(charmer, 1);
                charmer->ToPlayer()->SetViewpoint(this, false);
                charmer->ToPlayer()->SetClientControl(this, 0);
                if (IsPlayer())
                    ToPlayer()->SetMover(this);
                break;
            case CHARM_TYPE_POSSESS:
                ClearUnitState(UNIT_STATE_POSSESSED);
                charmer->ToPlayer()->SetClientControl(charmer, 1);
                charmer->ToPlayer()->SetViewpoint(this, false);
                charmer->ToPlayer()->SetClientControl(this, 0);
                charmer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL);
                if (IsPlayer())
                {
                    ToPlayer()->SetClientControl(this, 1);
                }
                break;
            case CHARM_TYPE_CHARM:
                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
                {
                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();
                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
                    {
                        SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_CLASS, uint8(cinfo->unit_class));
                        if (GetCharmInfo())
                            GetCharmInfo()->SetPetNumber(0, true);
                    }
                }
                break;
            default:
            case CHARM_TYPE_CONVERT:
                break;
        }
    }
    else if (type == CHARM_TYPE_CONVERT && IsPlayer())
    {
        ToPlayer()->SetClientControl(charmer, false);
        ToPlayer()->SetMover(this);
    }

    // a guardian should always have charminfo
    if (charmer->IsPlayer() && this != charmer->GetFirstControlled())
        charmer->ToPlayer()->SendRemoveControlBar();
    else if (IsPlayer() || (GetTypeId() == TYPEID_UNIT && !ToCreature()->isGuardian()))
        DeleteCharmInfo();
}

void Unit::RestoreFaction()
{
    if (IsPlayer())
        ToPlayer()->setFactionForRace(getRace());
    else
    {
        if (HasUnitTypeMask(UNIT_MASK_MINION))
        {
            if (Unit* owner = GetOwner())
            {
                setFaction(owner->getFaction());
                return;
            }
        }

        if (CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate())  // normal creature
            setFaction(cinfo->faction);
    }
}

bool Unit::CreateVehicleKit(uint32 id, uint32 creatureEntry)
{
    VehicleEntry const* vehInfo = sVehicleStore.LookupEntry(id);
    if (!vehInfo)
        return false;

    m_vehicleKit = new Vehicle(this, vehInfo, creatureEntry);
    m_updateFlag |= UPDATEFLAG_HAS_VEHICLE_CREATE;
    m_unitTypeMask |= UNIT_MASK_VEHICLE;
    return true;
}

void Unit::RemoveVehicleKit(bool dismount/* = false*/)
{
    if (!m_vehicleKit)
        return;

    m_vehicleKit->Uninstall(dismount);
    delete m_vehicleKit;

    m_vehicleKit = NULL;

    m_updateFlag &= ~UPDATEFLAG_HAS_VEHICLE_CREATE;
    m_unitTypeMask &= ~UNIT_MASK_VEHICLE;
    RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
    RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);
}

Unit* Unit::GetVehicleBase() const
{
    return m_vehicle ? m_vehicle->GetBase() : NULL;
}

Creature* Unit::GetVehicleCreatureBase() const
{
    if (Unit* veh = GetVehicleBase())
        if (Creature* c = veh->ToCreature())
            return c;

    return NULL;
}

uint64 Unit::GetTransGUID() const
{
    if (GetVehicle())
        return GetVehicleBase()->GetGUID();
    if (GetTransport())
        return GetTransport()->GetGUID();

    return 0;
}

TransportBase* Unit::GetDirectTransport() const
{
    if (Vehicle* veh = GetVehicle())
        return veh;
    return GetTransport();
}

bool Unit::IsInPartyWith(Unit const* unit) const
{
    if (this == unit)
        return true;

    const Unit* u1 = GetCharmerOrOwnerOrSelf();
    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();
    if (u1 == u2)
        return true;

    if (u1->IsPlayer() && u2->IsPlayer())
        return u1->ToPlayer()->IsInSameGroupWith(u2->ToPlayer());
    else if ((u2->IsPlayer() && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
        (u1->IsPlayer() && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
        return true;
    else
        return false;
}

bool Unit::IsInRaidWith(Unit const* unit) const
{
    if (this == unit)
        return true;

    const Unit* u1 = GetCharmerOrOwnerOrSelf();
    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();
    if (u1 == u2)
        return true;

    if (!u1 || !u2)
        return false;

    if (u1->IsPlayer() && u2->IsPlayer())
        return u1->ToPlayer()->IsInSameRaidWith(u2->ToPlayer());
    else if ((u2->IsPlayer() && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
            (u1->IsPlayer() && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
        return true;
    else
        return false;
}

void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
{
    Unit* owner = GetCharmerOrOwnerOrSelf();
    GroupPtr group = NULL;
    if (owner->IsPlayer())
        group = owner->ToPlayer()->GetGroup();

    if (group)
    {
        uint8 subgroup = owner->ToPlayer()->GetSubGroup();

        group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member) -> void
        {
            Player* Target = l_Member->player;

            // IsHostileTo check duel and controlled by enemy
            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
            {
                if (Target->isAlive() && IsInMap(Target))
                    TagUnitMap.push_back(Target);

                if (Guardian* pet = Target->GetGuardianPet())
                    if (pet->isAlive() && IsInMap(Target))
                        TagUnitMap.push_back(pet);
            }
        });
    }
    else
    {
        if (owner->isAlive() && (owner == this || IsInMap(owner)))
            TagUnitMap.push_back(owner);
        if (Guardian* pet = owner->GetGuardianPet())
            if (pet->isAlive() && (pet == this || IsInMap(pet)))
                TagUnitMap.push_back(pet);
    }
}

void Unit::GetRaidMembers(std::list<Unit*> &p_Members)
{
    Unit* l_Owner = GetCharmerOrOwnerOrSelf();
    GroupPtr l_Group = NULL;
    if (l_Owner->IsPlayer())
        l_Group = l_Owner->ToPlayer()->GetGroup();

    if (l_Group)
    {
        l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member) -> void
        {
            Player* l_Target = l_Member->player;

            // IsHostileTo check duel and controlled by enemy
            if (l_Target && !IsHostileTo(l_Target))
            {
                if (l_Target->isAlive() && IsInMap(l_Target))
                    p_Members.push_back(l_Target);

                if (Guardian* l_Pet = l_Target->GetGuardianPet())
                if (l_Pet->isAlive() && IsInMap(l_Target))
                    p_Members.push_back(l_Pet);
            }
        });
    }
    else
    {
        if (l_Owner->isAlive() && (l_Owner == this || IsInMap(l_Owner)))
            p_Members.push_back(l_Owner);
        if (Guardian* l_Pet = l_Owner->GetGuardianPet())
        if (l_Pet->isAlive() && (l_Pet == this || IsInMap(l_Pet)))
            p_Members.push_back(l_Pet);
    }
}

Aura* Unit::ToggleAura(uint32 spellId, Unit* target)
{
    if (!target)
        return nullptr;

    if (target->HasAura(spellId))
    {
        target->RemoveAurasDueToSpell(spellId);
        return nullptr;
    }

    return target->AddAura(spellId, target);
}

Aura* Unit::AddAura(uint32 spellId, Unit* target)
{
    if (!target)
        return nullptr;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId, GetMap()->GetDifficultyID());
    if (!spellInfo)
        return nullptr;

    if (!target->isAlive() && !(spellInfo->Attributes & SPELL_ATTR0_PASSIVE) && !(spellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD))
        return nullptr;

    // Glyph of Grounding Totem
    if (target->isTotem() && target->ToTempSummon() && target->ToTempSummon()->GetSummoner() && spellId == 8178)
        if (target->ToTempSummon()->GetSummoner()->HasAura(55441))
            return nullptr;

    return AddAura(spellInfo, MAX_EFFECT_MASK, target);
}

Aura* Unit::AddAura(SpellInfo const* spellInfo, uint32 effMask, Unit* target)
{
    if (!spellInfo)
        return nullptr;

    if (target->IsImmunedToSpell(spellInfo))
        return nullptr;

    for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
    {
        if (!(effMask & (1<<i)))
            continue;
        if (target->IsImmunedToSpellEffect(spellInfo, i))
            effMask &= ~(1<<i);
    }

    Aura* aura = Aura::TryRefreshStackOrCreate(spellInfo, effMask, target, this);
    if (aura != nullptr)
    {
        aura->ApplyForTargets();
        return aura;
    }
    return nullptr;
}

void Unit::SetAuraStack(uint32 spellId, Unit* target, uint32 stack)
{
    Aura* aura = target->GetAura(spellId, GetGUID());
    if (!aura)
        aura = AddAura(spellId, target);
    if (aura && stack)
        aura->SetStackAmount(stack);
}

void Unit::SendPlaySpellVisualKit(uint32 p_KitRecID, uint32 p_KitType, int32 p_Duration)
{
    WorldPacket l_Data(SMSG_PLAY_SPELL_VISUAL_KIT, 16 + 2 + 4 + 4 + 4);
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(p_KitRecID);             ///< SpellVisualKit.db2 index
    l_Data << uint32(p_KitType);
    l_Data << uint32(p_Duration);
    SendMessageToSet(&l_Data, true);
}

void Unit::CancelSpellVisualKit(int32 p_SpellVisualKitID)
{
    WorldPacket l_Data(Opcodes::SMSG_CANCEL_SPELL_VISUAL_KIT, 16 + 2 + 4);
    l_Data.appendPackGUID(GetGUID());
    l_Data << int32(p_SpellVisualKitID);
    SendMessageToSet(&l_Data, true);
}

void Unit::SendPlaySpellVisual(uint32 p_ID, Unit* p_Target, float p_Speed, float p_Orientation, Position p_Pos, bool p_ThisAsPos /*= false*/, bool p_SpeedAsTime /*= false*/)
{
    if (p_ThisAsPos)
        GetPosition(&p_Pos);
    else if (p_Target)
        GetPosition(&p_Pos);
    else if (p_Pos.m_positionX == 0.0f && p_Pos.m_positionY == 0.0f && p_Pos.m_positionZ == 0.0f)
    {
        p_Pos.m_positionX = 0.0f;
        p_Pos.m_positionY = 0.0f;
        p_Pos.m_positionZ = 0.0f;
    }

    WorldPacket l_Data(SMSG_PLAY_SPELL_VISUAL, 16 + 2 + 16 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1);
    l_Data.appendPackGUID(GetGUID());
    l_Data.appendPackGUID(p_Target ? p_Target->GetGUID() : 0);
    l_Data << float(p_Pos.m_positionX);
    l_Data << float(p_Pos.m_positionY);
    l_Data << float(p_Pos.m_positionZ);
    l_Data << uint32(p_ID);
    l_Data << float(p_Speed);
    l_Data << uint16(0);            ///< MissReason
    l_Data << uint16(0);            ///< ReflectStatus
    l_Data << float(p_Orientation);
    l_Data.WriteBit(p_SpeedAsTime);

    if (IsPlayer() && ToPlayer()->GetSession())
        ToPlayer()->GetSession()->SendPacket(&l_Data);
    else
        SendMessageToSet(&l_Data, false);
}

void Unit::SendPlaySpellVisual(uint32 p_ID, Unit* p_Target, float p_Speed, Position p_Pos, bool p_SpeedAsTime /*= false*/, bool p_Self /*= true*/)
{
    WorldPacket l_Data(SMSG_PLAY_SPELL_VISUAL, 16 + 2 + 16 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1);
    l_Data.appendPackGUID(GetGUID());
    l_Data.appendPackGUID(p_Target ? p_Target->GetGUID() : 0);
    l_Data << float(p_Pos.m_positionX);
    l_Data << float(p_Pos.m_positionY);
    l_Data << float(p_Pos.m_positionZ);
    l_Data << uint32(p_ID);
    l_Data << float(p_Speed);
    l_Data << uint16(0);            ///< MissReason
    l_Data << uint16(0);            ///< ReflectStatus
    l_Data << float(p_Pos.m_orientation);
    l_Data.WriteBit(p_SpeedAsTime);

    if (IsPlayer() && ToPlayer()->GetSession())
        ToPlayer()->GetSession()->SendPacket(&l_Data);
    if (!(IsPlayer() && ToPlayer()->GetSession()) || !p_Self)
        SendMessageToSet(&l_Data, false);
}

void Unit::CancelSpellVisual(int32 p_SpellVisualID)
{
    WorldPacket l_Data(Opcodes::SMSG_CANCEL_SPELL_VISUAL);
    l_Data.appendPackGUID(GetGUID());
    l_Data << int32(p_SpellVisualID);
    SendMessageToSet(&l_Data, true);
}

void Unit::SendScriptCast(uint32 p_SpellID)
{
    if (!IsPlayer())
        return;

    WorldPacket l_Data(Opcodes::SMSG_SCRIPT_CAST, 4);
    l_Data << p_SpellID;
    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

void Unit::ApplyResilience(Unit const* p_Victim, int32* p_Damage) const
{
    /// Player mounted on multi-passenger mount is also classified as vehicle
    if (IsVehicle() && GetTypeId() != TypeID::TYPEID_PLAYER)
        return;

    if (p_Victim->IsVehicle() && p_Victim->GetTypeId() != TypeID::TYPEID_PLAYER)
        return;

    /// Resilience works only for players or pets against other players or pets
    if (GetTypeId() != TypeID::TYPEID_PLAYER && (GetOwner() && GetOwner()->GetTypeId() != TypeID::TYPEID_PLAYER))
        return;

    /// Don't consider resilience if not in PvP - player or pet
    if (!GetCharmerOrOwnerPlayerOrPlayerItself())
        return;

    Unit const* l_Target = nullptr;
    if (p_Victim->GetTypeId() == TypeID::TYPEID_PLAYER)
        l_Target = p_Victim;
    else if (p_Victim->GetTypeId() == TypeID::TYPEID_UNIT && p_Victim->GetOwner() && p_Victim->GetOwner()->GetTypeId() == TypeID::TYPEID_PLAYER)
        l_Target = p_Victim->GetOwner();

    if (!l_Target)
        return;

    *p_Damage -= (int32)CalculatePct(float(*p_Damage), -l_Target->GetFloatValue(EPlayerFields::PLAYER_FIELD_MOD_RESILIENCE_PERCENT));
}

// Melee based spells can be miss, parry or dodge on this step
// Crit or block - determined on damage calculation phase! (and can be both in some time)
float Unit::MeleeSpellMissChance(const Unit* p_Victim, SpellInfo const* p_Spell, WeaponAttackType p_AttType) const
{
    // Calculate miss chance
    float l_MissChance = p_Victim->GetUnitMissChancePhysical(this, p_AttType);

    if (((p_Spell && !p_Spell->Id && haveOffhandWeapon() && (!ToPlayer() || ToPlayer()->GetActiveSpecializationID() != SPEC_ROGUE_OUTLAW)) || (haveOffhandWeapon() && (!p_Spell || p_Spell->Id == 6603))) &&
        !HasAura(200876) && GetEntry() != WarlockPet::WrathGuard)
        l_MissChance += 19.0f;

    // Calculate hit chance
    float l_HitChance = 100.0f;

    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
    if (p_Spell && p_Spell->Id)
    {
        if (Player* l_ModOwner = GetSpellModOwner())
            l_ModOwner->ApplySpellMod(p_Spell->Id, SPELLMOD_RESIST_MISS_CHANCE, l_HitChance);
    }

    // Increase hit chance from attacker auras and attacker ratings
    if (!p_Spell || !ToCreature() || !ToCreature()->IsDungeonBoss())
    {
        if (p_AttType == WeaponAttackType::RangedAttack)
            l_HitChance += m_modRangedHitChance;
        else
            l_HitChance += m_modMeleeHitChance;
    }

    l_MissChance += 100.0f - l_HitChance;

    if (l_MissChance < 0.0f)
        return 0.0f;
    if (l_MissChance > 100.0f)
        return 100.0f;

    return l_MissChance;
}

float Unit::MagicSpellMissChance(const Unit* p_Victim, SpellInfo const* p_Spell) const
{
    // Calculate miss chance
    float l_MissChance = p_Victim->GetUnitMissChanceSpell(this);

    // Calculate hit chance
    float l_HitChance = 100.0f;

    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
    if (p_Spell && p_Spell->Id)
    {
        if (Player* l_ModOwner = GetSpellModOwner())
            l_ModOwner->ApplySpellMod(p_Spell->Id, SPELLMOD_RESIST_MISS_CHANCE, l_HitChance);
    }

    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will ignore target's avoidance effects
    if (p_Spell && (p_Spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT))
    {
        // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
        l_HitChance += p_Victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, p_Spell->GetSchoolMask());
    }

    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
    l_HitChance += m_modSpellHitChance;

    l_MissChance += 100.0f - l_HitChance;

    return std::min(std::abs(l_MissChance), 100.0f);
}

void Unit::SetPhaseMaskWithSummons(uint32 p_NewPhaseMask, bool p_Update)
{
    uint32 l_OldPhaseMask = GetPhaseMask();

    Unit::SetPhaseMask(p_NewPhaseMask | l_OldPhaseMask, p_Update);
    Unit::SetPhaseMask(p_NewPhaseMask, p_Update);
}

void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
{
    if (newPhaseMask == GetPhaseMask())
        return;

    if (IsInWorld())
    {
        RemoveNotOwnSingleTargetAuras(newPhaseMask);            // we can lost access to caster or target

        // modify hostile references for new phasemask, some special cases deal with hostile references themselves
        if (GetTypeId() == TYPEID_UNIT || (!ToPlayer()->isGameMaster() && !ToPlayer()->GetSession()->PlayerLogout()))
        {
            HostileRefManager& refManager = getHostileRefManager();
            HostileReference* ref = refManager.getFirst();

            while (ref)
            {
                if (Unit* unit = ref->getSource()->getOwner())
                    if (Creature* creature = unit->ToCreature())
                        refManager.setOnlineOfflineState(creature, creature->InSamePhase(this) && (newPhaseMask & creature->GetPhaseMask()));

                ref = ref->next();
            }

            // modify threat lists for new phasemask
            if (GetTypeId() != TYPEID_PLAYER)
            {
                std::list<HostileReference*> threatList = getThreatManager().getThreatList();
                std::list<HostileReference*> offlineThreatList = getThreatManager().getOfflineThreatList();

                // merge expects sorted lists
                threatList.sort();
                offlineThreatList.sort();
                threatList.merge(offlineThreatList);

                for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)
                    if (Unit* unit = (*itr)->getTarget())
                        unit->getHostileRefManager().setOnlineOfflineState(ToCreature(), unit->InSamePhase(this) && (newPhaseMask & unit->GetPhaseMask()));
            }
        }
    }

    WorldObject::SetPhaseMask(newPhaseMask, update);

    if (!IsInWorld())
        return;

    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        if ((*itr)->GetTypeId() == TYPEID_UNIT)
            (*itr)->SetPhaseMask(newPhaseMask, true);

    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
        if (m_SummonSlot[i])
            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
                summon->SetPhaseMask(newPhaseMask, true);
}

class Unit::AINotifyTask : public BasicEvent
{
    Unit& m_owner;
public:
    explicit AINotifyTask(Unit * me) : BasicEvent(), m_owner(*me)
    {
        m_owner.m_VisibilityUpdScheduled = true;
    }

    ~AINotifyTask()
    {
        m_owner.m_VisibilityUpdScheduled = false;
    }

    virtual bool Execute(uint64 , uint32)
    {
        JadeCore::AIRelocationNotifier notifier(m_owner);
        m_owner.VisitNearbyObject(60.0f, notifier);
        return true;
    }

    static void ScheduleAINotify(Unit* me)
    {
        if (!me->m_VisibilityUpdScheduled)
            me->m_Events.AddEvent(new AINotifyTask(me), me->m_Events.CalculateTime(World::Visibility_AINotifyDelay));
    }
};

float g_RequiredMoveDistanceSq[6] =
{
    20.0f,  ///< MAP_COMMON
    25.0f,  ///< MAP_INSTANCE
    25.0f,  ///< MAP_RAID
    16.0f,  ///< MAP_BATTLEGROUND,
     1.0f,  ///< MAP_ARENA
    25.0f   ///< MAP_SCENARIO
};

class Unit::VisibilityUpdateTask : public BasicEvent
{
    Unit& m_owner;

    public:
        explicit VisibilityUpdateTask(Unit * me) : BasicEvent(), m_owner(*me) {}

        virtual bool Execute(uint64 , uint32)
        {
            Map* l_Map = m_owner.GetMap();
            if (!l_Map)
                return true;

            l_Map->AddUpdateVisibilityObject(&m_owner);
            return true;
        }
};

void Unit::DelayedUpdateVisibility()
{
    Map* l_Map = GetMap();
    if (!l_Map)
        return;

    float l_DistanceX = m_LastNotifyPosition.GetPositionX() - GetPositionX();
    float l_DistanceY = m_LastNotifyPosition.GetPositionY() - GetPositionY();
    float l_DistanceZ = m_LastNotifyPosition.GetPositionZ() - GetPositionZ();
    float l_DistanceSQ = l_DistanceX * l_DistanceX + l_DistanceY * l_DistanceY + l_DistanceZ * l_DistanceZ;

    float l_MinDistanceSQ = g_RequiredMoveDistanceSq[l_Map->GetEntry()->instanceType];
    if (l_DistanceSQ < l_MinDistanceSQ)
        return;

    m_LastNotifyPosition.Relocate(GetPositionX(), GetPositionY(), GetPositionZ());

    if (!m_sharedVision.empty())
    {
        for (SharedVisionList::const_iterator it = m_sharedVision.begin(); it != m_sharedVision.end();)
        {
            Player * tmp = *it;
            ++it;
            tmp->UpdateVisibilityForPlayer(false);
        }
    }

    if (isType(TYPEMASK_PLAYER))
       ToPlayer()->UpdateVisibilityForPlayer(false);

    WorldObject::UpdateObjectVisibility(true);
}

void Unit::UpdateObjectVisibility(bool forced)
{
    if (forced)
    {
        m_Events.KillEventType<VisibilityUpdateTask>();

        bool l_MapPerfLog = sMapMgr->m_LogMapPerformance || GetMap()->IsRaid();
        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::time_point();
        if (l_MapPerfLog)
            start = std::chrono::steady_clock::now();

        if (isType(TYPEMASK_PLAYER))
            ((Player*)this)->UpdateVisibilityForPlayer(true);

        WorldObject::UpdateObjectVisibility(true);

        if (l_MapPerfLog)
            GetMap()->m_UpdateVisibilityForcedTime += std::chrono::steady_clock::now() - start;
    }
    else if (!m_VisibilityUpdScheduled)
        m_Events.AddEvent(new VisibilityUpdateTask(this), m_Events.CalculateTime(World::Visibility_AINotifyDelay));

    AINotifyTask::ScheduleAINotify(this);
}

void Unit::SendMoveKnockBack(Player* p_Player, float p_SpeedXY, float p_SpeedZ, float p_Cos, float p_Sin)
{
    if (ToPlayer())
        sAnticheatMgr->HandleStartKnockback(ToPlayer()->GetGUIDLow());

    WorldPacket l_Packet(SMSG_MOVE_KNOCK_BACK, (1 + 8 + 4 + 4 + 4 + 4 + 4));

    l_Packet.appendPackGUID(GetGUID());
    l_Packet << uint32(m_movementCounter++);
    l_Packet << float(p_Cos);
    l_Packet << float(p_Sin);
    l_Packet << float(p_SpeedXY);
    l_Packet << float(p_SpeedZ);

    p_Player->GetSession()->SendPacket(&l_Packet);
}

void Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ, Unit* p_Caster /*= nullptr*/)
{
    Player* player = NULL;
    if (IsPlayer())
        player = ToPlayer();
    else if (Unit* charmer = GetCharmer())
    {
        player = charmer->ToPlayer();
        if (player && player->m_mover != this)
            player = NULL;
    }

    if (!player)
        GetMotionMaster()->MoveKnockbackFrom(x, y, speedXY, speedZ);
    else
    {
        float vcos, vsin;
        GetSinCos(x, y, vsin, vcos, p_Caster);
        SendMoveKnockBack(player, speedXY, -speedZ, vcos, vsin);

        /// Sniffed on retail, if knocked back while on a flying mount (even on the ground)
        /// Server sends fly mode again 500ms later to prevent player from falling
        AddDelayedEvent([this]() -> void
        {
            /// Refresh fly mode if needed
            if (HasAuraType(AuraType::SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
                SetCanFly(true);
        }, 500);
    }
}

void Unit::KnockbackFrom(Position p_Position, float p_SpeedXY, float p_SpeedZ, Unit* p_Caster /*= nullptr*/)
{
    KnockbackFrom(p_Position.m_positionX, p_Position.m_positionY, p_SpeedXY, p_SpeedZ, p_Caster);
}

/// Update it for 7.0.3
uint32 Unit::GetModelForForm(ShapeshiftForm form)
{
    /// Handle artifact shapeshift
    if (Player* l_Player = ToPlayer())
    {
        if (l_Player->GetActiveSpecializationID() == SPEC_DRUID_GUARDIAN || l_Player->GetActiveSpecializationID() == SPEC_DRUID_FERAL) ///< Hacky
        {
            if (MS::Artifact::Manager* l_Artifact = l_Player->GetCurrentlyEquippedArtifact())
            {
                if (l_Artifact->ToItem())
                {
                    if (ArtifactAppearanceEntry const* l_ArtifactAppearance = sArtifactAppearanceStore.LookupEntry(l_Artifact->ToItem()->GetModifier(ITEM_MODIFIER_ARTIFACT_APPEARANCE_ID)))
                    {
                        if (ShapeshiftForm(l_ArtifactAppearance->OverrideShapeshiftFormId) == form)
                            return l_ArtifactAppearance->OverrideShapeshiftDisplayId;
                    }
                }
            }
        }
    }

    switch (form)
    {
        case FORM_CAT_FORM:
        {
            /// Hack for Druid of the Flame, Fandral's Flamescythe
            if (HasAura(99245))
                return 38150;

            bool l_IncarnationKingOfTheJungle = HasAura(102543);
            uint32 l_KingOfTheJungleModel = 0;
            uint32 l_BaseCatModel = 0;

            // Based on Hair color
            if (getRace() == RACE_NIGHTELF)
            {
                uint8 hairColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    hairColor = urand(0, 10);

                switch (hairColor)
                {
                    case 7: // Violet
                    case 8:
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43764;
                        else
                            l_BaseCatModel = 29405;
                        break;
                    }
                    case 3: // Light Blue
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43763;
                        else
                            l_BaseCatModel = 29406;
                        break;
                    }
                    case 0: // Green
                    case 1: // Light Green
                    case 2: // Dark Green
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43762;
                        else
                            l_BaseCatModel = 29407;
                        break;
                    }
                    case 4: // White
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43765;
                        else
                            l_BaseCatModel = 29408;
                        break;
                    }
                    default: // original - Dark Blue
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43761;
                        else
                            l_BaseCatModel = 892;
                        break;
                    }
                }
            }
            else if (getRace() == RACE_TROLL)
            {
                uint8 hairColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);
                if (HasAura(107059))
                    hairColor = urand(0, 12); ///< Glyph of the Chameleon
                switch (hairColor)
                {
                    case 0: // Red
                    case 1:
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43776;
                        else
                            l_BaseCatModel = 33668;
                        break;
                    }
                    case 2: // Yellow
                    case 3:
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43778;
                        else
                            l_BaseCatModel = 33667;
                        break;
                    }
                    case 4: // Blue
                    case 5:
                    case 6:
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43773;
                        else
                            l_BaseCatModel = 33666;
                        break;
                    }
                    case 7: // Purple
                    case 10:
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43775;
                        else
                            l_BaseCatModel = 33665;
                        break;
                    }
                    default: // original - white
                    {
                        if (l_IncarnationKingOfTheJungle)
                            l_KingOfTheJungleModel = 43777;
                        else
                            l_BaseCatModel = 33669;
                        break;
                    }
                }
            }
            else if (getRace() == RACE_WORGEN)
            {
                // Based on Skin color
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 9);
                // Male
                if (getGender() == GENDER_MALE)
                {
                    switch (skinColor)
                    {
                        case 1: // Brown
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43781;
                            else
                                l_BaseCatModel = 33662;
                            break;
                        }
                        case 2: // Black
                        case 7:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43780;
                            else
                                l_BaseCatModel = 33661;
                            break;
                        }
                        case 4: // yellow
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43784;
                            else
                                l_KingOfTheJungleModel = 33664;
                            break;
                        }
                        case 3: // White
                        case 5:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43785;
                            else
                                l_BaseCatModel = 33663;
                        }
                        default: // original - Gray
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43782;
                            else
                                l_BaseCatModel = 33660;
                            break;
                        }
                    }
                }
                // Female
                else
                {
                    switch (skinColor)
                    {
                        case 5: // Brown
                        case 6:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43781;
                            else
                                l_BaseCatModel = 33662;
                            break;
                        }
                        case 7: // Black
                        case 8:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43780;
                            else
                                l_BaseCatModel = 33661;
                            break;
                        }
                        case 3: // yellow
                        case 4:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43784;
                            else
                                l_BaseCatModel = 33664;
                            break;
                        }
                        case 2: // White
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43785;
                            else
                                l_BaseCatModel = 33663;
                            break;
                        }
                        default: // original - Gray
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43782;
                            else
                                l_BaseCatModel = 33660;
                            break;
                        }
                    }
                }
            }
            // Based on Skin color
            else if (getRace() == RACE_TAUREN)
            {
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 20);
                // Male
                if (getGender() == GENDER_MALE)
                {
                    switch (skinColor)
                    {
                        case 12: // White
                        case 13:
                        case 14:
                        case 18: // Completly White
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43769;
                            else
                                l_BaseCatModel = 29409;
                            break;
                        }
                        case 9: // Light Brown
                        case 10:
                        case 11:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43770;
                            else
                                l_BaseCatModel = 29410;
                            break;
                        }
                        case 6: // Brown
                        case 7:
                        case 8:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43768;
                            else
                                l_BaseCatModel = 29411;
                            break;
                        }
                        case 0: // Dark
                        case 1:
                        case 2:
                        case 3: // Dark Grey
                        case 4:
                        case 5:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43766;
                            else
                                l_BaseCatModel = 29412;
                            break;
                        }
                        default: // original - Grey
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43767;
                            else
                                l_BaseCatModel = 8571;
                            break;
                        }
                    }
                }
                // Female
                else
                {
                    switch (skinColor)
                    {
                        case 10: // White
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43769;
                            else
                                l_BaseCatModel = 29409;
                            break;
                        }
                        case 6: // Light Brown
                        case 7:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43770;
                            else
                                l_BaseCatModel = 29410;
                            break;
                        }
                        case 4: // Brown
                        case 5:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43768;
                            else
                                l_BaseCatModel = 29411;
                            break;
                        }
                        case 0: // Dark
                        case 1:
                        case 2:
                        case 3:
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43766;
                            else
                                l_BaseCatModel = 29412;
                            break;
                        }
                        default: // original - Grey
                        {
                            if (l_IncarnationKingOfTheJungle)
                                l_KingOfTheJungleModel = 43767;
                            else
                                l_BaseCatModel = 8571;
                            break;
                        }
                    }
                }
            }
            else if (getRace() == RACE_HIGHMOUNTAIN_TAUREN)
            {
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);

                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 4);

                    switch (skinColor)
                    {
                        case 0: ///< Brown
                        {
                            if (l_IncarnationKingOfTheJungle)
                                return 66777;
                            else
                                return 80598;
                        }
                        case 1: ///< Light brown
                        {
                            if (l_IncarnationKingOfTheJungle)
                                return 66778;
                            else
                                return 80597;
                        }
                        case 2: ///< White
                        {
                            if (l_IncarnationKingOfTheJungle)
                                return 66781;
                            else
                                return 80599;
                        }
                        case 3: ///< Black
                        {
                            if (l_IncarnationKingOfTheJungle)
                                return 66775;
                            else
                                return 80596;
                        }
                        default:
                            if (l_IncarnationKingOfTheJungle)
                                return 66776;
                            else
                                return 80599;
                    }

            }

            if (l_KingOfTheJungleModel)
                return l_KingOfTheJungleModel;
            else if (l_BaseCatModel)
                return l_BaseCatModel;
            else if (Player::TeamForRace(getRace()) == ALLIANCE)
                return 892;
            else
                return 8571;
        }
        case FORM_BEAR_FORM:
        {
            bool l_IncarnationGuardianOfUrsoc = HasAura(102558);

            // Based on Hair color
            /// need to be rework
            if (getRace() == RACE_NIGHTELF)
            {
                uint8 hairColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    hairColor = urand(0, 8);
                switch (hairColor)
                {
                    case 0: // Green
                    case 1: // Light Green
                    case 2: // Dark Green
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43759;
                        else
                            return 29413;
                    }
                    case 6: // Black
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43756;
                        else
                            return 29414;
                    }
                    case 4: // White
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43760;
                        else
                            return 29416;
                    }
                    case 3: // Light Blue
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43757;
                        else
                            return 29415;
                    }
                    default: // original - Violet
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43758;
                        else
                            return 29417;
                    }
                }
            }
            /// need to be rework
            else if (getRace() == RACE_TROLL)
            {
                uint8 hairColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    hairColor = urand(0, 14);
                switch (hairColor)
                {
                    case 0: // Red
                    case 1:
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43748;
                        else
                            return 33657;
                    }
                    case 2: // Yellow
                    case 3:
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43750;
                        else
                            return 33659;
                    }
                    case 7: // Purple
                    case 10:
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43747;
                        else
                            return 33656;
                    }
                    case 8: // White
                    case 9:
                    case 11:
                    case 12:
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43749;
                        else
                            return 33658;
                    }
                    default: // original - Blue
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 43746;
                        else
                            return 33655;
                    }
                }
            }
            /// need to be rework
            else if (getRace() == RACE_WORGEN)
            {
                // Based on Skin color
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 8);
                // Male
                if (getGender() == GENDER_MALE)
                {
                    switch (skinColor)
                    {
                        case 1: // Brown
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43752;
                            else
                                return 33652;
                        }
                        case 2: // Black
                        case 7:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43751;
                            else
                                return 33651;
                        }
                        case 4: // Yellow
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43755;
                            else
                                return 33654;
                        }
                        case 3: // White
                        case 5:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43754;
                            else
                                return 33653;
                        }
                        default: // original - Gray
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43753;
                            else
                                return 33650;
                        }
                    }
                }
                // Female
                else
                {
                    switch (skinColor)
                    {
                        case 5: // Brown
                        case 6:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43752;
                            else
                                return 33652;
                        }
                        case 7: // Black
                        case 8:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43751;
                            else
                                return 33651;
                        }
                        case 3: // yellow
                        case 4:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43755;
                            else
                                return 33654;
                        }
                        case 2: // White
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43754;
                            else
                                return 33653;
                        }
                        default: // original - Gray
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43753;
                            else
                                return 33650;
                        }
                    }
                }
            }
            // Based on Skin color
            /// need to be rework
            else if (getRace() == RACE_TAUREN)
            {
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 20);
                // Male
                if (getGender() == GENDER_MALE)
                {
                    switch (skinColor)
                    {
                        case 0: // Dark (Black)
                        case 1:
                        case 2:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43741;
                            else
                                return 29418;
                        }
                        case 3: // White
                        case 4:
                        case 5:
                        case 12:
                        case 13:
                        case 14:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43743;
                            else
                                return 29419;
                        }
                        case 9: // Light Brown/Grey
                        case 10:
                        case 11:
                        case 15:
                        case 16:
                        case 17:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43745;
                            else
                                return 29420;
                        }
                        case 18: // Completly White
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43744;
                            else
                                return 29421;
                        }
                        default: // original - Brown
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43742;
                            else
                                return 2289;
                        }
                    }
                }
                // Female
                else
                {
                    switch (skinColor)
                    {
                        case 0: // Dark (Black)
                        case 1:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43741;
                            else
                                return 29418;
                        }
                        case 2: // White
                        case 3:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43743;
                            else
                                return 29419;
                        }
                        case 6: // Light Brown/Grey
                        case 7:
                        case 8:
                        case 9:
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43745;
                            else
                                return 29420;
                        }
                        case 10: // Completly White
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43744;
                            else
                                return 29421;
                        }
                        default: // original - Brown
                        {
                            if (l_IncarnationGuardianOfUrsoc)
                                return 43742;
                            else
                                return 2289;
                        }
                    }
                }
            }
            /// Based on Skin color
            else if (getRace() == RACE_HIGHMOUNTAIN_TAUREN)
            {
                uint8 skinColor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
                if (HasAura(107059)) ///< Glyph of the Chameleon
                    skinColor = urand(0, 4);

                switch (skinColor)
                {
                    case 0: ///< Brown
                    {
                        if (l_IncarnationGuardianOfUrsoc) ///< no special models on this race (7.3.5 26124)
                            return 80592;
                        else
                            return 80592;
                    }
                    case 1: ///< Light brown
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 80595;
                        else
                            return 80595;
                    }
                    case 2: ///< White
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 80594;
                        else
                            return 80594;
                    }
                    case 3: ///< Black
                    {
                        if (l_IncarnationGuardianOfUrsoc)
                            return 80591;
                        else
                            return 80591;
                    }
                    default:
                        return 80593; ///< Withe with Purple mark
                }
            }
            else if (Player::TeamForRace(getRace()) == ALLIANCE)
                return 2281;
            else
                return 2289;
        }
        case FORM_FLIGHT_FORM_EPIC:
        case FORM_FLIGHT_FORM:
        {
            /// Glyph of the Sentinel
            bool l_GlyphoftheSentinel = HasAura(219062);
            bool l_HasClassMount = HasSpell(231437);

            switch (getRace())
            {
                case RACE_NIGHTELF:
                {
                    if (l_HasClassMount)
                        return 74305;
                    else if (l_GlyphoftheSentinel)
                        return 64328;

                    return 21243;
                }
                case RACE_TAUREN:
                {
                    if (l_HasClassMount)
                        return 74304;
                    else if (l_GlyphoftheSentinel)
                        return 64329;

                    return 20872;
                }
                case RACE_WORGEN:
                {
                    if (l_HasClassMount)
                        return 74307;
                    else if (l_GlyphoftheSentinel)
                        return 64330;

                    return 37729;
                }
                case RACE_TROLL:
                {
                    if (l_HasClassMount)
                        return 74306;
                    else if (l_GlyphoftheSentinel)
                        return 64331;

                    return 37730;
                }
                case RACE_HIGHMOUNTAIN_TAUREN:
                {
                    if (l_HasClassMount)
                        return 74304;
                    else if (l_GlyphoftheSentinel)
                        return 64329;

                    return 81439;
                }
                default:
                    break;
            }
        }
        case FORM_TRAVEL_FORM:
        {
            /// In Legion Stag form is an optional item who allow player to use ground form in flying zone
            bool l_StagForm = HasAura(210053);

            /// Glyph of the Cheetah
            if (HasAura(131113))
                return 1043;

            ///< Glyph of the Doe
            if (HasAura(224122))
                return 70576;

            switch (getRace())
            {
                case RACE_NIGHTELF:
                case RACE_WORGEN:
                {
                    if (l_StagForm)
                        return 40816;
                    return 40816;
                }
                case RACE_TROLL:
                case RACE_TAUREN:
                {
                    if (l_StagForm)
                        return 45339;
                    return 45339;
                }
                case RACE_HIGHMOUNTAIN_TAUREN:
                {
                    if (l_StagForm)
                        return 81440;
                    return 81440;
                }
                default:
                    break;
            }
            break;
        }
        case FORM_MOONKIN_FORM:
        case FORM_MOONKIN_FORM_AFFINITY:
        {
            /// Glyph of Stars
            if (HasAura(114301))
            {
                return GetNativeDisplayId();
            }

            bool l_ChosenOfElune = HasAura(102560); ///< Incarnation : Chosen of Elune

            switch (getRace())
            {
                case RACE_NIGHTELF:
                {
                    if (l_ChosenOfElune)
                        return 43790;
                    return 15374;
                }
                case RACE_TAUREN:
                {
                    if (l_ChosenOfElune)
                        return 43786;
                    return 15375;
                }
                case RACE_WORGEN:
                {
                    if (l_ChosenOfElune)
                        return 43787;
                    return 37173;
                }
                case RACE_TROLL:
                {
                    if (l_ChosenOfElune)
                        return 43789;
                    return 37174;
                }
                case RACE_HIGHMOUNTAIN_TAUREN:
                {
                    if (l_ChosenOfElune)
                        return 43786;
                    return 15375;
                }
                default:
                    break;
            }
            break;
        }
        case FORM_AQUATIC_FORM:
        {
            /// Glyph of the Orca
            if (HasAura(114333))
                return 4591;
            break;
        }
        case FORM_GHOST_WOLF:
        {
            /// Glyph of the Spectral Wolf
            if (HasAura(58135))
                return 60247;

            ///< Glyph of the Spectral Raptor
            if (HasAura(212631))
                return 74353;

            break;
        }
        default:
            break;
    }

    uint32 modelid = 0;
    SpellShapeshiftFormEntry const* formEntry = sSpellShapeshiftFormStore.LookupEntry(form);
    if (formEntry && formEntry->CreatureDisplayID[0])
    {
        /// Take the alliance modelid as default
        if (GetTypeId() != TYPEID_PLAYER)
            return formEntry->CreatureDisplayID[0];
        else
        {
            if (Player::TeamForRace(getRace()) == ALLIANCE)
                modelid = formEntry->CreatureDisplayID[0];
            else
                modelid = formEntry->CreatureDisplayID[1];

            /// If the player is horde but there are no values for the horde modelid - take the alliance modelid
            if (!modelid && Player::TeamForRace(getRace()) == HORDE)
                modelid = formEntry->CreatureDisplayID[0];
        }
    }

    if (!modelid)
        modelid = GetNativeDisplayId();
    return modelid;
}

uint32 Unit::GetCategoryForTotem(uint32 p_TotemCategory)
{
    switch (p_TotemCategory)
    {
        case TOTEM_CATEGORY_FIRE:
        case TOTEM_CATEGORY_FIRE_2:
        case TOTEM_CATEGORY_FIRE_3:
            return SUMMON_TYPE_TOTEM_FIRE;
        case TOTEM_CATEGORY_EARTH:
        case TOTEM_CATEGORY_EARTH_2:
        case TOTEM_CATEGORY_EARTH_3:
        case TOTEM_CATEGORY_EARTH_4:
            return SUMMON_TYPE_TOTEM_EARTH;
        case TOTEM_CATEGORY_WATER:
        case TOTEM_CATEGORY_WATER_2:
        case TOTEM_CATEGORY_WATER_3:
            return SUMMON_TYPE_TOTEM_WATER;
        case TOTEM_CATEGORY_AIR:
        case TOTEM_CATEGORY_AIR_2:
        case TOTEM_CATEGORY_AIR_3:
        case TOTEM_CATEGORY_AIR_4:
        case TOTEM_CATEGORY_AIR_5:
        case TOTEM_CATEGORY_AIR_6:
            return SUMMON_TYPE_TOTEM_AIR;
        default:
            break;
    }
    return 0;
}


uint32 Unit::GetModelForTotem(uint32 p_TotemType)
{
    ///< Tidal Totem
    if (p_TotemType == PlayerTotemCategory::TOTEM_CATEGORY_WATER_3)
        return 69144;

    p_TotemType = GetCategoryForTotem(p_TotemType);

    switch (getRace())
    {
        case RACE_ORC:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 30758;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 30757;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 30759;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 30756;
                default:
                    return 30758;
            }
            break;
        }
        case RACE_DWARF:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 30754;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 30753;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 30755;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 30736;
                default:
                    return 30754;
            }
            break;
        }
        case RACE_TROLL:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 30762;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 30761;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 30763;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 30760;
                default:
                    return 30762;
            }
            break;
        }
        case RACE_TAUREN:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 4589;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 4588;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 4587;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 4590;
                default:
                    return 4589;
            }
            break;
        }
        case RACE_DRAENEI:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 19074;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 19073;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 19075;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 19071;
                default:
                    return 19074;
            }
            break;
        }
        case RACE_GOBLIN:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 30783;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 30782;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 30784;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 30781;
                default:
                    return 30783;
            }
            break;
        }
        case RACE_PANDAREN_NEUTRAL:
        case RACE_PANDAREN_ALLIANCE:
        case RACE_PANDAREN_HORDE:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 41670;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 41669;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 41671;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 41668;
                default:
                    return 41670;
            }
            break;
        }
        case RACE_HIGHMOUNTAIN_TAUREN:
        {
            switch (p_TotemType)
            {
                case SUMMON_TYPE_TOTEM_FIRE:    ///< fire
                    return 81444;
                case SUMMON_TYPE_TOTEM_EARTH:   ///< earth
                    return 81443;
                case SUMMON_TYPE_TOTEM_WATER:   ///< water
                    return 81442;
                case SUMMON_TYPE_TOTEM_AIR:     ///< air
                    return 81441;
                default:
                    return 81444;
            }
            break;
        }
    }
    return 0;
}

void Unit::JumpTo(float speedXY, float speedZ, bool forward)
{
    float angle = forward ? 0 : M_PI;
    if (GetTypeId() == TYPEID_UNIT)
        GetMotionMaster()->MoveJumpTo(angle, speedXY, speedZ);
    else
    {
        float vcos = std::cos(angle+GetOrientation());
        float vsin = std::sin(angle+GetOrientation());
        SendMoveKnockBack(ToPlayer(), speedXY, -speedZ, vcos, vsin);
    }
}

void Unit::JumpTo(WorldObject* obj, float speedZ)
{
    float x, y, z;
    obj->GetContactPoint(this, x, y, z);
    float speedXY = GetExactDist2d(x, y) * 10.0f / speedZ;
    GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
}

bool Unit::HandleSpellClick(Unit* clicker, int8 seatId)
{
    uint32 spellClickEntry = GetVehicleKit() ? GetVehicleKit()->GetCreatureEntry() : GetEntry();
    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(spellClickEntry);
    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
    {
        //! First check simple relations from clicker to clickee
        if (!itr->second.IsFitToRequirements(clicker, this))
            return false;

        //! Check database conditions
        if (!sConditionMgr->IsObjectMeetingSpellClickConditions(spellClickEntry, itr->second.spellId, clicker, this))
            return false;

        if (ToCreature() && IsAIEnabled)
        {
            if (!ToCreature()->AI()->CanUseSpellClick(clicker, itr->second.spellId))
                return false;
        }

        Unit* caster = (itr->second.castFlags & NPC_CLICK_CAST_CASTER_CLICKER) ? clicker : this;
        Unit* target = (itr->second.castFlags & NPC_CLICK_CAST_TARGET_CLICKER) ? clicker : this;
        uint64 origCasterGUID = (itr->second.castFlags & NPC_CLICK_CAST_ORIG_CASTER_OWNER) ? GetOwnerGUID() : clicker->GetGUID();

        SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(itr->second.spellId);
        // if (!spellEntry) should be checked at npc_spellclick load
        if (!spellEntry)
        {
            sLog->outAshran("HandleSpellClick: spellEntry pointer is NULL!!");
            return false;
        }

        switch (spellEntry->Id)
        {
            /// Capture points
            case 97388:
            case 97372:
            case 156098:
            {
                bool l_HasMechanicImmunity = false;
                if (caster->getClass() == Classes::CLASS_DRUID && caster->GetShapeshiftForm() != ShapeshiftForm::FORM_NONE)
                {
                    AuraEffectList l_MechanicImunityList = caster->GetAuraEffectsByType(SPELL_AURA_MECHANIC_IMMUNITY);
                    for (AuraEffect const* l_AuraEffect : l_MechanicImunityList)
                    {
                        if (l_AuraEffect->GetMiscValue() != MECHANIC_POLYMORPH)
                        {
                            l_HasMechanicImmunity = true;
                            break;
                        }
                    }
                }
                else
                    l_HasMechanicImmunity = caster->HasAuraType(AuraType::SPELL_AURA_MECHANIC_IMMUNITY);

                if (caster->HasAuraType(SPELL_AURA_SCHOOL_IMMUNITY) || l_HasMechanicImmunity)
                    return false;
                if (caster->IsPlayer() && caster->ToPlayer()->GetBattleground())
                {
                    caster->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
                    caster->RemoveAurasByType(SPELL_AURA_MOD_INVISIBILITY);
                    caster->RemoveAurasByType(SPELL_AURA_MOD_CAMOUFLAGE);
                    caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
                }
                break;
            }
            default:
                break;
        }

        if (seatId > -1)
        {
            uint8 i = 0;
            bool valid = false;
            while (i < spellEntry->EffectCount && !valid)
            {
                if (spellEntry->Effects[i].ApplyAuraName == SPELL_AURA_CONTROL_VEHICLE)
                {
                    valid = true;
                    break;
                }
                ++i;
            }

            if (!valid)
                return false;

            if (IsInMap(caster))
                caster->CastCustomSpell(itr->second.spellId, SpellValueMod(SPELLVALUE_BASE_POINT0+i), seatId+1, target, false, NULL, nullptr, origCasterGUID);
            else    // This can happen during Player::_LoadAuras
            {
                int32 bp0[SpellEffIndex::MAX_EFFECTS];
                for (uint8 eff = 0; eff < spellEntry->EffectCount; eff++)
                    bp0[eff] = spellEntry->Effects[i].BasePoints;
                bp0[i] = seatId + 1;
                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, &bp0[0], NULL, origCasterGUID);
            }
        }
        else
        {
            if (IsInMap(caster))
                caster->CastSpell(target, spellEntry, false, NULL, nullptr, origCasterGUID);
            else
                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, NULL, NULL, origCasterGUID);
        }
    }

    Creature* creature = ToCreature();
    if (creature && creature->IsAIEnabled)
        creature->AI()->OnSpellClick(clicker);

    return true;
}

void Unit::EnterVehicle(Unit* base, int8 seatId, bool fullTriggered)
{
    CastCustomSpell(VEHICLE_SPELL_RIDE_HARDCODED, SPELLVALUE_BASE_POINT0, seatId + 1, base, fullTriggered ? TRIGGERED_FULL_MASK : TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE);
}

void Unit::_EnterVehicle(Vehicle* vehicle, int8 seatId, AuraApplication const* aurApp)
{
    // Must be called only from aura handler
    if (!isAlive() || GetVehicleKit() == vehicle || vehicle->GetBase()->IsOnVehicle(this))
        return;

    if (m_vehicle)
    {
        if (m_vehicle == vehicle)
        {
            if (seatId >= 0 && seatId != GetTransSeat())
                ChangeSeat(seatId);
            return;
        }
        else
            ExitVehicle();
    }

    if (aurApp && aurApp->GetRemoveMode())
        return;

    if (Player* player = ToPlayer())
    {
        if (vehicle->GetBase()->IsPlayer() && player->isInCombat())
            return;

        InterruptNonMeleeSpells(false);
        player->StopCastingCharm();
        player->StopCastingBindSight();
        Dismount();
        RemoveAurasByType(SPELL_AURA_MOUNTED);

        // drop flag at invisible in bg
        if (Battleground* bg = player->GetBattleground())
            bg->EventPlayerDroppedFlag(player);

        WorldPacket l_Data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
        player->GetSession()->SendPacket(&l_Data);

        switch (vehicle->GetVehicleInfo()->ID)
        {
            case 533:   ///< Bone Spike
            case 647:   ///< Bone Spike
            case 648:   ///< Bone Spike
            case 3417:  ///< Grasping Earth
                break;
            default:
                player->UnsummonPetTemporaryIfAny();
                break;
        }
    }

    ASSERT(!m_vehicle);
    m_vehicle = vehicle;
    if (!m_vehicle->AddPassenger(this, seatId))
    {
        m_vehicle = NULL;
        return;
    }
}

void Unit::ChangeSeat(int8 seatId, bool next)
{
    if (!m_vehicle)
        return;

    if (seatId < 0)
    {
        seatId = m_vehicle->GetNextEmptySeat(GetTransSeat(), next);
        if (seatId < 0)
            return;
    }
    else if (seatId == GetTransSeat() || !m_vehicle->HasEmptySeat(seatId))
        return;

    m_vehicle->RemovePassenger(this);
    if (!m_vehicle->AddPassenger(this, seatId))
        ASSERT(false);
}

void Unit::ExitVehicle(Position const* exitPosition)
{
    //! This function can be called at upper level code to initialize an exit from the passenger's side.
    if (!m_vehicle)
        return;

    Unit* l_VerhiculeBase = GetVehicleBase();
    if (l_VerhiculeBase != nullptr)
        l_VerhiculeBase->RemoveAurasByType(SPELL_AURA_CONTROL_VEHICLE, GetGUID());

    if (m_vehicle)
        if (m_vehicle->ArePassengersSpawnedByAI())
            _ExitVehicle(exitPosition);
}

void Unit::_ExitVehicle(Position const* exitPosition)
{
    if (!m_vehicle)
        return;

    m_vehicle->RemovePassenger(this);
    Player* player = ToPlayer();

    // If player is on mounted duel and exits the mount should immediately lose the duel
    if (player && player->m_Duel && player->m_Duel->isMounted)
        player->DuelComplete(DUEL_FLED);

    // This should be done before dismiss, because there may be some aura removal
    Vehicle* vehicle = m_vehicle;
    m_vehicle = NULL;

    Position l_ExitPos;

    /// Exit position not specified
    /// This should use passenger's current position, leaving it as it is now
    /// Because we calculate positions incorrect (sometimes under map)
    if (!exitPosition)
        vehicle->GetBase()->GetPosition(&l_ExitPos);
    else
        l_ExitPos = *exitPosition;

    if (Creature* l_Me = ToCreature())
    {
        if (l_Me->IsAIEnabled)
            l_Me->AI()->OnExitVehicle(vehicle->GetBase(), l_ExitPos);
    }

    AddUnitState(UNIT_STATE_MOVE);

    if (IsPlayer())
        ToPlayer()->SetFallInformation(0, GetPositionZ());
    else if (HasUnitMovementFlag(MOVEMENTFLAG_ROOT))
    {
        WorldPacket data(SMSG_SPLINE_MOVE_UNROOT, 16 + 2);
        ObjectGuid guid = GetGUID();
        data.appendPackGUID(guid);
        SendMessageToSet(&data, false);
    }

    Movement::MoveSplineInit init(this);
    init.MoveTo(l_ExitPos.GetPositionX(), l_ExitPos.GetPositionY(), l_ExitPos.GetPositionZ(), false);
    init.SetFacing(GetOrientation());
    init.SetTransportExit();
    init.Launch();

    SetControlled(false, UNIT_STATE_ROOT);      // SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT

    if (player)
    {
        player->ResummonPetTemporaryUnSummonedIfAny();
        player->SummonLastSummonedBattlePet();
    }

    if (vehicle->GetBase()->HasUnitTypeMask(UNIT_MASK_MINION))
        if (((Minion*)vehicle->GetBase())->GetOwner() == this)
            vehicle->Dismiss();

    if (HasUnitTypeMask(UNIT_MASK_ACCESSORY))
    {
        // Vehicle just died, we die too
        if (vehicle->GetBase()->getDeathState() == JUST_DIED)
            setDeathState(JUST_DIED);
        // If for other reason we as minion are exiting the vehicle (ejected, master dismounted) - unsummon
        else
        {
            ToTempSummon()->UnSummon(2000); // Approximation
            SetVisible(false); /// Hide from players until it is despawned
        }
    }

    /// Switch to the right zone-map if needed
    if (player && GetMap() && GetMap()->GetEntry()->instanceType == InstanceTypes::MAP_COMMON)
    {
        player->AddMapTask(eTaskType::TaskSwitchToPhasedMap, [player]() -> void
        {
            player->SwitchToPhasedMap(player->GetMapId());
        });
    }

    if (player)
        player->SetTeleportFlagForAnticheat(true);
}

bool Unit::IsFalling() const
{
    return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR) || movespline->isFalling();
}

bool Unit::CanSwim() const
{
    // Mirror client behavior, if this method returns false then client will not use swimming animation and for players will apply gravity as if there was no water
    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CANNOT_SWIM))
        return false;
    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)) // is player
        return true;
    if (HasFlag(UNIT_FIELD_FLAGS_2, 0x1000000))
        return false;
    return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT | UNIT_FLAG_RENAME | UNIT_FLAG_UNK_15);
}

bool Unit::SetWalk(bool p_Enable)
{
    if (p_Enable == IsWalking())
        return false;

    if (p_Enable)
        AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
    else
        RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);

    static Opcodes const l_WalkModeTable[2] = { SMSG_SPLINE_MOVE_SET_RUN_MODE, SMSG_SPLINE_MOVE_SET_WALK_MODE };

    WorldPacket l_Data(l_WalkModeTable[p_Enable]);
    l_Data.appendPackGUID(GetGUID());

    SendMessageToSet(&l_Data, true);
    return true;
}

bool Unit::SetDisableGravity(bool p_Disable, bool p_PacketOnly /*= false*/)
{
    if (!p_PacketOnly)
    {
        if (p_Disable == IsLevitating())
            return false;

        if (p_Disable)
        {
            AddUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);
            RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_SPLINE_ELEVATION);
            SetFall(false);
        }
        else
        {
            RemoveUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);
            if (!HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY))
                SetFall(true);
        }
    }

    static Opcodes const l_GravityOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_GRAVITY_ENABLE,  SMSG_MOVE_ENABLE_GRAVITY  },
        { SMSG_SPLINE_MOVE_GRAVITY_DISABLE, SMSG_MOVE_DISABLE_GRAVITY }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_GravityOpcodeTable[p_Disable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_GravityOpcodeTable[p_Disable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

bool Unit::SetFall(bool p_Enable)
{
    if (p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_FALLING))
        return false;

    if (p_Enable)
    {
        AddUnitMovementFlag(MOVEMENTFLAG_FALLING);
        m_movementInfo.SetFallTime(0);
    }
    else
        RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR);

    return true;
}

bool Unit::SetSwim(bool p_Enable)
{
    if (p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
        return false;

    if (p_Enable)
        AddUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
    else
        RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING);

    static Opcodes const l_SwimOpcodeTable[2] = { SMSG_SPLINE_MOVE_STOP_SWIM, SMSG_SPLINE_MOVE_START_SWIM };

    WorldPacket l_Data(l_SwimOpcodeTable[p_Enable]);
    l_Data.appendPackGUID(GetGUID());

    SendMessageToSet(&l_Data, true);

    return true;
}

bool Unit::SetCanFly(bool p_Enable, bool p_Force)
{
    if (!p_Force && p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY))
        return false;

    if (p_Enable)
    {
        AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
        RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_SPLINE_ELEVATION);
        SetFall(false);
    }
    else
    {
        RemoveUnitMovementFlag(MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_MASK_MOVING_FLY);
        if (!IsLevitating())
            SetFall(true);
    }

    static Opcodes const l_FlyOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_UNSET_FLYING, SMSG_MOVE_UNSET_CAN_FLY },
        { SMSG_SPLINE_MOVE_SET_FLYING,   SMSG_MOVE_SET_CAN_FLY   }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_FlyOpcodeTable[p_Enable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_FlyOpcodeTable[p_Enable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

bool Unit::SetWaterWalking(bool p_Enable, bool p_PacketOnly /*= false*/)
{
    if (!p_PacketOnly)
    {
        if (p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_WATERWALKING))
            return false;

        if (p_Enable)
            AddUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
        else
            RemoveUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
    }

    static Opcodes const l_WaterWalkingOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_SET_LAND_WALK,  SMSG_MOVE_LAND_WALK  },
        { SMSG_SPLINE_MOVE_SET_WATER_WALK, SMSG_MOVE_WATER_WALK }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_WaterWalkingOpcodeTable[p_Enable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_WaterWalkingOpcodeTable[p_Enable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

bool Unit::SetFeatherFall(bool p_Enable, bool p_PacketOnly /*= false*/)
{
    if (!p_PacketOnly)
    {
        if (p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW))
            return false;

        if (p_Enable)
            AddUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW);
        else
            RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW);
    }

    static Opcodes const l_FeatherFallOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_SET_NORMAL_FALL,  SMSG_MOVE_NORMAL_FALL  },
        { SMSG_SPLINE_MOVE_SET_FEATHER_FALL, SMSG_MOVE_FEATHER_FALL }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_FeatherFallOpcodeTable[p_Enable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_FeatherFallOpcodeTable[p_Enable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

bool Unit::SetHover(bool p_Enable, bool p_PacketOnly /*= false*/)
{
    if (!p_PacketOnly)
    {
        if (p_Enable == HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
            return false;

        /// Not confirmed for players
        if (!IsPlayer())
        {
            if (p_Enable)
            {
                if (!IsLevitating())
                    m_updateFlag |= UPDATEFLAG_PLAY_HOVER_ANIM;

                SetPositionH(GetFloatValue(UNIT_FIELD_HOVER_HEIGHT));
            }
            else
            {
                if (!IsLevitating())
                    m_updateFlag &= ~UPDATEFLAG_PLAY_HOVER_ANIM;

                SetPositionH(0.0f);
            }

            if (!IsLevitating())
                SendPlayHoverAnim(p_Enable);
        }

        if (p_Enable)
        {
            /// No need to check height on ascent
            AddUnitMovementFlag(MOVEMENTFLAG_HOVER);

            UpdateHeight(GetFloatValue(UNIT_FIELD_HOVER_HEIGHT));
        }
        else
        {
            RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
            UpdateHeight(0.0f);
        }
    }

    static Opcodes const l_HoverOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_UNSET_HOVER, SMSG_MOVE_UNSET_HOVER   },
        { SMSG_SPLINE_MOVE_SET_HOVER,   SMSG_MOVE_SET_HOVER     }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_HoverOpcodeTable[p_Enable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_HoverOpcodeTable[p_Enable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

void Unit::SendPlayHoverAnim(bool p_Enable)
{
    WorldPacket l_Data(Opcodes::SMSG_SET_PLAY_HOVER_ANIM);
    l_Data.appendPackGUID(GetGUID());
    l_Data.WriteBit(p_Enable);
    l_Data.FlushBits();
    SendMessageToSet(&l_Data, true);
}

bool Unit::SetCollision(bool disable)
{
    if (disable == HasUnitMovementFlag(MOVEMENTFLAG_DISABLE_COLLISION))
        return false;

    if (disable)
        AddUnitMovementFlag(MOVEMENTFLAG_DISABLE_COLLISION);
    else
        RemoveUnitMovementFlag(MOVEMENTFLAG_DISABLE_COLLISION);

    static Opcodes const l_CollisionOpcodeTable[2][2] =
    {
        { SMSG_SPLINE_MOVE_COLLISION_ENABLE,  SMSG_MOVE_ENABLE_COLLISION  },
        { SMSG_SPLINE_MOVE_COLLISION_DISABLE, SMSG_MOVE_DISABLE_COLLISION }
    };

    bool l_IsPlayer = GetTypeId() == TYPEID_PLAYER && ToPlayer()->m_mover->GetTypeId() == TYPEID_PLAYER;

    if (l_IsPlayer)
    {
        WorldPacket l_Data(l_CollisionOpcodeTable[disable][1]);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter

        SendMessageToSet(&l_Data, true);
    }
    else
    {
        WorldPacket l_Data(l_CollisionOpcodeTable[disable][0]);
        l_Data.appendPackGUID(GetGUID());

        SendMessageToSet(&l_Data, true);
    }

    return true;
}

void Unit::NearTeleportTo(float x, float y, float z, float orientation, bool casting /*= false*/, uint32 p_Options /*= TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET*/)
{
    DisableSpline();
    if (IsPlayer())
        ToPlayer()->TeleportTo(GetMapId(), x, y, z, orientation, p_Options | (casting ? TELE_TO_SPELL : 0));
    else
    {
        Position l_Position;
        l_Position.m_positionX = x;
        l_Position.m_positionY = y;
        l_Position.m_positionZ = z;
        l_Position.m_orientation = orientation;
        SendTeleportPacket(l_Position);

        UpdatePosition(x, y, z, orientation, true);
        UpdateObjectVisibility();

        if (IsVehicle())
            GetVehicleKit()->RelocatePassengers();
    }
}

void Unit::SendTeleportPacket(Position &p_NewPosition)
{
    if (GetTypeId() == TYPEID_PLAYER)
    {
        WorldPacket l_TeleportPacket(SMSG_MOVE_TELEPORT, 38);
        bool l_HasVehicle = false;

        Position l_Position;
        l_Position.Relocate(p_NewPosition);

        if (TransportBase* l_TransportBase = GetDirectTransport())
            l_TransportBase->CalculatePassengerOffset(l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, l_Position.m_orientation);

        l_TeleportPacket.appendPackGUID(GetGUID());
        l_TeleportPacket << uint32(m_movementCounter++);    //  SequenceIndex
        l_TeleportPacket << float(l_Position.GetPositionX());
        l_TeleportPacket << float(l_Position.GetPositionY());
        l_TeleportPacket << float(l_Position.GetPositionZ());
        l_TeleportPacket << float(l_Position.GetOrientation());
        l_TeleportPacket << uint8(0);                       // Unk

        l_TeleportPacket.WriteBit(GetTransGUID() != 0);
        l_TeleportPacket.WriteBit(l_HasVehicle);
        l_TeleportPacket.FlushBits();

        if (GetTransGUID() != 0)
            l_TeleportPacket.appendPackGUID(GetTransGUID());

        if (l_HasVehicle)
        {
            l_TeleportPacket << uint8(0);   ///< VehicleSeatIndex
            l_TeleportPacket.WriteBit(0);   ///< VehicleExitVoluntary
            l_TeleportPacket.WriteBit(0);   ///< VehicleExitTeleport
            l_TeleportPacket.FlushBits();
        }

        ToPlayer()->SendDirectMessage(&l_TeleportPacket);
        sAnticheatMgr->HandleTeleport(ToPlayer()->GetGUIDLow(), true);
    }

    MovementInfo l_MovementInfo = m_movementInfo;

    /// Fix for near TP
    ///if (GetTypeId() != TYPEID_PLAYER)
    {
        l_MovementInfo.guid = GetGUID();
        l_MovementInfo.pos.Relocate(p_NewPosition);
        l_MovementInfo.time = getMSTime();
    }

    WorldPacket l_TeleportUpdatePacket(SMSG_MOVE_UPDATE_TELEPORT, 300);

    WorldSession::WriteMovementInfo(l_TeleportUpdatePacket, &l_MovementInfo);

    l_TeleportUpdatePacket << uint32(0);    ///< Movement force count

    l_TeleportUpdatePacket.WriteBit(true);  ///< HasWalkSpeed
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasRunSpeed
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasRunBack
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasSwimSpeed
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasSwimBack
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasFlightSpeed
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasFlightBack
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasTurnRate
    l_TeleportUpdatePacket.WriteBit(true);  ///< HasPitchRate
    l_TeleportUpdatePacket.FlushBits();

    l_TeleportUpdatePacket << float(GetSpeed(MOVE_WALK));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_RUN));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_RUN_BACK));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_SWIM));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_SWIM_BACK));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_FLIGHT));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_FLIGHT_BACK));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_TURN_RATE));
    l_TeleportUpdatePacket << float(GetSpeed(MOVE_PITCH_RATE));

    SendMessageToSet(&l_TeleportUpdatePacket, false);
}

bool Unit::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
{
    // prevent crash when a bad coord is sent by the client
    if (!JadeCore::IsValidMapCoord(x, y, z, orientation))
        return false;

    bool turn = (GetOrientation() != orientation);
    bool relocated = (teleport || GetPositionX() != x || GetPositionY() != y || GetPositionZ() != z);

    if (turn)
        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);

    if (relocated)
    {
        bool l_Stop = true;
        if (IsPlayer() && !IsMoving() && ToPlayer()->HasMovementForce())
            l_Stop = false;

        if (l_Stop)
            RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);

        // move and update visible state if need
        if (IsPlayer())
            GetMap()->PlayerRelocation(ToPlayer(), x, y, z, orientation);
        else
        {
            GetMap()->CreatureRelocation(ToCreature(), x, y, z, orientation);
            // code block for underwater state update
            UpdateUnderwaterState(GetMap(), x, y, z);
        }
    }
    else if (turn)
        UpdateOrientation(orientation);

    return (relocated || turn);
}

//! Only server-side orientation update, does not broadcast to client
void Unit::UpdateOrientation(float orientation)
{
    SetOrientation(orientation);
    if (IsVehicle())
        GetVehicleKit()->RelocatePassengers();
}

//! Only server-side height update, does not broadcast to client
void Unit::UpdateHeight(float newZ)
{
    SetPositionH(newZ);
    if (IsVehicle())
        GetVehicleKit()->RelocatePassengers();
}

void Unit::SendThreatListUpdate()
{
    if (!getThreatManager().isThreatListEmpty())
    {
        uint32 l_Count = getThreatManager().getThreatList().size();

        WorldPacket l_Data(SMSG_THREAT_UPDATE, 1024);
        l_Data.appendPackGUID(GetGUID());
        l_Data << l_Count;

        std::list<HostileReference*>& l_ThreatList = getThreatManager().getThreatList();
        for (std::list<HostileReference*>::const_iterator l_Iter = l_ThreatList.begin(); l_Iter != l_ThreatList.end(); ++l_Iter)
        {
            l_Data.appendPackGUID((*l_Iter)->getUnitGuid());
            l_Data << uint32((*l_Iter)->getThreat());
        }

        SendMessageToSet(&l_Data, false);
    }
}

void Unit::SendChangeCurrentVictimOpcode(HostileReference* p_HostileReference)
{
    if (!getThreatManager().isThreatListEmpty())
    {
        uint32 l_Count = getThreatManager().getThreatList().size();

        WorldPacket l_Data(SMSG_HIGHEST_THREAT_UPDATE, 1 * 1024);
        l_Data.appendPackGUID(GetGUID());
        l_Data.appendPackGUID(p_HostileReference->getUnitGuid());
        l_Data << l_Count;

        std::list<HostileReference*>& l_ThreatList = getThreatManager().getThreatList();
        for (std::list<HostileReference*>::const_iterator l_Iter = l_ThreatList.begin(); l_Iter != l_ThreatList.end(); ++l_Iter)
        {
            l_Data.appendPackGUID((*l_Iter)->getUnitGuid());
            l_Data << uint32((*l_Iter)->getThreat());
        }

        SendMessageToSet(&l_Data, false);
    }
}

void Unit::SendClearThreatListOpcode()
{
    WorldPacket l_Data(SMSG_THREAT_CLEAR, 16 + 2);
    l_Data.appendPackGUID(GetGUID());
    SendMessageToSet(&l_Data, false);
}

void Unit::SendRemoveFromThreatListOpcode(HostileReference* p_HostileReference)
{
    WorldPacket l_Data(SMSG_THREAT_REMOVE, 16 + 2 + 16 + 2);
    l_Data.appendPackGUID(GetGUID());
    l_Data.appendPackGUID(p_HostileReference->getUnitGuid());
    SendMessageToSet(&l_Data, false);
}

void Unit::RewardRage(float baseRage)
{
    float addRage = baseRage;

    if (addRage < 0.0f)
        addRage = 0.0f;

    ModifyPower(POWER_RAGE, uint32(addRage * GetPowerCoeff(POWER_RAGE)));
}

void Unit::StopAttackFaction(uint32 faction_id)
{
    if (Unit* victim = getVictim())
    {
        if (victim->getFactionTemplateEntry() && victim->getFactionTemplateEntry()->Faction == faction_id)
        {
            AttackStop();
            if (IsNonMeleeSpellCasted(false))
                InterruptNonMeleeSpells(false);

            // melee and ranged forced attack cancel
            if (IsPlayer())
                ToPlayer()->SendAttackSwingCancelAttack();
        }
    }

    AttackerSet const& attackers = getAttackers();
    for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
    {
        auto l_FactionTemplate = (*itr)->getFactionTemplateEntry();
        if (l_FactionTemplate && l_FactionTemplate->Faction == faction_id)
        {
            (*itr)->AttackStop();
            itr = attackers.begin();
        }
        else
            ++itr;
    }

    getHostileRefManager().deleteReferencesForFaction(faction_id);

    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        (*itr)->StopAttackFaction(faction_id);
}

void Unit::OutDebugInfo() const
{
    sLog->outError(LOG_FILTER_UNITS, "Unit::OutDebugInfo");
    sLog->outInfo(LOG_FILTER_UNITS, "GUID " UI64FMTD ", entry %u, type %u, name %s", GetGUID(), GetEntry(), (uint32)GetTypeId(), GetName());
    sLog->outInfo(LOG_FILTER_UNITS, "OwnerGUID " UI64FMTD ", MinionGUID " UI64FMTD ", CharmerGUID " UI64FMTD ", CharmedGUID " UI64FMTD, GetOwnerGUID(), GetMinionGUID(), GetCharmerGUID(), GetCharmGUID());
    sLog->outInfo(LOG_FILTER_UNITS, "In world %u, unit type mask %u", (uint32)(IsInWorld() ? 1 : 0), m_unitTypeMask);
    if (IsInWorld())
        sLog->outInfo(LOG_FILTER_UNITS, "Mapid %u", GetMapId());

    std::ostringstream o;
    o << "Summon Slot: ";
    for (uint32 i = 0; i < MAX_SUMMON_SLOT; ++i)
        o << m_SummonSlot[i] << ", ";

    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
    o.str("");

    o << "Controlled List: ";
    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        o << (*itr)->GetGUID() << ", ";
    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
    o.str("");

    o << "Aura List: ";
    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); ++itr)
        o << itr->first << ", ";
    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
    o.str("");

    if (IsVehicle())
    {
        o << "Passenger List: ";
        for (SeatMap::iterator itr = GetVehicleKit()->Seats.begin(); itr != GetVehicleKit()->Seats.end(); ++itr)
            if (Unit* passenger = ObjectAccessor::GetUnit(*GetVehicleBase(), itr->second.Passenger))
                o << passenger->GetGUID() << ", ";
        sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
    }

    if (GetVehicle())
        sLog->outInfo(LOG_FILTER_UNITS, "On vehicle %u.", GetVehicleBase()->GetEntry());
}

uint32 Unit::GetRemainingPeriodicAmount(uint64 caster, uint32 spellId, AuraType auraType, uint8 effectIndex) const
{
    uint32 amount = 0;
    AuraEffectList const& periodicAuras = GetAuraEffectsByType(auraType);
    for (AuraEffectList::const_iterator i = periodicAuras.begin(); i != periodicAuras.end(); ++i)
    {
        if ((*i)->GetCasterGUID() != caster || (*i)->GetId() != spellId || (*i)->GetEffIndex() != effectIndex || !(*i)->GetTotalTicks())
            continue;
        amount += uint32(((*i)->GetAmount() * std::max<int32>((*i)->GetTotalTicks() - int32((*i)->GetTickNumber()), 0)) / (*i)->GetTotalTicks());
        break;
    }

    return amount;
}

void Unit::SendClearTarget()
{
    WorldPacket l_Data(SMSG_BREAK_TARGET);
    l_Data.appendPackGUID(GetGUID());
    SendMessageToSet(&l_Data, false);
}

bool Unit::IsVisionObscured(Unit* victim, SpellInfo const* spellInfo)
{
    Aura* victimAura = nullptr;
    Aura* myAura = nullptr;
    Unit* victimCaster = NULL;
    Unit* myCaster = NULL;

    AuraEffectList const& vAuras = victim->GetAuraEffectsByType(SPELL_AURA_INTERFERE_TARGETTING);
    for (AuraEffectList::const_iterator i = vAuras.begin(); i != vAuras.end(); ++i)
    {
        victimAura = (*i)->GetBase();
        victimCaster = victimAura->GetCaster();
        break;
    }

    AuraEffectList const& myAuras = GetAuraEffectsByType(SPELL_AURA_INTERFERE_TARGETTING);
    for (AuraEffectList::const_iterator i = myAuras.begin(); i != myAuras.end(); ++i)
    {
        myAura = (*i)->GetBase();
        myCaster = myAura->GetCaster();
        break;
    }

    /// Caster & Target are both in a Smoke Bomb, targeting okay, no matter which reactions
    /// If both are IN the same Smoke Bomb, they can attack each other
    if (myAura && victimAura && myCaster && victimCaster && victimCaster == myCaster)
        return false;
    /// Only caster is in Smoke Bomb
    else if (myAura && victimAura == nullptr && myCaster && victimCaster == nullptr)
    {
        /// Smoke Bomb's caster is friendly, can target IN our OUT
        if (myCaster->IsFriendlyTo(this))
            return false;
        /// Smoke Bomb's caster is hostile, can only target IN if caster's IN, OUT if caster's OUT
        else
            return true;
    }
    /// Only victim is in Smoke Bomb
    else if (victimAura && myAura == nullptr && victimCaster && myCaster == nullptr)
    {
        /// Smoke Bomb's caster is friendly, can target IN our OUT
        if (victimCaster->IsFriendlyTo(this))
            return false;
        /// Smoke Bomb's caster is hostile, can only target IN if caster's IN, OUT if caster's OUT
        else
            return true;
    }
    /// Failed auras, will result in crash
    else
        return false;

    return false;
}

uint32 Unit::GetResistance(SpellSchoolMask mask) const
{
    int32 resist = -1;
    for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
        if (mask & (1 << i) && (resist < 0 || resist > int32(GetResistance(SpellSchools(i)))))
            resist = int32(GetResistance(SpellSchools(i)));

    // resist value will never be negative here
    return uint32(resist);
}

void CharmInfo::SetIsCommandAttack(bool val)
{
    m_isCommandAttack = val;
}

bool CharmInfo::IsCommandAttack()
{
    return m_isCommandAttack;
}

void CharmInfo::SetIsCommandFollow(bool val)
{
    _isCommandFollow = val;
}

bool CharmInfo::IsCommandFollow()
{
    return _isCommandFollow;
}

void CharmInfo::SaveStayPosition()
{
    //! At this point a new spline destination is enabled because of Unit::StopMoving()
    G3D::Vector3 const stayPos = m_unit->movespline->FinalDestination();
    m_stayX = stayPos.x;
    m_stayY = stayPos.y;
    m_stayZ = stayPos.z;
}

void CharmInfo::GetStayPosition(float &x, float &y, float &z)
{
    x = m_stayX;
    y = m_stayY;
    z = m_stayZ;
}

void CharmInfo::SetIsAtStay(bool val)
{
    m_isAtStay = val;
}

bool CharmInfo::IsAtStay()
{
    return m_isAtStay;
}

void CharmInfo::SetIsFollowing(bool val)
{
    m_isFollowing = val;
}

bool CharmInfo::IsFollowing()
{
    return m_isFollowing;
}

void CharmInfo::SetIsReturning(bool val)
{
    m_isReturning = val;
}

bool CharmInfo::IsReturning()
{
    return m_isReturning;
}

void CharmInfo::SetIsMoveTo(bool val)
{
    m_IsMoveTo = val;
}

bool CharmInfo::IsMoveTo()
{
    return m_IsMoveTo;
}

void CharmInfo::SetIsMoveToStay(bool val)
{
    m_IsMoveToStay = val;
}

bool CharmInfo::IsMoveToStay()
{
    return m_IsMoveToStay;
}

void Unit::SetInFront(WorldObject const* target)
{
    if (!HasUnitState(UNIT_STATE_CANNOT_TURN) && !HasFlag(EUnitFields::UNIT_FIELD_FLAGS_2, eUnitFlags2::UNIT_FLAG2_DISABLE_TURN))
        SetOrientation(GetAngle(target));
}

void Unit::SetFacingTo(float ori)
{
    Movement::MoveSplineInit init(this);

    init.LaunchRotate(ori);

    SetOrientation(ori);
}

void Unit::SetFacingToObject(WorldObject* object)
{
    // never face when already moving
    if (!IsStopped())
        return;

    // TODO: figure out under what conditions creature will move towards object instead of facing it where it currently is.
    Movement::MoveSplineInit init(this);
    init.MoveTo(GetPositionX(), GetPositionY(), GetPositionZ());
    init.SetFacing(GetAngle(object));   // when on transport, GetAngle will still return global coordinates (and angle) that needs transforming
    init.Launch();
}

void Unit::FocusTarget(Spell const* p_FocusSpell, WorldObject* p_Target)
{
    // already focused
    if (_focusSpell)
        return;

    _focusSpell = p_FocusSpell;
    SetGuidValue(UNIT_FIELD_TARGET, p_Target->GetGUID());

    // Set server side orientation if needed (needs to be after attribute check)
    SetInFront(p_Target);
}

void Unit::ReleaseFocus(Spell const* focusSpell)
{
    // focused to something else
    if (focusSpell != _focusSpell)
        return;

    _focusSpell = nullptr;
    if (Unit* victim = getVictim())
        SetGuidValue(UNIT_FIELD_TARGET, victim->GetGUID());
    else
        SetGuidValue(UNIT_FIELD_TARGET, 0);
}

void Unit::SendCanTurnWhileFalling(bool p_Apply)
{
    if (GetTypeId() != TYPEID_PLAYER)
        return;

    WorldPacket l_Data;

    if (p_Apply)
    {
        l_Data.Initialize(SMSG_MOVE_SET_CAN_TURN_WHILE_FALLING, 16 + 2 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);  // Movement counter
    }
    else
    {
        l_Data.Initialize(SMSG_MOVE_UNSET_CAN_TURN_WHILE_FALLING, 16 + 2 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);  // Movement counter
    }

    ToPlayer()->GetSession()->SendPacket(&l_Data);
}

bool Unit::IsSplineEnabled() const
{
    return movespline->Initialized() && !movespline->Finalized();
}

bool Unit::IsSplineFinished() const
{
    return movespline->Finalized();
}

uint32 Unit::GetDamageDoneInPastSecsBySpell(uint32 p_Secs, uint32 p_SpellId)
{
    uint32 damage = 0;

    for (DmgDoneList::iterator itr = m_dmgDone.begin(); itr != m_dmgDone.end(); itr++)
    {
        if (((*itr)->s_spellId && (getMSTime() - (*itr)->s_timestamp) <= (p_Secs * IN_MILLISECONDS)) && p_SpellId == (*itr)->s_spellId)
            damage += (*itr)->s_damage;
    }

    return damage;
};

void Unit::WriteMovementUpdate(WorldPacket &data) const
{
    WorldSession::WriteMovementInfo(data, (MovementInfo*)&m_movementInfo);
}

Unit* Unit::GetSoulSwapDotTarget()
{
    if (Unit* soulSwapTarget = sObjectAccessor->FindUnit(soulSwapTargetGUID))
    {
        if (soulSwapTarget->IsInWorld())
            return soulSwapTarget;
        else
            return NULL;
    }
    else
        return NULL;
}

void Unit::RemoveSoulSwapDOT(Unit* p_Target)
{
    _SoulSwapDOTList.clear();

    AuraEffectList const l_PeriodicList = p_Target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
    if (l_PeriodicList.empty())
        return;

    for (AuraEffect* l_AuraEffect : l_PeriodicList)
    {
        if (l_AuraEffect == nullptr) /// prevent crash
            continue;

        if (l_AuraEffect->GetSpellInfo()->SpellFamilyName != SPELLFAMILY_WARLOCK ||
            l_AuraEffect->GetCasterGUID() != GetGUID()) /// only warlock spells
            continue;

        _SoulSwapDOTList.push_back(l_AuraEffect->GetId());
        Aura* l_CurrentAura = p_Target->GetAura(l_AuraEffect->GetId(), GetGUID());
        if (l_CurrentAura == nullptr)
            continue;

        AuraEffect* l_CurrentAuraEffect = l_CurrentAura->GetEffect(EFFECT_0);
        if (l_CurrentAuraEffect == nullptr)
            continue;

        _SoulSwapDOTData.insert(new SoulSwapAurasData(l_CurrentAura->GetId(), l_CurrentAura->GetDuration(), l_CurrentAura->GetStackAmount(), l_CurrentAuraEffect->GetAmount(), l_CurrentAuraEffect->GetPeriodicTimer()));
    }
}

void Unit::ApplySoulSwapDOT(Unit* caster, Unit* target)
{
    if (caster->GetGUID() != target->GetGUID())
    {
        for (AuraIdList::const_iterator iter = _SoulSwapDOTList.begin(); iter != _SoulSwapDOTList.end(); ++iter)
            AddAura((*iter), target);

        /// Restore all aura spell mods
        for (std::set<SoulSwapAurasData*>::iterator itr = _SoulSwapDOTData.begin(); itr != _SoulSwapDOTData.end(); ++itr)
        {
            if (Aura* appliedAura = target->GetAura((*itr)->m_id, GetGUID()))
            {
                /// Maybe we should refresh duration
                if (!GetSoulSwapRefreshDuration())
                    appliedAura->SetDuration((*itr)->m_duration);

                appliedAura->SetStackAmount((*itr)->m_stacks);
                if (appliedAura->GetEffect(EFFECT_0)) {
                    appliedAura->GetEffect(EFFECT_0)->SetAmount((*itr)->m_damage);
                    appliedAura->GetEffect(EFFECT_0)->SetPeriodicTimer((*itr)->m_amplitude);
                }
                appliedAura->SetNeedClientUpdateForTargets();
            }

            delete (*itr);
        }
    }

    _SoulSwapDOTList.clear();
    _SoulSwapDOTData.clear();
}

void Unit::BuildValuesUpdate(uint8 updateType, ByteBuffer* data, Player* target) const
{
    if (!target)
        return;

    ByteBuffer fieldBuffer;

    UpdateMask updateMask;
    updateMask.SetCount(m_valuesCount);

    uint32* flags;
    uint32 visibleFlag = GetUpdateFieldData(target, flags);

    Creature const* creature = ToCreature();
    for (uint16 index = 0; index < m_valuesCount; ++index)
    {
        if (_fieldNotifyFlags & flags[index] ||
            ((flags[index] & visibleFlag) & UF_FLAG_SPECIAL_INFO) ||
            ((updateType == UPDATETYPE_VALUES ? _changesMask.GetBit(index) : m_uint32Values[index]) && (flags[index] & visibleFlag)) ||
            (index == UNIT_FIELD_AURA_STATE && HasFlag(UNIT_FIELD_AURA_STATE, PER_CASTER_AURA_STATE_MASK)))
        {
            updateMask.SetBit(index);

            if (index == UNIT_FIELD_NPC_FLAGS)
            {
                uint32 appendValue = m_uint32Values[UNIT_FIELD_NPC_FLAGS];

                if (creature)
                    if (!target->canSeeSpellClickOn(creature))
                        appendValue &= ~UNIT_NPC_FLAG_SPELLCLICK;

                fieldBuffer << uint32(appendValue);
            }
            else if (index == UNIT_FIELD_AURA_STATE)
            {
                // Check per caster aura states to not enable using a spell in client if specified aura is not by target
                fieldBuffer << BuildAuraStateUpdateForTarget(target);
            }
            // FIXME: Some values at server stored in float format but must be sent to client in uint32 format
            else if (index >= UNIT_FIELD_ATTACK_ROUND_BASE_TIME && index <= UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME)
            {
                // convert from float to uint32 and send
                fieldBuffer << uint32(m_floatValues[index] < 0 ? 0 : m_floatValues[index]);
            }
            // there are some float values which may be negative or can't get negative due to other checks
            else if ((index >= UNIT_FIELD_STAT_NEG_BUFF   && index < UNIT_FIELD_STAT_NEG_BUFF + MAX_STATS) ||
                (index >= UNIT_FIELD_STAT_POS_BUFF   && index < UNIT_FIELD_STAT_POS_BUFF + MAX_STATS) ||
                (index >= UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE  && index < (UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + MAX_SPELL_SCHOOL)) ||
                (index >= UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE  && index < (UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + MAX_SPELL_SCHOOL)))
            {
                fieldBuffer << uint32(m_floatValues[index]);
            }
            // Gamemasters should be always able to select units - remove not selectable flag
            else if (index == UNIT_FIELD_FLAGS)
            {
                uint32 appendValue = m_uint32Values[UNIT_FIELD_FLAGS];

                if (InstanceScript const* l_Instance = GetInstanceScript())
                    l_Instance->OnCustomValuesUpdate(this, target, appendValue);

                if (target->isGameMaster())
                    appendValue &= ~UNIT_FLAG_NOT_SELECTABLE;

                fieldBuffer << uint32(appendValue);
            }
            // use modelid_a if not gm, _h if gm for CREATURE_FLAG_EXTRA_TRIGGER creatures
            else if (index == UNIT_FIELD_DISPLAY_ID)
            {
                uint32 displayId = m_uint32Values[UNIT_FIELD_DISPLAY_ID];
                if (creature)
                {
                    CreatureTemplate const* cinfo = creature->GetCreatureTemplate();

                    // this also applies for transform auras
                    if (SpellInfo const* transform = sSpellMgr->GetSpellInfo(getTransForm()))
                        for (uint8 i = 0; i < transform->EffectCount; ++i)
                            if (transform->Effects[i].IsAura(SPELL_AURA_TRANSFORM))
                                if (CreatureTemplate const* transformInfo = sObjectMgr->GetCreatureTemplate(transform->Effects[i].MiscValue))
                                {
                                    cinfo = transformInfo;
                                    break;
                                }

                    if (creature->GetFlagsExtra() & CREATURE_FLAG_EXTRA_TRIGGER)
                    {
                        if (target->isGameMaster())
                            displayId = 17519; // world visible trigger's model
                        else
                        {
                            if (cinfo->Modelid[1])
                                displayId = cinfo->Modelid[1]; // Modelid2 is an invisible model for players
                            else
                                displayId = 11686; // world invisible trigger's model
                        }
                    }

                    if (creature->IsAIEnabled)
                        creature->AI()->OnSendDisplayID(displayId, target);
                }

                fieldBuffer << uint32(displayId);
            }
            // hide lootable animation for unallowed players
            else if (index == OBJECT_FIELD_DYNAMIC_FLAGS)
            {
                uint32 l_DynFlags = BuildDynamicFlagForTarget(target);

                if (creature && creature->IsAIEnabled)
                    creature->AI()->OnBuildDynFlags(l_DynFlags, target);

                fieldBuffer << l_DynFlags;
            }
            // FG: pretend that OTHER players in own group are friendly ("blue")
            else if (index == UNIT_FIELD_SHAPESHIFT_FORM || index == UNIT_FIELD_FACTION_TEMPLATE)
            {
                uint32 l_Value = m_uint32Values[index];
                if (index == UNIT_FIELD_FACTION_TEMPLATE && creature && creature->IsAIEnabled)
                    creature->AI()->OnSendFactionTemplate(l_Value, target);

                /// Avoid to send FACTION_FRIENDLY if the player is in gm on to self player, can crash the client or have weird behavior (e.g. flight master freeze the client)
                if (index == UNIT_FIELD_FACTION_TEMPLATE && l_Value == FACTION_FRIENDLY && IsPlayer() && target == this)
                {
                    if (ChrRacesEntry const* l_ChrRaceEntry = sChrRacesStore.LookupEntry(getRace()))
                        l_Value = l_ChrRaceEntry->FactionID;
                }

                if (IsControlledByPlayer() && target != this && sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP) && IsInRaidWith(target))
                {
                    FactionTemplateEntry const* ft1 = getFactionTemplateEntry();
                    FactionTemplateEntry const* ft2 = target->getFactionTemplateEntry();
                    if (ft1 && ft2 && !ft1->IsFriendlyTo(*ft2))
                    {
                        if (index == UNIT_FIELD_SHAPESHIFT_FORM)
                            // Allow targeting opposite faction in party when enabled in config
                            fieldBuffer << (m_uint32Values[UNIT_FIELD_SHAPESHIFT_FORM] & ((UNIT_BYTE2_FLAG_SANCTUARY /*| UNIT_BYTE2_FLAG_AURAS | UNIT_BYTE2_FLAG_UNK5*/) << 8)); // this flag is at uint8 offset 1 !!
                        else
                            // pretend that all other HOSTILE players have own faction, to allow follow, heal, rezz (trade wont work)
                            fieldBuffer << uint32(target->getFaction());
                    }
                    else
                        fieldBuffer << l_Value;
                }
                else
                    fieldBuffer << l_Value;
            }
            else if (index >= UNIT_FIELD_SUMMONED_BY  && index <= UNIT_FIELD_SUMMONED_BY + 3)
            {
                if (m_unitTypeMask & UNIT_MASK_MINION && (m_unitTypeMask & UNIT_MASK_CONTROLABLE_GUARDIAN) == 0)
                    fieldBuffer << uint32(0);
                else
                    fieldBuffer << m_uint32Values[index];
            }
            else
            {
                // send in current format (float as float, uint32 as uint32)
                fieldBuffer << m_uint32Values[index];
            }
        }
    }

    *data << uint8(updateMask.GetBlockCount());
    updateMask.AppendToPacket(data);
    data->append(fieldBuffer);
}

uint32 Unit::BuildDynamicFlagForTarget(Player* p_Target) const
{
    uint32 l_DynamicFlags = m_uint32Values[OBJECT_FIELD_DYNAMIC_FLAGS] & ~UNIT_DYNFLAG_TAPPED;

    if (Creature const* l_Creature = ToCreature())
    {
        if (!l_Creature->m_LootContainers.empty() && !l_Creature->isTappedBy(p_Target))
            l_DynamicFlags |= UNIT_DYNFLAG_TAPPED;

        if (!p_Target->isAllowedToLoot(l_Creature))
            l_DynamicFlags &= ~UNIT_DYNFLAG_LOOTABLE;
    }

    // unit UNIT_DYNFLAG_TRACK_UNIT should only be sent to caster of SPELL_AURA_MOD_STALKED auras
    if (l_DynamicFlags  & UNIT_DYNFLAG_TRACK_UNIT)
        if (!HasAuraTypeWithCaster(SPELL_AURA_MOD_STALKED, p_Target->GetGUID()))
            l_DynamicFlags &= ~UNIT_DYNFLAG_TRACK_UNIT;

    switch (GetMapId())
    {
        case 1676: ///< Tomb Of Sargeras
        {
            if (GetEntry() != 119072 && (HasAura(235621) ^ p_Target->HasAura(235621)))
                l_DynamicFlags |= UNIT_DYNFLAG_HIDE_MODEL | UNIT_DYNFLAG_NO_INTERACT;
            break;
        }
        case 1753: ///< Seat of Triumvirate
        {
            if (GetEntry() != 122482 && (HasAura(244061) ^ p_Target->HasAura(244061)))
                l_DynamicFlags |= UNIT_DYNFLAG_HIDE_MODEL | UNIT_DYNFLAG_NO_INTERACT;
            break;
        }

        default:
            break;
    }

    return l_DynamicFlags;
}

float Unit::CalculateDamageDealtFactor(Unit* p_Unit, Creature* p_Creature)
{
    if (!p_Unit || !p_Creature || (p_Creature->IsPetGuardianStuff() && p_Creature->GetCharmerOrOwnerPlayerOrPlayerItself()))
        return 1.0f;

    int32 l_TargetExpansion = p_Creature->GetCreatureTemplate()->expansion;
    uint8 l_PlayerLevel = p_Unit->getLevel();
    uint32 l_PlayerExpansion = JadeCore::GetExpansionForLevel(l_PlayerLevel);

    if (l_PlayerExpansion <= l_TargetExpansion)
        return 1.0f;

    if (l_TargetExpansion == -1)
        return 1.0f;

    float l_DamageDealtFactor = 1.0f;

    if (l_TargetExpansion <= EXPANSION_WARLORDS_OF_DRAENOR)
    {
        uint8 l_ExpansionDifference = l_PlayerExpansion - l_TargetExpansion;

        if (l_ExpansionDifference >= 1 && l_ExpansionDifference < 3)
            l_DamageDealtFactor = 1 + 0.0625f * l_ExpansionDifference;
        else if (l_ExpansionDifference == 3)
            l_DamageDealtFactor = 1.5f + 0.5f * l_ExpansionDifference;
        else if (l_ExpansionDifference > 3)
            l_DamageDealtFactor = 16.5f;
    }

    uint16 l_IntendedItemLevelByExpansion[MAX_EXPANSION - 1] = { 65, 115, 200, 346, 463, 667 };
    uint16 l_MaxPlayerLevelsByExpansion[MAX_EXPANSION - 1] = { 69, 79, 84, 89, 99, 109 };

    if (l_TargetExpansion > 0 && p_Unit->IsPlayer())
    {
        Player* p_Player = p_Unit->ToPlayer();

        if ((p_Player->getLevel() <= l_MaxPlayerLevelsByExpansion[l_TargetExpansion - 1]) && p_Player->GetAverageItemLevelEquipped() > l_IntendedItemLevelByExpansion[l_TargetExpansion - 1])
        {
            float l_AltDamageDealtFactor = 1 + 5 / 3 * 0.01f * (p_Player->GetAverageItemLevelEquipped() - l_IntendedItemLevelByExpansion[l_TargetExpansion - 1]);
            l_DamageDealtFactor = std::max(l_DamageDealtFactor, l_AltDamageDealtFactor);
        }
    }

    return l_DamageDealtFactor;
}

float Unit::CalculateDamageTakenFactor(Unit* p_Unit, Creature* p_Creature)
{
    if (!p_Unit || !p_Creature || (p_Creature->IsPetGuardianStuff() && p_Creature->GetCharmerOrOwnerPlayerOrPlayerItself()))
        return 1.0f;

    uint8 l_TargetExpansion = p_Creature->GetCreatureTemplate()->expansion;

    if (JadeCore::GetExpansionForLevel(p_Unit->getLevel()) <= l_TargetExpansion)
        return 1.0f;

    int32 l_LevelDiff = p_Unit->getLevelForTarget(p_Creature) - p_Creature->getLevelForTarget(p_Unit);

    float l_DamageTakenFactor = 1.0f;

    if (l_LevelDiff > 0 && l_TargetExpansion <= EXPANSION_WARLORDS_OF_DRAENOR)
    {
        // 10% DR per level diff, with a floor of 10%
        l_DamageTakenFactor = std::max(1.0f - 0.1f * l_LevelDiff, 0.1f);
    }

    uint16 l_IntendedItemLevelByExpansion[MAX_EXPANSION] = {65, 115, 200, 346, 463, 609};
    uint16 l_MaxPlayerLevelsByExpansion[MAX_EXPANSION] = {69, 79, 84, 89, 99, 109};

    if (l_TargetExpansion && l_LevelDiff > 0 && p_Unit->IsPlayer())
    {
        Player* p_Player = p_Unit->ToPlayer();

        if ((p_Player->getLevel() <= l_MaxPlayerLevelsByExpansion[l_TargetExpansion - 1]) && p_Player->GetAverageItemLevelEquipped() > l_IntendedItemLevelByExpansion[l_TargetExpansion - 1])
        {
            float l_ItemLevelFactor = p_Player->GetAverageItemLevelEquipped() - l_IntendedItemLevelByExpansion[l_TargetExpansion - 1];
            l_ItemLevelFactor = std::min(l_ItemLevelFactor, 99.9f);

            float l_AltDamageTakenFactor = 1 - 0.01f * l_ItemLevelFactor;
            l_DamageTakenFactor = std::min(l_DamageTakenFactor, l_AltDamageTakenFactor);
        }
    }

    return l_DamageTakenFactor;
}


float Unit::GetDiminishingPVPDamage(SpellInfo const* p_Spellproto) const
{
    if (!p_Spellproto || !CanApplyPvPSpellModifiers())
        return 0.0f;

    /// Explicit diminishing Pvp damage
    switch (p_Spellproto->SpellFamilyName)
    {
        case SPELLFAMILY_DRUID:
        {
            /// Rage of the Sleeper deals 10% damage in PvP
            if (p_Spellproto->Id == 219432)
                return -90.0f;
            /// Tranquility heals 200% in PvP
            if (p_Spellproto->Id == 157982)
                return 100.0f;
            /// Rake deals 80% damage in PvP
            if (p_Spellproto->Id == 1822 || p_Spellproto->Id == 155722)
                return -20.0f;
            /// Maul deals 53.333% damage in PvP
            if (p_Spellproto->Id == 6807)
                return -46.667f;
            /// Echoing Stars deals 75% damage in PvP
            if (p_Spellproto->Id == 226104)
                return -25.0f;
            /// Starfall deals 50% damage in PvP
            if (p_Spellproto->Id == 191037)
                return -50.0f;
            /// Ashamane's Frenzy deals 50% damage in PvP
            if (p_Spellproto->Id == 210723)
                return -50.0f;
            /// Shooting Stars deals 50% damage in PvP
            if (p_Spellproto->Id == 202497)
                return -50.0f;
            /// Solar Wrath deals 140% damage in PvP
            if (p_Spellproto->Id == 190984)
                return 40.0f;
            /// Half Moon deals 90% damage in PvP
            if (p_Spellproto->Id == 202768)
                return -10.0f;
            /// Full Moon deals 90% damage in PvP
            if (p_Spellproto->Id == 202771)
                return -10.0f;
            /// Healing touch heals 200% in PvP
            if (p_Spellproto->Id == 5185)
                return 100.0f;
            /// Brutal Slash deals 60% damage in PvP
            if (p_Spellproto->Id == 202028)
                return -40.0f;
            /// Lunar Inspiration - MoonFire deals 80% damage in PvP
            if (p_Spellproto->Id == 155625)
                return -20.0f;
            break;
        }
        case SPELLFAMILY_PRIEST:
        {
            /// Power Word: shield's value is increased by 110% in PvP. Only Discipline Priest
            if (p_Spellproto->Id == 17 && ToPlayer() && ToPlayer()->GetActiveSpecializationID() == SPEC_PRIEST_DISCIPLINE)
                return 10.0f;
            /// Atonement's trasnfer amount is increased by 25% in PvP
            if (p_Spellproto->Id == 81751 || p_Spellproto->Id == 94472)
                return 25.0f;
            /// Heal heals 250% in PvP
            if (p_Spellproto->Id == 2060)
                return 150.0f;
            /// Prayer of Mending heals 150% in PvP
            if (p_Spellproto->Id == 33110)
                return 50.0f;
            /// Vampiric Touch deals 85% damage in PvP
            if (p_Spellproto->Id == 34914)
                return -15.0f;
            /// Flash Heal heals 160% in PvP
            if (p_Spellproto->Id == 2061)
                return 60.0f;
            /// Mind Blast deals 135% damage in PvP
            if (p_Spellproto->Id == 8092)
                return 35.0f;
            /// Mind Flay deals 155% damage in PvP
            if (p_Spellproto->Id == 15407)
                return 55.0f;
            /// Shadow Word: Void deals 120% damage in PvP
            if (p_Spellproto->Id == 205351)
                return 20.0f;
            /// Void Eruption deals 40% damage in PvP
            if (p_Spellproto->Id == 228360)
                return -60.0f;
            break;
        }
        case SPELLFAMILY_WARLOCK:
        {
            /// Chaos Bolt deals 90% damage in PvP
            if (p_Spellproto->Id == 116858)
                return -10.0f;
            /// Shadowburn deals 80% damage in PvP
            if (p_Spellproto->Id == 17877)
                return -20.0f;
            /// Agony deals 85% damage in PvP
            if (p_Spellproto->Id == 980)
                return -15.0f;
            /// Unstable Affliction deals 110 % damage in PvP
            if (p_Spellproto->Id == 233490)
                return 10.0f;
            /// Drain Soul deals 115 % damage in PvP
            if (p_Spellproto->Id == 198590)
                return 15.0f;
            /// Rain of fire deals 80 % damage in PvP
            if (p_Spellproto->Id == 42223)
                return -20.0f;
            /// Chaos Barrage and Shadow Bolt deals 45 % damage in PvP
            if (p_Spellproto->Id == 196657 || p_Spellproto->Id == 187394)
                return -55.0f;
            /// Channel Demonfire deals 56 % damage in PvP
            if (p_Spellproto->Id == 196448)
                return -44.0f;
            /// Implosion deals 70% damage in PvP
            if (p_Spellproto->Id == 196277)
                return -30.0f;
            break;
        }
        case SPELLFAMILY_SHAMAN:
        {
            /// Earth Shock deals 62.5% damage in PvP
            if (p_Spellproto->Id == 8042)
                return -37.5f;
            /// Healing Surge heals for 120% in PvP
            if (p_Spellproto->Id == 8004 && ToPlayer() && ToPlayer()->GetActiveSpecializationID() == SPEC_SHAMAN_RESTORATION)
                return 20.0f;
            /// Healing wave heals for 175% in PvP
            if (p_Spellproto->Id == 77472)
                return 75.0f;
            /// Healing Stream Totem heals for 140% in PvP
            if (p_Spellproto->Id == 52042)
                return 40.0f;
            /// Stormstrike deals 75% damage in PvP
            if (p_Spellproto->Id == 32176 || p_Spellproto->Id == 32175)
                return -25.0f;
            /// Icefury deals 65% damage in PvP
            if (p_Spellproto->Id == 210714)
                return -35.0f;
            /// Elemental Blast deals 85% damage in PvP
            if (p_Spellproto->Id == 117014)
                return -15.0f;
            /// Windstrike deals 75% damage in PvP
            if (p_Spellproto->Id == 115357 || p_Spellproto->Id == 115360)
                return -25.0f;
            break;
        }
        case SPELLFAMILY_HUNTER:
        {
            /// Siodewinders deals 90% damage in PvP
            if (p_Spellproto->Id == 214581)
                return -10.0f;
            /// Cobra Shot deals 75% damage in PvP
            if (p_Spellproto->Id == 193455)
                return -25.0f;
            /// Kill Command deals 80% damage in PvP
            if (p_Spellproto->Id == 83381)
                return -20.0f;
            /// Aimed Shot deals 85% damage in PvP https://trello.com/c/dapq7vEM/2733-huntermarksmanship-aimed-shot-pvp-mod (was 80% in 7.0.3 then increased by 5%)
            if (p_Spellproto->Id == 19434)
                return -15.0f;
            /// Marked Shot deals 70% damage in PvP
            if (p_Spellproto->Id == 212621)
                return -30.0f;
            /// Piercing Shot deals 50% damage in PvP
            if (p_Spellproto->Id == 198670 || p_Spellproto->Id == 213678)
                return -50.0f;
            /// Exhiliration heals for 60% in PvP
            if (p_Spellproto->Id == 109304)
                return -40.0f;
            /// A Murder of Crows deal 65% damage in PvP
            if (p_Spellproto->Id == 206505)
                return -35.0f;
            /// Barrage deals 80% damage in PvP
            if (p_Spellproto->Id == 120361)
                return -20.0f;
            /// Steel trap deals 30% damage in PvP
            if (p_Spellproto->Id == 162487)
                return -70.0f;
            /// Caltrops deal 80% damage in PvP
            if (p_Spellproto->Id == 194279)
                return -20.0f;
            break;
        }
        case SPELLFAMILY_MONK:
        {
            /// Strike of the Windlord, damage is now reduced by 40% in PvP
            if (p_Spellproto->Id == 222029 || p_Spellproto->Id == 205414)
                return -40.0f;
            /// Fists of Fury deals 80% damage in PvP
            if (p_Spellproto->Id == 117418)
                return -20.0f;
            /// Revival heals for 200% in PvP
            if (p_Spellproto->Id == 115310)
                return 100.0f;
            /// Soothing Mist heals for 80% in PvP
            if (p_Spellproto->Id == 115175)
                return -20.0f;
            /// Invoke Xuen, the White Tiger deals 60% damage in PvP
            if (p_Spellproto->Id == 123996)
                return -40.0f;
            /// Life Cocoon absorb 110% in PvP
            if (p_Spellproto->Id == 116849)
                return 10.0f;
            /// Blackout Kick deals 110% damage in PvP
            if (p_Spellproto->Id == 100784)
                return 10.0f;
            /// Rising Sun Kick deals 90% damage in PvP
            if (p_Spellproto->Id == 185099)
                return -10.0f;
            break;
        }
        case SPELLFAMILY_DEATHKNIGHT:
        {
            /// Sindragosa's Fury deals 40% damage in PvP
            if (p_Spellproto->Id == 190780)
                return -60.0f;
            /// Virulent Plague deals 45% damage in PvP
            if (p_Spellproto->Id == 191587)
                return -55.0f;
            /// Epidemic deals 85% damage in PvP
            if (p_Spellproto->Id == 212739 || p_Spellproto->Id == 215969)
                return -15.0f;
            /// Dark Arbiter deals 60% damage in PvP
            if (p_Spellproto->Id == 198715)
                return -40.0f;
            /// Summon Gargoyle deals 66.666% damage in PvP
            if (p_Spellproto->Id == 51963)
                return -33.33333f;
            /// Breath of Sindragosa deals 60% damage in PvP
            if (p_Spellproto->Id == 155166)
                return -40.0f;
            /// Dragged To Helheim deals 80% damage in PvP (Spell casted by army  of the dead explosion with artifact trait "Portal to the underworld"
            if (p_Spellproto->Id == 218321)
                return -20.0f;
            /// Clawing Shadows deal 75% damage in PvP
            if (p_Spellproto->Id == 207311)
                return -25.0f;
            /// Heart Strike deals 75% damage in PvP
            if (p_Spellproto->Id == 206930)
                return -25.0f;
            break;
        }
        case SPELLFAMILY_MAGE:
        {
            /// Fireball deals 175% damage in PvP
            if (p_Spellproto->Id == 133)
                return 75.0f;
            /// Pyroblast deals 70% damage in PvP
            if (p_Spellproto->Id == 11366)
                return -30.0f;
            /// Ice Lance deals 120% damage in PvP
            if (p_Spellproto->Id == 228598)
                return 20.0f;
            /// Unstable Magic deals 60% damage in PvP
            if (p_Spellproto->Id == 157979 || p_Spellproto->Id == 157978 || p_Spellproto->Id == 157977)
                return -40.0f;
            /// FlameStrike deals 90% damage in PVP
            if (p_Spellproto->Id == 2120)
                return -10.0f;
            /// Meteor deals 70% damage in PvP
            if (p_Spellproto->Id == 153564)
                return -30.0f;
            /// Ebonbolt deals 90% damage in PvP
            if (p_Spellproto->Id == 228599)
                return -10.0f;
            /// Flurry deals 95% damage in PvP
            if (p_Spellproto->Id == 228354)
                return -5.f;
            break;
        }
        case SPELLFAMILY_WARRIOR:
        {
            /// Soul of the Slaughter heals 70% damage in PvP
            if (p_Spellproto->Id == 240432)
                return -30.0f;
            /// Mortal Strike deals 75% damage in PvP
            if (p_Spellproto->Id == 12294 || p_Spellproto->Id == 246820)
                return -25.0f;
            /// Rend deals 85% damage in PvP
            if (p_Spellproto->Id == 772)
                return -15.0f;
            break;
        }
        case SPELLFAMILY_DEMONHUNTER:
        {
            /// Soul Fragments from Shattered Souls heal for 80% in PvP
            if (p_Spellproto->Id == 210042 || p_Spellproto->Id == 210049 || p_Spellproto->Id == 203794)
                return -20.0f;
            /// Chaos Blades deal 75% damage in PvP
            if (p_Spellproto->Id == 211797)
                return -25.0f;
            /// Fury of the Illidari deals 70% damage in PvP
            if (p_Spellproto->Id == 201628 || p_Spellproto->Id == 201789)
                return -30.0f;
            /// Annihilation deal 95% damage in PvP
            if (p_Spellproto->Id == 227518 || p_Spellproto->Id == 201428)
                return -5.0f;
            /// Fel Barrage deal 70% damage in PvP
            if (p_Spellproto->Id == 211052)
                return -30.0f;
            /// Demonic Trample deal 50% damage in PvP
            if (p_Spellproto->Id == 208645)
                return -50.0f;
            break;
        }
        case SPELLFAMILY_PALADIN:
        {
            /// Avenger's Shield deals 50% damage in PvP
            if (p_Spellproto->Id == 31935)
                return -50.0f;
            /// Shield of the Righteous deals 50% damage in PvP
            if (p_Spellproto->Id == 53600)
                return -50.0f;
            /// Light of the Protector heals for 40% in PvP
            if (p_Spellproto->Id == 184092)
                return -60.0f;
            /// Hand of the Protector heals for 40% in PvP
            if (p_Spellproto->Id == 213652)
                return -60.0f;
            /// Holy Shock deals 50% damage in PvP
            if (p_Spellproto->Id == 25912)
                return -50.0f;
            /// Blade of Justice deals 80% damage in PvP
            if (p_Spellproto->Id == 184575)
                return -20.0f;
            /// Templar's Verdict deals 93% damage in PVP
            if (p_Spellproto->Id == 224266)
                return -7.0f;
            /// Flash of Light heals 150% in PVP
            if (p_Spellproto->Id == 19750)
                return 50.0f;
            /// Holy Light heals 160% in PVP
            if (p_Spellproto->Id == 82326)
                return 60.0f;
            /// Blade of Justice deals 90,9% damage in PVP
            if (p_Spellproto->Id == 184575)
                return -9.9f;
             /// Divine Storm deals 93% damage in PVP
            if (p_Spellproto->Id == 224239)
                return -7.0f;
            break;
        }
        case SPELLFAMILY_ROGUE:
        {
            /// Eviscerate deals 85% damage in PvP
            if (p_Spellproto->Id == 196819)
                return -15.0f;
            /// Nightblade deals 85% damage in PvP
            if (p_Spellproto->Id == 195452)
                return -15.0f;
            /// Death from above (lift off) deals 50% damage in PvP
            if (p_Spellproto->Id == 152150)
                return 25.0f;
            /// Bag of tricks deals 60% damage in PvP
            if (p_Spellproto->Id == 192660)
                return -40.0f;
            /// Shadowstrike deals 70% damage in PvP
            if (p_Spellproto->Id == 185438)
                return -30.0f;
            break;
        }
        case SPELLFAMILY_GENERIC:
        {
            /// Light's Judgment deals 40% damage in PvP
            if (p_Spellproto->Id == 256893)
                return -60.0f;
            /// Implosion deals 70% damage in PvP
            if (p_Spellproto->Id == 196278)
                return -30.0f;
            break;
        }
        default:
            break;
    }

    return 0.0f;
}

void Unit::BuildEncounterFrameData(WorldPacket* p_Data, bool p_Engage, uint8 p_TargetFramePriority /*= 0*/)
{
    if (p_Engage)
    {
        p_Data->Initialize(SMSG_INSTANCE_ENCOUNTER_ENGAGE_UNIT, 16 + 2 + 1);
        p_Data->append(GetPackGUID());
        *p_Data << uint8(p_TargetFramePriority);
    }
    else
    {
        p_Data->Initialize(SMSG_INSTANCE_ENCOUNTER_DISENGAGE_UNIT, 16 + 2);
        p_Data->append(GetPackGUID());
    }
}

int32 Unit::GetCommandDemonSpellByEntry(uint32 p_Entry)
{
    switch (p_Entry)
    {
        case WarlockPet::Imp:
        case WarlockPet::FellImp:
            return 119905;// Cauterize Master
        case WarlockPet::VoidWalker:
        case WarlockPet::VoidLord:
            return 119907;// Suffering
        case WarlockPet::Succubus:
            return 119909; // Whiplash
        case WarlockPet::Shivarra:
            return 119913;// Fellash
        case WarlockPet::FelHunter:
            return 119910;// Spell Lock
        case WarlockPet::Observer:
            return 119911;// Optical Blast
        case WarlockPet::FelGuard:
            return 119914;// Felstorm
        case WarlockPet::WrathGuard:
            return 119915;// Wrathstorm
        case WarlockPet::DoomGuardPet:
        case WarlockPet::TerrorGuardPet:
            return 171140; // Shadow Lock
        case WarlockPet::InfernalPet:
            return 171152; // Meteor Strike (Infernal)
        case WarlockPet::AbyssalPet:
        case WarlockPet::AbyssalPEtGreenFire:
            return 171154; // Meteor Strike (Abyssal)
        default:
            return 0;
    }
    return 0;
}

bool Unit::AddPoisonTarget(uint32 p_SpellID, uint32 p_LowGuid)
{
    /// First target registration
    if (m_PoisonTargets.find(p_LowGuid) == m_PoisonTargets.end())
    {
        std::set<uint32> l_SpellSet;
        l_SpellSet.insert(p_SpellID);
        m_PoisonTargets.insert(std::make_pair(p_LowGuid, l_SpellSet));
        return true;
    }

    /// Target has already this spell registered
    if (m_PoisonTargets[p_LowGuid].find(p_SpellID) != m_PoisonTargets[p_LowGuid].end())
        return false;

    /// Register new spell for target
    m_PoisonTargets[p_LowGuid].insert(p_SpellID);
    return true;
}

bool Unit::HasPoisonTarget(uint32 p_LowGuid) const
{
    for (auto l_Iter : m_PoisonTargets)
    {
        if (l_Iter.first == p_LowGuid)
            return true;
    }

    return false;
}

void Unit::RemovePoisonTarget(uint32 p_LowGuid, uint32 p_SpellID)
{
    /// Target is not registered
    if (m_PoisonTargets.find(p_LowGuid) == m_PoisonTargets.end())
        return;

    /// Spell is not registered for target
    if (m_PoisonTargets[p_LowGuid].find(p_SpellID) == m_PoisonTargets[p_LowGuid].end())
        return;

    /// Unregister spell for target
    m_PoisonTargets[p_LowGuid].erase(p_SpellID);

    /// If no spell registered, unregister target
    if (m_PoisonTargets[p_LowGuid].empty())
        m_PoisonTargets.erase(p_LowGuid);
}

void Unit::ClearPoisonTargets()
{
    m_PoisonTargets.clear();
}

void Unit::SetChannelSpellID(uint32 p_SpellID)
{
    SetChannelSpellID(sSpellMgr->GetSpellInfo(p_SpellID));
}

void Unit::SetChannelSpellID(SpellInfo const* p_SpellInfo)
{
    if (p_SpellInfo)
    {
        SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL, p_SpellInfo->Id);
        SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL_XSPELL_VISUAL, p_SpellInfo->GetSpellXSpellVisualId(this));
    }
    else
    {
        SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL, 0);
        SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL_XSPELL_VISUAL, 0);
    }
}

void Unit::SetChannelSpellID(uint32 p_SpellID, uint32 p_SpellXSpellVisualID)
{
    SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL, p_SpellID);
    SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL_XSPELL_VISUAL, p_SpellXSpellVisualID);
}

bool Unit::IsOutdoors()
{
    if (GetExactDistSq(&m_LastOutdoorPosition) < 4.0f * 4.0f)
        return m_LastOutdoorStatus;
    else
    {
        m_LastOutdoorPosition.Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
        m_LastOutdoorStatus = GetMap()->IsOutdoors(GetPositionX(), GetPositionY(), GetPositionZ());
        return m_LastOutdoorStatus;
    }
}

uint32 Unit::GetVirtualItemId(uint32 slot) const
{
    if (slot >= MAX_EQUIPMENT_ITEMS)
        return 0;

    return GetUInt32Value(UNIT_FIELD_VIRTUAL_ITEMS + slot * 2);
}

uint16 Unit::GetVirtualItemAppearanceMod(uint32 slot) const
{
    if (slot >= MAX_EQUIPMENT_ITEMS)
        return 0;

    return GetUInt16Value(UNIT_FIELD_VIRTUAL_ITEMS + slot * 2 + 1, 0);
}

void Unit::SetVirtualItem(uint32 slot, uint32 itemID, uint16 appearanceModID /*= 0*/, uint16 itemVisual /*= 0*/)
{
    if (slot >= MAX_EQUIPMENT_ITEMS)
        return;

    SetUInt32Value(UNIT_FIELD_VIRTUAL_ITEMS + slot * 2, itemID);
    SetUInt16Value(UNIT_FIELD_VIRTUAL_ITEMS + slot * 2 + 1, 0, appearanceModID);
    SetUInt16Value(UNIT_FIELD_VIRTUAL_ITEMS + slot * 2 + 1, 1, itemVisual);
}

uint32 Unit::GetZoneId(bool p_ForceRecalc) const
{
    if (!p_ForceRecalc && GetExactDistSq(&m_LastZonePosition) < 4.0f * 4.0f)
        return m_LastZoneId;
    else
    {
        const_cast<Position*>(&m_LastZonePosition)->Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
        *(const_cast<uint32*>(&m_LastZoneId)) = WorldObject::GetZoneId();
        return m_LastZoneId;
    }
}

uint32 Unit::GetAreaId(bool p_ForceRecalc) const
{
    if (!p_ForceRecalc && GetExactDistSq(&m_LastAreaPosition) < 4.0f * 4.0f)
        return m_LastAreaId;
    else
    {
        const_cast<Position*>(&m_LastAreaPosition)->Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
        *(const_cast<uint32*>(&m_LastAreaId)) = WorldObject::GetAreaId();
        return m_LastAreaId;
    }
}

void Unit::GetZoneAndAreaId(uint32& p_ZoneId, uint32& p_AreaId, bool p_ForceRecalc) const
{
    if (!p_ForceRecalc && GetExactDistSq(&m_LastAreaPosition) < 4.0f * 4.0f && GetExactDistSq(&m_LastZonePosition) < 4.0f * 4.0f)
    {
        p_ZoneId = m_LastZoneId;
        p_AreaId = m_LastAreaId;
        return;
    }

    const_cast<Position*>(&m_LastZonePosition)->Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
    const_cast<Position*>(&m_LastAreaPosition)->Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
    WorldObject::GetZoneAndAreaId(p_ZoneId, p_AreaId);
    *(const_cast<uint32*>(&m_LastZoneId)) = p_ZoneId;
    *(const_cast<uint32*>(&m_LastAreaId)) = p_AreaId;
}

Unit* Unit::GetUnitForLinkedSpell(Unit* caster, Unit* target, uint8 type)
{
    switch (type)
    {
        case LINK_UNIT_TYPE_PET: //1
            return (Unit*)(ToPlayer() ? ToPlayer()->GetPet() : nullptr);
        case LINK_UNIT_TYPE_OWNER: //2
            return GetAnyOwner();
        case LINK_UNIT_TYPE_CASTER: //3
            return caster;
        case LINK_UNIT_TYPE_SELECTED: //4
            return ToPlayer() ? ToPlayer()->GetSelectedUnit() : nullptr;
        case LINK_UNIT_TYPE_TARGET: //5
            return target;
        case LINK_UNIT_TYPE_VICTIM: //6
            return getVictim();
        case LINK_UNIT_TYPE_ATTACKER: //7
            if (Unit* owner = caster->GetOwner())
                return owner->getAttackerForHelper();
            else
                return caster->getAttackerForHelper();
        case LINK_UNIT_TYPE_NEARBY: //8
            return SelectNearbyTarget(target);
        case LINK_UNIT_TYPE_NEARBY_ALLY: //9
            return SelectNearbyAlly(target);
            break;
        case LINK_UNIT_TYPE_ORIGINALCASTER: //10
            return this;
    }

    return nullptr;
}

void Unit::SendSpellCreateVisual(SpellInfo const* spellInfo, Position const* position, Unit* target, uint32 type, uint32 visualId)
{
    bool exist = false;
    bool HasPosition = false;
    bool l_SpeedAsTime = false;
    Position TargetPosition = { 0.0f, 0.0f, 0.0f, 0.0f };

    float l_TravelSpeed = spellInfo->Speed;
    uint32 l_VisualID = 0;

    if (auto const* spellVisual = sSpellMgr->GetPlaySpellVisualData(spellInfo->Id))
    {
        float chance = 100.0f / spellVisual->size();
        for (auto const& x : *spellVisual)
        {
            if (x.Type != type)
                continue;

            if (x.Type == SPELL_VISUAL_TYPE_CUSTOM && x.SpellVisualID != visualId)
                continue;

            if (x.TravelSpeed)
                l_TravelSpeed = x.TravelSpeed;

            l_SpeedAsTime = x.SpeedAsTime;
            HasPosition = x.HasPosition;
            exist = true;

            l_VisualID = x.SpellVisualID;

            if (!type && roll_chance_f(chance))
                break;
        }
    }

    if (!exist)
        return;

    if (l_TravelSpeed && HasPosition)
    {
        if (target && target != this)
            TargetPosition = *target;
        else
            TargetPosition = *position;
    }

    SendPlaySpellVisual(l_VisualID, target, l_TravelSpeed, TargetPosition, l_SpeedAsTime);
}

void Unit::SendSpellPlayOrphanVisual(SpellInfo const* spellInfo, bool apply, Position const* position, Unit* target)
{
    if (auto const* orphan = sSpellMgr->GetSpellVisualPlayOrphan(spellInfo->Id))
    {
        for (auto const& playOrphan : *orphan)
        {
            if (apply)
            {
                G3D::Vector3 l_Src(m_positionX, m_positionY, m_positionZ);
                G3D::Vector3 l_Orientation(playOrphan.SourceOrientation.m_positionX, playOrphan.SourceOrientation.m_positionY, playOrphan.SourceOrientation.m_positionZ);
                G3D::Vector3 l_Dst;

                if (target && playOrphan.Type)
                    l_Dst = G3D::Vector3(target->m_positionX, target->m_positionY, target->m_positionZ);
                else
                    l_Dst = G3D::Vector3(position->m_positionX, position->m_positionY, position->m_positionZ);

                uint64 l_Target = 0;
                if (target && !playOrphan.Type)
                    l_Target = target->GetGUID();

                PlayOrphanSpellVisual(l_Src, l_Orientation, l_Dst, playOrphan.SpellVisualID, playOrphan.TravelSpeed, l_Target, playOrphan.SpeedAsTime, playOrphan.UnkFloat);
            }
            else
                CancelSpellVisual(playOrphan.SpellVisualID);
        }
    }
}

void Unit::SendSpellCooldown(int32 spellID, int32 spelCooldown, int32 cooldown /*= 0*/, CooldownFlags flags /*= CooldownFlags::CooldownFlagNone*/)
{
    Player* player = ToPlayer();

    if (!player)
    {
        if (Unit* owner = GetAnyOwner())
            player = owner->ToPlayer();
    }

    if (!player)
        return;

    if (!cooldown)
    {
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spelCooldown))
            cooldown = spellInfo->RecoveryTime;
    }

    if (!cooldown)
    {
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellID))
            cooldown = spellInfo->RecoveryTime;
    }

    if (!cooldown)
    {
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spelCooldown))
            cooldown = spellInfo->StartRecoveryTime;
    }

    if (!cooldown)
        return;

    WorldPacket data(SMSG_SPELL_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
    data.appendPackGUID(GetGUID());
    data << uint8(flags);
    data << uint32(1);
    data << uint32(spellID);
    data << uint32(cooldown);
    data << float(1.0f);

    player->GetSession()->SendPacket(&data);
}

void DelayCastEvent::Execute(Unit *caster)
{
    Unit* target = caster;

    if (TargetGUID && target->GetGUID() != TargetGUID)
        target = ObjectAccessor::GetUnit(*caster, TargetGUID);

    if (!target)
        return;

    caster->CastSpell(target, Spell, triggered);
};

bool DelayCastEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
{
    if (!m_owner.IsInWorld())
        return false;

    Unit* caster = &m_owner;
    Unit* target = &m_owner;

    if (TargetGUID && target->GetGUID() != TargetGUID)
        target = ObjectAccessor::GetUnit(m_owner, TargetGUID);

    if (target)
        caster->CastSpell(target, Spell, triggered);
    return true;
};

bool DelayDestCastEvent::Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
{
    if (!m_Owner.IsInWorld())
        return true;

    Unit* l_Caster = &m_Owner;

    l_Caster->CastSpell(m_Position, m_SpellID, m_Triggered);
    return true;
};

bool DelaySummonEvent::Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
{
    if (!m_Owner.IsInWorld())
        return true;

    Creature* l_Owner = &m_Owner;

    l_Owner->SummonCreature(m_Summon, m_Pos.GetPositionX(), m_Pos.GetPositionY(), m_Pos.GetPositionZ() + m_ModZ);
    return true;
}

void Unit::RecalculateAllAurasAmount(bool p_Delay /*= false*/)
{
    if (p_Delay)
    {
        bool& l_RecalculateScheduled = m_SpellHelper.GetBool(eSpellHelpers::AuraRecalculation);
        if (l_RecalculateScheduled)
            return;

        l_RecalculateScheduled = true;

        uint64 l_Guid = GetGUID();
        Map* l_Map    = GetMap();
        GetMap()->AddTask([l_Guid, l_Map]() -> void
        {
            if (Unit* l_Unit = sObjectAccessor->FindUnit(l_Guid))
            {
                if (l_Unit->GetMap() != l_Map)
                    return;

                l_Unit->RecalculateAllAurasAmount(0);
            }

            return;
        });

        return;
    }

    m_SpellHelper.GetBool(eSpellHelpers::AuraRecalculation) = false;

    Player* l_Player = ToPlayer();
    if (l_Player)
    {
        MS::Artifact::Manager* l_Artifact = l_Player->GetCurrentlyEquippedArtifact();
        if (l_Artifact)
            l_Artifact->_LearnSpells();
    }

    /// Refresh amount of all auras
    /// m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)
    {
        Aura*& l_Aura = m_auraUpdateIterator->second;
        ++m_auraUpdateIterator;                             ///< Need shift to next for allow update if need into aura update
        for (uint8 eff = 0; eff < l_Aura->GetEffectCount(); ++eff)
        {
            if (l_Aura->HasEffect(eff) && l_Aura->GetId() != 77215) ///< Mastery from Warlock is modify in case if you get trinket with proc mastery and Deadwind Harvester
                l_Aura->GetEffect(eff)->RecalculateAmount(true);
        }
    }
}

bool Unit::CanApplyPvPSpellModifiers() const
{
    Player* l_Player = GetSpellModOwner();
    if (!l_Player)
        return false;

    if (l_Player->IsInDuel())
        return true;

    if (l_Player->IsInBattleground())
        return true;

    return false;
}

bool Unit::IsInNoPathArea()
{
    if (InstanceScript* l_Instance = GetInstanceScript())
        return l_Instance->IsInNoPathArea(*this);

    return false;
}

/// Temp enum, need more reverse work on LogicOpperators in CGPlayer_C::MatchesCondition
enum
{
    LOGIC_FLAG_01                       = 0x00000001,
    LOGIC_FLAG_02                       = 0x00000002,
    LOGIC_FLAG_03                       = 0x00000004,
    LOGIC_FLAG_04                       = 0x00000008,
    LOGIC_FLAG_05                       = 0x00000010,
    LOGIC_FLAG_06                       = 0x00000020,
    LOGIC_FLAG_07                       = 0x00000040,
    LOGIC_FLAG_COL_0_XOR_RESULT_TRUE    = 0x00010000,
    LOGIC_FLAG_COL_1_XOR_RESULT_TRUE    = 0x00020000,
    LOGIC_FLAG_COL_2_XOR_RESULT_TRUE    = 0x00040000,
    LOGIC_FLAG_COL_3_XOR_RESULT_TRUE    = 0x00080000,
};

std::pair<bool, std::string> Unit::EvalPlayerCondition(uint32 p_ConditionsID, bool p_FailIfConditionNotFound) const
{
    PlayerConditionEntry const* l_Entry = sPlayerConditionStore.LookupEntry(p_ConditionsID);

    if (!l_Entry && !sScriptMgr->HasPlayerConditionScript(p_ConditionsID))
        return std::pair<bool, std::string>(!p_FailIfConditionNotFound, "Condition entry not found");

    if (sScriptMgr->HasPlayerConditionScript(p_ConditionsID))
    {
        if (!sScriptMgr->EvalPlayerConditionScript(p_ConditionsID, l_Entry, this))
            return std::pair<bool, std::string>(false, "Condition script failed");

        return std::pair<bool, std::string>(true, "");
    }

    auto EvalMatch = [](bool * p_Matches, uint32 p_Flags) -> bool
    {
        bool l_Result = p_Matches[0] && p_Matches[1] && p_Matches[2] && p_Matches[3];
        bool l_FirstMatchFlagMatch  = (!!(p_Flags & LOGIC_FLAG_COL_0_XOR_RESULT_TRUE)) ^ p_Matches[0];
        bool l_SecondMatchFlagMatch = (!!(p_Flags & LOGIC_FLAG_COL_1_XOR_RESULT_TRUE)) ^ p_Matches[1];
        bool l_ThirdMatchFlagMatch  = (!!(p_Flags & LOGIC_FLAG_COL_2_XOR_RESULT_TRUE)) ^ p_Matches[2];
        bool l_FourthMatchFlagMatch = (!!(p_Flags & LOGIC_FLAG_COL_3_XOR_RESULT_TRUE)) ^ p_Matches[3];

        if (p_Flags & LOGIC_FLAG_01)
        {
            if (l_FirstMatchFlagMatch)
                l_Result = l_SecondMatchFlagMatch;
        }
        else if (p_Flags & LOGIC_FLAG_02)
            l_Result = l_FirstMatchFlagMatch | l_SecondMatchFlagMatch;

        if (p_Flags & LOGIC_FLAG_03)
            l_Result = l_Result & l_ThirdMatchFlagMatch;
        else if (p_Flags & LOGIC_FLAG_04)
            l_Result = l_Result | l_ThirdMatchFlagMatch;

        if (p_Flags & LOGIC_FLAG_05)
        {
            if (!l_Result)
                return false;
        }
        else if (p_Flags & LOGIC_FLAG_06)
            l_Result = l_FourthMatchFlagMatch | l_Result;

        if ((p_Flags & (LOGIC_FLAG_07 - 1)) == 0)
            return (l_FirstMatchFlagMatch && l_SecondMatchFlagMatch && l_ThirdMatchFlagMatch && l_FourthMatchFlagMatch);

        return l_Result;
    };

    /// @TODO : Flags

    #pragma region Level conditions
    if (l_Entry->MinLevel != 0 && getLevel() < l_Entry->MinLevel)
        return std::pair<bool, std::string>(false, "Failed on MinLevel => db2(" + std::to_string(l_Entry->MinLevel) + ") you(" + std::to_string(getLevel()) + ")");
    if (l_Entry->MaxLevel != 0 && getLevel() > l_Entry->MaxLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxLevel => db2(" + std::to_string(l_Entry->MaxLevel) + ") you(" + std::to_string(getLevel()) + ")");
    #pragma endregion Level conditions

    #pragma region Class, Race, Gender, NativeGender
    if (l_Entry->RaceMask != 0 && (l_Entry->RaceMask & getRaceMask()) == 0)
        return std::pair<bool, std::string>(false, "Failed on RaceMask => db2(" + std::to_string(l_Entry->RaceMask) + ") you(" + std::to_string(getRaceMask()) + ")");
    if (l_Entry->ClassMask != 0 && (l_Entry->ClassMask & getClassMask()) == 0)
        return std::pair<bool, std::string>(false, "Failed on ClassMask => db2(" + std::to_string(l_Entry->ClassMask) + ") you(" + std::to_string(getClassMask()) + ")");
    if (l_Entry->Gender != -1 && l_Entry->Gender != 3 && l_Entry->Gender != getGender())
        return std::pair<bool, std::string>(false, "Failed on Gender => db2(" + std::to_string(l_Entry->Gender) + ") you(" + std::to_string(getGender()) + ")");
    if (l_Entry->NativeGender != -1 && l_Entry->NativeGender != 3 && l_Entry->NativeGender != getGender())
        return std::pair<bool, std::string>(false, "Failed on NativeGender => db2(" + std::to_string(l_Entry->NativeGender) + ") you(" + std::to_string(getGender()) + ")");
    #pragma endregion Class, Race, Gender, NativeGender

    #pragma region Skills
    if (IsPlayer())
    {
        for (uint32 l_I = 0; l_I < 4; ++l_I)
        {
            if (l_Entry->SkillID[l_I] != 0)
            {
                if (!ToPlayer()->HasSkill(l_Entry->SkillID[l_I]))
                    return std::pair<bool, std::string>(false, "Failed on SkillID => db2(" + std::to_string(l_Entry->SkillID[l_I]) + ") you don't known this skill");

                int32 l_Skill = (int32)ToPlayer()->GetSkillValue(l_Entry->SkillID[l_I]);

                if (l_Entry->MinSkill[l_I] != 0 && l_Skill < l_Entry->MinSkill[l_I])
                    return std::pair<bool, std::string>(false, "Failed on MinSkill => db2(" + std::to_string(l_Entry->MinSkill[l_I]) + ") you(" + std::to_string(l_Skill) + ")");
                if (l_Entry->MaxSkill[l_I] != 0 && l_Skill > l_Entry->MaxSkill[l_I])
                    return std::pair<bool, std::string>(false, "Failed on MaxSkill => db2(" + std::to_string(l_Entry->MaxSkill[l_I]) + ") you(" + std::to_string(l_Skill) + ")");
            }
        }
    }
    #pragma endregion Skills

    /// @TODO : SkillLogic

    #pragma region Language
    if (IsPlayer())
    {
        if (l_Entry->LanguageID != 0)
        {
            uint32 l_SkillID = lang_description[l_Entry->LanguageID].skill_id;

            if (!ToPlayer()->HasSkill(l_SkillID))
                return std::pair<bool, std::string>(false, "Failed on LanguageID => db2(" + std::to_string(l_Entry->LanguageID) + ") you don't known this language");

            int32 l_Skill = (int32)ToPlayer()->GetSkillValue(l_SkillID);

            if (l_Entry->MinLanguage != 0 && l_Skill < l_Entry->MinLanguage)
                return std::pair<bool, std::string>(false, "Failed on MinLanguage => db2(" + std::to_string(l_Entry->MinLanguage) + ") you(" + std::to_string(l_Skill) + ")");
            if (l_Entry->MaxLanguage != 0 && l_Skill > l_Entry->MaxLanguage)
                return std::pair<bool, std::string>(false, "Failed on MaxLanguage => db2(" + std::to_string(l_Entry->MaxLanguage) + ") you(" + std::to_string(l_Skill) + ")");
        }
    }
    #pragma endregion Language

    /// @TODO : MinFaction
    /// @TODO : MinReputation
    /// @TODO : MaxReputation
    /// @TODO : ReputationLogic
    /// @TODO : MinPVPRank
    /// @TODO : MaxPVPRank
    /// @TODO : PVPMedal

    #pragma region PrevQuestLogic, PrevQuestID
    if (IsPlayer() && (l_Entry->PrevQuestID[0] || l_Entry->PrevQuestID[1] || l_Entry->PrevQuestID[2] || l_Entry->PrevQuestID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->PrevQuestID[0] != 0) l_Matches[0] = ToPlayer()->GetQuestRewardStatus(l_Entry->PrevQuestID[0]);
        if (l_Entry->PrevQuestID[1] != 0) l_Matches[1] = ToPlayer()->GetQuestRewardStatus(l_Entry->PrevQuestID[1]);
        if (l_Entry->PrevQuestID[2] != 0) l_Matches[2] = ToPlayer()->GetQuestRewardStatus(l_Entry->PrevQuestID[2]);
        if (l_Entry->PrevQuestID[3] != 0) l_Matches[3] = ToPlayer()->GetQuestRewardStatus(l_Entry->PrevQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->PrevQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on PrevQuestID");
    }
    #pragma endregion PrevQuestLogic, PrevQuestID

    #pragma region CurrQuestLogic, CurrQuestID
    if (IsPlayer() && (l_Entry->CurrQuestID[0] || l_Entry->CurrQuestID[1] || l_Entry->CurrQuestID[2] || l_Entry->CurrQuestID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrQuestID[0] != 0) l_Matches[0] = ToPlayer()->HasQuest(l_Entry->CurrQuestID[0]);
        if (l_Entry->CurrQuestID[1] != 0) l_Matches[1] = ToPlayer()->HasQuest(l_Entry->CurrQuestID[1]);
        if (l_Entry->CurrQuestID[2] != 0) l_Matches[2] = ToPlayer()->HasQuest(l_Entry->CurrQuestID[2]);
        if (l_Entry->CurrQuestID[3] != 0) l_Matches[3] = ToPlayer()->HasQuest(l_Entry->CurrQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->CurrQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrQuestID");
    }
    #pragma endregion CurrQuestLogic, CurrQuestID

    #pragma region CurrentCompletedQuestLogic, CurrentCompletedQuestID
    if (IsPlayer() && (l_Entry->CurrentCompletedQuestID[0] || l_Entry->CurrentCompletedQuestID[1] || l_Entry->CurrentCompletedQuestID[2] || l_Entry->CurrentCompletedQuestID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrentCompletedQuestID[0] != 0) l_Matches[0] = ToPlayer()->GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[0]);
        if (l_Entry->CurrentCompletedQuestID[1] != 0) l_Matches[1] = ToPlayer()->GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[1]);
        if (l_Entry->CurrentCompletedQuestID[2] != 0) l_Matches[2] = ToPlayer()->GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[2]);
        if (l_Entry->CurrentCompletedQuestID[3] != 0) l_Matches[3] = ToPlayer()->GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->CurrentCompletedQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrentCompletedQuestID");
    }
    #pragma endregion CurrentCompletedQuestLogic, CurrentCompletedQuestID

    #pragma region SpellLogic, SpellID
    if (IsPlayer() && (l_Entry->SpellID[0] || l_Entry->SpellID[1] || l_Entry->SpellID[2] || l_Entry->SpellID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->SpellID[0] != 0) l_Matches[0] = ToPlayer()->HasSpell(l_Entry->SpellID[0])/* || HasAura(l_Entry->SpellID[0])*/;
        if (l_Entry->SpellID[1] != 0) l_Matches[1] = ToPlayer()->HasSpell(l_Entry->SpellID[1])/* || HasAura(l_Entry->SpellID[1])*/;
        if (l_Entry->SpellID[2] != 0) l_Matches[2] = ToPlayer()->HasSpell(l_Entry->SpellID[2])/* || HasAura(l_Entry->SpellID[2])*/;
        if (l_Entry->SpellID[3] != 0) l_Matches[3] = ToPlayer()->HasSpell(l_Entry->SpellID[3])/* || HasAura(l_Entry->SpellID[3])*/;

        if (!EvalMatch(l_Matches, l_Entry->SpellLogic))
            return std::pair<bool, std::string>(false, "Failed on SpellID");
    }
    #pragma endregion SpellLogic, SpellID

    #pragma region ItemLogic, ItemID, ItemCount
    if (IsPlayer() && (l_Entry->ItemID[0] || l_Entry->ItemID[1] || l_Entry->ItemID[2] || l_Entry->ItemID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->ItemID[0] != 0) l_Matches[0] = ToPlayer()->HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[0] ? 1 : l_Entry->ItemCount[0], false);
        if (l_Entry->ItemID[1] != 0) l_Matches[1] = ToPlayer()->HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[1] ? 1 : l_Entry->ItemCount[1], false);
        if (l_Entry->ItemID[2] != 0) l_Matches[2] = ToPlayer()->HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[2] ? 1 : l_Entry->ItemCount[2], false);
        if (l_Entry->ItemID[3] != 0) l_Matches[3] = ToPlayer()->HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[3] ? 1 : l_Entry->ItemCount[3], false);

        if (!EvalMatch(l_Matches, l_Entry->ItemLogic))
            return std::pair<bool, std::string>(false, "Failed on ItemID");
    }
    #pragma endregion ItemLogic, ItemID, ItemCount

    /// @TODO : ItemFlags

    #pragma region Explored
    auto IsAreaExplored = [this](uint32 p_AreaID) -> bool ///< p_AreaID is unused
    {
        uint16 l_AreaFlag = sAreaTableStore.LookupEntry(0) ? sAreaTableStore.LookupEntry(0)->AreaBit : 0xFFFF;

        if (l_AreaFlag == 0xFFFF)
            return false;
        int l_Offset = l_AreaFlag / 32;

        if (l_Offset >= PLAYER_EXPLORED_ZONES_SIZE)
            return false;

        uint32 l_Value = (uint32)(1 << (l_AreaFlag % 32));

        if (!(GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + l_Offset) & l_Value))
            return false;

        return true;
    };

    if (IsPlayer() && l_Entry->Explored[0] != 0 && !IsAreaExplored(l_Entry->Explored[0]))
        return std::pair<bool, std::string>(false, "Failed on Explored[0] => db2(" + std::to_string(l_Entry->Explored[0]) + ") area is not explored");
    if (IsPlayer() && l_Entry->Explored[1] != 0 && !IsAreaExplored(l_Entry->Explored[1]))
        return std::pair<bool, std::string>(false, "Failed on Explored[1] => db2(" + std::to_string(l_Entry->Explored[1]) + ") area is not explored");
    #pragma endregion Explored

    /// @TODO : Time

    #pragma region AuraSpellLogic, AuraSpellID
    if (l_Entry->AuraSpellID[0] || l_Entry->AuraSpellID[1] || l_Entry->AuraSpellID[2] || l_Entry->AuraSpellID[3])
    {
        bool l_Matches[] { true, true, true, true };

        if (l_Entry->AuraSpellID[0] != 0) l_Matches[0] = HasAura(l_Entry->AuraSpellID[0]);
        if (l_Entry->AuraSpellID[1] != 0) l_Matches[1] = HasAura(l_Entry->AuraSpellID[1]);
        if (l_Entry->AuraSpellID[2] != 0) l_Matches[2] = HasAura(l_Entry->AuraSpellID[2]);
        if (l_Entry->AuraSpellID[3] != 0) l_Matches[3] = HasAura(l_Entry->AuraSpellID[3]);

        if (!EvalMatch(l_Matches, l_Entry->AuraSpellLogic))
            return std::pair<bool, std::string>(false, "Failed on AuraSpellID");
    }
    #pragma endregion AuraSpellLogic, AuraSpellID

    #pragma region WorldStateExpressionID
    if (l_Entry->WorldStateExpressionID != 0 && IsPlayer())
    {
        WorldStateExpressionEntry const* l_Expression = sWorldStateExpressionStore.LookupEntry(l_Entry->WorldStateExpressionID);

        if (!l_Expression)
            return std::pair<bool, std::string>(false, "Failed on WorldStateExpressionID => DB2 WorldStateExpression entry not found");

        if (!l_Expression->Eval(const_cast<Player*>(ToPlayer())))
            return std::pair<bool, std::string>(false, "Failed on WorldStateExpressionID => eval failed");
    }
    #pragma endregion WorldStateExpressionID

    #pragma region Weather
    if (l_Entry->WeatherID != 0)
    {
        AreaTableEntry const* l_Zone = sAreaTableStore.LookupEntry(GetZoneId());

        if (!l_Zone)
            return std::pair<bool, std::string>(false, "Failed on WeatherID => DB2 AreaTable entry not found");

        Weather* l_Weather = WeatherMgr::FindWeather(l_Zone->ID);

        if (!l_Weather)
            return std::pair<bool, std::string>(false, "Failed on WeatherID => no valid weather found");

        if (l_Weather->GetType() != l_Entry->WeatherID) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
            return std::pair<bool, std::string>(false, "Failed on WeatherID => db2(" + std::to_string(l_Entry->WeatherID) + ") you(" + std::to_string(l_Weather->GetType()) + ")");
    }
    #pragma endregion Weather

    /// @TODO : PartyStatus
    /// @TODO : LifetimeMaxPVPRank

    #pragma region AchievementLogic, Achievement
    if (IsPlayer() && (l_Entry->Achievement[0] || l_Entry->Achievement[1] || l_Entry->Achievement[2] || l_Entry->Achievement[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->Achievement[0] != 0) l_Matches[0] = ToPlayer()->HasAchieved(l_Entry->Achievement[0]);
        if (l_Entry->Achievement[1] != 0) l_Matches[1] = ToPlayer()->HasAchieved(l_Entry->Achievement[1]);
        if (l_Entry->Achievement[2] != 0) l_Matches[2] = ToPlayer()->HasAchieved(l_Entry->Achievement[2]);
        if (l_Entry->Achievement[3] != 0) l_Matches[3] = ToPlayer()->HasAchieved(l_Entry->Achievement[3]);

        if (!EvalMatch(l_Matches, l_Entry->AchievementLogic))
            return std::pair<bool, std::string>(false, "Failed on Achievement");
    }
    #pragma endregion AchievementLogic, Achievement

    /// @TODO : LfgLogic
    /// @TODO : LfgStatus
    /// @TODO : LfgCompare
    /// @TODO : LfgValue

    #pragma region AreaLogic, AreaID
    if (l_Entry->AreaID[0] || l_Entry->AreaID[1] || l_Entry->AreaID[2] || l_Entry->AreaID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->AreaID[0] != 0) l_Matches[0] = l_Entry->AreaID[0] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[1] != 0) l_Matches[1] = l_Entry->AreaID[1] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[2] != 0) l_Matches[2] = l_Entry->AreaID[2] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[3] != 0) l_Matches[3] = l_Entry->AreaID[3] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')

        if (!EvalMatch(l_Matches, l_Entry->AreaLogic))
            return std::pair<bool, std::string>(false, "Failed on AreaID");
    }
    #pragma endregion AreaLogic, AreaID

    #pragma region ModifierTree
    if (IsPlayer() && l_Entry->ModifierTreeID)
    {
        if (!ToPlayer()->HasModifierTreeSatisfied(l_Entry->ModifierTreeID))
            return { false, "Failed at ModifierTree"};
    }
    #pragma endregion ModifierTree

    #pragma region CurrencyLogic, CurrencyID, CurrencyCount
    if (IsPlayer() && (l_Entry->CurrencyID[0] || l_Entry->CurrencyID[1] || l_Entry->CurrencyID[2] || l_Entry->CurrencyID[3]))
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrencyID[0] != 0) l_Matches[0] = ToPlayer()->HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[0] ? 1 : l_Entry->CurrencyCount[0]));
        if (l_Entry->CurrencyID[1] != 0) l_Matches[1] = ToPlayer()->HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[1] ? 1 : l_Entry->CurrencyCount[1]));
        if (l_Entry->CurrencyID[2] != 0) l_Matches[2] = ToPlayer()->HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[2] ? 1 : l_Entry->CurrencyCount[2]));
        if (l_Entry->CurrencyID[3] != 0) l_Matches[3] = ToPlayer()->HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[3] ? 1 : l_Entry->CurrencyCount[3]));

        if (!EvalMatch(l_Matches, l_Entry->CurrencyLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrencyID");
    }
    #pragma endregion CurrencyLogic, CurrencyID, CurrencyCount

    #pragma region QuestKillID, QuestKillLogic, QuestKillMonster
    if (IsPlayer() && l_Entry->QuestKillID != 0)
    {
        if (!ToPlayer()->HasQuest(l_Entry->QuestKillID))
            return std::pair<bool, std::string>(false, "Failed on QuestKillID => db2(" + std::to_string(l_Entry->QuestKillID) + ") you didn't have quest(" + std::to_string(l_Entry->QuestKillID) + ")");

        auto GetNpcObjectiveID = [](uint32 p_QuestID, uint32 p_NPCID) -> uint32
        {
            Quest const* l_Quest = sObjectMgr->GetQuestTemplate(p_QuestID);

            if (!l_Quest)
                return 0;

            for (auto const& l_Obective : l_Quest->QuestObjectives)
            {
                if (l_Obective.Type != QUEST_OBJECTIVE_TYPE_NPC)
                    continue;

                if (l_Obective.ObjectID == p_NPCID) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                    return l_Obective.ID;
            }

            return 0;
        };

        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->QuestKillMonster[0] != 0) l_Matches[0] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[0]) && ToPlayer()->GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[0]));
        if (l_Entry->QuestKillMonster[1] != 0) l_Matches[1] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[1]) && ToPlayer()->GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[1]));
        if (l_Entry->QuestKillMonster[2] != 0) l_Matches[2] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[2]) && ToPlayer()->GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[2]));
        if (l_Entry->QuestKillMonster[3] != 0) l_Matches[3] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[3]) && ToPlayer()->GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[3]));

        if (!EvalMatch(l_Matches, l_Entry->QuestKillLogic))
            return std::pair<bool, std::string>(false, "Failed on QuestKillMonster");
    }
    #pragma endregion QuestKillID, QuestKillLogic, QuestKillMonster

    /// @TODO : MinExpansionLevel
    /// @TODO : MaxExpansionLevel
    /// @TODO : MinExpansionTier
    /// @TODO : MaxExpansionTier
    /// @OBSOLETE : MinGuildLevel
    /// @OBSOLETE : MaxGuildLevel
    /// @TODO : PhaseUseFlags
    /// @TODO : PhaseID
    /// @TODO : PhaseGroupID

    #pragma region MinAvgItemLevel, MaxAvgItemLevel
    if (IsPlayer() && l_Entry->MinAvgItemLevel != 0 && GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel) < (uint32)l_Entry->MinAvgItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MinAvgItemLevel => db2(" + std::to_string(l_Entry->MinAvgItemLevel) + ") you(" + std::to_string(GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel)) + ")");
    if (IsPlayer() && l_Entry->MaxAvgItemLevel != 0 && GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel) > (uint32)l_Entry->MaxAvgItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxAvgItemLevel => db2(" + std::to_string(l_Entry->MaxAvgItemLevel) + ") you(" + std::to_string(GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel)) + ")");
    #pragma endregion MinAvgItemLevel, MaxAvgItemLevel

    #pragma region MinAvgEquippedItemLevel, MaxAvgItemLevel
    if (IsPlayer() && l_Entry->MinAvgEquippedItemLevel != 0 && ToPlayer()->GetAverageItemLevelEquipped() < (uint32)l_Entry->MinAvgEquippedItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MinAvgEquippedItemLevel => db2(" + std::to_string(l_Entry->MinAvgEquippedItemLevel) + ") you(" + std::to_string(ToPlayer()->GetAverageItemLevelEquipped()) + ")");
    if (IsPlayer() && l_Entry->MaxAvgEquippedItemLevel != 0 && ToPlayer()->GetAverageItemLevelEquipped() > (uint32)l_Entry->MaxAvgEquippedItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxAvgEquippedItemLevel => db2(" + std::to_string(l_Entry->MaxAvgEquippedItemLevel) + ") you(" + std::to_string(ToPlayer()->GetAverageItemLevelEquipped()) + ")");
    #pragma endregion MinAvgEquippedItemLevel, MaxAvgItemLevel

    #pragma region ChrSpecializationIndex, ChrSpecializationRole
    if (IsPlayer() && l_Entry->ChrSpecializationIndex != -1)
    {
        if (ChrSpecializationsEntry const* l_Spec = sChrSpecializationsStore.LookupEntry(ToPlayer()->GetActiveSpecializationID()))
        {
            if (l_Spec->OrderIndex != l_Entry->ChrSpecializationIndex)
                return std::pair<bool, std::string>(false, "Failed on ChrSpecializationIndex => db2(" + std::to_string(l_Entry->ChrSpecializationIndex) + ") you(" + std::to_string(l_Spec->OrderIndex) + ")");
        }
    }

    if (IsPlayer() && l_Entry->ChrSpecializationRole != -1)
    {
        if (ChrSpecializationsEntry const* l_Spec = sChrSpecializationsStore.LookupEntry(ToPlayer()->GetActiveSpecializationID()))
        {
            if (l_Spec->Role != l_Entry->ChrSpecializationRole)
                return std::pair<bool, std::string>(false, "Failed on ChrSpecializationRole => db2(" + std::to_string(l_Entry->ChrSpecializationRole) + ") you(" + std::to_string(l_Spec->Role) + ")");
        }
    }
    #pragma endregion ChrSpecializationIndex, ChrSpecializationRole

    /// @TODO : PowerType
    /// @TODO : PowerTypeComp
    /// @TODO : PowerTypeValue

    return std::pair<bool, std::string>(true, "");
}

void Unit::ScheduleUpdateAuraDuration(float p_OldModTimeRate, float p_NewModTimeRate, bool delayed/* = true*/)
{
    auto l_Func = [this, p_OldModTimeRate, p_NewModTimeRate]() -> void
    {
        float l_TimeRateModifier = p_NewModTimeRate / p_OldModTimeRate;

        for (std::pair<uint32, AuraApplication*> l_AuraApp : m_appliedAuras)
        {
            Aura* l_Aura = l_AuraApp.second->GetBase();
            if (!l_Aura)
                continue;

            if (l_Aura->GetDuration() != -1)
                l_Aura->SetDuration(static_cast<float>(l_Aura->GetDuration()) * l_TimeRateModifier);

            for (uint32 l_EffectIndex = 0; l_EffectIndex < l_Aura->GetEffectCount(); ++l_EffectIndex)
            {
                AuraEffect* l_AuraEffect = l_Aura->GetEffect(l_EffectIndex);
                if (!l_AuraEffect || !l_AuraEffect->IsPeriodic())
                    continue;

                uint32 l_OldAmplitude = l_AuraEffect->GetAmplitude();
                l_AuraEffect->CalculatePeriodic(l_Aura->GetCaster(), false, false, true);
                uint32 l_NewAmplitude = l_AuraEffect->GetAmplitude();

                float l_AmplitudeVariation = static_cast<float>(l_NewAmplitude) / static_cast<float>(l_OldAmplitude);
                l_AuraEffect->SetPeriodicTimer(static_cast<float>(l_AuraEffect->GetPeriodicTimer()) * l_AmplitudeVariation);
            }
        }
    };

    if (delayed)
        AddDelayedEvent(l_Func, 0);
    else
        l_Func();
}

void Unit::AttackerStateUpdateWithSchoolMask(Unit* p_Victim, WeaponAttackType p_AttackType, bool p_Extra, SpellSchoolMask p_SchoolMask)
{
    if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
        return;

    if (!p_Victim->isAlive())
        return;

    if (!IsAIEnabled || !GetMap()->Instanceable())
        if ((p_AttackType == WeaponAttackType::BaseAttack || p_AttackType == WeaponAttackType::OffAttack) && !IsWithinLOSInMap(p_Victim))
            return;

    CombatStart(p_Victim);
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);

    if (p_AttackType != WeaponAttackType::BaseAttack && p_AttackType != WeaponAttackType::OffAttack)
        return;                                             // ignore ranged case

     // melee attack spell casted at main hand attack only - no normal melee dmg dealt
    if (p_AttackType == WeaponAttackType::BaseAttack && m_currentSpells[CURRENT_MELEE_SPELL] && !p_Extra)
        m_currentSpells[CURRENT_MELEE_SPELL]->cast();
    else
    {
        // attack can be redirected to another target
        p_Victim = GetMeleeHitRedirectTarget(p_Victim);

        bool l_CheatGod = p_Victim->IsPlayer() && p_Victim->ToPlayer()->GetCommandStatus(PlayerCommandStates::CHEAT_GOD);

        CalcDamageInfo l_DamageInfo(this, p_Victim, 0, p_SchoolMask, DIRECT_DAMAGE, p_AttackType);
        CalculateMeleeDamage(&l_DamageInfo);
        // Send log damage message to client
        DealDamageMods(l_DamageInfo);

        if (!l_CheatGod)
            DealMeleeDamage(&l_DamageInfo, true);

        SendAttackStateUpdate(&l_DamageInfo);

        //TriggerAurasProcOnEvent(damageInfo);
        ProcDamageAndSpell(l_DamageInfo.GetTarget(), l_DamageInfo.procAttacker, l_DamageInfo.procVictim, l_DamageInfo.procEx, l_DamageInfo);

        if (l_CheatGod)
            DealMeleeDamage(&l_DamageInfo, true);

        if (ToCreature() && ToCreature()->IsAIEnabled)
            ToCreature()->AI()->OnMeleeAttackDone(p_Victim, &l_DamageInfo, p_AttackType);
    }
}

void Unit::PlayCosmeticEvent(uint32 p_EventId)
{
    InstanceScript* l_InstanceScript = GetInstanceScript();
    if (!l_InstanceScript)
        return;

    uint64 l_ThisGuid = GetGUID();
    l_InstanceScript->PlayCosmeticEvent(p_EventId, l_ThisGuid);
}

void Unit::SendAbsorbLog(Unit* p_Victim, uint32 p_InterruptedSpellID, uint32 p_SpellID, Unit* p_Caster, uint32 p_AbsorbDamage)
{
    uint64 l_CasterGUID = p_Caster ? p_Caster->GetGUID() : 0;
    uint64 l_VictimGUID = p_Victim ? p_Victim->GetGUID() : 0;

    WorldPacket l_Data(SMSG_SPELL_ABSORB_LOG, 60);
    l_Data.appendPackGUID(l_VictimGUID);
    l_Data.appendPackGUID(GetGUID()); ///< TargetGUID
    l_Data << uint32(p_InterruptedSpellID);
    l_Data << uint32(p_SpellID);
    l_Data.appendPackGUID(l_CasterGUID);
    l_Data << uint32(p_AbsorbDamage);
    l_Data.WriteBit(false); ///< HasLogData
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);

    if (p_Caster)
        if (Player* l_Player = p_Caster->ToPlayer())
            if (Battleground* l_Bg = l_Player->GetBattleground())
                l_Bg->UpdatePlayerScore(l_Player, NULL, SCORE_HEALING_DONE, p_AbsorbDamage);
}

void Unit::RemoveAllDoTAuras()
{
    RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE);
    RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);
    RemoveAurasByType(SPELL_AURA_PERIODIC_LEECH);
}

bool Unit::IsAnySummon() const
{
    if (IsPlayer())
        return false;

    if (auto cre = ToCreature())
        if (cre->IsDungeonBoss() && !cre->HasUnitTypeMask(UNIT_MASK_HUNTER_PET))
            return false;

    return (m_unitTypeMask & (UNIT_MASK_GUARDIAN | UNIT_MASK_PET | UNIT_MASK_HUNTER_PET | UNIT_MASK_TOTEM)) != 0;
}

void Unit::RemoveEntryInUnitsWithMyAurasList(uint64 const guid, uint32 auraId)
{
    auto itr = m_unitsWithMyAuras.find(guid);
    if (itr == m_unitsWithMyAuras.end())
        return;

    uint32 i = 0;

    for (auto& j : itr->second)
    {
        if (j == auraId)
        {
            std::lock_guard<std::recursive_mutex> guard(units_with_my_auras_lock);
            m_unitsWithMyAuras[guid].erase(m_unitsWithMyAuras[guid].begin() + i);

            if (m_unitsWithMyAuras[guid].empty())
                m_unitsWithMyAuras.erase(guid);

            return;
        }
        i++;
    }
}