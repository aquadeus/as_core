////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include <regex>
#include "AnticheatMgr.h"
#include "Common.h"
#include "Language.h"
#include "DatabaseEnv.h"
#include "Log.h"
#include "Opcodes.h"
#include "SpellMgr.h"
#include "World.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "UpdateMask.h"
#include "Player.h"
#include "Vehicle.h"
#include "SkillDiscovery.h"
#include "QuestDef.h"
#include "GossipDef.h"
#include "UpdateData.h"
#include "Channel.h"
#include "ChannelMgr.h"
#include "MapManager.h"
#include "MapInstanced.h"
#include "InstanceSaveMgr.h"
#include "GridNotifiers.h"
#include "GridNotifiersImpl.h"
#include "CellImpl.h"
#include "ObjectMgr.h"
#include "GuildMgr.h"
#include "GroupMgr.h"
#include "ObjectAccessor.h"
#include "CreatureAI.h"
#include "Formulas.h"
#include "Group.h"
#include "Pet.h"
#include "Util.h"
#include "Transport.h"
#include "Weather.h"
#include "Battleground.h"
#include "BattlegroundAV.h"
#include "BattlegroundMgr.hpp"
#include "OutdoorPvP.h"
#include "OutdoorPvPMgr.h"
#include "Arena.h"
#include "Chat.h"
#include "Spell.h"
#include "SocialMgr.h"
#include "GameEventMgr.h"
#include "AchievementMgr.h"
#include "SpellAuras.h"
#include "SpellAuraEffects.h"
#include "ConditionMgr.h"
#include "DisableMgr.h"
#include "WeatherMgr.h"
#include "LFGMgr.h"
#include "InstanceScript.h"
#include "AccountMgr.h"
#include "DB2Stores.h"
#include "Battlefield.h"
#include "BattlefieldMgr.h"
#include "UpdateFieldFlags.h"
#include "PetBattle.h"
#include "MSCallback.hpp"
#include "Vignette.hpp"
#include "WowTime.hpp"
#include "GameTables.h"
#include "ItemPrototype.h"
#include "CollectionMgr.hpp"
#include "HelperDefines.h"
#include "WorldQuestMgr.h"
#include "ScenarioMgr.h"
#include "ChallengeMgr.h"
#include "POIMgr.hpp"
#include "QuestPackets.h"
#include "RecruitAFriendMgr.hpp"
#include "GarbageCollector.h"
#include "SmartScript.h"

# include "GarrisonMgr.hpp"
# include "../../../scripts/Draenor/Garrison/GarrisonScriptData.hpp"
# include "InterRealmOpcodes.h"

#include "WordFilterMgr.h"
#ifndef CROSS
# include "CharacterDatabaseCleaner.h"

# include "TicketMgr.h"
# include "Guild.h"

#else
# include "InterRealmMgr.h"
#endif

#define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)

enum SkillFieldOffset
{
    SKILL_ID_OFFSET = 0,
    SKILL_STEP_OFFSET           = 64,
    SKILL_RANK_OFFSET           = SKILL_STEP_OFFSET + 64,
    SUBSKILL_START_RANK_OFFSET  = SKILL_RANK_OFFSET + 64,
    SKILL_MAX_RANK_OFFSET       = SUBSKILL_START_RANK_OFFSET + 64,
    SKILL_TEMP_BONUS_OFFSET     = SKILL_MAX_RANK_OFFSET + 64,
    SKILL_PERM_BONUS_OFFSET     = SKILL_TEMP_BONUS_OFFSET + 64
};

// corpse reclaim times
#define DEATH_EXPIRE_STEP (5*MINUTE)
#define MAX_DEATH_COUNT 3

static uint32 gCopseReclaimDelay[MAX_DEATH_COUNT] = { 30, 60, 120 };

bool PetQueryHolder::Initialize()
{
    SetSize(MAX_PET_LOGIN_QUERY);

    bool res = true;

#ifdef CROSS
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(m_RealmId)->GetDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif
    PreparedStatement* stmt = NULL;

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_AURA);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADAURA, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_AURA_EFFECT);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADAURAEFFECT, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_SPELL);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADSPELL, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_SPELL_COOLDOWN);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADSPELLCOOLDOWN, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_DECLINED_NAME);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_DECLINED_NAME, stmt);

    return res;
}

PreparedStatement* PetQueryHolder::GenerateFirstLoadStatement(uint32 p_PetEntry, uint32 p_PetNumber, uint32 p_OwnerID, bool p_CurrentPet, PetSlot p_SlotID, uint32 p_RealmID)
{
#ifdef CROSS
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(p_RealmID)->GetDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    PreparedStatement* l_Statement = nullptr;

    if (p_PetNumber)
    {
        // Known petnumber entry
        //        0     1      2       3       4     5       6        7     8       9        10        11       12       13           14          15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_PetNumber);
    }
    else if (p_CurrentPet && p_SlotID != PET_SLOT_UNK_SLOT)
    {
        // Current pet (slot 0)
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_SlotID);
    }
    else if (p_PetEntry)
    {
        // Known petentry entry (unique for summoned pet, but non unique for hunter pet (only from current or not stabled pets)
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT_2);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_PetEntry);
        l_Statement->setUInt32(2, PET_SLOT_HUNTER_FIRST);
        l_Statement->setUInt32(3, PET_SLOT_HUNTER_LAST);
        l_Statement->setUInt32(4, PET_SLOT_STABLE_LAST);
    }
    else
    {
        // Any current or other non-stabled pet (for hunter "call pet")
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_SLOT);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, PET_SLOT_HUNTER_FIRST);
        l_Statement->setUInt32(2, PET_SLOT_HUNTER_LAST);
        l_Statement->setUInt32(3, p_SlotID);
    }

    return l_Statement;
}

#ifdef CROSS
# define RealmDatabase (*GetRealmDatabase())
#else
# define RealmDatabase CharacterDatabase
#endif

// == Player ====================================================
// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
Player::Player(WorldSession* session) : Unit(true), m_reputationMgr(this), phaseMgr(this), m_archaeologyMgr(this), m_VignetteMgr(this)
{
#ifdef _MSC_VER
#pragma warning(default:4355)
#endif

    m_WorldQuestMgr = new MS::WorldQuest::Manager(this);
    m_Garrison = new MS::Garrison::Manager(this);
    m_GarrisonUpdateTimer.SetInterval(2 * IN_MILLISECONDS);

    m_VoidStorageLoaded = false;

    CurrentPlayedMovie = 0;

    m_speakTime = 0;
    m_speakCount = 0;

    m_bgRoles = 0;

    m_lastPlayedEmote = 0;

    m_pmChatTime = 0;
    m_pmChatCount = 0;

    m_petSlotUsed = 0;
    m_currentPetSlot = PET_SLOT_DELETED;

    m_objectType |= TYPEMASK_PLAYER;
    m_objectTypeId = TYPEID_PLAYER;

    m_valuesCount = PLAYER_END;
    _dynamicValuesCount = PLAYER_DYNAMIC_END;

    m_session = session;

    m_divider = 0;

    m_ExtraFlags = 0;

    m_tokenCounter = 0;

    m_spellModTakingSpell = NULL;
    //m_pad = 0;

    // players always accept
    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        SetAcceptWhispers(true);

    m_curSelection = 0;
    m_lootGuid = 0;

    m_lootSpecId = 0;

    m_RegenPowerTimer = 0;
    m_regenTimerCount = 0;
    m_weaponChangeTimer = 0;

    m_zoneUpdateId = 0;
    m_zoneUpdateTimer = 0;

    m_areaUpdateId = 0;
    m_IsOutdoors = false;

    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    _resurrectionData = NULL;

    memset(m_items, 0, sizeof(Item*) * PLAYER_SLOTS_COUNT);

    m_social = NULL;

    // group is initialized in the reference constructor
    SetGroupInvite(0);
    m_groupUpdateMask = 0;
    m_bPassOnGroupLoot = false;

    m_Duel = NULL;

    m_GuildIdInvited = 0;

    m_atLoginFlags = AT_LOGIN_NONE;

    mSemaphoreTeleport_Near = false;
    mSemaphoreTeleport_Far = false;
    mTeleportFlagForAnticheat = true;

    m_DelayedOperations = 0;
    m_bCanDelayTeleport = false;
    m_bHasDelayedTeleport = false;
    m_isMoltenCored = false;
    m_teleport_options = 0;

    m_trade = NULL;
    m_ClientStateIndex = 0;

    m_cinematic = 0;

    PlayerTalkClass = new PlayerMenu(GetSession());
    m_currentBuybackSlot = BUYBACK_SLOT_START;

    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    m_EndSalesTimestamp = 0;

    // Init rune flags
    for (uint8 i = 0; i < MAX_RUNES; ++i)
        SetRuneTimer(i, 0xFFFFFFFF);

    for (uint8 i=0; i < MAX_TIMERS; i++)
        m_MirrorTimer[i] = DISABLED_MIRROR_TIMER;

    m_MirrorTimerFlags = UNDERWATER_NONE;
    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
    m_isInWater = false;
    m_drunkTimer = 0;
    m_restTime = 0;
    m_deathTimer = 0;
    m_deathExpireTime = 0;

    m_swingErrorMsg = 0;

    for (uint8 j = 0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; ++j)
    {
        m_bgBattlegroundQueueID[j].BgType = MS::Battlegrounds::BattlegroundType::None;
        m_bgBattlegroundQueueID[j].invitedToInstance = 0;
    }

    m_logintime = time(NULL);
    m_Last_tick = m_logintime;
    m_WeaponProficiency = 0;
    m_ArmorProficiency = 0;
    m_canParry = false;
    m_canBlock = false;
    m_canDualWield = false;
    m_canTitanGrip = false;

    m_temporaryUnsummonedPetNumber = 0;
    //cache for UNIT_FIELD_CREATED_BY_SPELL to allow
    //returning reagents for temporarily removed pets
    //when dying/logging out
    m_oldpetspell = 0;
    m_lastpetnumber = 0;

    ////////////////////Rest System/////////////////////
    _restTime = 0;
    inn_triggerId = 0;
    m_rest_bonus = 0;
    _restFlagMask = 0;
    ////////////////////Rest System/////////////////////

    m_mailsUpdated = false;
    unReadMails = 0;
    m_nextMailDelivereTime = 0;

    m_itemUpdateQueueBlocked = false;

    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
        m_forced_speed_changes[i] = 0;

    m_stableSlots = 0;

    /////////////////// Instance System /////////////////////

    m_HomebindTimer = 0;
    m_InstanceValid = true;
    m_dungeonDifficulty = DifficultyNormal;
    m_raidDifficulty = DifficultyRaidNormal;
    m_LegacyRaidDifficulty = Difficulty10N;
    m_PrevMapDifficulty = DifficultyRaidNormal;

    m_LastPotions.clear();

    _talentMgr = new PlayerTalentInfo();

    m_glyphsChanged = false;

    for (uint8 i = 0; i < BASEMOD_END; ++i)
    {
        m_auraBaseMod[i][FLAT_MOD] = 0.0f;
        m_auraBaseMod[i][PCT_MOD] = 1.0f;
    }

    for (uint8 i = 0; i < MAX_COMBAT_RATING; i++)
        m_baseRatingValue[i] = 0;

    m_baseSpellPower = 0;
    m_baseManaRegen = 0;
    m_baseHealthRegen = 0;
    m_spellPenetrationItemMod = 0;

    // Honor System
    m_lastHonorUpdateTime = time(NULL);

    // Player summoning
    m_summon_expire = 0;
    m_summon_mapid = 0;
    m_summon_x = 0.0f;
    m_summon_y = 0.0f;
    m_summon_z = 0.0f;

    m_mover = this;
    m_movedPlayer = this;
    m_seer = this;

    m_contestedPvPTimer = 0;

    m_declinedname = NULL;

    m_isActive = true;

    m_runes = nullptr;

    m_lastFallTime = 0;
    m_lastFallZ = 0;

    m_grantableLevels = 0;

    m_ControlledByPlayer = true;

#ifndef CROSS
    sWorld->IncreasePlayerCount();
#endif

    m_ChampioningFaction = 0;

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        m_powerFraction[i] = 0;

    isDebugAreaTriggers = false;

    m_IsDebugQuestLogs = false;

    m_WeeklyQuestChanged = false;

    m_MonthlyQuestChanged = false;

    m_SeasonalQuestChanged = false;

    SetPendingBind(0, 0);

    _activeCheats = CHEAT_NONE;
    _maxPersonalArenaRate = 0;

    _lastTargetedGO = 0;

    m_PersonnalXpRate = sWorld->getRate(RATE_XP_KILL);

    m_knockBackTimer = 0;

    m_CinematicSequence         = NULL;
    m_InCinematic               = false;
    m_CinematicClientStartTime  = 0;

    m_BattlePetSummon = 0;

    m_ignoreMovementCount = 0;

    m_groupUpdateDelay = 5000;

    m_emote = 0;

    memset(_voidStorageItems, 0, VOID_STORAGE_MAX_SLOT * sizeof(VoidStorageItem*));

    for (uint8 l_Bracket = 0; l_Bracket < (uint8)BattlegroundBracketType::Max; ++l_Bracket)
    {
        m_ArenaPersonalRating[l_Bracket]   = sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING);
        m_ArenaMatchMakerRating[l_Bracket] = sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING);
        m_BestRatingOfWeek[l_Bracket]      = 0;
        m_BestRatingOfPrevWeek[l_Bracket]  = 0;
        m_BestRatingOfSeason[l_Bracket]    = 0;
        m_DayWins[l_Bracket]               = 0;
        m_DayGames[l_Bracket]              = 0;
        m_WeekWins[l_Bracket]              = 0;
        m_PrevWeekWins[l_Bracket]          = 0;
        m_PrevWeekGames[l_Bracket]         = 0;
        m_SeasonWins[l_Bracket]            = 0;
        m_WeekGames[l_Bracket]             = 0;
        m_SeasonGames[l_Bracket]           = 0;
    }

    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        prohibited[i] = prohibited_struct();
    }

    m_initializeCallback = false;

    m_needSummonPetAfterStopFlying = false;

    m_PvPCombatTimer = 0;
    m_pvpCombat = false;

    m_LastSummonedBattlePet = 0;

    m_BattlePets = new std::vector<std::shared_ptr<BattlePet>>();

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    ///////////////////////////////////////////////////////////

    m_WargameRequest = nullptr;
    m_WargameInvited = false;

#ifdef CROSS
    m_NeedRemove  = false;
    m_PlayOnCross = false;
#endif

    m_PreviousLocation = WorldLocation();

    for (uint8 l_I = 0; l_I < StoreCallback::MaxDelivery; l_I++)
        m_StoreDeliveryProcessed[l_I] = false;

    m_StoreDeliverySave = false;

#ifndef CROSS
    m_InterRealmPlayerState = InterRealmPlayerState::None;
    m_InterRealmPlayerStateLastChange = 0;
    m_irZoneId = 0;
    m_irAreaId = 0;
    m_irMapId  = 0;
#endif

    m_BeaconOfFaithTargetGUID = 0;
    m_BeaconOfLightTargetGUID = 0;

    m_MasteryCache = 0.0f;

    m_achievementMgr = new PlayerAchievementMgr(this);
    m_LastActiveSummon = 0;

    m_EndSalesTimestamp = 0;

    m_BackPackAutoSortDisabled = false;
    m_LastSpecialMovementTime = 0;

    m_IsInMapSwitch = false;

    m_IsInBattleground = false;
    m_IsInBattlegroundProcess = false;
    m_IsInBattlegroundLeaving = false;
    m_IsInDuel = false;

    m_AppearZoneInstanceId = 0;

    m_LegendaryPoints = 0;
    m_LegendaryCount  = 0;

    m_HighestHitReceived     = 0;
    m_HighestHitDealt        = 0;
    m_TotalDamageReceived    = 0;
    m_HighestHealCast        = 0;
    m_HighestHealingReceived = 0;
    m_TotalHealingReceived   = 0;
    m_CriteriaUpdateTimer    = 60000;

    m_IsInLootboxProcess        = false;
    m_IsInLoyaltyLootBoxProcess = false;
    m_CurrentLootboxId = 0;

    m_SkipUpdateCounter = 0;
    m_DelayedUpdateTime = 0;

    m_QueuedSpell = nullptr;

    m_NeedForcedVisibilityUpdate = false;

    m_Group = nullptr;
    m_OriginalGroup = nullptr;
    m_SubGroup = 0;
    m_OriginalSubGroup = 0;

    m_CelestialBodyID = 0;

    m_OldMap = nullptr;

    m_TaskInProgress = true;
    m_RegisteredTaskCounters[0] = 0;
    m_RegisteredTaskCounters[1] = 0;

    m_QueryCallbackMgr = std::make_shared<QueryCallbackManager>();

    m_IsInDestructor = 0;

    m_challengeEntry = nullptr;

    m_PlayerCommandCooldown = 0;
}

void Player::Clear()
{
    sLFGListMgr->RemovePlayerDueToLogout(GetGUIDLow());
    sSpellLogMgr->RemoveListener(this);

    getHostileRefManager().clearReferences();
    getFollowerRefManager().clearReferences();

    if (Map* l_Map = m_OldMap)
    {
        uint64 l_GUID = GetGUID();
        l_Map->AddTask([l_Map, l_GUID]() -> void
        {
            l_Map->RemoveLeavingPlayer(l_GUID);
        });
    }

 #ifndef CROSS
    sWorld->DecreasePlayerCount();
# endif
}

Player::~Player()
{
#ifndef CROSS
    if (m_Garrison)
        delete m_Garrison;
#endif

    if (m_WorldQuestMgr)
        delete m_WorldQuestMgr;

    if (m_WargameRequest)
        delete m_WargameRequest;

    if (m_achievementMgr)
        delete m_achievementMgr;

    // it must be unloaded already in PlayerLogout and accessed only for loggined player
    //m_social = NULL;

    // temp check
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
    {
        for (uint8 slot = 0; slot < PLAYER_SLOTS_COUNT; slot++)
        {
            if (m_items[slot] == NULL)
                continue;

            if (m_items[i] == m_items[slot] && slot != i)
            {
                sLog->outAshran("Player[%u] have same item pointer in two slot ! (slot: %u, copy slot: %u)", GetGUIDLow(), i, slot);
                m_items[i] = NULL;
            }
        }
    }

    // Note: buy back item already deleted from DB when player was saved
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        delete m_items[i];

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
        delete itr->second;

    delete _talentMgr;

    //all mailed items should be deleted, also all mail should be deallocated
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        delete *itr;

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated

    delete PlayerTalkClass;

    for (size_t x = 0; x < ItemSetEff.size(); x++)
        delete ItemSetEff[x];

    delete m_declinedname;
    delete m_runes;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        delete _voidStorageItems[i];

    ClearResurrectRequestData();

    if (m_session && m_session->IsDummySession())
        delete m_session;

    if (m_BattlePets)
        delete m_BattlePets;

    for (auto l_Artifact : m_ArtifactMgrHolder)
        delete l_Artifact.second;
}

void Player::CleanupsBeforeDelete(bool finalCleanup)
{
    TradeCancel(false);
    DuelComplete(DUEL_INTERRUPTED);

    Unit::CleanupsBeforeDelete(finalCleanup);

    if (m_transport)
        m_transport->RemovePassenger(this);

    // clean up player-instance binds, may unload some instance saves
    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        m_boundInstances[i].safe_foreach(true, [this](BoundInstancesMap::const_iterator* p_Itr) -> void
        {
            (*p_Itr)->second->save->RemovePlayer(this);
        });
    }
}

bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
{
    // @FIXME: outfitId not used in player creating
    // TODO: need more checks against packet modifications
    // should check that skin, face, hair* are valid via DB2 per race/class
    // also do it in Player::BuildEnumData, Player::LoadFromDB

    Object::_Create(guidlow, 0, HIGHGUID_PLAYER);

    m_name = createInfo->Name;

    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
            GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
        return false;
    }

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        m_items[i] = nullptr;

    ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
    if (!cEntry)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DB2-files?)",
            GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
        return false;
    }

    /// @TODO ValidateAppearance

    uint8 powertype = GetDisplayPowerForCurrentState();

    SetUInt32Value(EUnitFields::UNIT_FIELD_SCALE_DURATION, 500);
    SetObjectScale(1.0f);

    setFactionForRace(createInfo->Race);

    if (!IsValidGender(createInfo->Gender))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%hhu) - refusing to do so",
            GetSession()->GetAccountId(), m_name.c_str(), createInfo->Gender);
        return false;
    }

    static const uint32 g_CreateCharacterCustomZone = 20000;

    CharacterTemplate const* l_Template = sObjectMgr->GetCharacterTemplate(createInfo->TemplateId);
    if (l_Template && (GetTeam() == HORDE ? l_Template->m_HordeMapID != -1 : l_Template->m_AlianceMapID != -1))
    {
        if (GetTeam() == HORDE)
        {
            uint32 l_ZoneId = sMapMgr->GetZoneId(l_Template->m_HordeMapID, l_Template->m_HordePos.GetPositionX(), l_Template->m_HordePos.GetPositionY(), l_Template->m_HordePos.GetPositionZ());
            Relocate(l_Template->m_HordePos);
            SetCurrMap(sMapMgr->CreateMap(l_Template->m_HordeMapID, g_CreateCharacterCustomZone, this));
        }
        else
        {
            uint32 l_ZoneId = sMapMgr->GetZoneId(l_Template->m_AlianceMapID, l_Template->m_AliancePos.GetPositionX(), l_Template->m_AliancePos.GetPositionY(), l_Template->m_AliancePos.GetPositionZ());
            Relocate(l_Template->m_AliancePos);
            SetCurrMap(sMapMgr->CreateMap(l_Template->m_AlianceMapID, g_CreateCharacterCustomZone, this));
        }
    }
    else
    {
        uint32 l_ZoneId = sMapMgr->GetZoneId(info->mapId, info->positionX, info->positionY, info->positionZ);
        Relocate(info->positionX, info->positionY, info->positionZ, info->orientation);
        SetCurrMap(sMapMgr->CreateMap(info->mapId, g_CreateCharacterCustomZone, this));
    }

    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE, createInfo->Race);
    SetOriginalRace(createInfo->Race);
    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_CLASS, createInfo->Class);
    SetGender(createInfo->Gender);
    SetUInt32Value(UNIT_FIELD_DISPLAY_POWER, powertype);
    InitDisplayIds();

    if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_PVP);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    }

    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);            // default for players in 3.0.3

    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, uint32(-1)); // -1 is default value

    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID, createInfo->Skin);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_FACE_ID, createInfo->Face);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_STYLE_ID, createInfo->HairStyle);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID, createInfo->HairColor);
    SavePlayerBytes(GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID));

    SetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_CUSTOM_OPTOTIONS_FACIAL_STYLE, createInfo->FacialHair);
    SetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_CUSTOM_OPTOTIONS_BLINDFOLDS, createInfo->Blindfolds);
    SetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_CUSTOM_OPTOTIONS_TATTOOS, createInfo->Tattoos);
    SetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_CUSTOM_OPTOTIONS_HORN_STYLE, createInfo->HornStyle);

    SetInventorySlotCount(INVENTORY_DEFAULT_SIZE);

    SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, (GetSession()->IsARecruiter() || GetSession()->GetRecruiterId() != 0) ? REST_STATE_RAF_LINKED : REST_STATE_NOT_RAF_LINKED);

    SetByteValue(PLAYER_FIELD_INEBRIATION, PLAYER_BYTES_3_OFFSET_GENDER, createInfo->Gender);
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_4_OFFSET_ARENA_FACTION, 0);               ///< BattlefieldArenaFaction (0 or 1)

    SetGuidValue(OBJECT_FIELD_DATA, 0);
    SetUInt32Value(PLAYER_FIELD_GUILD_RANK_ID, 0);
    SetGuildLevel(0);
    SetUInt32Value(PLAYER_FIELD_GUILD_TIME_STAMP, 0);

    for (int i = 0; i < KNOWN_TITLES_SIZE; ++i)
        SetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i, 0);  // 0=disabled
    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);

    SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);

    ChrRacesEntry const* l_RaceEntry = sChrRacesStore.LookupEntry(createInfo->Race);
    if (!l_RaceEntry)
        return false;

    // set starting level
    int8 l_StartLevel;
    switch (getClass())
    {
        case CLASS_DEATH_KNIGHT:
            l_StartLevel = sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL);
            break;
        case CLASS_DEMON_HUNTER:
            l_StartLevel = sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL) > 98 ? sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL) : 98;
            break;
        default:
            l_StartLevel = std::max(sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL), l_RaceEntry->StartingLevel);
    }

    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
    {
        uint32 gm_level = sWorld->getIntConfig(CONFIG_START_GM_LEVEL);
        if (gm_level > l_StartLevel)
            l_StartLevel = gm_level;
    }

    if (l_Template)
    {
        SetUInt64Value(PLAYER_FIELD_COINAGE, l_Template->m_Money);
        SetUInt32Value(UNIT_FIELD_LEVEL, l_Template->m_Level);
    }
    else
    {
        SetUInt64Value(PLAYER_FIELD_COINAGE, sWorld->getIntConfig(CONFIG_START_PLAYER_MONEY));
        SetUInt32Value(UNIT_FIELD_LEVEL, l_StartLevel);
    }

    InitRunes();

    SetCurrency(CURRENCY_TYPE_HONOR_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_HONOR_POINTS));
    SetCurrency(CURRENCY_TYPE_JUSTICE_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_JUSTICE_POINTS));
    SetCurrency(CURRENCY_TYPE_CONQUEST_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_CONQUEST_POINTS));

    if (sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE))
        SetHonorLevel(MAX_HONOR_LEVEL);

    // start with every map explored
    if (sWorld->getBoolConfig(CONFIG_START_ALL_EXPLORED))
    {
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; i++)
            SetFlag(PLAYER_FIELD_EXPLORED_ZONES + i, 0xFFFFFFFF);
    }

    //Reputations if "StartAllReputation" is enabled, -- TODO: Fix this in a better way
    if (sWorld->getBoolConfig(CONFIG_START_ALL_REP))
    {
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(942), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(935), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(936), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1011), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(970), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(967), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(989), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(932), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(934), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1038), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1077), 42999);

        // Factions depending on team, like cities and some more stuff
        switch (GetTeam())
        {
        case ALLIANCE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(72), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(47), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(69), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(930), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(730), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(978), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(54), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(946), 42999);
            break;
        case HORDE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(76), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(68), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(81), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(911), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(729), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(941), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(530), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(947), 42999);
            break;
        default:
            break;
        }
    }

    // Played time
    m_Last_tick = time(NULL);
    m_Played_time[PLAYED_TIME_TOTAL] = 0;
    m_Played_time[PLAYED_TIME_LEVEL] = 0;

    InitStatsForLevel();
    InitTaxiNodesForLevel();
    InitTalentForLevel();
    InitPrimaryProfessions();                               // to max set before any spell added

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)

    if (getPowerType() == POWER_MANA)
    {
        UpdateMaxPower(POWER_MANA);                         // Update max Mana (for add bonus from intellect)
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    }

    if (getPowerType() == POWER_RUNIC_POWER)
    {
        SetPower(POWER_RUNES, 6);
        SetMaxPower(POWER_RUNES, 6);
        SetPower(POWER_RUNIC_POWER, 0);
        SetMaxPower(POWER_RUNIC_POWER, 1000);
    }

#ifndef CROSS
    // original spells
    LearnDefaultSkills();
    LearnCustomSpells();
#endif

    // original action bar
    for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
    {
        // create new button
        ActionButton& ab = m_actionButtons[action_itr->button];

        // set data
        ab.SetActionAndType(action_itr->action, ActionButtonType(action_itr->type));
    }
#ifndef CROSS
    if (l_Template)
    {
        for (auto& l_ReputationInfo : l_Template->m_TemplateFactions)
        {
            if (FactionEntry const* l_Faction = sFactionStore.LookupEntry(l_ReputationInfo.m_FactionID))
                GetReputationMgr().SetReputation(l_Faction, l_ReputationInfo.m_Reputaion);
        }

        for (auto l_Spell : l_Template->m_SpellIDs)
            learnSpell(l_Spell, false);

        std::list<CharacterTemplate::TemplateItem const*> l_RemainingTemplates;
        for (auto& l_Item : l_Template->m_TemplateItems)
        {
            if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_Item.m_ItemID))
            {
                // Give bags first to the players, then the equipment
                if (l_Proto->Class == ITEM_CLASS_CONTAINER)
                {
                    if (!l_Item.m_Faction || (l_Item.m_Faction == 1 && GetTeam() == ALLIANCE) || (l_Item.m_Faction == 2 && GetTeam() == HORDE))
                        StoreNewItemInBestSlots(l_Item.m_ItemID, l_Item.m_Count);
                    continue;
                }
                else
                    l_RemainingTemplates.push_back(&l_Item);
            }
        }

        for (auto l_Item : l_RemainingTemplates)
        {
            if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_Item->m_ItemID))
            {
                if ((l_Proto->AllowableRace & getRaceMask()) == 0)
                    continue;

                if (!l_Item->m_Faction || (l_Item->m_Faction == 1 && GetTeam() == ALLIANCE) || (l_Item->m_Faction == 2 && GetTeam() == HORDE))
                {
                    ItemContext l_ItemContext = ItemContext::None;
                    switch (l_Item->m_Type)
                    {
                        case 1: ///< Shop PvE premade
                            l_ItemContext = ItemContext::RaidLfr;
                            break;
                        case 3: ///< PTR PvE templates
                            l_ItemContext = ItemContext::RaidNormal;
                            break;
                        default:
                            break;
                    }

                    if (l_ItemContext != ItemContext::None)
                        StoreNewItemInBestSlots(l_Item->m_ItemID, l_Item->m_Count, l_ItemContext);
                }
            }
        }
    }
    else
    {
        // original items
        CharStartOutfitEntry const* oEntry = NULL;
        for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
        {
            if (CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i))
            {
                if (entry->RaceID  == createInfo->Race  &&
                    entry->ClassID == createInfo->Class &&
                    entry->SexID   == createInfo->Gender)
                {
                    oEntry = entry;
                    break;
                }
            }
        }

        if (oEntry)
        {
            for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
            {
                if (oEntry->ItemId[j] <= 0)
                    continue;

                uint32 itemId = oEntry->ItemId[j];

                // just skip, reported in ObjectMgr::LoadItemTemplates
                ItemTemplate const* iProto = sObjectMgr->GetItemTemplate(itemId);
                if (!iProto)
                    continue;

                if (createInfo->OutfitId == 0)
                    continue;

                // BuyCount by default
                uint32 count = iProto->BuyCount;

                // @todo remove this, use data in db2 or player_createinfoitem.
                // special amount for food/drink
                if (iProto->Class == ITEM_CLASS_CONSUMABLE && iProto->SubClass == ITEM_SUBCLASS_FOOD_DRINK)
                {
                    switch (iProto->Spells[0].SpellCategory)
                    {
                        case SPELL_CATEGORY_FOOD:                                // food
                            count = getClass() == CLASS_DEATH_KNIGHT ? 10 : 4;
                            break;
                        case SPELL_CATEGORY_DRINK:                                // drink
                            count = 2;
                            break;
                    }
                    if (iProto->GetMaxStackSize() < count)
                        count = iProto->GetMaxStackSize();
                }

                switch(itemId)
                {
                    // This switch prevents these items (used next for a quest) to be added to a pandaren player at his creation.
                    case 73207:
                    case 73208:
                    case 73209:
                    case 73210:
                    case 73211:
                    case 73212:
                    case 73213:
                    case 76390:
                    case 76391:
                    case 76392:
                    case 76393:
                        continue;
                    default:
                        break;
                }

                StoreNewItemInBestSlots(itemId, count);
            }
        }
    }
#endif
#ifndef CROSS
    for (PlayerCreateInfoItems::const_iterator item_id_itr = info->item.begin(); item_id_itr != info->item.end(); ++item_id_itr)
        StoreNewItemInBestSlots(item_id_itr->item_id, item_id_itr->item_amount);
#endif
#ifndef CROSS
    // bags and main-hand weapon must equipped at this moment
    // now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
    // or ammo not equipped in special bag
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            uint16 eDest;
            // equip offhand weapon/shield if it attempt equipped before main-hand weapon
            InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false);
            if (msg == EQUIP_ERR_OK)
            {
                RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                EquipItem(eDest, pItem, true);
            }
            // move other items to more appropriate slots
            else
            {
                ItemPosCountVec sDest;
                msg = CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                    pItem = StoreItem(sDest, pItem, true); ///< pItem is never read 01/18/16
                }
            }
        }
    }
    // all item positions resolved
#endif
    if (ChrSpecializationsEntry const* l_DefaultSpec = GetDefaultChrSpecializationForClass(getClass()))
    {
        SetActiveTalentGroup(l_DefaultSpec->OrderIndex);
        SetPrimarySpecialization(l_DefaultSpec->ID);
    }

    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, g_RealmID);

    for (uint8 i = 0; i < (uint8)BattlegroundBracketType::Max; ++i)
    {
        SetArenaPersonalRating(i, sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING));
        SetArenaMatchMakerRating(i, sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING));
    }
#ifndef CROSS
    // Pandaren's start quest
    if (createInfo->Race == RACE_PANDAREN_NEUTRAL)
    {
        Quest const* quest = NULL;
        switch (createInfo->Class)
        {
            case CLASS_WARRIOR: quest = sObjectMgr->GetQuestTemplate(30045); break;
            case CLASS_SHAMAN: quest = sObjectMgr->GetQuestTemplate(30044); break;
            case CLASS_ROGUE: quest = sObjectMgr->GetQuestTemplate(30043); break;
            case CLASS_PRIEST: quest = sObjectMgr->GetQuestTemplate(30042); break;
            case CLASS_HUNTER: quest = sObjectMgr->GetQuestTemplate(30041); break;
            case CLASS_MAGE: quest = sObjectMgr->GetQuestTemplate(30040); break;
            case CLASS_MONK: quest = sObjectMgr->GetQuestTemplate(30039); break;
            default: break;
        }

        if (quest)
        {
            this->AddQuest(quest, NULL);
            if (CanCompleteQuest(quest->GetQuestId()))
                CompleteQuest(quest->GetQuestId());
        }
    }
#endif
#ifndef CROSS
    if (WorldSession* l_Session = GetSession())
        l_Session->OnGMTicketGetTicketEvent();
#endif

    UpdateStats(GetStatByAuraGroup(UNIT_MOD_STAT_STAMINA));
    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)
    SetFullHealth();
    return true;
}

bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount, ItemContext p_ItemContext)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Creating initial item, itemId = %u, count = %u", titem_id, titem_amount);

    // attempt equip by one
    while (titem_amount > 0)
    {
        uint16 eDest;
        InventoryResult msg = CanEquipNewItem(NULL_SLOT, eDest, titem_id, false);
        if (msg != EQUIP_ERR_OK)
            break;

        Item* l_Item = EquipNewItem(eDest, titem_id, true);

        if (l_Item && p_ItemContext != ItemContext::None)
        {
            std::vector<uint32> l_Bonus;
            Item::GenerateItemBonus(titem_id, p_ItemContext, l_Bonus, false, this);
            l_Item->AddItemBonuses(l_Bonus);
        }

        AutoUnequipOffhandIfNeed();
        --titem_amount;
    }

    if (titem_amount == 0)
        return true;                                        // equipped

    // attempt store
    ItemPosCountVec sDest;
    // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
    InventoryResult msg = CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, titem_id, titem_amount);
    if (msg == EQUIP_ERR_OK)
    {
        std::vector<uint32> l_Bonus;
        if (p_ItemContext != ItemContext::None)
            Item::GenerateItemBonus(titem_id, p_ItemContext, l_Bonus, false, this);

        Item* l_Item = StoreNewItem(sDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id), l_Bonus);
        return true;                                        // stored
    }

    // item can't be added
    sLog->outError(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Can't equip or store initial item %u for race %u class %u, error msg = %u", titem_id, getRace(), getClass(), msg);
    return false;
}

void Player::RewardCurrencyAtKill(Unit* p_Victim)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (!p_Victim->ToCreature())
        return;

    if (!p_Victim->ToCreature()->GetEntry())
        return;

    if (uint32 l_TrackingQuestId = Vignette::GetTrackingQuestIdFromWorldObject(p_Victim))
    {
        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuestId);
        if (IsQuestBitFlaged(l_QuestBit) && !p_Victim->ToCreature()->IsAllowedTrackingQuestLooter(GetGUID()))
            return;
    }

    CurrencyOnKillEntry const* l_Curr = sObjectMgr->GetCurrencyOnKillEntry(p_Victim->ToCreature()->GetEntry());
    if (!l_Curr)
        return;

    bool l_Result = true;
    if (p_Victim->ToCreature()->AI())
        p_Victim->ToCreature()->AI()->CurrenciesRewarder(l_Result);

    if (!l_Result)
        return;

    for (CurrencyOnKillEntry::const_iterator idx = l_Curr->begin(); idx != l_Curr->end(); ++idx)
    {
        // Players won't receive justice points from pre-MoP dungeons/raids when they are more than Cataclysm max level (85)
        if ((idx->first == CURRENCY_TYPE_JUSTICE_POINTS
            || idx->first == CURRENCY_TYPE_VALOR_POINTS)
            && p_Victim->GetMap()->Expansion() != EXPANSION_MISTS_OF_PANDARIA
            && getLevel() > 85)
            continue;

        if (idx->first == CurrencyTypes::CURRENCY_TYPE_ARTIFACT_FRAGEMENT) ///< Specific check for ashran to prevent double currency reward, it has its own table/container
            continue;

        int32 l_Pct = 100;
        Unit::AuraEffectList const& l_Auras = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_PCT);
        for (Unit::AuraEffectList::const_iterator i = l_Auras.begin(); i != l_Auras.end(); ++i)
        {
            if (idx->first == (*i)->GetMiscValue()) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                l_Pct += (*i)->GetAmount();
        }

        ConditionContainer const* l_Conditions = sConditionMgr->GetConditionsForItemLoot(LOOT_ITEM_TYPE_CURRENCY, idx->first);
        if (l_Conditions)
        {
            ConditionSourceInfo srcInfo = ConditionSourceInfo(this);

            if (!sConditionMgr->IsObjectMeetToConditions(srcInfo, *l_Conditions))
                continue;
        }

        ModifyCurrency(idx->first, CalculatePct(idx->second, l_Pct), false);
    }
}

/// Send mirror timer start
/// @p_TimerType    : Type of timer, see MirrorTimerType enum
/// @p_MaxValue     : Max value
/// @p_CurrValue    : Current value
/// @p_Scale        : Time scale
/// @p_Paused       : Is the timer paused
void Player::SendMirrorTimer(MirrorTimerType p_TimerType, uint32 p_MaxValue, uint32 p_CurrValue, int32 p_Scale, uint32 p_SpellID, bool p_Paused)
{
    if (p_MaxValue == DISABLED_MIRROR_TIMER)
    {
        if (p_CurrValue != DISABLED_MIRROR_TIMER)
            StopMirrorTimer(p_TimerType);

        return;
    }

    WorldPacket l_Data(SMSG_START_MIRROR_TIMER, 4 + 4 + 4 + 4 + 4 + 1);
    l_Data << int32(p_TimerType);
    l_Data << int32(p_CurrValue);
    l_Data << int32(p_MaxValue);
    l_Data << int32(p_Scale);
    l_Data << int32(p_SpellID);
    l_Data.WriteBit(p_Paused);
    l_Data.FlushBits();

    GetSession()->SendPacket(&l_Data);
}
/// Send mirror timer stop
/// @p_TimerType : Type of timer, see MirrorTimerType enum
void Player::StopMirrorTimer(MirrorTimerType p_TimerType)
{
    m_MirrorTimer[p_TimerType] = DISABLED_MIRROR_TIMER;

    WorldPacket l_Data(SMSG_STOP_MIRROR_TIMER, 4);
    l_Data << uint32(p_TimerType);

    GetSession()->SendPacket(&l_Data);
}

bool Player::IsImmuneToEnvironmentalDamage()
{
    // check for GM and death state included in isAttackableByAOE
    return (!isTargetableForAttack(false));
}

uint32 Player::EnvironmentalDamage(EnviromentalDamage p_Type, uint32 p_Damage)
{
    if (IsImmuneToEnvironmentalDamage())
        return 0;

    if (p_Type == DAMAGE_FALL && !GetSession()->IsPremium())
    {
        /// Handle falling damage disabling in some situations
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->IsPlayerImmuneToFallDamage(this))
                return 0;
        }
    }

    DamageInfo l_DamageInfo(nullptr, this, p_Damage, (p_Type == DAMAGE_LAVA) ? SPELL_SCHOOL_MASK_FIRE : SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE);

    if (p_Type == DAMAGE_LAVA || p_Type == DAMAGE_SLIME)
        CalcAbsorbResist(l_DamageInfo);

    DealDamageMods(l_DamageInfo);

    WorldPacket l_Data(SMSG_ENVIRONMENTAL_DAMAGE_LOG, (21));
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint8(p_Type != DAMAGE_FALL_TO_VOID ? p_Type : DAMAGE_FALL);
    l_Data << uint32(l_DamageInfo.GetAmount());
    l_Data << uint32(l_DamageInfo.GetAbsorb());
    l_Data << uint32(l_DamageInfo.GetResist());

    l_Data.WriteBit(false);               ///< HasPowerData
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);

    uint32 l_FinalDamage = DealDamage(this, l_DamageInfo.GetAmount(), NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false, l_DamageInfo.GetAbsorb());

    if (!isAlive())
    {
        if (p_Type == DAMAGE_FALL && !GetSession()->IsPremium())                               ///< DealDamage not apply item durability loss at self damage
        {
            sLog->outDebug(LOG_FILTER_PLAYER, "We are fall to death, loosing 10 percents durability");

            DurabilityLossAll(0.10f, false);
            /// durability lost message
            SendDurabilityLoss(this, 10);
        }

        UpdateCriteria(CRITERIA_TYPE_DEATHS_FROM, 1, p_Type);
    }

    return l_FinalDamage;
}

int32 Player::getMaxTimer(MirrorTimerType timer)
{
    switch (timer)
    {
        case FATIGUE_TIMER:
            return MINUTE * IN_MILLISECONDS;
        case BREATH_TIMER:
        {
            if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || isGameMaster()/*GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING))*/)
                return DISABLED_MIRROR_TIMER;
            int32 UnderWaterTime = 3 * MINUTE * IN_MILLISECONDS;
            AuraEffectList const& mModWaterBreathing = GetAuraEffectsByType(SPELL_AURA_MOD_WATER_BREATHING);
            for (AuraEffectList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
                AddPct(UnderWaterTime, (*i)->GetAmount());
            return UnderWaterTime;
        }
        case FIRE_TIMER:
        {
            if (!isAlive())
                return DISABLED_MIRROR_TIMER;
            return 1 * IN_MILLISECONDS;
        }
        default:
            return 0;
    }
}

void Player::UpdateMirrorTimers()
{
    // Desync flags for update on next HandleDrowning
    if (m_MirrorTimerFlags)
        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
}

void Player::HandleDrowning(uint32 p_TimeDiff)
{
    if (!m_MirrorTimerFlags && (GetMapId() != 1804 && m_areaUpdateId != 9528))
    {
        if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)
            StopMirrorTimer(FATIGUE_TIMER);

        return;
    }

    if (!m_MirrorTimerFlags)
    {
        /// Fatigue timer not activated - activate it
        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1, 0, false);
        }
        else
        {
            m_MirrorTimer[FATIGUE_TIMER] -= p_TimeDiff;
            /// Timer limit - need deal damage or teleport ghost to graveyard
            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
            {
                m_MirrorTimer[FATIGUE_TIMER] += 1 * IN_MILLISECONDS;

                if (isAlive())                                                      ///< Calculate and deal damage
                {
                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel() - 1);
                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
                }
                else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))    ///< Teleport ghost to graveyard
                    RepopAtGraveyard();
            }
        }
        return;
    }

    /// In water
    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
    {
        /// Vash'jir zones
        if (m_zoneUpdateId == 4815 || m_zoneUpdateId == 4816 || m_zoneUpdateId == 5144 || m_zoneUpdateId == 5145|| m_zoneUpdateId == 5146)
            return;

        /// Breath timer not activated - activate it
        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1, 0, false);
        }
        else                                                                        ///< If activated - do tick
        {
            m_MirrorTimer[BREATH_TIMER]-=p_TimeDiff;
            /// Timer limit - need deal damage
            if (m_MirrorTimer[BREATH_TIMER] < 0)
            {
                m_MirrorTimer[BREATH_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                // @TODO: Check this formula
                uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
                EnvironmentalDamage(DAMAGE_DROWNING, damage);
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))                ///< Update time in client if need
                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1, 0, false);
        }
    }
    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)                  ///< Regen timer
    {
        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);

        /// Need breath regen
        m_MirrorTimer[BREATH_TIMER]+=10*p_TimeDiff;
        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !isAlive())
            StopMirrorTimer(BREATH_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10, 0, false);
    }

    /// In dark water
    if ((m_MirrorTimerFlags & UNDERWARER_INDARKWATER) && !GetVehicle())
    {
        /// Fatigue timer not activated - activate it
        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1, 0, false);
        }
        else
        {
            m_MirrorTimer[FATIGUE_TIMER]-=p_TimeDiff;
            /// Timer limit - need deal damage or teleport ghost to graveyard
            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
            {
                m_MirrorTimer[FATIGUE_TIMER]+= 1*IN_MILLISECONDS;

                if (isAlive())                                                      ///< Calculate and deal damage
                {
                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel() - 1);
                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
                }
                else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))    ///< Teleport ghost to graveyard
                    RepopAtGraveyard();
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER))
                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1, 0, false);
        }
    }
    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)                 ///< Regen timer
    {
        int32 l_DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
        m_MirrorTimer[FATIGUE_TIMER]+=10*p_TimeDiff;

        if (m_MirrorTimer[FATIGUE_TIMER] >= l_DarkWaterTime || !isAlive())
            StopMirrorTimer(FATIGUE_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
            SendMirrorTimer(FATIGUE_TIMER, l_DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10, 0, false);
    }

    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA | UNDERWATER_INSLIME) && !(_lastLiquid && _lastLiquid->SpellID))
    {
        /// Breath timer not activated - activate it
        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
        else
        {
            m_MirrorTimer[FIRE_TIMER] -= p_TimeDiff;

            if (m_MirrorTimer[FIRE_TIMER] < 0)
            {
                m_MirrorTimer[FIRE_TIMER] += 1*IN_MILLISECONDS;

                /// Calculate and deal damage
                /// @TODO: Check this formula
                uint32 damage = urand(600, 700);

                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
                    EnvironmentalDamage(DAMAGE_LAVA, damage);
                else
                {
                    if (!IsInBattleground())
                    {
                        damage = CountPctFromMaxHealth(frand(9.0f, 11.0f), this);

                        EnvironmentalDamage(DAMAGE_SLIME, damage);
                    }
                }
            }
        }
    }
    else
        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;

    /// Recheck timers flag
    m_MirrorTimerFlags &= ~UNDERWATER_EXIST_TIMERS;

    for (uint8 i = 0; i < MAX_TIMERS; ++i)
    {
        if (m_MirrorTimer[i] != DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimerFlags |= UNDERWATER_EXIST_TIMERS;
            break;
        }
    }

    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
}

///The player sobers by 1% every 9 seconds
void Player::HandleSobering()
{
    m_drunkTimer = 0;

    uint8 currentDrunkValue = GetDrunkValue();
    uint8 drunk = currentDrunkValue ? --currentDrunkValue : 0;
    SetDrunkValue(drunk);
}

DrunkenState Player::GetDrunkenstateByValue(uint8 value)
{
    if (value >= 90)
        return DRUNKEN_SMASHED;
    if (value >= 50)
        return DRUNKEN_DRUNK;
    if (value)
        return DRUNKEN_TIPSY;
    return DRUNKEN_SOBER;
}

void Player::SetDrunkValue(uint8 newDrunkValue, uint32 itemId /*= 0*/)
{
    bool isSobering = newDrunkValue < GetDrunkValue();
    uint32 oldDrunkenState = Player::GetDrunkenstateByValue(GetDrunkValue());
    if (newDrunkValue > 100)
        newDrunkValue = 100;

    // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
    int32 drunkPercent = std::max<int32>(newDrunkValue, GetTotalAuraModifier(SPELL_AURA_MOD_FAKE_INEBRIATE));
    if (drunkPercent)
    {
        m_invisibilityDetect.AddFlag(INVISIBILITY_DRUNK);
        m_invisibilityDetect.SetValue(INVISIBILITY_DRUNK, drunkPercent);
    }
    else if (!HasAuraType(SPELL_AURA_MOD_FAKE_INEBRIATE) && !newDrunkValue)
        m_invisibilityDetect.DelFlag(INVISIBILITY_DRUNK);

    uint32 newDrunkenState = Player::GetDrunkenstateByValue(newDrunkValue);
    SetByteValue(PLAYER_FIELD_INEBRIATION, PLAYER_BYTES_3_OFFSET_INEBRIATION, newDrunkValue);
    UpdateObjectVisibility();

    if (!isSobering)
        m_drunkTimer = 0;   // reset sobering timer

    if (newDrunkenState == oldDrunkenState)
        return;

    WorldPacket l_Data(SMSG_CROSSED_INEBRIATION_THRESHOLD, (8 + 4 + 4));
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(itemId);
    l_Data << uint32(newDrunkenState);
    SendMessageToSet(&l_Data, true);
}

void Player::Update(uint32 p_time)
{
    bool l_LogMapPerformance = sMapMgr->m_LogMapPerformance || GetMap()->IsRaid();

    auto l_RegisterUpdatePartTime = [this, l_LogMapPerformance]()->void
    {
        if (!l_LogMapPerformance)
            return;

        GetMap()->m_PlayersUpdateTime[m_UpdateStep] += std::chrono::steady_clock::now() - m_CurrentStepTimer;
        m_UpdateStep++;
        m_CurrentStepTimer = std::chrono::steady_clock::now();
    };

    if (!IsInWorld())
        return;

#ifndef CROSS
    if (m_InterRealmPlayerState == InterRealmPlayerState::InTransfer && (m_InterRealmPlayerStateLastChange + 30) < time(nullptr))
        SetInterRealmPlayerState(InterRealmPlayerState::None);
#endif

    if (m_timeSyncClient)
        m_timeSyncClient += p_time;

    if (GetMap()->GetEntry()->IsContinent() && !isInCombat() && !m_Events.HasScheduledEvent() && !GetSession()->HasRecentSpellPacket() && m_SkipUpdateCounter < sWorld->getIntConfig(CONFIG_PLAYER_SKIP_UPDATE_MAX))
    {
        m_SkipUpdateCounter++;
        m_DelayedUpdateTime += p_time;
        return;
    }

    p_time += m_DelayedUpdateTime;
    m_DelayedUpdateTime = 0;
    m_SkipUpdateCounter = 0;

    if (sMapMgr->m_LogMapPerformance || GetMap()->IsRaid())
    {
        m_UpdateStep = 0;
        m_CurrentStepTimer = std::chrono::steady_clock::now();
    }

    m_QueryCallbackMgr->Update();

    time_t now = time(nullptr);

    for (auto l_Itr : m_ChestTimedLockout)
    {
        if (l_Itr.second < now)
        {
            m_ChestTimedLockout.erase(l_Itr.first);

            PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHEST_TIMED_LOCKOUT);
            l_Stmt->setUInt32(0, GetGUIDLow());
            l_Stmt->setUInt32(1, l_Itr.first);
            CharacterDatabase.Execute(l_Stmt);
            break;
        }
    }

    if (m_CriteriaUpdateTimer < p_time)
    {
        if (m_HighestHitReceived)
        {
            UpdateCriteria(CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, m_HighestHitReceived);
            m_HighestHitReceived = 0;
        }

        if (m_HighestHitDealt)
        {
            UpdateCriteria(CRITERIA_TYPE_HIGHEST_HIT_DEALT, m_HighestHitDealt);
            m_HighestHitDealt = 0;
        }

        if (m_TotalDamageReceived)
        {
            UpdateCriteria(CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, m_TotalDamageReceived);
            m_TotalDamageReceived = 0;
        }

        if (m_HighestHealCast)
        {
            UpdateCriteria(CRITERIA_TYPE_HIGHEST_HEAL_CAST, m_HighestHealCast);
            m_HighestHealCast = 0;
        }

        if (m_HighestHealingReceived)
        {
            UpdateCriteria(CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, m_HighestHealingReceived);
            m_HighestHealingReceived = 0;
        }

        if (m_TotalHealingReceived)
        {
            UpdateCriteria(CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, m_TotalHealingReceived);
            m_TotalHealingReceived = 0;
        }

        m_CriteriaUpdateTimer = 60000;
    }
    else
        m_CriteriaUpdateTimer -= p_time;

    l_RegisterUpdatePartTime(); ///< 0

    if (!m_initializeCallback)
    {
        PreparedStatement* stmt;

        stmt = RealmDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, getClass() == CLASS_WARLOCK ? 254 : m_currentPetSlot);
        _petPreloadCallback = RealmDatabase.AsyncQuery(stmt);

        m_initializeCallback = true;
    }

    l_RegisterUpdatePartTime(); ///< 1


    // Process player callback
    {
        PreparedQueryResult result;

        if (_petPreloadCallback.ready())
        {
            _petPreloadCallback.get(result);
            LoadPet(result);
            _petPreloadCallback.cancel();
        }

        l_RegisterUpdatePartTime(); ///< 2

        if (_petLoginCallback.ready())
        {
            SQLQueryHolder* param;
            _petLoginCallback.get(param);

            Pet* pet = new Pet(this);
            if (!HasAura(205024)) ///< Lonely Winter
                pet->LoadPetFromDB(this, 0, 0, true, PET_SLOT_ACTUAL_PET_SLOT, false, (PetQueryHolder*)param, [param](Pet* p_Pet, bool p_Result) -> void
                {
                    if (!p_Result)
                    {
                        p_Pet->CleanBeforeGC();
                        sGarbageCollector->Add(p_Pet);
                    }

                    delete param;
                });

            _petLoginCallback.cancel();
        }

        l_RegisterUpdatePartTime(); ///< 3
    }

    l_RegisterUpdatePartTime(); ///< 4

    if (m_InCinematic && m_CinematicSequence)
    {
        bool l_StartedAtClient = getMSTime() > m_CinematicClientStartTime;
        uint32 l_Time = getMSTime() - m_CinematicClientStartTime;

        if (l_StartedAtClient)
        {
            if (l_Time > m_CinematicSequence->Duration)
                StopCinematic();
            else if (l_StartedAtClient)
            {
                Position l_NewPosition;
                m_CinematicSequence->GetPositionAtTime(l_Time, &l_NewPosition.m_positionX, &l_NewPosition.m_positionY, &l_NewPosition.m_positionZ);

                Unit::UpdatePosition(l_NewPosition.m_positionX, l_NewPosition.m_positionY, l_NewPosition.m_positionZ, 0, true);
                SetFall(false);
            }
        }
    }

    l_RegisterUpdatePartTime(); ///< 5

    // undelivered mail
    if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
    {
        SendNewMail();
        ++unReadMails;

        // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
        m_nextMailDelivereTime = 0;
    }

    l_RegisterUpdatePartTime(); ///< 6

    // If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
    // Having this would prevent more aura charges to be dropped, so let's crash
    //ASSERT (!m_spellModTakingSpell);
    if (m_spellModTakingSpell)
    {
        //sLog->outFatal(LOG_FILTER_PLAYER, "Player has m_pad %u during update!", m_pad);
        //if (m_spellModTakingSpell)
        sLog->outFatal(LOG_FILTER_SPELLS_AURAS, "Player has m_spellModTakingSpell %u during update!", m_spellModTakingSpell->m_spellInfo->Id);
        m_spellModTakingSpell = NULL;
    }

    l_RegisterUpdatePartTime(); ///< 7

    //used to implement delayed far teleports
    SetCanDelayTeleport(true);
    Unit::Update(p_time);
    SetCanDelayTeleport(false);

    l_RegisterUpdatePartTime(); ///< 8

    if (m_WargameRequest != nullptr && (m_WargameRequest->CreationDate + 60) < now)
    {
        delete m_WargameRequest;
        m_WargameRequest = nullptr;
    }

    UpdatePvPFlag(now);

    l_RegisterUpdatePartTime(); ///< 9

    UpdateContestedPvP(p_time);

    l_RegisterUpdatePartTime(); ///< 10

    UpdateDuelFlag(now);

    l_RegisterUpdatePartTime(); ///< 11

    CheckDuelDistance(now);

    l_RegisterUpdatePartTime(); ///< 12

    UpdateAfkReport(now);

    l_RegisterUpdatePartTime(); ///< 13

    UpdatePvP(p_time);

    l_RegisterUpdatePartTime(); ///< 14

    sScriptMgr->OnUpdate(this, p_time);

    l_RegisterUpdatePartTime(); ///< 15

    if (isCharmed())
        if (Unit* charmer = GetCharmer())
            if (charmer->GetTypeId() == TYPEID_UNIT && charmer->isAlive())
                UpdateCharmedAI();

    l_RegisterUpdatePartTime(); ///< 16

    // Update items that have just a limited lifetime
    if (now > m_Last_tick)
        UpdateItemDuration(uint32(now - m_Last_tick));

    l_RegisterUpdatePartTime(); ///< 17

    // check every second
    if (now > m_Last_tick + 1000)
        UpdateSoulboundTradeItems();

    l_RegisterUpdatePartTime(); ///< 18

    if (_petBattleJournalCallback.ready())
    {
        PreparedQueryResult l_Result;
        _petBattleJournalCallback.get(l_Result);
        bool l_ResultRes = _LoadPetBattles(std::move(l_Result));
        _petBattleJournalCallback.cancel();

        if (!l_ResultRes)
            ReloadPetBattles();
    }

    l_RegisterUpdatePartTime(); ///< 19

    if (!m_timedquests.empty())
    {
        QuestSet::iterator iter = m_timedquests.begin();
        while (iter != m_timedquests.end())
        {
            QuestStatusData& q_status = m_QuestStatus[*iter];
            if (q_status.Timer <= p_time)
            {
                uint32 quest_id  = *iter;
                ++iter;                                     // current iter will be removed in FailQuest
                FailQuest(quest_id);
            }
            else
            {
                q_status.Timer -= p_time;
                m_QuestStatusSave[*iter] = true;
                ++iter;
            }
        }
    }

    l_RegisterUpdatePartTime(); ///< 20

    m_achievementMgr->UpdateTimedCriteria(p_time);

    l_RegisterUpdatePartTime(); ///< 21

    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
    {
        if (Unit* victim = getVictim())
        {
            // default combat reach 10
            // TODO add weapon, skill check

            bool l_MustCheckO = true;

            /// Can attack own vehicle in any direction
            if (m_vehicle)
            {
                if (IsOnVehicle(victim) || (m_vehicle->GetBase() && m_vehicle->GetBase()->IsOnVehicle(victim)))
                    l_MustCheckO = false;
            }

            if (victim->IsOnVehicle())
                l_MustCheckO = false;

            if (isAttackReady(WeaponAttackType::BaseAttack))
            {
                if (!IsWithinMeleeRange(victim) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                {
                    setAttackTimer(WeaponAttackType::BaseAttack, 100);
                    if (m_swingErrorMsg != 1)               // send single time (client auto repeat)
                    {
                        SendAttackSwingError(ATTACKSWINGERR_NOT_IN_RANGE);
                        m_swingErrorMsg = 1;
                    }
                }
                //120 degrees of radiant range
                else if (l_MustCheckO && !HasInArc(2 * M_PI / 3, victim))
                {
                    setAttackTimer(WeaponAttackType::BaseAttack, 100);
                    if (m_swingErrorMsg != 2)               // send single time (client auto repeat)
                    {
                        SendAttackSwingError(ATTACKSWINGERR_BAD_FACING);
                        m_swingErrorMsg = 2;
                    }
                }
                else
                {
                    m_swingErrorMsg = 0;                    // reset swing error state

                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (haveOffhandWeapon())
                        if (getAttackTimer(WeaponAttackType::OffAttack) < ATTACK_DISPLAY_DELAY)
                            setAttackTimer(WeaponAttackType::OffAttack, ATTACK_DISPLAY_DELAY);

                    // do attack if player doesn't have Shadow Blades or SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL
                    if (!HasAura(211048) && !HasAura(247938) && !HasAura(121471) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    {
                        AttackerStateUpdate(victim, WeaponAttackType::BaseAttack);
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }
                    else if (HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        // Should have only one aura of this type at the same time
                        AuraEffectList const& mOverrideAutoAttacks = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL);
                        for (AuraEffectList::const_iterator i = mOverrideAutoAttacks.begin(); i != mOverrideAutoAttacks.end(); ++i)
                        {
                            CastSpell(victim, (*i)->GetTriggerSpell(), true);
                            resetAttackTimer(WeaponAttackType::BaseAttack);
                            break;
                        }
                    }
                    // Shadow Blade - Main Hand
                    else if (getClass() == CLASS_ROGUE && HasAura(121471) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        CastSpell(victim, 121473, true);
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }

                    /// Chaos Blade - Main Hand
                    else if (getClass() == CLASS_DEMON_HUNTER && HasAura(247938) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        CastSpell(victim, 211796, true);
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }
                }
            }

            if (haveOffhandWeapon() && isAttackReady(WeaponAttackType::OffAttack))
            {

                if (!IsWithinMeleeRange(victim) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    setAttackTimer(WeaponAttackType::OffAttack, 100);
                else if (l_MustCheckO && !HasInArc(2 * M_PI / 3, victim))
                    setAttackTimer(WeaponAttackType::OffAttack, 100);
                else
                {
                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (getAttackTimer(WeaponAttackType::BaseAttack) < ATTACK_DISPLAY_DELAY)
                        setAttackTimer(WeaponAttackType::BaseAttack, ATTACK_DISPLAY_DELAY);

                    /// Shadow Blade - Off Hand
                    if (getClass() == CLASS_ROGUE && HasAura(121471) && IsWithinLOSInMap(victim))
                    {
                        CastSpell(victim, 121474, true);
                        resetAttackTimer(WeaponAttackType::OffAttack);
                    }

                    /// Chaos Blade - Off Hand
                    else if (getClass() == CLASS_DEMON_HUNTER && HasAura(247938) && IsWithinLOSInMap(victim))
                    {
                        CastSpell(victim, 211797, true);
                        resetAttackTimer(WeaponAttackType::OffAttack);
                    }

                    // do attack if player doesn't have Shadow Blades or SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL
                    else if (!HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    {
                        AttackerStateUpdate(victim, WeaponAttackType::OffAttack);
                        resetAttackTimer(WeaponAttackType::OffAttack);
                    }
                    else if (HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        // Should have only one aura of this type at the same time
                        AuraEffectList const& mOverrideAutoAttacks = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL);
                        for (AuraEffectList::const_iterator i = mOverrideAutoAttacks.begin(); i != mOverrideAutoAttacks.end(); ++i)
                        {
                            CastSpell(victim, (*i)->GetMiscValue(), true);
                            resetAttackTimer(WeaponAttackType::OffAttack);
                            break;
                        }
                    }
                }

            }
        }
    }

    l_RegisterUpdatePartTime(); ///< 22

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
    {
        if (roll_chance_i(3) && _restTime > 0)      // freeze update
        {
            time_t currTime = time(nullptr);
            time_t timeDiff = currTime - _restTime;
            if (timeDiff >= 10)                               // freeze update
            {
                _restTime = currTime;

                float bubble = 0.125f * sWorld->getRate(RATE_REST_INGAME);
                float extraPerSec = ((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP) / 72000.0f) * bubble;

                // speed collect rest bonus (section/in hour)
                ModRestBonus(timeDiff * extraPerSec);
            }
        }
    }

    l_RegisterUpdatePartTime(); ///< 23

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS) && isAlive())
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);

    if (m_weaponChangeTimer > 0)
    {
        if (p_time >= m_weaponChangeTimer)
            m_weaponChangeTimer = 0;
        else
            m_weaponChangeTimer -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 24

    if (m_zoneUpdateTimer > 0)
    {
        if (p_time >= m_zoneUpdateTimer)
        {
            // On zone update tick check if we are still in an inn if we are supposed to be in one
            if (HasRestFlag(REST_FLAG_IN_TAVERN))
            {
                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(GetInnTriggerId());
                if (!atEntry || !IsInAreaTriggerRadius(atEntry))
                    RemoveRestFlag(REST_FLAG_IN_TAVERN);
            }

            uint32 newzone, newarea;
            GetZoneAndAreaId(newzone, newarea, true);

            if (m_zoneUpdateId != newzone)
                UpdateZone(newzone, newarea);                // also update area
            else
            {
                // use area updates as well
                // needed for free far all arenas for example
                if (m_areaUpdateId != newarea)
                {
                    UpdateArea(newarea);
                    sScriptMgr->OnPlayerUpdateZone(this, m_zoneUpdateId, m_zoneUpdateId, newarea);
                }

                /// Check for custom instance zones ...
                uint32 l_ActualInstanceZoneId = GetMap()->GetInstanceZoneId() & 0xFFFF;
                if (CustomInstanceZones const* l_CustomInstanceZones = sObjectMgr->GetCustomInstanceZones(newzone))
                {
                    for (CustomInstanceZone const& l_InstanceZone : *l_CustomInstanceZones)
                    {
                        bool l_In = GetDistance(l_InstanceZone.Position) < l_InstanceZone.Radius;
                        if ((!l_In && l_ActualInstanceZoneId == l_InstanceZone.CustomZoneID)        ///< Player just get out of a custom instanced zone
                            || (l_In && l_ActualInstanceZoneId != l_InstanceZone.CustomZoneID))     ///< Player just get into a custom instanced zone
                        {
                            uint32 l_CustomZoneId = l_InstanceZone.CustomZoneID;
                            CustomInstanceZone const* l_InstanceZonePtr = &l_InstanceZone;
                            AddMapTask(eTaskType::TaskSwitchToPhasedMap, [this, l_InstanceZonePtr, l_In]() -> void
                            {
                                SwitchToPhasedMap(GetMapId(), l_In ? l_InstanceZonePtr : nullptr);
                            });
                            break;
                        }
                    }
                }

                m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
            }

#ifndef CROSS
            /// Shipyard map has broken area settings
            if (IsInShipyard())
            {
                uint64 l_Guid = GetGUID();

                Map * l_Map = sMapMgr->FindBaseNonInstanceMap(MS::Garrison::GDraenor::Globals::BaseMap, 0);

                if (!l_Map)
                    l_Map = sMapMgr->CreateBaseMap(MS::Garrison::GDraenor::Globals::BaseMap, 0);

                if (l_Map)
                {
                    uint32 l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area;

                    l_Map->GetZoneAndAreaId(l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area, m_positionX, m_positionY, m_positionZ);
                    const GarrSiteLevelEntry * l_GarrisonSiteEntry = GetDraenorGarrison()->GetGarrisonSiteLevelEntry(); ///< l_garrisonSiteEntry is never read 01/18/16

                    if (l_DraenorBaseMap_Area != MS::Garrison::GDraenor::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()])
                    {
                        AddMapTask(eTaskType::TaskSwitchToPhasedMap, [=]() -> void
                        {
                            if (IsInWorld())
                                _SetOutOfShipyard();

                            m_TaskInProgress = false;
                        });
                    }
                }
            }
#endif
        }
        else
            m_zoneUpdateTimer -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 25

    if (m_timeSyncTimer > 0 && !IsBeingTeleportedFar())
    {
        if (p_time >= m_timeSyncTimer)
            SendTimeSync();
        else
            m_timeSyncTimer -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 26

    if (isAlive())
    {
        m_RegenPowerTimer += p_time;
        RegenerateAll();
    }

    if (m_PlayerCommandCooldown)
    {
        if (m_PlayerCommandCooldown <= p_time)
            m_PlayerCommandCooldown = 0;
        else
            m_PlayerCommandCooldown -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 27

    if (m_deathState == JUST_DIED)
        KillPlayer();

    l_RegisterUpdatePartTime(); ///< 28

    if (m_nextSave > 0)
    {
        if (p_time >= m_nextSave)
        {
            // m_nextSave reseted in SaveToDB call
            SaveToDB();
            sLog->outDebug(LOG_FILTER_PLAYER, "Player '%s' (GUID: %u) saved", GetName(), GetGUIDLow());
        }
        else
            m_nextSave -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 29

    //Handle Water/drowning
    HandleDrowning(p_time);

    l_RegisterUpdatePartTime(); ///< 30

    // Played time
    if (now > m_Last_tick)
    {
        uint32 elapsed = uint32(now - m_Last_tick);
        m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
        m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
        m_Last_tick = now;
    }

    if (GetDrunkValue())
    {
        m_drunkTimer += p_time;
        if (m_drunkTimer > 9 * IN_MILLISECONDS)
            HandleSobering();
    }

    l_RegisterUpdatePartTime(); ///< 31

    if (HasPendingBind())
    {
        if (_pendingBindTimer <= p_time)
        {
            // Player left the instance
            if (_pendingBindId == GetInstanceId())
                BindToInstance();
            SetPendingBind(0, 0);
        }
        else
            _pendingBindTimer -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 32

    // not auto-free ghost from body in instances
    if (m_deathTimer > 0 && !GetBaseMap()->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
    {
        if (p_time >= m_deathTimer)
        {
            m_deathTimer = 0;
            BuildPlayerRepop();
            RepopAtGraveyard();
        }
        else
            m_deathTimer -= p_time;
    }

    l_RegisterUpdatePartTime(); ///< 33

    if (m_knockBackTimer)
    {
        if ( m_knockBackTimer + 2000 < getMSTime())
            m_knockBackTimer = 0;
    }

    UpdateEnchantTime(p_time);
    UpdateHomebindTime(p_time);

    l_RegisterUpdatePartTime(); ///< 34

    if (!_instanceResetTimes.empty())
    {
        for (InstanceTimeMap::iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end();)
        {
            if (itr->second < now)
                _instanceResetTimes.erase(itr++);
            else
                ++itr;
        }
    }

    l_RegisterUpdatePartTime(); ///< 35

    if (getClass() == CLASS_DEATH_KNIGHT)
    {
        // Update rune timers
        for (uint8 i = 0; i < MAX_RUNES; ++i)
        {
            uint32 timer = GetRuneTimer(i);

            // Don't update timer if rune is disabled
            if (GetRuneCooldown(i))
                continue;

            // Timer has began
            if (timer < 0xFFFFFFFF)
            {
                timer += p_time;
                SetRuneTimer(i, std::min(uint32(2500), timer));
            }
        }
    }

    l_RegisterUpdatePartTime(); ///< 36

    // group update
    // Avoid spam of SMSG_PARTY_MEMBER_STAT
    if (m_groupUpdateDelay < p_time)
    {
        SendUpdateToOutOfRangeGroupMembers();
        m_groupUpdateDelay = 5000;
    }
    else
        m_groupUpdateDelay -= p_time;

    l_RegisterUpdatePartTime(); ///< 37

    Pet* pet = GetPet();
    if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange()) && !pet->isPossessed() && !IsInCinematic())
        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true, pet->m_Stampeded);

    l_RegisterUpdatePartTime(); ///< 38

    if (pet && IsFlying() && !pet->isPossessed())
    {
        UnsummonPetTemporaryIfAny();
        m_needSummonPetAfterStopFlying = true;
    }
    else if (!IsFlying() && m_needSummonPetAfterStopFlying)
    {
        ResummonPetTemporaryUnSummonedIfAny();
        m_needSummonPetAfterStopFlying = false;
    }

    l_RegisterUpdatePartTime(); ///< 39

    //we should execute delayed teleports only for alive(!) players
    //because we don't want player's ghost teleported from graveyard
    if (IsHasDelayedTeleport())
        TeleportTo(m_teleport_dest, m_teleport_options);

    l_RegisterUpdatePartTime(); ///< 40

    getHostileRefManager().Update();

    l_RegisterUpdatePartTime(); ///< 41

#ifndef CROSS
    m_GarrisonUpdateTimer.Update(p_time);

    if (m_GarrisonUpdateTimer.Passed())
    {
        if (m_Garrison)
            m_Garrison->Update();

        m_GarrisonUpdateTimer.Reset();
    }

    l_RegisterUpdatePartTime(); ///< 42
#endif

    m_VignetteMgr.Update();

    l_RegisterUpdatePartTime(); ///< 43

    sScriptMgr->OnPlayerUpdate(this, p_time);

    l_RegisterUpdatePartTime(); ///< 44


    /// Just dequeue critical operations from the locked queue into a vector to reduce the lock time and avoid deadlock if some operations use locks
    std::vector<std::function<void()>> l_CriticalOperations;
    m_CriticalOperationLock.lock();
    while (!m_CriticalOperation.empty())
    {
        if (m_CriticalOperation.front())
            l_CriticalOperations.push_back(m_CriticalOperation.front());

        m_CriticalOperation.pop();
    }
    m_CriticalOperationLock.unlock();

    /// Execute all the critical operations
    for (auto& l_Operation : l_CriticalOperations)
        l_Operation();

#ifdef CROSS

    while (!m_ItemToGuidSync.empty())
    {
        uint32 l_LocalItemGuid = InterRealmClient::GetIRClient(this)->GenerateLocalRealmLowGuid(HIGHGUID_ITEM);
        if (l_LocalItemGuid == 0)
            break;

        if (Item* l_Item = GetItemByGuid(m_ItemToGuidSync.front()))
            l_Item->SetRealGUID(MAKE_NEW_GUID(l_LocalItemGuid, 0, HIGHGUID_ITEM));

        m_ItemToGuidSync.pop();
    }
#endif /* CROSS */
    l_RegisterUpdatePartTime(); ///< 45

    if (m_NeedForcedVisibilityUpdate)
    {
        UpdateObjectVisibility(true);
        m_NeedForcedVisibilityUpdate = false;
    }

    l_RegisterUpdatePartTime(); ///< 46

    UpdatePhaseTimings(p_time);
}

void Player::setDeathState(DeathState s)
{
    uint32 ressSpellId = 0;

    bool cur = isAlive();

    if (s == JUST_DIED)
    {
        if (!cur)
        {
            sLog->outError(LOG_FILTER_PLAYER, "setDeathState: attempt to kill a dead player %s(%d)", GetName(), GetGUIDLow());
            return;
        }

        // drunken state is cleared on death
        SetDrunkValue(0);

        RemoveAllMovementForces();

        ClearResurrectRequestData();

        if (Pet* pet = GetPet())
            RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true, pet->m_Stampeded);
        else
            RemovePet(NULL, PET_SLOT_ACTUAL_PET_SLOT, true, GetPet() ? GetPet()->m_Stampeded : true);

        // save value before aura remove in Unit::setDeathState
        ressSpellId = GetFirstDescriptorRessurectSpell();

        // passive spell
        if (!ressSpellId)
            ressSpellId = GetResurrectionSpellId();
        UpdateCriteria(CRITERIA_TYPE_DEATH_AT_MAP, 1);
        UpdateCriteria(CRITERIA_TYPE_DEATH, 1);
        UpdateCriteria(CRITERIA_TYPE_DEATH_IN_DUNGEON, 1);
        ResetCriteria(CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,   CRITERIA_CONDITION_NO_DEATH);
        ResetCriteria(CRITERIA_TYPE_HONORABLE_KILL,         CRITERIA_CONDITION_NO_DEATH);
        ResetCriteria(CRITERIA_TYPE_GET_KILLING_BLOWS,      CRITERIA_CONDITION_NO_DEATH);
    }
    else if (s == ALIVE)
    {
        if (HasAura(84559))
            RemoveAurasDueToSpell(84559); // The Quick and the Dead
    }

    Unit::setDeathState(s);

    // restore resurrection spell id for player after aura remove
    if (s == JUST_DIED && cur && ressSpellId)
        SetResurectSpell(ressSpellId);

    if (isAlive() && !cur)
        //clear aura case after resurrection by another way (spells will be applied before next death)
        SetResurectSpell(0);
}

void Player::SetRestFlag(RestFlag restFlag, uint32 triggerId /*= 0*/)
{
    uint32 oldRestMask = _restFlagMask;
    _restFlagMask |= restFlag;

    if (!oldRestMask && _restFlagMask) // only set flag/time on the first rest state
    {
        _restTime = time(nullptr);
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
    }

    if (triggerId)
        inn_triggerId = triggerId;
}

void Player::RemoveRestFlag(RestFlag restFlag)
{
    uint32 oldRestMask = _restFlagMask;
    _restFlagMask &= ~restFlag;

    if (oldRestMask && !_restFlagMask) // only remove flag/time on the last rest state remove
    {
        _restTime = 0;
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
    }
}

bool Player::BuildEnumData(PreparedQueryResult p_Result, ByteBuffer* p_Data)
{
    //             0               1                2                3                 4                  5                       6                        7
    //    "SELECT characters.guid, characters.name, characters.race, characters.class, characters.gender, characters.playerBytes, characters.playerBytes2, characters.level, "
    //     8                9               10                     11                     12                     13                    14
    //    "characters.zone, characters.map, characters.position_x, characters.position_y, characters.position_z, guild_member.guildid, characters.playerFlags, "
    //    15                    16                   17                     18                   19               20                     21               22
    //    "characters.at_login, character_pet.entry, character_pet.modelid, character_pet.level, characters.data, character_banned.guid, characters.slot, character_declinedname.genitive"

    Field * l_Fields = p_Result->Fetch();

    /// Character visual
    uint8 l_CharacterRace       = l_Fields[2].GetUInt8();
    uint8 l_CharacterClass      = l_Fields[3].GetUInt8();
    uint8 l_CharacterGender     = l_Fields[4].GetUInt8();
    uint8 l_CharacterSkin       = uint8( l_Fields[5].GetUInt32() & 0xFF);
    uint8 l_CharacterFace       = uint8((l_Fields[5].GetUInt32() >> 8)  & 0xFF);
    uint8 l_CharacterHairStyle  = uint8((l_Fields[5].GetUInt32() >> 16) & 0xFF);
    uint8 l_CharacterHairColor  = uint8((l_Fields[5].GetUInt32() >> 24) & 0xFF);
    uint8 l_Tattoos             = uint8( l_Fields[6].GetUInt32() & 0xFF);
    uint8 l_HornStyle           = uint8((l_Fields[6].GetUInt32() >> 8) & 0xFF);
    uint8 l_BlindFolds          = uint8((l_Fields[6].GetUInt32() >> 16) & 0xFF);
    uint8 l_CharacterFacialHair = uint8((l_Fields[6].GetUInt32() >> 24) & 0xFF);

    /// Character informations
    uint64      l_CharacterGuid         = MAKE_NEW_GUID(l_Fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
    std::string l_CharacterName         = l_Fields[1].GetString();
    uint32      l_CharacterLoginFlags   = l_Fields[15].GetUInt16();
    uint32      l_CharacterGuildID      = l_Fields[13].GetUInt32();
    uint8       l_CharacterOrder        = l_Fields[21].GetUInt8();
    uint8       l_CharacterLevel        = l_Fields[7].GetUInt8();
    uint64      l_CharacterGuildGuid    = MAKE_NEW_GUID(l_CharacterGuildID, 0, l_CharacterGuildID ? uint32(HIGHGUID_GUILD) : 0);
    Tokenizer   l_CharacterEquipment(l_Fields[19].GetString(), ' ');

    /// Character location
    uint32  l_CharacterZoneID       = l_Fields[8].GetUInt16();
    uint32  l_CharacterMapID        = uint32(l_Fields[9].GetUInt16());
    float   l_CharacterPositionX    = l_Fields[10].GetFloat();
    float   l_CharacterPositionY    = l_Fields[11].GetFloat();
    float   l_CharacterPositionZ    = l_Fields[12].GetFloat();

    uint32  l_HomebindMapID         = uint32(l_Fields[22].GetUInt16());
    uint32  l_HomebindZoneID        = uint32(l_Fields[23].GetUInt16());
    float   l_HomebindMapPositionX  = l_Fields[24].GetFloat();
    float   l_HomebindMapPositionY  = l_Fields[25].GetFloat();
    float   l_HomebindMapPositionZ  = l_Fields[26].GetFloat();

    auto l_RelocateToHomebind = [&]() -> void
    {
        l_CharacterMapID        = l_HomebindMapID;
        l_CharacterZoneID       = l_HomebindZoneID;
        l_CharacterPositionX    = l_HomebindMapPositionX;
        l_CharacterPositionY    = l_HomebindMapPositionY;
        l_CharacterPositionZ    = l_HomebindMapPositionZ;
    };

    if (!sMapStore.LookupEntry(l_CharacterMapID) || l_CharacterLoginFlags & AT_LOGIN_UNLOCK)
        l_RelocateToHomebind();

    uint32 l_PlayerFlags = l_Fields[14].GetUInt32();
    uint32 l_CharacterFlags = 0;

    if (l_PlayerFlags & PLAYER_FLAGS_HIDE_HELM)
        l_CharacterFlags |= CHARACTER_FLAG_HIDE_HELM;

    if (l_PlayerFlags & PLAYER_FLAGS_HIDE_CLOAK)
        l_CharacterFlags |= CHARACTER_FLAG_HIDE_CLOAK;

    if (l_PlayerFlags & PLAYER_FLAGS_GHOST)
        l_CharacterFlags |= CHARACTER_FLAG_GHOST;

    if (l_CharacterLoginFlags & AT_LOGIN_RENAME)
        l_CharacterFlags |= CHARACTER_FLAG_RENAME;

    if (l_Fields[20].GetUInt32())
        l_CharacterFlags |= CHARACTER_FLAG_LOCKED_BY_BILLING;

    /*if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED))
    {
        if (!l_Fields[27].GetString().empty())
            l_CharacterFlags |= CHARACTER_FLAG_DECLINED;
    }
    else
        l_CharacterFlags |= CHARACTER_FLAG_DECLINED;*/

    l_CharacterFlags |= CHARACTER_FLAG_DECLINED;

    if (l_CharacterLoginFlags & AT_LOGIN_LOCKED_FOR_TRANSFER)
        l_CharacterFlags |= CHARACTER_LOCKED_FOR_TRANSFER;

    bool l_CharacterFirstLogin = l_CharacterLoginFlags & AT_LOGIN_FIRST;

    uint32 l_CharacterCustomizationFlags = 0;

    if (l_CharacterLoginFlags & AT_LOGIN_CUSTOMIZE)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_CUSTOMIZE;
    else if (l_CharacterLoginFlags & AT_LOGIN_CHANGE_FACTION)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_FACTION;
    else if (l_CharacterLoginFlags & AT_LOGIN_CHANGE_RACE)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_RACE;

    uint32 l_CharacterPetDisplayId  = 0;
    uint32 l_CharacterPetLevel      = 0;
    uint32 l_CharacterPetFamily     = CREATURE_FAMILY_NONE;

    /// show pet at selection character in character list only for non-ghost character
    if (p_Result && !(l_PlayerFlags & PLAYER_FLAGS_GHOST) && (l_CharacterClass == CLASS_WARLOCK || l_CharacterClass == CLASS_HUNTER || l_CharacterClass == CLASS_DEATH_KNIGHT || l_CharacterClass == CLASS_MAGE))
    {
        uint32 l_PetEntry = l_Fields[16].GetUInt32();

        if (CreatureTemplate const* l_CreatureTemplate = sObjectMgr->GetCreatureTemplate(l_PetEntry))
        {
            l_CharacterPetDisplayId = l_Fields[17].GetUInt32();
            l_CharacterPetLevel     = l_Fields[18].GetUInt16();
            l_CharacterPetFamily    = l_CreatureTemplate->family;
        }
    }

    /// @TODO: Fix ValidateAppearance
    /*std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> l_CustomDisplay;
    l_CustomDisplay[0] = l_Tattoos;
    l_CustomDisplay[1] = l_HornStyle;
    l_CustomDisplay[2] = l_BlindFolds;

    if (!Player::ValidateAppearance(l_CharacterRace, l_CharacterClass, l_CharacterGender, l_CharacterHairStyle, l_CharacterHairColor, l_CharacterFace, l_CharacterFacialHair, l_CharacterSkin, l_CustomDisplay))
    {
        /// Set customize flags
        if ((l_CharacterCustomizationFlags & (CHAR_CUSTOMIZE_FLAG_CUSTOMIZE | CHAR_CUSTOMIZE_FLAG_FACTION | CHAR_CUSTOMIZE_FLAG_RACE)) == 0)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
            stmt->setUInt16(0, uint16(AT_LOGIN_CUSTOMIZE));
            stmt->setUInt64(1, l_Fields[0].GetUInt32());
            CharacterDatabase.Execute(stmt);

            l_CharacterCustomizationFlags |= CHAR_CUSTOMIZE_FLAG_CUSTOMIZE;
        }

        /// Reset invalid appearance data
        l_CharacterSkin       = 0;
        l_CharacterFace       = 0;
        l_CharacterHairStyle  = 0;
        l_CharacterHairColor  = 0;
        l_Tattoos             = 0;
        l_HornStyle           = 0;
        l_BlindFolds          = 0;
        l_CharacterFacialHair = 0;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);
        stmt->setUInt8(0, l_CharacterGender);
        stmt->setUInt32(1, 0);
        stmt->setUInt32(2, 0);
        stmt->setUInt32(3, l_Fields[0].GetUInt32());
        CharacterDatabase.Execute(stmt);
    }*/

    p_Data->appendPackGUID(l_CharacterGuid);                ///< Character GUID
    *p_Data << uint8(l_CharacterOrder);                     ///< List order
    *p_Data << uint8(l_CharacterRace);                      ///< Race
    *p_Data << uint8(l_CharacterClass);                     ///< Class
    *p_Data << uint8(l_CharacterGender);                    ///< Gender
    *p_Data << uint8(l_CharacterSkin);                      ///< Skin
    *p_Data << uint8(l_CharacterFace);                      ///< Face
    *p_Data << uint8(l_CharacterHairStyle);                 ///< Hair style
    *p_Data << uint8(l_CharacterHairColor);                 ///< Hair color
    *p_Data << uint8(l_CharacterFacialHair);                ///< Facial hair
    *p_Data << uint8(l_Tattoos);
    *p_Data << uint8(l_HornStyle);
    *p_Data << uint8(l_BlindFolds);
    *p_Data << uint8(l_CharacterLevel);                     ///< Level
    *p_Data << uint32(l_CharacterZoneID);                   ///< Zone id
    *p_Data << uint32(l_CharacterMapID);                    ///< Map Id
    *p_Data << float(l_CharacterPositionX);                 ///< X
    *p_Data << float(l_CharacterPositionY);                 ///< Y
    *p_Data << float(l_CharacterPositionZ);                 ///< Z
    p_Data->appendPackGUID(l_CharacterGuildGuid);           ///< Character guild GUID
    *p_Data << uint32(l_CharacterFlags);                    ///< Character flags
    *p_Data << uint32(l_CharacterCustomizationFlags);       ///< atLoginFlags
    *p_Data << uint32(0);                                   ///< Flags3
    *p_Data << uint32(l_CharacterPetDisplayId);             ///< Pet DisplayID
    *p_Data << uint32(l_CharacterPetLevel);                 ///< Pet level
    *p_Data << uint32(l_CharacterPetFamily);                ///< Pet family
    *p_Data << uint32(0);                                   ///< Profession 1
    *p_Data << uint32(0);                                   ///< Profession 2

    /// Character visible equipment
    bool l_IsOld = l_CharacterEquipment.size() != (InventorySlots::INVENTORY_SLOT_BAG_END * 3);

    for (uint8 l_EquipmentSlot = 0; l_EquipmentSlot < INVENTORY_SLOT_BAG_END; ++l_EquipmentSlot)
    {
        uint32 l_Visualbase = l_EquipmentSlot * 3;

        /// Every time you change the storage (adding or removing a value from the array), put the ancient loading here
        if (l_IsOld)
        {
            uint64 l_ItemDatas = GetUInt64ValueFromArray(l_CharacterEquipment, l_Visualbase);
            uint32 l_ItemID = ((uint32*)(&l_ItemDatas))[0];
            uint32 l_DisplayID = ((uint32*)(&l_ItemDatas))[1];

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_ItemID);
            if (!l_ItemTemplate)
            {
                *p_Data << uint32(0);                           ///< Item display ID
                *p_Data << uint32(0);                           ///< Enchantment aura ID
                *p_Data << uint8(0);                            ///< Inventory type
                continue;
            }

            SpellItemEnchantmentEntry const* l_ItemEnchantmentEntry = nullptr;

            uint32 l_EnchantmentData = GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 1);

            for (uint8 l_EnchantmentSlot = PERM_ENCHANTMENT_SLOT; l_EnchantmentSlot <= TEMP_ENCHANTMENT_SLOT; ++l_EnchantmentSlot)
            {
                /// Values stored in 2 uint16
                uint32 l_EnchantmentID = 0x0000FFFF & (l_EnchantmentData >> l_EnchantmentSlot * 16);
                if (!l_EnchantmentID)
                    continue;

                l_ItemEnchantmentEntry = sSpellItemEnchantmentStore.LookupEntry(l_EnchantmentID);

                if (l_ItemEnchantmentEntry)
                    break;
            }

            *p_Data << uint32(l_DisplayID ? l_DisplayID : l_ItemTemplate->DisplayInfoID);           ///< Item display ID
            *p_Data << uint32(l_ItemEnchantmentEntry ? l_ItemEnchantmentEntry->ItemVisual : 0);     ///< Enchantment aura ID
            *p_Data << uint8(l_ItemTemplate->InventoryType);                                        ///< Inventory type
        }
        else
        {
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase));
            if (!l_ItemTemplate)
            {
                *p_Data << uint32(0);                           ///< Item display ID
                *p_Data << uint32(0);                           ///< Enchantment aura ID
                *p_Data << uint8(0);                            ///< Inventory type
                continue;
            }

            *p_Data << uint32(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 1)); ///< Item display ID
            *p_Data << uint32(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 2)); ///< Enchantment aura ID
            *p_Data << uint8(l_ItemTemplate->InventoryType);                                    ///< Inventory type
        }
    }

    *p_Data << uint32(0);                                   ///< LastPlayedTime
    *p_Data << uint16(0);                                   ///< SpecID
    *p_Data << uint32(0);                                   ///< Unk 7.0.3 21384 - unk 4 + 4 byte loop
    *p_Data << uint32(0);                                   ///< LastLoginBuild
    *p_Data << uint32(0);                                   ///< Flags4

    p_Data->WriteBits(l_CharacterName.size(), 6);           ///< Character name
    p_Data->WriteBit(true);                                 ///< Is character first login. For some reason that prevent a client wow-error if your locale is russian ...
    p_Data->WriteBit(0);                                    ///< BoostInProgress
    p_Data->WriteBits(0, 5);                                ///< Unk 19508
    p_Data->FlushBits();
    p_Data->WriteString(l_CharacterName);                   ///< Character name

    return true;
}

bool Player::ToggleAFK()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    bool state = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    // afk player not allowed in battleground
#ifndef CROSS
    if (state && InBattleground() && !InArena())
        LeaveBattleground();
#else /* CROSS */
    if (isAFK() && InBattleground() && !InArena())
    {
        if (Battleground* bg = GetBattleground())
        {
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
            bg->RemoveFromInterRealm(GetGUID());
        }
    }
#endif /* CROSS */

    return state;
}

bool Player::ToggleDND()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);

    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
}

uint8 Player::GetChatTag() const
{
    uint8 tag = CHAT_TAG_NONE;

    if (isGMChat())
        tag |= CHAT_TAG_GM;
    if (isDND())
        tag |= CHAT_TAG_DND;
    if (isAFK())
        tag |= CHAT_TAG_AFK;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
        tag |= CHAT_TAG_DEV;

    return tag;
}

bool Player::TeleportTo(uint32 p_MapID, float p_X, float p_Y, float p_Z, float p_O, uint32 p_Options, bool p_AddToTask)
{
    if (p_AddToTask)
    {
        AddMapTask(eTaskType::TaskTeleport, [=]() -> void
        {
            TeleportTo(p_MapID, p_X, p_Y, p_Z, p_O, p_Options, false);
        });
        return true;
    }

    if (!MapManager::IsValidMapCoord(p_MapID, p_X, p_Y, p_Z, p_O))
    {
        sLog->outError(LogFilterType::LOG_FILTER_MAPS, "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
            p_MapID, p_X, p_Y, p_Z, p_O, GetGUIDLow(), GetName(), GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        m_TaskInProgress = false;
        return false;
    }

    if (DisableMgr::IsDisabledFor(DisableType::DISABLE_TYPE_MAP, p_MapID, this))
    {
        sLog->outError(LogFilterType::LOG_FILTER_MAPS, "Player (GUID: %u, name: %s) tried to enter a forbidden map %u", GetGUIDLow(), GetName(), p_MapID);
        SendTransferAborted(p_MapID, TRANSFER_ABORT_MAP_NOT_ALLOWED);
        m_TaskInProgress = false;
        return false;
    }

    /// Preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
    Pet* l_Pet = GetPet();

    MapEntry const* l_MapEntry = sMapStore.LookupEntry(p_MapID);

# ifdef CROSS
    /// Teleport player in original world.
    if (!l_MapEntry->IsBattlegroundOrArena())
    {
        Battleground* l_BG = GetBattleground();
        if (l_BG && l_BG->IsPlayerInBattleground(GetGUID()))
        {
            l_BG->RemovePlayerAtLeave(GetGUID(), false, true);
            l_BG->RemoveFromInterRealm(GetGUID());
        }
        else
        {
            uint64 l_Guid = GetGUID();
            MS::Utilities::CallBackPtr l_CallBack = std::make_shared<MS::Utilities::Callback>([l_Guid](bool p_Success) -> void
            {
                Player* l_Player = sObjectAccessor->FindPlayer(l_Guid);
                if (!l_Player)
                    return;

                if (InterRealmClient* l_Client = l_Player->GetSession()->GetInterRealmClient())
                    l_Client->SendBattlefieldLeave(l_Player->GetRealGUID());

                l_Player->SetNeedRemove(true);
            });

            SaveToDB(false, false, l_CallBack);
        }
        m_TaskInProgress = false;
        return false;
    }
# endif

    /// Don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
    if (!InBattleground() && l_MapEntry->IsBattlegroundOrArena())
    {
        m_TaskInProgress = false;
        return false;
    }

    /// Client without expansion support
    if (GetSession() && (GetSession()->Expansion() < l_MapEntry->Expansion()))
    {
        sLog->outDebug(LogFilterType::LOG_FILTER_MAPS, "Player %s using client without required expansion tried teleport to non accessible map %u", GetName(), p_MapID);

        if (GetTransport())
        {
            m_transport->RemovePassenger(this);
            m_transport = nullptr;
            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
            m_movementInfo.t_time = 0;
            m_movementInfo.t_seat = -1;

            /// Teleport to near graveyard if on transport, looks blizz like :)
            RepopAtGraveyard();
        }

        SendTransferAborted(p_MapID, TRANSFER_ABORT_INSUF_EXPAN_LVL, l_MapEntry->Expansion());
        m_TaskInProgress = false;
        /// Normal client can't teleport to this map...
        return false;
    }
    else
        sLog->outDebug(LogFilterType::LOG_FILTER_MAPS, "Player %s is being teleported to map %u", GetName(), p_MapID);

    if (m_vehicle)
        ExitVehicle();

    /// Reset movement flags at teleport, because player will continue move with these flags after teleport
    SetUnitMovementFlags(GetUnitMovementFlags() & MOVEMENTFLAG_MASK_HAS_PLAYER_STATUS_OPCODE);
    m_movementInfo.ResetJump();
    DisableSpline();

    GetSession()->DoLootRelease(GetLootGUID());

    m_unitsWithMyAuras.clear();

    if (m_transport)
    {
        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_LEAVE_TRANSPORT))
        {
            m_transport->RemovePassenger(this);
            m_transport = nullptr;
            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
            m_movementInfo.t_time = 0;
            m_movementInfo.t_seat = -1;
            m_movementInfo.t_guid = 0;
        }
    }

    /// The player was ported to another map and loses the duel immediately.
    /// We have to perform this check before the teleport, otherwise the
    /// ObjectAccessor won't find the flag.
    if (m_Duel && GetMapId() != p_MapID && GetMap()->GetGameObject(GetGuidValue(EPlayerFields::PLAYER_FIELD_DUEL_ARBITER)))
        DuelComplete(DuelCompleteType::DUEL_FLED);

    /// Save previous location
    m_PreviousLocation = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());

    if (GetMapId() == p_MapID)
    {
        /// Lets reset far teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportFar(false);
        /// Setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());
        /// If teleport spell is casted in Unit::Update() func
        /// Then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetSemaphoreTeleportNear(true);
            /// Lets save teleport destination for player
            m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
            m_teleport_options = p_Options;
            m_TaskInProgress = false;
            return true;
        }

        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_UNSUMMON_PET))
        {
            /// Same map, only remove pet if out of range for new position
            if (l_Pet && !l_Pet->IsWithinDist3d(p_X, p_Y, p_Z, GetMap()->GetVisibilityRange()))
            {
                UnsummonPetTemporaryIfAny();
                UnsummonCurrentBattlePetIfAny(true);
            }
        }

        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_LEAVE_COMBAT))
        {
            CombatStop();
            DeleteThreatList();
            getHostileRefManager().deleteReferences();
        }

        /// This will be used instead of the current location in SaveToDB
        m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
        SetFallInformation(0, p_Z);

        /// Code for finish transfer called in WorldSession::HandleMovementOpcodes()
        /// At client packet CMSG_MOVE_TELEPORT_ACK
        SetSemaphoreTeleportNear(true);

        uint32 l_ZoneId = sMapMgr->GetZoneId(p_MapID, p_X, p_Y, p_Z);

        // Relocate the player to the teleport destination
        Map* l_NewMap = nullptr;

        if (!l_MapEntry->Instanceable() && l_ZoneId != GetZoneId(false))
            l_NewMap = sMapMgr->CreateMap(p_MapID, l_ZoneId, this);

        if (l_NewMap && l_NewMap->CanEnter(this) && l_NewMap != GetMap())
        {
            AddMapTask(eTaskType::TaskSwitchToPhasedMap, [p_MapID, this]() -> void
            {
                Relocate(GetTeleportDest());
                SwitchToPhasedMap(p_MapID);
            });
        }
        else
        {
            /// Near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
            if (!GetSession()->PlayerLogout())
                SendTeleportPacket(m_teleport_dest);
        }

        sScriptMgr->OnTeleport(this, nullptr, false);
        m_TaskInProgress = false;
    }
    else
    {
        /// Pandaria
        if (p_MapID == 870 && getLevel() < 80 && getClass() != Classes::CLASS_MONK && !isGameMaster())
        {
            m_TaskInProgress = false;
            return false;
        }

        /// Deepholm
        if (p_MapID == 646 && getLevel() < 80 && !isGameMaster())
        {
            m_TaskInProgress = false;
            return false;
        }

        if (GetMapId() == 860 && GetTeamId() == TeamId::TEAM_NEUTRAL)
        {
            m_TaskInProgress = false;
            return false;
        }

        /// Far teleport to another map
        Map* l_OldMap = IsInWorld() ? GetMap() : nullptr;
        /// Check if we can enter before stopping combat / removing pet / totems / interrupting spells

        /// Check enter rights before map getting to avoid creating instance copy for player
        /// This check not dependent from map instance copy and same for all instance copies of selected map
        if (!sMapMgr->CanPlayerEnter(p_MapID, this, false))
        {
            m_TaskInProgress = false;
            return false;
        }

        if (GroupPtr l_Group = GetGroup())
        {
            if (l_MapEntry->IsDungeon())
                l_Group->IncrementPlayersInInstance();
            else
                l_Group->DecrementPlayersInInstance();
        }

        /// I think this always returns true. Correct me if I am wrong.
        /// If the map is not created, assume it is possible to enter it.
        /// It will be created in the WorldPortAck.
        /// Lets reset near teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportNear(false);

        /// Setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());

        /// If teleport spell is casted in Unit::Update() func
        /// Then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetSemaphoreTeleportFar(true);

            /// Lets save teleport destination for player
            m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
            m_teleport_options = p_Options;
            m_TaskInProgress = false;
            return true;
        }

        SetSelection(0);
        CombatStop();
        ResetContestedPvP();

        /// Remove player from battleground on far teleport (when changing maps)
        if (Battleground const* l_Battleground = GetBattleground())
        {
            /// Note: at battleground join battleground id set before teleport
            /// And we already will found "current" battleground
            /// Just need check that this is targeted map or leave

            /// Don't teleport to entry point
            if (l_Battleground->GetMapId() != p_MapID)
#ifdef CROSS
            {
#endif /* CROSS */
                LeaveBattleground(false);
#ifdef CROSS
                SetSemaphoreTeleportFar(true);

                /// Lets save teleport destination for player
                m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
                m_teleport_options = p_Options;
                m_TaskInProgress = false;
                return true;
            }
#endif /* CROSS */
        }

        /// Remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
        if (l_MapEntry->IsBattleArena())
        {
            RemoveArenaSpellCooldowns(true);
            RemoveArenaAuras();

            if (l_Pet)
                l_Pet->RemoveArenaAuras();
        }

        /// Remove pet on map change
        if (l_Pet)
            UnsummonPetTemporaryIfAny();

        UnsummonCurrentBattlePetIfAny(true);

        /// Remove stealth on map change
        if (HasAuraType(AuraType::SPELL_AURA_MOD_STEALTH))
        {
            RemoveAurasByType(AuraType::SPELL_AURA_MOD_STEALTH);

            switch (getClass())
            {
                case Classes::CLASS_ROGUE:
                    RemoveSpellCooldown(1784);
                    RemoveSpellCooldown(115191);
                    break;
                case Classes::CLASS_DRUID:
                    RemoveSpellCooldown(5215);
                    break;
                default:
                    break;
            }
        }

        /// Remove all dyn objects and AreaTrigger
        RemoveAllDynObjects();
        RemoveAllAreasTrigger();

        /// Stop spellcasting
        /// Not attempt interrupt teleportation spell at caster teleport
        if (!(p_Options & TeleportToOptions::TELE_TO_SPELL))
        {
            if (IsNonMeleeSpellCasted(true))
                InterruptNonMeleeSpells(true);
        }

        /// Remove auras before removing from map...
        RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_CHANGE_MAP | SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_MOVE | SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_TURNING);

        /// New final coordinates
        float l_FinalX = p_X;
        float l_FinalY = p_Y;
        float l_FinalZ = p_Z;
        float l_FinalO = p_O;

        if (!GetSession()->PlayerLogout())
        {
            /// Send transfer packets
            bool l_TransferSpellID = false;

            WorldPacket l_Data(Opcodes::SMSG_TRANSFER_PENDING, 50);

            l_Data << uint32(p_MapID);
            l_Data << float(m_PreviousLocation.GetPositionX());
            l_Data << float(m_PreviousLocation.GetPositionY());
            l_Data << float(m_PreviousLocation.GetPositionZ());

            l_Data.WriteBit(m_transport != nullptr);
            l_Data.WriteBit(l_TransferSpellID);
            l_Data.FlushBits();

            if (m_transport)
                l_Data << m_transport->GetEntry() << GetMapId();

            if (l_TransferSpellID)
                l_Data << uint32(0);

            GetSession()->SendPacket(&l_Data);
        }

        /// Remove from old map now
        if (l_OldMap)
            l_OldMap->RemovePlayerFromMap(this, false);

        if (GetMap())
            ResetMapForTeleport();

        if (m_transport)
        {
            l_FinalX += m_movementInfo.t_pos.GetPositionX();
            l_FinalY += m_movementInfo.t_pos.GetPositionY();
            l_FinalZ += m_movementInfo.t_pos.GetPositionZ();
            l_FinalO += m_movementInfo.t_pos.GetOrientation();
        }

        m_teleport_dest = WorldLocation(p_MapID, l_FinalX, l_FinalY, l_FinalZ, l_FinalO);
        SetFallInformation(0, l_FinalZ);

        /// If the player is saved before worldportack (at logout for example)
        /// This will be used instead of the current location in SaveToDB
        if (!GetSession()->PlayerLogout())
        {
            WorldPacket l_Data(SMSG_SUSPEND_TOKEN, 5);
            l_Data << uint32(m_movementCounter);
            l_Data.WriteBits(/*options & TELE_TO_SEAMLESS ? 2 : */1, 2);
            l_Data.FlushBits();
            SendDirectMessage(&l_Data);
        }

        /// Move packet sent by client always after far teleport
        /// Code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
        SetSemaphoreTeleportFar(true);
    }

    return true;
}

void Player::SwitchToPhasedMap(uint32 p_MapID, CustomInstanceZone const* p_CustomInstanceZone /*= nullptr*/, std::function<void(Player*)> p_Callback)
{
    MapEntry const* l_MapEntry = sMapStore.LookupEntry(p_MapID);
    if (!l_MapEntry)
    {
        m_TaskInProgress = false;
        return;
    }

    float l_X = GetPositionX();
    float l_Y = GetPositionY();
    float l_Z = GetPositionZ();
    float l_Orientation = GetOrientation();

    Map* l_NewMap = nullptr;

    // Check enter rights before map getting to avoid creating instance copy for player
    // this check not dependent from map instance copy and same for all instance copies of selected map
    if (!sMapMgr->CanPlayerEnter(p_MapID, this, false))
    {
        m_TaskInProgress = false;
        return;
    }

    uint32 l_ZoneId = sMapMgr->GetZoneId(p_MapID, l_X, l_Y, l_Z);

    // Relocate the player to the teleport destination
    l_NewMap = sMapMgr->CreateMap(p_MapID, l_ZoneId, this, p_CustomInstanceZone);
    if (!l_NewMap || !l_NewMap->CanEnter(this))
    {
        m_TaskInProgress = false;
        return;
    }

    if (l_NewMap == GetMap())
    {
        m_TaskInProgress = false;
        return;
    }

    m_IsInMapSwitch = true;

    DuelComplete(DuelCompleteType::DUEL_FLED);

    /// If the player is a vehicle kit (2 seats mount case) save passengers in order to switch them & restore them on the vehicle
    std::vector<std::pair<uint64, uint8>> l_Passengers;
    if (Vehicle* l_VehicleKit = GetVehicleKit())
    {
        for (auto l_Itr : l_VehicleKit->Seats)
        {
            uint64 l_PassengerGuid = l_Itr.second.Passenger;
            if (IS_PLAYER_GUID(l_PassengerGuid))
            {
                Player* l_Passenger = sObjectAccessor->FindPlayer(l_PassengerGuid);
                if (!l_Passenger)
                    continue;

                /// Prevent destroy client-side to make smooth map switch
                l_Passenger->PreventClientDestroy(GetGUID());
                PreventClientDestroy(l_Passenger->GetGUID());

                l_Passengers.push_back(std::make_pair(l_PassengerGuid, l_Itr.first));
            }
        }
    }

    if (GroupPtr l_Group = GetGroup())
    {
        if (l_MapEntry->IsDungeon())
            l_Group->IncrementPlayersInInstance();
        else
            l_Group->DecrementPlayersInInstance();
    }

    SetSelection(0);
    CombatStop();
    ResetContestedPvP();

    GetSession()->DoLootRelease(GetLootGUID());

#ifndef CROSS
    // Remove player from battleground on far teleport (when changing maps)
    if (Battleground const* l_Battleground = GetBattleground())
    {
        if (l_Battleground->GetMapId() != p_MapID)
            LeaveBattleground(false);
    }
#endif

    // Remove pet on map change
    if (Pet* l_Pet = GetPet()) ///< l_Pet is unused
        UnsummonPetTemporaryIfAny();

    UnsummonCurrentBattlePetIfAny(true);

    // Remove all dynamic objects and AreaTrigger
    RemoveAllDynObjects();
    RemoveAllAreasTrigger();

    // Stop spellcasting
    // Not attempt interrupt teleportation spell at caster teleport
    if (IsNonMeleeSpellCasted(true))
        InterruptNonMeleeSpells(true);

    // Remove auras before removing from map...
    if (!sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE))
        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING);

    // Remove from old map now
    if (Map* l_OldMap = IsInWorld() ? GetMap() : NULL)
#ifdef CROSS
    {
        SetMapSwitchDestination(p_MapID);
#endif /* CROSS */
        l_OldMap->RemovePlayerFromMap(this, false);
#ifdef CROSS
    }
#endif /* CROSS */

    m_teleport_dest = WorldLocation(p_MapID, l_X, l_Y, l_Z, l_Orientation);
    SetFallInformation(0, l_Z);

    ResetMapForTeleport();

    m_unitsWithMyAuras.clear();

    uint64 l_Guid = GetGUID();
    l_NewMap->AddTask([l_NewMap, l_Guid, p_MapID, l_Passengers, p_CustomInstanceZone, p_Callback]()->void
    {
        Player* l_Player = sObjectAccessor->FindPlayerInOrOutOfWorld(l_Guid);
        if (!l_Player)
            return;

        WorldLocation const l_NewLoc = l_Player->GetTeleportDest();

        l_Player->Relocate(&l_NewLoc);
        l_Player->SetMap(l_NewMap);

        if (!l_Player->GetSession()->PlayerLogout())
        {
            WorldPacket l_Data(SMSG_NEW_WORLD, 4 + 4 + 4 + 4 + 4 + 4);

            l_Data << uint32(p_MapID);                                              ///< uint32
            l_Data << float(l_Player->GetTeleportDest().GetPositionX());            ///< float
            l_Data << float(l_Player->GetTeleportDest().GetPositionY());            ///< float
            l_Data << float(l_Player->GetTeleportDest().GetPositionZ());            ///< float
            l_Data << float(l_Player->GetTeleportDest().GetOrientation());          ///< float
            l_Data << uint32(NewWorldReason::NEW_WORLD_SEAMLESS);                   ///< Reason
            l_Data << float(0.0f);                                                  ///< MovementOffset Adjusts all pending movement events by this offset
            l_Data << float(0.0f);                                                  ///< MovementOffset Adjusts all pending movement events by this offset
            l_Data << float(0.0f);                                                  ///< MovementOffset Adjusts all pending movement events by this offset

            l_Player->GetSession()->SendPacket(&l_Data);
        }

        l_Player->GetMap()->AddPlayerToMap(l_Player, true);

        /// Near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
        if (l_Player->IsBeingTeleportedNear() && !l_Player->GetSession()->PlayerLogout())
            l_Player->SendTeleportPacket(l_Player->GetTeleportDest());

#ifdef CROSS
        l_Player->SetMapSwitchDestination(-1);
#endif

        // Update zone immediately, otherwise leave channel will cause crash in mtmap
        uint32 l_NewZone, l_NewArea;
        l_Player->GetZoneAndAreaId(l_NewZone, l_NewArea, true);
        l_Player->UpdateZone(l_NewZone, l_NewArea);

        for (uint8 i = 0; i < 9; ++i)
            l_Player->UpdateSpeed(UnitMoveType(i), true);

        // honorless target
        if (l_Player->pvpInfo.inHostileArea)
            l_Player->CastSpell(l_Player, 2479, true);
        // in friendly area
        else if (l_Player->IsPvP() && !l_Player->HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
            l_Player->UpdatePvP(false, false);

        l_Player->ResummonPetTemporaryUnSummonedIfAny();
        l_Player->SummonLastSummonedBattlePet();
        l_Player->RecastCombatAllySpellIfNeeded();

        l_Player->m_IsInMapSwitch = false;
        l_Player->m_TaskInProgress = false;

        p_Callback(l_Player);
    });
}

bool Player::TeleportToBGEntryPoint(bool inter_realm /*= false*/)
{
    if (m_bgData.joinPos.m_mapId == MAPID_INVALID)
        return false;

    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
    return TeleportTo(m_bgData.joinPos, 0);
}

void Player::ProcessDelayedOperations()
{
    if (m_DelayedOperations == 0)
        return;

    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER && _resurrectionData)
    {
        ResurrectPlayer(0.0f, false);

        if (GetMaxHealth() > _resurrectionData->Health)
            SetHealth(_resurrectionData->Health);
        else
            SetFullHealth();

        for (int l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
            SetPower((Powers)l_Power, GetDefaultValuePower((Powers)l_Power));

        if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
            SetPower(POWER_MANA, _resurrectionData->Mana);

        if (uint32 aura = _resurrectionData->Aura)
            CastSpell(this, aura, true, NULL, nullptr, _resurrectionData->GUID);

        SpawnCorpseBones();

        /// Resurrecting - 60s aura preventing client from new res spells
        RemoveAura(160029);
        ClearResurrectRequestData();
    }

    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
        SaveToDB();

    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
        CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);

    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
    {
        if (m_bgData.mountSpell)
        {
            CastSpell(this, m_bgData.mountSpell, true);
            m_bgData.mountSpell = 0;
        }
    }

    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
    {
        if (m_bgData.HasTaxiPath())
        {
            m_taxi.ClearTaxiDestinations(); ///< so we don't go back to starting flight point again
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
            m_bgData.ClearTaxiPath();

            ContinueTaxiFlight();
        }
    }

    if (m_DelayedOperations & DELAYED_BG_GROUP_RESTORE)
    {
        if (GroupPtr g = GetGroup())
            g->SendUpdateToPlayer(GetGUID());
    }

    if (m_DelayedOperations & DELAYED_PET_BATTLE_INITIAL)
    {
        if (PetBattle* l_Battle = sPetBattleSystem->GetBattle(_petBattleId))
        {
            uint8 l_TeamID = l_Battle->Teams[PETBATTLE_TEAM_1]->OwnerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

            PetBattleRequest l_Request;
            memcpy(&l_Request, &l_Battle->PvPMatchMakingRequest, sizeof(PetBattleRequest));

            if (l_TeamID == PETBATTLE_TEAM_2)
            {
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][0], l_Request.TeamPosition[PETBATTLE_TEAM_2][0]);
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][1], l_Request.TeamPosition[PETBATTLE_TEAM_2][1]);
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][2], l_Request.TeamPosition[PETBATTLE_TEAM_2][2]);
            }

            l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[2] = GetMap()->GetHeight(l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[0], l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[1], MAX_HEIGHT);

            GetSession()->SendPetBattleFinalizeLocation(&l_Request);

            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED | UNIT_FLAG_IMMUNE_TO_NPC);
            SetFacingTo(GetAngle(l_Battle->PvPMatchMakingRequest.TeamPosition[!l_TeamID][0], l_Battle->PvPMatchMakingRequest.TeamPosition[!l_TeamID][1]));
            SetRooted(true);

            if (!l_Battle->PvPMatchMakingRequest.IsPvPReady[l_TeamID])
                l_Battle->PvPMatchMakingRequest.IsPvPReady[l_TeamID] = true;

            if (l_Battle->PvPMatchMakingRequest.IsPvPReady[PETBATTLE_TEAM_1] == true && l_Battle->PvPMatchMakingRequest.IsPvPReady[PETBATTLE_TEAM_2] == true)
                l_Battle->Begin();
        }
    }

    if (m_DelayedOperations & DELAYED_LEAVE_GROUP)
        RemoveFromGroup(RemoveMethod::GROUP_REMOVEMETHOD_LEAVE);

    if (m_DelayedOperations & DELAYED_REPUTATION_UPDATE)
        GetReputationMgr().UpdateReputationCriterias();

    //we have executed ALL delayed ops, so clear the flag
    m_DelayedOperations = 0;
}

void Player::AddToWorld()
{
    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be added when logging in
    Unit::AddToWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->AddToWorld();

    if (IsVehicle())
        GetVehicleKit()->Install();
}

void Player::RemoveFromWorld()
{
    // cleanup
    if (IsInWorld())
    {
        ///- Release charmed creatures, unsummon totems and remove pets/guardians
        StopCastingCharm();
        StopCastingBindSight();
        UnsummonPetTemporaryIfAny();
        UnsummonCurrentBattlePetIfAny(true);
        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
    }

    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be removed when logging out
    Unit::RemoveFromWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
    {
        if (m_items[i])
            m_items[i]->RemoveFromWorld();
    }

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        iter->second->RemoveFromWorld();

    if (m_uint32Values)
    {
        if (WorldObject* viewpoint = GetViewpoint())
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s has viewpoint %u %u when removed from world", GetName(), viewpoint->GetEntry(), viewpoint->GetTypeId());
            SetViewpoint(viewpoint, false);
        }
    }
}

void Player::RegenerateAll()
{
    m_regenTimerCount += m_RegenPowerTimer;

    Regenerate(POWER_MANA);
    Regenerate(POWER_FOCUS);
    Regenerate(POWER_ENERGY);

    if (!isInCombat() || IsPolymorphed() || m_baseHealthRegen ||  HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) || HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT))
    {
        m_HealthTimer.Update(m_RegenPowerTimer);

        if (m_HealthTimer.Passed())
        {
            RegenerateHealth();
            m_HealthTimer.Reset();
        }
    }

    for (uint32 l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
    {
        uint32 l_Index = GetPowerIndexByClass(getClass(), l_Power);

        if (l_Index == MAX_POWERS)
            continue;

        if (PowerTypeEntry const* l_Entry = sPowerTypeStore.LookupEntry(l_Power))
        {
            switch (l_Power)
            {
                case POWER_RUNES:
                {
                    // Runes act as cooldowns, and they don't need to send any data
                    int8 l_RuneCoolCount = 0;

                    float l_RuneRegenMultiplier = GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_RUNES);
                    l_RuneRegenMultiplier /= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);

                    while (l_RuneCoolCount < MAX_RECHARGING_RUNES && !m_runes->CooldownOrder.empty() && m_runes->CooldownOrder.size() > l_RuneCoolCount)
                    {
                        uint8 l_RuneIndex = m_runes->CooldownOrder[l_RuneCoolCount];
                        if (!GetRuneCooldown(l_RuneIndex)) ///< impossible case ?
                         continue;

                        uint32 l_CooldownRune = GetRuneCooldown(l_RuneIndex);

                        if (l_CooldownRune > m_RegenPowerTimer * l_RuneRegenMultiplier)
                            SetRuneCooldown(l_RuneIndex, l_CooldownRune - (m_RegenPowerTimer * l_RuneRegenMultiplier));
                        else
                        {
                            SetRuneCooldown(l_RuneIndex, 0);
                            ModifyPower(POWER_RUNES, 1);
                        }
                        l_RuneCoolCount++;
                    }
                    break;
                }
                default:
                {
                    if (l_Entry->RegenerationPeace >= 0.0f || isInCombat())   ///< Negative regens are out of combat only
                        continue;

                    if (!GetPower((Powers)l_Power))
                        continue;

                    IntervalTimer& l_CurrentTimer = m_PowerTimers[l_Index];
                    l_CurrentTimer.Update(m_RegenPowerTimer);

                    if (l_CurrentTimer.Passed())
                    {
                        Regenerate((Powers)l_Power);

                        float l_AbsValue = fabsf(l_Entry->RegenerationPeace);
                        uint32 l_Timer = uint32(l_AbsValue < 1.0f ? 1000.0f / l_AbsValue : 1000.0f);

                        if (l_CurrentTimer.GetInterval() != l_Timer)
                        {
                            l_CurrentTimer.SetInterval(l_Timer);
                            l_CurrentTimer.SetCurrent(0);
                        }

                        if (!GetPower((Powers)l_Power))
                        {
                            if (l_Power == POWER_LUNAR_POWER)
                                l_CurrentTimer.SetInterval(l_Entry->RegenerationDelay - 1);
                            else
                                l_CurrentTimer.SetInterval(l_Entry->RegenerationDelay);

                            l_CurrentTimer.SetCurrent(0);
                        }

                        l_CurrentTimer.Reset();
                    }

                    ///< Blessing Of An'she
                    if (l_Power == POWER_LUNAR_POWER && GetPower((Powers)l_Power) && l_CurrentTimer.GetInterval() == (l_Entry->RegenerationDelay - 1))
                    {
                        l_CurrentTimer.SetInterval(1000);
                        l_CurrentTimer.SetCurrent(0);
                    }
                    break;
                }
            }
        }
    }
    m_RegenPowerTimer = 0;
}

void Player::ResetAllPowerCombatTimers()
{
    for (uint32 l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
    {
        uint32 l_Index = GetPowerIndexByClass(getClass(), l_Power);

        if (l_Index == MAX_POWERS)
            continue;

        if (PowerTypeEntry const* l_Entry = sPowerTypeStore.LookupEntry(l_Power))
        {
            if (l_Entry->RegenerationPeace >= 0.0f)   ///< Negative regens are out of combat only @TODO use the second field instead RegenerationCombat
                continue;

            m_PowerTimers[l_Index].SetInterval(l_Entry->RegenerationDelay);
            m_PowerTimers[l_Index].SetCurrent(0);
        }
    }
}

void Player::Regenerate(Powers power)
{
    int32 maxValue = GetMaxPower(power);
    if (!maxValue)
        return;

    int32 curValue = GetPower(power);

    /// @Todo: possible use of miscvalueb instead of amount
    if (HasAuraTypeWithValue(SPELL_AURA_PREVENT_REGENERATE_POWER, power))
        return;

    /// Skip regeneration for power type we cannot have // Custom MoP script
    uint32 powerIndex = GetPowerIndex(power, getClass());
    if (powerIndex == MAX_POWERS)
        return;

    PowerTypeEntry const* l_PowerType = sPowerTypeStore.LookupEntry(power);
    if (!l_PowerType)
        return;

    float addvalue = l_PowerType->RegenerationPeace < 0.0f ? std::min(l_PowerType->RegenerationPeace, -1.0f) : 0.0f;

    /// Powers now benefit from haste.
    float HastePct = 1.0f + GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + CR_HASTE_MELEE) * GetRatingMultiplier(CR_HASTE_MELEE) / 100.0f;

    /// Power Regeneration is affected by UNIT_FIELD_MOD_TIME_RATE
    float l_ModTimeRatePct = 1.0f;
    if (GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE))
        l_ModTimeRatePct /= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);

    bool l_PreventDefault = false;
    //sScriptMgr->OnPlayerRegenPower(this, power, addvalue, l_PreventDefault);

    if (!l_PreventDefault)
    {
        switch (power)
        {
            /// Regenerate Mana
            case POWER_MANA:
            {
                float ManaIncreaseRate = sWorld->getRate(RATE_POWER_MANA);

                if (isInCombat())
                    addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_RegenPowerTimer) + CalculatePct(0.001f, HastePct));
                else
                    addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_RegenPowerTimer) + CalculatePct(0.001f, HastePct));
                break;
            }
            /// Regenerate Rage
            case POWER_RAGE:
            case POWER_PAIN:
            case POWER_LUNAR_POWER:
            {
                addvalue = !HasAuraType(SPELL_AURA_INTERRUPT_REGEN) ? l_PowerType->RegenerationPeace / HastePct : 0.0f;
                break;
            }
            /// Regenerate Focus & Energy
            case POWER_ENERGY:
            case POWER_FOCUS:
            {
                float l_Haste = 1.0f / GetFloatValue(UNIT_FIELD_MOD_HASTE);
                addvalue = l_PowerType->RegenerationPeace * l_Haste;
                addvalue *= 0.001f * m_RegenPowerTimer + CalculatePct(0.001f, l_Haste);
                break;
            }
            /// Regenerate Runic Power
            case POWER_RUNIC_POWER:
            {
                float RunicPowerDecreaseRate = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
                addvalue = !HasAuraType(SPELL_AURA_INTERRUPT_REGEN) ? (addvalue * RunicPowerDecreaseRate / HastePct) : 0.0f;
                break;
            }
            case POWER_SOUL_SHARDS:
                return;
            default:
                break;
        }
    }

    /// Mana regen calculated in Player::UpdateManaRegen()
    if (power != POWER_MANA && power != POWER_CHI && power != POWER_HOLY_POWER && power != POWER_SOUL_SHARDS)
    {
        AuraEffectList const& ModPowerRegenPCTAuras = GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
        for (AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
            if (Powers((*i)->GetMiscValue()) == power)
                AddPct(addvalue, (*i)->GetAmount());

        // Butchery requires combat for this effect
        if (power != POWER_RUNIC_POWER || isInCombat())
            addvalue += float(GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, power)) * float(((power != POWER_ENERGY) ? m_regenTimerCount : m_RegenPowerTimer) / (5 * IN_MILLISECONDS));
    }

    addvalue *= l_ModTimeRatePct;

    if ((power == POWER_FOCUS || power == POWER_ENERGY) && addvalue < 0.f)
        sLog->outAshran("Player::Regenerate => Power (%u) regen is negative (%.2f)! ", uint32(power), addvalue);

    if (power == POWER_INSANITY && HasAura(194249))
        addvalue = 0;

    if (addvalue < 0.0f)
    {
        if (curValue == 0)
            return;
    }
    else if (addvalue > 0.0f)
    {
        if (curValue == maxValue)
            return;
    }
    else
        return;

    addvalue += m_powerFraction[powerIndex];

    int32 integerValue = uint32(fabs(addvalue));

    if (addvalue < 0.0f)
    {
        if (curValue > integerValue)
        {
            curValue -= integerValue;
            m_powerFraction[powerIndex] = addvalue + integerValue;
        }
        else
        {
            curValue = 0;
            m_powerFraction[powerIndex] = 0;
        }
    }
    else
    {
        curValue += integerValue;

        if (curValue > maxValue)
        {
            curValue = maxValue;
            m_powerFraction[powerIndex] = 0;
        }
        else
            m_powerFraction[powerIndex] = addvalue - integerValue;
    }

    SetPower(power, curValue, true);
}

void Player::RegenerateHealth()
{
    uint64 curValue = GetHealth();
    uint64 maxValue = GetMaxHealth();

    if (curValue >= maxValue)
        return;

    float HealthIncreaseRate = sWorld->getRate(RATE_HEALTH);

    float addvalue = 0.0f;
    bool inFight = isInCombat();

    /// 7.1.5 Build 23420: Added Dampening to health regen (mostly to counter food users in arena) + removed bonus health regen while sitting (checked on retail) SHOULDNT AFFECT POLYMORPH REGEN !!!
    uint32 l_DampeningValue = 0;

    // polymorphed case
    if (IsPolymorphed())
    {
        addvalue = (float)GetMaxHealth() / 3;
        if (AuraEffect* l_DampeningEffect = GetAuraEffect(110310, 0))
            l_DampeningValue = l_DampeningEffect->GetAmount();
    }
    // normal regen case (maybe partly in combat case)
    else if (!inFight || HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
    {
        addvalue = HealthIncreaseRate; ///< addvalue is never read 01/18/16
        if (getLevel() < 15)
            addvalue = (0.20f*((float)GetMaxHealth())/getLevel()*HealthIncreaseRate);
        else
            addvalue = 0.015f*((float)GetMaxHealth())*HealthIncreaseRate;

        AuraEffectList const& mModHealthRegenPct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
        for (AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
            AddPct(addvalue, (*i)->GetAmount());

        addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * 2 * IN_MILLISECONDS / (5 * IN_MILLISECONDS);

        if (inFight)
            ApplyPct(addvalue, GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));

        if (AuraEffect* l_DampeningEffect = GetAuraEffect(110310, 0))
            l_DampeningValue = l_DampeningEffect->GetAmount();
    }

    // always regeneration bonus (including combat)
    addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
    addvalue += m_baseHealthRegen / 2.5f;

    if (addvalue < 0)
        addvalue = 0;

    addvalue = CalculatePct(addvalue, 100 - l_DampeningValue);

    ModifyHealth(int32(addvalue));
}

void Player::ResetAllPowers()
{
    if (getClass() == CLASS_ROGUE || getClass() == CLASS_DRUID)
        ClearComboPoints();

    SetHealth(GetMaxHealth());

    for (int l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
        SetPower((Powers)l_Power, GetDefaultValuePower((Powers)l_Power));
}

bool Player::CanInteractWithQuestGiver(Object* questGiver)
{
    switch (questGiver->GetTypeId())
    {
        case TYPEID_UNIT:
            return GetNPCIfCanInteractWith(questGiver->GetGUID(), UNIT_NPC_FLAG_QUESTGIVER) != NULL;
        case TYPEID_GAMEOBJECT:
            return GetGameObjectIfCanInteractWith(questGiver->GetGUID(), GAMEOBJECT_TYPE_QUESTGIVER) != NULL;
        case TYPEID_PLAYER:
            return isAlive() && questGiver->ToPlayer()->isAlive();
        case TYPEID_ITEM:
            return isAlive();
        default:
            break;
    }
    return false;
}

Creature* Player::GetNPCIfCanInteractWith(uint64 p_Guid, uint32 p_NpcFlagMask)
{
    /// Unit checks
    if (!p_Guid)
        return nullptr;

    if (!IsInWorld())
        return nullptr;

    if (isInFlight())
        return nullptr;

    /// Exist (we need look pets also for some interaction (quest/etc)
    Creature* l_Creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, p_Guid);
    if (!l_Creature)
        return nullptr;

    /// Deathstate checks
    if (!isAlive() && !(l_Creature->GetCreatureTemplate()->type_flags & CreatureTypeFlags::CREATURE_TYPE_FLAG_GHOST_VISIBLE))
        return nullptr;

    /// Alive or spirit healer
    if (!l_Creature->isAlive() && !(l_Creature->GetCreatureTemplate()->type_flags & CreatureTypeFlags::CREATURE_TYPE_FLAG_CAN_INTERACT_WHILE_DEAD))
        return nullptr;

    /// Appropriate npc type
    if (p_NpcFlagMask && !l_Creature->HasFlag(EUnitFields::UNIT_FIELD_NPC_FLAGS, p_NpcFlagMask))
    {
        /// Targetted object doesn't have required flag.
        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_NO_FLAG);

        return nullptr;
    }

    /// Not allow interaction under control, but allow with own pets
    if (l_Creature->GetCharmerGUID())
        return nullptr;

    /// Not enemy
    if (l_Creature->IsHostileTo(this))
        return nullptr;

    /// Not unfriendly
    if (FactionTemplateEntry const* l_FactionTemplate = sFactionTemplateStore.LookupEntry(l_Creature->getFaction()))
    {
        if (l_FactionTemplate->Faction)
        {
            if (FactionEntry const* l_Faction = sFactionStore.LookupEntry(l_FactionTemplate->Faction))
            {
                if (l_Faction->ReputationIndex >= 0 && GetReputationMgr().GetRank(l_Faction) <= ReputationRank::REP_UNFRIENDLY)
                {
                    AuraEffectList const& l_AuraList = GetAuraEffectsByType(AuraType::SPELL_AURA_FORCE_REACTION);

                    for (AuraEffectList::const_iterator l_Iter = l_AuraList.begin(); l_Iter != l_AuraList.end(); ++l_Iter)
                        if ((*l_Iter)->GetSpellEffectInfo() && (*l_Iter)->GetMiscValue() == l_FactionTemplate->Faction && (*l_Iter)->GetSpellEffectInfo()->BasePoints >= ReputationRank::REP_UNFRIENDLY)
                            return l_Creature;
                    return nullptr;
                }
            }
        }
    }

    /// Not too far
    bool l_ByPassDist = false;
    if (l_Creature->IsAIEnabled)
        l_ByPassDist = l_Creature->AI()->CanByPassDistanceCheck();

    if (!l_ByPassDist && !l_Creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return nullptr;

    return l_Creature;
}

Creature* Player::GetNPCIfCanInteractWithFlag2(uint64 guid, uint32 npcflagmask)
{
    // unit checks
    if (!guid)
        return NULL;

    if (!IsInWorld())
        return NULL;

    if (isInFlight())
        return NULL;

    // exist (we need look pets also for some interaction (quest/etc)
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (!creature)
        return NULL;

    // Deathstate checks
    if (!isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_GHOST_VISIBLE))
        return NULL;

    // alive or spirit healer
    if (!creature->isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_CAN_INTERACT_WHILE_DEAD))
        return NULL;

    // appropriate npc type
    if (npcflagmask && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS + 1, npcflagmask))
        return NULL;

    // not allow interaction under control, but allow with own pets
    if (creature->GetCharmerGUID())
        return NULL;

    // not enemy
    if (creature->IsHostileTo(this))
        return NULL;

    // not unfriendly
    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
        if (factionTemplate->Faction)
            if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->Faction))
                if (faction->ReputationIndex >= 0 && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
                    return NULL;

    // not too far
    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return NULL;

    return creature;
}

GameObject* Player::GetGameObjectIfCanInteractWith(uint64 guid, GameobjectTypes type) const
{
    if (GameObject* go = GetMap()->GetGameObject(guid))
    {
        if (go->GetGoType() == type)
        {
            float maxdist;
            switch (type)
            {
                // TODO: find out how the client calculates the maximal usage distance to spellless working
                // gameobjects like guildbanks and mailboxes - 10.0 is a just an abitrary choosen number
                case GAMEOBJECT_TYPE_GUILD_BANK:
                case GAMEOBJECT_TYPE_MAILBOX:
                    maxdist = 10.0f;
                    break;
                case GAMEOBJECT_TYPE_FISHINGHOLE:
                    maxdist = 20.0f+CONTACT_DISTANCE;       // max spell range
                    break;
                case GAMEOBJECT_TYPE_ARTIFACT_FORGE:
                    maxdist = 15.0f;
                    break;
                default:
                    maxdist = INTERACTION_DISTANCE;
                    break;
            }

            if (go->IsWithinDistInMap(this, maxdist))
                return go;

            sLog->outDebug(LOG_FILTER_MAPS, "IsGameObjectOfTypeInRange: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)", go->GetGOInfo()->name.c_str(),
                go->GetGUIDLow(), GetName(), GetGUIDLow(), go->GetDistance(this));
        }
    }
    return NULL;
}

bool Player::IsUnderWater() const
{
    return IsInWater() &&
        GetPositionZ() < (GetBaseMap()->GetWaterLevel(GetPositionX(), GetPositionY())-2);
}

void Player::SetInWater(bool apply)
{
    if (m_isInWater == apply)
        return;

    //define player in water by opcodes
    //move player's guid into HateOfflineList of those mobs
    //which can't swim and move guid back into ThreatList when
    //on surface.
    //TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
    m_isInWater = apply;

    // remove auras that need water/land
    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);

    getHostileRefManager().updateThreatTables();
}

void Player::SendArenaCooldown(uint32 p_SpellID, uint32 p_Cooldown, bool p_IsPassive /*= false*/)
{
    ArenaCooldown l_Cooldown;

    l_Cooldown.SpellID      = p_SpellID;
    l_Cooldown.StartTimeMS  = m_timeSyncClient;

    if (p_IsPassive)
    {
        l_Cooldown.EndPassiveTimeMS = l_Cooldown.StartTimeMS + p_Cooldown;
        l_Cooldown.EndTimeMS        = 0;
    }
    else
    {
        l_Cooldown.EndPassiveTimeMS = 0;
        l_Cooldown.EndTimeMS        = l_Cooldown.StartTimeMS + p_Cooldown;
    }

    ClearDynamicValue(EPlayerDynamicFields::PLAYER_DYNAMIC_FIELD_ARENA_COOLDOWNS);

    SetDynamicStructuredValue(EPlayerDynamicFields::PLAYER_DYNAMIC_FIELD_ARENA_COOLDOWNS, 0, &l_Cooldown);
}

bool Player::IsInAreaTriggerRadius(const AreaTriggerEntry* trigger) const
{
    if (!trigger || GetMapId() != trigger->ContinentID)
        return false;

    if (trigger->Radius > 0.0f)
    {
        // if we have radius check it
        float dist = GetDistance(trigger->Pos[0], trigger->Pos[1], trigger->Pos[2]);
        if (dist > trigger->Radius)
            return false;
    }
    else
    {
        Position center(trigger->Pos[0], trigger->Pos[1], trigger->Pos[2], trigger->BoxYaw);
        if (!IsWithinBox(center, trigger->BoxLength / 2.0f, trigger->BoxWidth / 2.0f, trigger->BoxHeight / 2.0f))
            return false;
    }

    return true;
}

void Player::SetGameMaster(bool p_On)
{
    if (p_On && !(m_ExtraFlags & PLAYER_EXTRA_GM_ON))
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
        setFaction(FACTION_FRIENDLY);
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* l_Pet = GetPet())
        {
            l_Pet->setFaction(FACTION_FRIENDLY);
            l_Pet->getHostileRefManager().setOnlineOfflineState(false);
        }

        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        ResetContestedPvP();

        getHostileRefManager().setOnlineOfflineState(false);
        CombatStopWithPets();

        SetPhaseMask(uint32(PHASEMASK_ANYWHERE), false);    // see and visible in all phases
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
    else if (!p_On && m_ExtraFlags & PLAYER_EXTRA_GM_ON)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_ON;
        setFactionForRace(getRace());
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* l_Pet = GetPet())
        {
            l_Pet->setFaction(getFaction());
            l_Pet->getHostileRefManager().setOnlineOfflineState(true);
        }

        // restore FFA PvP Server state
        if (sWorld->IsFFAPvPRealm())
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);

        // restore FFA PvP area state, remove not allowed for GM mounts
        UpdateArea(m_areaUpdateId);

        getHostileRefManager().setOnlineOfflineState(true);
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);

        phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_SERVERSIDE_CHANGED);
        phaseMgr.Update();
    }

    UpdateObjectVisibility();

    if (InstanceScript* l_Instance = GetInstanceScript())
        l_Instance->UpdateCreatureGroupSizeStats();

    GetMap()->SendInstanceGroupSizeChanged();
}

void Player::SetGMVisible(bool on)
{
    if (on)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_INVISIBLE;         //remove flag
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
    }
    else
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_INVISIBLE;          //add flag

        SetAcceptWhispers(false);
        SetGameMaster(true);

        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
}

bool Player::IsGroupVisibleFor(Player const* p) const
{
    switch (sWorld->getIntConfig(CONFIG_GROUP_VISIBILITY))
    {
        default: return IsInSameGroupWith(p);
        case 1:  return IsInSameRaidWith(p);
        case 2:  return GetTeam() == p->GetTeam();
    }
}

bool Player::IsInSameGroupWith(Player const* p) const
{
    GroupPtr l_Group = GetGroup();
    return p == this || (l_Group != NULL &&
        l_Group == p->GetGroup() &&
        l_Group->SameSubGroup(this, p));
}

///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
/// \todo Shouldn't we also check if there is no other invitees before disbanding the group?
void Player::UninviteFromGroup()
{
    uint32 groupGUID = GetGroupInvite();
    if (!groupGUID)
        return;

    GroupPtr group = sGroupMgr->GetGroupByGUID(groupGUID);
    if (!group)
        return;

    group->RemoveInvite(this);

    if (group->GetMembersCount() <= 1)                       // group has just 1 member => disband
    {
        if (group->IsCreated())
        {
            group->Disband(true);
        }
        else
        {
            group->RemoveAllInvites();

            if (group->GetDbStoreId())
            {
                sLog->outExtChat("#jarvis", "danger", true, "Try to delete a group without remove it from the group db store");
                sGroupMgr->FreeGroupDbStoreId(group);
            }
        }
    }
}

void Player::RemoveFromGroup(GroupPtr group, uint64 guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
{
    if (group)
    {
        group->RemoveMember(guid, method, kicker, reason);
        group = NULL;
    }
}

void Player::SendLogXPGain(uint32 GivenXP, Unit* victim, uint32 BonusXP, bool recruitAFriend, float group_rate)
{
    WorldPacket data(SMSG_LOG_XP_GAIN);

    ObjectGuid victimGuid = victim ? victim->GetGUID() : 0;
    data.appendPackGUID(victimGuid);
    data << uint32(GivenXP + BonusXP);  ///< Amount
    data << uint8(victim ? 0 : 1);      ///< 00-kill_xp type, 01-non_kill_xp type
    data << uint32(GivenXP);            ///< Original
    data << float(group_rate);          ///< Group bonus
    data << uint8(recruitAFriend);      ///< Refer A Friend
    data.FlushBits();

    GetSession()->SendPacket(&data);
}

void Player::GiveXP(uint32 xp, Unit* victim, float group_rate)
{
    if (xp < 1)
        return;

    if (!isAlive() && !GetBattlegroundId())
        return;

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
        return;

    uint8 level = getLevel();

    sScriptMgr->OnGivePlayerXP(this, xp, victim);

    // XP to money conversion processed in Player::RewardQuest
    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    // Favored experience increase START
    uint32 zone = GetZoneId();
    float favored_exp_mult = 0;
    if ((HasAura(32096) || HasAura(32098)) && (zone == 3483 || zone == 3562 || zone == 3836 || zone == 3713 || zone == 3714))
        favored_exp_mult = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
    xp = uint32(xp * (1 + favored_exp_mult));
    // Favored experience increase END


    // VIP xp reward
    if (GetSession()->IsPremium())
        xp *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);

    uint32 bonus_xp = 0;
    bool recruitAFriend = HasAura(eRecruitAFriendConstants::TrackerSpell);

    // RaF does NOT stack with rested experience
    if (recruitAFriend)
        bonus_xp = sRecruitAFriendMgr->GetFloatConstant(eRecruitAFriendConstants::RateXP) * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
    else
        bonus_xp = victim ? GetXPRestBonus(xp) : 0; // XP resting bonus

    SendLogXPGain(xp, victim, bonus_xp, recruitAFriend, group_rate);

    uint32 curXP = GetUInt32Value(PLAYER_FIELD_XP);
    uint32 nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    uint32 newXP = curXP + xp + bonus_xp;

    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        newXP -= nextLvlXP;

        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            GiveLevel(level + 1);

        level = getLevel();
        nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    }

    SetUInt32Value(PLAYER_FIELD_XP, newXP);
}

/// Todo update it for 7.0.3
// Give xp when gathering herbalism and mining
// Formulas found here : http://www.wowwiki.com/Formulas:Gather_XP
void Player::GiveGatheringXP()
{
    uint32 level = getLevel();
    uint32 gain = 0;

    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    if (level < 50)
        gain = 12.76f * level;
    else if (level > 49 && level < 60)
        gain = 25 * level - 550;
    else if (level > 59 && level < 70)
        gain = 20 * level - 200;
    else if (level > 69 && level < 80)
        gain = 100 * level - 6600;
    else if (level > 79 && level < 85)
        gain = 750 * level - 58250;
    else if (level > 84 && level < 90)
        gain = 1720 * level - 138800; // (7400 - 14280),  Guessed, @TODO : find blizzlike formula (7400 - 14280)
    else if (level > 89 && level < 95)
        gain = -225 * level + 23100;
    else if (level > 94 && level < 100)
        gain = -228 * level + 24512;    ///< Guessed
    else if (level > 101 && level < 109)
        gain = -228 * level + 24512;    ///< TODO

    float GatheringXpRate = 1;
    GatheringXpRate = sWorld->getRate(RATE_XP_GATHERING);

    gain *= GatheringXpRate;
    GiveXP(gain, nullptr);
}

// Update player to next level
// Current player experience not update (must be update by caller)
void Player::GiveLevel(uint8 level, bool p_Boosted /*= false*/)
{
    uint8 oldLevel = getLevel();
    if (level == oldLevel)
        return;

    if (level == 110 && !p_Boosted)
        sRecruitAFriendMgr->AddEvent(eRecruitAFriendMgrEvents::EventPlayerLevelMax, GetRealGUID());

    /// Reset MMR values
    for (uint8 l_I = 0; l_I < (uint8)BattlegroundBracketType::Max; ++l_I)
    {
        SetArenaPersonalRating(l_I, sWorld->getIntConfig(WorldIntConfigs::CONFIG_ARENA_START_PERSONAL_RATING));
        SetArenaMatchMakerRating(l_I, sWorld->getIntConfig(WorldIntConfigs::CONFIG_ARENA_START_MATCHMAKER_RATING));
    }

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, basehp, basemana);

    // send levelup info to client
    WorldPacket data(SMSG_LEVELUP_INFO, 100);

    data << uint32(level);
    data << uint32(int32(basehp) - int32(GetCreateHealth()));

    {
        data << uint32(GetPowerIndex(POWER_MANA, getClass()) == MAX_POWERS ? 0 : int32(basemana) - int32(GetCreateMana()));

        for (uint32 l_I = 1; l_I < MAX_POWERS_PER_CLASS; ++l_I)
            data << uint32(0);
    }

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)       // Stats loop (0-4)
        data << uint32(int32(info.stats[i]) - GetCreateStat(Stats(i)));

    uint32 const* l_RowLevels = (getClass() != CLASS_DEATH_KNIGHT) ? DefaultTalentRowLevels : DKTalentRowLevels;

    data << uint32(std::find(l_RowLevels, l_RowLevels + MAX_TALENT_TIERS, level) != (l_RowLevels + MAX_TALENT_TIERS));

    GetSession()->SendPacket(&data);

    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(level));

    //update level, max level of skills
    m_Played_time[PLAYED_TIME_LEVEL] = 0;                   // Level Played Time reset

    SetLevel(level);

    /// TO DO: repair WQ unlock. Should be added after https://ru.wowhead.com/quest=43341 completion
    if (level >= 98)
    {
        m_WorldQuestMgr->OnLogin();

        AchievementEntry const* l_AchievementEntry = sAchievementStore.LookupEntry(11473); ///< WQ Unlock hidden achievement
        if (!l_AchievementEntry)
            return;

        CompletedAchievement(l_AchievementEntry);
    }

    UpdateSkillsForLevel();
    LearnDefaultSkills();
    LearnSpecializationSpells();

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);
    SetCreateMana(basemana);

    InitTalentForLevel();
    InitTaxiNodesForLevel();

    UpdateAllStats();

    if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
       UpdateSkillsToMaxSkillsForLevel();

    RescaleAllItemsIfNeeded();

    // Refresh amount of all auras (aura which use scaling for basepoint calcul need to be refresh at level up ...)
    AuraApplicationMap const& l_AppliedAuras =  GetAppliedAuras();
    for (AuraApplicationMap::const_iterator i = l_AppliedAuras.begin(); i != l_AppliedAuras.end(); ++i)
        i->second->GetBase()->RecalculateAmountOfEffects(true);

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
    SetPower(POWER_FOCUS, 0);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();

#ifndef CROSS
    if (MailLevelReward const* mailReward = sObjectMgr->GetMailLevelReward(level, getRaceMask(), getClassMask()))
    {
        int loc_idx = GetSession()->GetSessionDbLocaleIndex();

        std::string subject = mailReward->subject;
        std::string body = mailReward->body;

        if (loc_idx >= 0)
        {
            if (MailRewardLocale const* loc = sObjectMgr->GetMailRewardLocale(mailReward->entry))
            {
                ObjectMgr::GetLocaleString(loc->subject, loc_idx, subject);
                ObjectMgr::GetLocaleString(loc->body, loc_idx, body);
            }
        }

        MailDraft draft(subject, body);

        if (mailReward->gold)
            draft.AddMoney(uint64(mailReward->gold));

        SQLTransaction trans = CharacterDatabase.BeginTransaction();

        for (uint32 itemId : mailReward->items)
        {
            if (Item* item = Item::CreateItem(itemId, 1, this))
            {
                item->SaveToDB(trans);
                draft.AddItem(item);
            }
        }

        draft.SendMailTo(trans, this, MailSender(MAIL_CREATURE, MailLevelReward::Sender));
        CharacterDatabase.CommitTransaction(trans);
    }
#endif

    UpdateCriteria(CRITERIA_TYPE_REACH_LEVEL);
    UpdateCriteria(CRITERIA_TYPE_REACH_LEVEL_2, getLevel());

    /// Refer-A-Friend
    if (GetSession()->GetRecruiterId())
    {
        if (level < sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
        {
            if (level % 2 == 0)
            {
                ++m_grantableLevels;

                if (!HasByteFlag(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_RAF_GRANTABLE_LEVEL, 0x01))
                    SetByteFlag(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_RAF_GRANTABLE_LEVEL, 0x01);
            }
        }
    }

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddConditionType(CONDITION_LEVEL);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    if (level == 85)
    {
        uint32 idQuest;
        if (GetTeam() == ALLIANCE)
        {
            idQuest = 29547;
        }
        else
            idQuest = 29611;

        Quest const* quest = sObjectMgr->GetQuestTemplate(idQuest);
        if (quest)
            AddQuest(quest, NULL);
    }
    else if (level == 90 && GetQuestStatus(36881) == QUEST_STATUS_NONE)
    {
        if (Quest const* l_Quest = sObjectMgr->GetQuestTemplate(36881)) // Add quest for starting WoD missions and go to Draenor
        {
            if (GetQuestStatus(36881) == QUEST_STATUS_NONE || GetQuestStatus(36881) == QUEST_STATUS_FAILED)
                AddQuest(l_Quest, NULL);
        }
    }

    sScriptMgr->OnPlayerLevelChanged(this, oldLevel);

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->OnOwnerLevelChange(level);
#endif

    if (IsMaxLevel())
    {
        /// Start honor level at 1 when level 110 is reached
        if (!GetHonorLevel())
            GiveHonorLevel();
    }
}

void Player::InitStatsForLevel(bool reapplyMods)
{
    if (reapplyMods)                                        //reapply stats values only on .reset stats (level) command
        _RemoveAllStatBonuses();

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), basehp, basemana);

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);

    SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));

    // reset before any aura state sources (health set/aura apply)
    SetUInt32Value(UNIT_FIELD_AURA_STATE, 0);

    UpdateSkillsForLevel();

    // set default cast time multiplier
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_TIME_RATE, 1.0f);
    SetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, 0.0f);
    SetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, 0.0f);

    // reset size before reapply auras
    SetObjectScale(1.0f);

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);

    //set create powers
    SetCreateMana(basemana);

    SetArmor(int32(m_createStats[STAT_AGILITY]*2));

    InitStatBuffMods();

    //reset rating fields values
    for (uint16 index = PLAYER_FIELD_COMBAT_RATINGS; index < PLAYER_FIELD_COMBAT_RATINGS + MAX_COMBAT_RATING; ++index)
        SetUInt32Value(index, 0);

    SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, 0);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_DONE_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_PERIODIC_HEALING_DONE_PERCENT, 1.0f);
    for (uint8 i = 0; i < 7; ++i)
    {
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i, 0);
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, 0);
        SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT+i, 1.00f);
    }

    SetFloatValue(PLAYER_FIELD_MOD_SPELL_POWER_PERCENT, 1.0f);

    //reset attack power, damage and attack speed fields
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME, 2000.0f);
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 1, 2000.0f); // offhand attack time
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME, 2000.0f);

    for (uint8 i = 0; i < WeaponAttackType::MaxAttack; ++i)
    {
        m_WeaponDamage[i][MINDAMAGE] = 0.0f;
        m_WeaponDamage[i][MAXDAMAGE] = 0.0f;
    }

    SetFloatValue(UNIT_FIELD_MIN_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE, 0.0f);
    for (uint8 l_WeaponAttackType = WeaponAttackType::BaseAttack; l_WeaponAttackType < WeaponAttackType::MaxAttack; l_WeaponAttackType++)
    {
        SetFloatValue(PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS       + l_WeaponAttackType, 1.0f);
        SetFloatValue(PLAYER_FIELD_WEAPON_ATK_SPEED_MULTIPLIERS + l_WeaponAttackType, 1.0f);
    }

    SetInt32Value(UNIT_FIELD_ATTACK_POWER,            0);
    SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, 0.0f);
    SetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER,     0);
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, 0.0f);

    // Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    SetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE, 0.0f);

    for (uint8 l_I = 0; l_I < PlayerAvgItemLevelOffsets::MaxAvgItemLevel; l_I++)
        SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + l_I, 0.0f);

    SetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE, 0.0f);

    SetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE, 0.0f);

    // Static 30% damage blocked
    SetUInt32Value(PLAYER_FIELD_SHIELD_BLOCK, 30);

    // Dodge percentage
    SetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE, 0.0f);

    // set armor (resistance 0) to original value (create_agility*2)
    SetArmor(int32(m_createStats[STAT_AGILITY]*2));
    SetResistanceBuffMods(SpellSchools(0), true, 0.0f);
    SetResistanceBuffMods(SpellSchools(0), false, 0.0f);
    // set other resistance to original value (0)
    for (uint8 i = 1; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetResistance(SpellSchools(i), 0);
        SetResistanceBuffMods(SpellSchools(i), true, 0.0f);
        SetResistanceBuffMods(SpellSchools(i), false, 0.0f);
    }

    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, 0);
    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE, 0);
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetUInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i, 0);
        SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i, 0.0f);
    }
    // Reset no reagent cost field
    for (uint8 i = 0; i < 3; ++i)
        SetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK + i, 0);
    // Init data for form but skip reapply item mods for form
    InitDataForForm(reapplyMods);

    // save new stats
    for (uint8 i = POWER_MANA; i < MAX_POWERS; ++i)
        UpdateMaxPower(Powers(i));

    SetMaxHealth(basehp);                     // stamina bonus will applied later
    m_HealthTimer.SetInterval(2000);

    // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
    SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, 0);

    // cleanup unit flags (will be re-applied if need at aura load).
    RemoveFlag(UNIT_FIELD_FLAGS,
        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_REMOVE_CLIENT_CONTROL | UNIT_FLAG_NOT_ATTACKABLE_1 |
        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
        UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
        UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
        UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
        UNIT_FLAG_SKINNABLE      | UNIT_FLAG_MOUNT        | UNIT_FLAG_TAXI_FLIGHT      );
    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);   // must be set

    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);// must be set

    // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK | PLAYER_FLAGS_DND | PLAYER_FLAGS_GM | PLAYER_FLAGS_GHOST | PLAYER_ALLOW_ONLY_ABILITY);

    RemoveStandFlags(UNIT_STAND_FLAGS_ALL);                 // one form stealth modified bytes
    RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP | UNIT_BYTE2_FLAG_SANCTUARY);

    // restore if need some important flags
    SetUInt32Value(PLAYER_FIELD_OVERRIDE_SPELLS_ID, 0);                 // flags empty by default


    if (reapplyMods)                                        // reapply stats values only on .reset stats (level) command
        _ApplyAllStatBonuses();

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();

    for (int l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
        SetPower((Powers)l_Power, GetDefaultValuePower((Powers)l_Power));

    /// All players have 15% of expertise, even if it's hidden stat
    /// https://worldofwarcraft.com/en-us/news/20629899/world-of-warcraft-7-2-the-tomb-of-sargeras-patch-notes
    SetFloatValue(PLAYER_FIELD_MAINHAND_EXPERTISE, 20.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_EXPERTISE, 20.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_EXPERTISE, 20.0f);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();
}

void Player::SendKnownSpells()
{
    /// WPP have two loop one for KnownSpellsCount but another too for FavoriteSpellsCount
    uint32 l_SpellCount = 0;

    WorldPacket l_Data(SMSG_SEND_KNOWN_SPELLS, 25 * 1024);

    l_Data.WriteBit(1);              ///< InitialLogin

    l_Data.FlushBits();

    l_Data << uint32(l_SpellCount); ///< KnownSpellsCount
    l_Data << uint32(0);            ///< FavoriteSpellsCount

    /// spell count placeholder
    for (PlayerSpellMap::const_iterator l_It = m_spells.begin(); l_It != m_spells.end(); ++l_It)
    {
        if (!l_It->second)
            continue;

        if (l_It->second->state == PlayerSpellState::PLAYERSPELL_REMOVED
            || l_It->second->state == PlayerSpellState::PLAYERSPELL_TEMPORARY)
            continue;

        if (!l_It->second->active || l_It->second->disabled)
            continue;

        if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_It->first))
            if (IsArtifactSpell(l_SpellInfo->Id) && l_SpellInfo->IsPassive())
                continue;

        l_Data << uint32(l_It->first);

        ++l_SpellCount;
    }

    l_Data.wpos(1);
    l_Data << uint32(l_SpellCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::RemoveMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->messageID == id)
        {
            //do not delete item, because Player::removeMail() is called when returning mail to sender.
            m_mail.erase(itr);
            return;
        }
    }
}

void Player::SendMailResult(uint32 p_MailID, MailResponseType p_MailAction, MailResponseResult p_MailError, uint32 p_EquipError, uint32 p_ItemGuid, uint32 p_ItemCount)
{
    WorldPacket l_Data(SMSG_SEND_MAIL_RESULT, 4 * 6);

    l_Data << uint32(p_MailID);
    l_Data << uint32(p_MailAction);
    l_Data << uint32(p_MailError);
    l_Data << uint32(p_EquipError);
    l_Data << uint32(p_ItemGuid);
    l_Data << uint32(p_ItemCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendNewMail()
{
    // deliver undelivered mail
    WorldPacket l_Data(SMSG_RECEIVED_MAIL, 4);
    l_Data << float(0.0f);

    GetSession()->SendPacket(&l_Data);
}

void Player::UpdateNextMailTimeAndUnreads()
{
    // calculate next delivery time (min. from non-delivered mails
    // and recalculate unReadMail
    time_t cTime = time(NULL);
    m_nextMailDelivereTime = 0;
    unReadMails = 0;
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->deliver_time > cTime)
        {
            if (!m_nextMailDelivereTime || m_nextMailDelivereTime > (*itr)->deliver_time)
                m_nextMailDelivereTime = (*itr)->deliver_time;
        }
        else if (((*itr)->checked & MAIL_CHECK_MASK_READ) == 0)
            ++unReadMails;
    }
}

void Player::AddNewMailDeliverTime(time_t deliver_time)
{
    if (deliver_time <= time(NULL))                          // ready now
    {
        ++unReadMails;
        SendNewMail();
    }
    else                                                    // not ready and no have ready mails
    {
        if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
            m_nextMailDelivereTime = deliver_time;
    }
}

bool Player::addSpell(uint32 spellId, bool active, bool learning, bool dependent, bool disabled, bool loading /*= false*/, bool p_IsMountFavorite, bool p_LearnBattlePet, bool p_FromShopItem, uint32 fromSkill, bool p_ByPassSpec)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
        return false;

    if (loading && spellInfo->m_IsPVPTalent)
    {
        removeSpell(spellId);
        return false;
    }

    if (spellId == 781 && disabled)
        int test = 0;

    if (sSpellMgr->IsSpellForbidden(spellId) && !isGameMaster() && sWorld->getBoolConfig(CONFIG_SPELL_FORBIDDEN))
    {
#ifndef CROSS
        std::string banString;
        banString = "Auto-ban for spell cheat ";
        char buff[2048];

        sprintf(buff, "(spellId : %u)", (uint32)spellId);
        banString += buff;
        sWorld->BanAccount(BAN_CHARACTER, GetName(), "-1", banString, "Auto-Ban");
#endif
        return false;
    }

    /// Prevent load of incorrect passives / spells
    if (!p_ByPassSpec)
    {
        if (!spellInfo->SpecializationIdList.empty() && std::find(spellInfo->SpecializationIdList.begin(), spellInfo->SpecializationIdList.end(), GetActiveSpecializationID()) == spellInfo->SpecializationIdList.end()
            && spellInfo->Id != 674)    ///< Ambidextrie hackfix, removed at spec switch (rogue))
            return false;
    }

    /// - Remove non authorized spell (learned when system was buggede)
    if ((spellInfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && (getRaceMask() & uint64(RACEMASK_HORDE)) == 0)
        || (spellInfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && (getRaceMask() & uint64(RACEMASK_ALLIANCE)) == 0))
        return false;

    // Validate profession
    if (loading)
    {
        SkillLineAbilityMapBounds spellBounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellInfo->Id);
        for (SkillLineAbilityMap::const_iterator spell_idx = spellBounds.first; spell_idx != spellBounds.second; ++spell_idx)
        {
            if (!IsProfessionSkill(spell_idx->second->SkillLine))
                continue;

            if (!HasSkill(spell_idx->second->SkillLine) || !GetSkillValue(spell_idx->second->SkillLine))
                disabled = true;
        }
    }

    PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    bool dependent_set = false;
    bool disabled_case = false;

    PlayerSpellMap::iterator itr = m_spells.find(spellId);

    // Remove temporary spell if found to prevent conflicts
    if (itr != m_spells.end() && itr->second->state == PLAYERSPELL_TEMPORARY)
        RemoveTemporarySpell(spellId);
    else if (itr != m_spells.end())
    {
        uint32 next_active_spell_id = 0;
        // fix activate state for non-stackable low rank (and find next spell for !active case)
        if (spellInfo->IsRanked())
        {
            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
            {
                if (HasSpell(next))
                {
                    // high rank already known so this must !active
                    active = false;
                    next_active_spell_id = next;
                }
            }
        }

        // not do anything if already known in expected state
        if (itr->second->state != PLAYERSPELL_REMOVED && itr->second->active == active &&
            itr->second->dependent == dependent && itr->second->disabled == disabled)
        {
            if (!IsInWorld() && !learning)                   // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;

            return false;
        }

        // dependent spell known as not dependent, overwrite state
        if (itr->second->state != PLAYERSPELL_REMOVED && !itr->second->dependent && dependent)
        {
            itr->second->dependent = dependent;
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            dependent_set = true;
        }

        // update active state for known spell
        if (itr->second->active != active && itr->second->state != PLAYERSPELL_REMOVED && !itr->second->disabled)
        {
            itr->second->active = active;

            if (!IsInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;
            else if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;

            if (active)
            {
                if (spellInfo->IsPassive() && IsNeedCastPassiveSpellAtLearn(spellInfo))
                    CastSpell (this, spellId, true);
            }
            else if (IsInWorld())
            {
                if (next_active_spell_id)
                {
                    // update spell ranks in spellbook and action bar
                    WorldPacket l_Data(SMSG_SUPERCEDED_SPELLS);
                    l_Data << uint32(1);                    ///< SpellCount
                    l_Data << uint32(1);                    ///< SupercededCount
                    l_Data << uint32(0);                    ///< Favorite
                    l_Data << uint32(next_active_spell_id); ///< SpellID
                    l_Data << uint32(spellId);              ///< Superceded
                    GetSession()->SendPacket(&l_Data);
                }
                else
                {
                    WorldPacket data(SMSG_UNLEARNED_SPELLS, 4 + 4);
                    data << uint32(1);                      ///< UnlearnedSpellCount
                    data << uint32(spellId);                ///< SpellID
                    data.WriteBit(0);                       ///< Favorite
                    GetSession()->SendPacket(&data);
                }
            }

            return active;  ///< learn (show in spell book if active now)
        }

        if (itr->second->disabled != disabled && itr->second->state != PLAYERSPELL_REMOVED)
        {
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            itr->second->disabled = disabled;

            if (disabled)
                return false;

            disabled_case = true;
        }
        else switch (itr->second->state)
        {
            case PLAYERSPELL_UNCHANGED:                     // known saved spell
                return false;
            case PLAYERSPELL_REMOVED:                       // re-learning removed not saved spell
            {
                delete itr->second;
                m_spells.erase(itr);
                state = PLAYERSPELL_CHANGED;
                break;                                      // need re-add
            }
            default:                                        // known not saved yet spell (new or modified)
            {
                // can be in case spell loading but learned at some previous spell loading
                if (!IsInWorld() && !learning && !dependent_set)
                    itr->second->state = PLAYERSPELL_UNCHANGED;

                return false;
            }
        }
    }

    if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
    {
        // non talent spell: learn low ranks (recursive call)
        if (uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spellId))
        {
            if (!IsInWorld() || disabled)                    // at spells loading, no output, but allow save
                addSpell(prev_spell, active, true, true, disabled);
            else                                            // at normal learning
                learnSpell(prev_spell, true);
        }

        PlayerSpell* newspell = new PlayerSpell;
        newspell->state           = state;
        newspell->active          = active;
        newspell->dependent       = dependent;
        newspell->disabled        = disabled;
        newspell->IsMountFavorite = p_IsMountFavorite;
        newspell->FromShopItem    = p_FromShopItem;
        newspell->ByPassSpec      = p_ByPassSpec;

        // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
        if (newspell->active && !newspell->disabled && spellInfo->IsRanked() != 0)
        {
            WorldPacket l_Data(SMSG_SUPERCEDED_SPELLS);

            uint32 bitCount = 0;
            ByteBuffer l_DataBuffer;

            for (PlayerSpellMap::iterator l_Iter = m_spells.begin(); l_Iter != m_spells.end(); ++l_Iter)
            {
                if (l_Iter->second->state == PLAYERSPELL_REMOVED)
                    continue;

                SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Iter->first);
                if (!l_SpellInfo)
                    continue;

                if (spellInfo->IsDifferentRankOf(l_SpellInfo))
                {
                    if (l_Iter->second->active)
                    {
                        if (spellInfo->IsHighRankOf(l_SpellInfo))
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                l_DataBuffer << uint32(spellId);
                                l_DataBuffer << uint32(l_Iter->first);
                            }

                            // mark old spell as disable (SMSG_SUPERCEDED_SPELLS replace it in client by new)
                            l_Iter->second->active = false;
                            if (l_Iter->second->state != PLAYERSPELL_NEW)
                                l_Iter->second->state = PLAYERSPELL_CHANGED;
                        }
                        else
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                l_DataBuffer << uint32(l_Iter->first);
                                l_DataBuffer << uint32(spellId);
                            }

                            // mark new spell as disable (not learned yet for client and will not learned)
                            newspell->active = false;
                            if (newspell->state != PLAYERSPELL_NEW)
                                newspell->state = PLAYERSPELL_CHANGED;
                        }
                    }
                }
            }

            l_Data << uint32(bitCount);
            l_Data << uint32(bitCount);
            l_Data << uint32(0);    ///< Favorite

            if (l_DataBuffer.size())
                l_Data.append(l_DataBuffer);

            GetSession()->SendPacket(&l_Data);
        }

        m_spells[spellId] = newspell;

        /// WoD Custom Fix : Firebolt just for Fire specialization
        if (spellId == 133 && GetActiveSpecializationID() != SPEC_MAGE_FIRE)
            newspell->disabled = true;

        // return false if spell disabled
        if (newspell->disabled)
            return false;
    }

    // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
    // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
    if (!loading && sSpellMgr->IsTalent(spellInfo->Id) && spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
    {
        // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
        CastSpell(this, spellId, true);
    }
    // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
    else if (spellInfo->IsPassive())
    {
        /// Areatrigger creation must be delayed during loading - Player not in world yet
        if (spellInfo->HasEffect(SpellEffects::SPELL_EFFECT_CREATE_AREATRIGGER) || spellInfo->HasAura(AuraType::SPELL_AURA_AREATRIGGER))
            DelayedCastSpell(this, spellId, true, 1 * TimeConstants::IN_MILLISECONDS);
        else if (IsNeedCastPassiveSpellAtLearn(spellInfo))
            CastSpell(this, spellId, true);
    }
    else if (spellInfo->HasEffect(SPELL_EFFECT_SKILL_STEP))
    {
        CastSpell(this, spellId, true);
        return false;
    }

    // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
    if (uint32 freeProfs = GetFreePrimaryProfessionPoints())
    {
        if (spellInfo->IsPrimaryProfessionFirstRank())
        {
            uint16 l_SkillId = spellInfo->GetPrimaryProfessionSkill();
            if (m_PrimaryProfessionLearnt.count(l_SkillId) == 0)
            {
                m_PrimaryProfessionLearnt.insert(l_SkillId);
                SetFreePrimaryProfessions(freeProfs - 1);
            }
        }
    }

    SkillLineAbilityMapBounds skill_bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);

    if (SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spellId))
    {
        // add dependent skills if this spell is not learned from adding skill already
        if (spellLearnSkill->skill != fromSkill)
        {
            uint32 skill_value = GetPureSkillValue(spellLearnSkill->skill);
            uint32 skill_max_value = GetPureMaxSkillValue(spellLearnSkill->skill);

            if (skill_value < spellLearnSkill->value)
                skill_value = spellLearnSkill->value;

            uint32 new_skill_max_value = spellLearnSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : spellLearnSkill->maxvalue;

            if (skill_max_value < new_skill_max_value)
                skill_max_value = new_skill_max_value;

            SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skill_value, skill_max_value);
        }
    }
    else
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->SkillLine);
            if (!pSkill)
                continue;

            if (_spell_idx->second->SkillLine == fromSkill)
                continue;

            // Runeforging special case
            if ((_spell_idx->second->Flags & SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN && !HasSkill(_spell_idx->second->SkillLine)) || ((_spell_idx->second->SkillLine == SKILL_RUNEFORGING) && _spell_idx->second->TrivialSkillLineRankHigh == 0))
                if (SkillRaceClassInfoEntry const* rcInfo = GetSkillRaceClassInfo(_spell_idx->second->SkillLine, getRace(), getClass()))
                    LearnDefaultSkill(rcInfo);
        }
    }

    // learn dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spellId);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
    {
        if (!itr2->second.autoLearned)
        {
            if (!IsInWorld() || !itr2->second.active)       // at spells loading, no output, but allow save
                addSpell(itr2->second.spell, itr2->second.active, true, true, false, true);
            else                                            // at normal learning
                learnSpell(itr2->second.spell, true);
        }
    }

    if (!GetSession()->PlayerLoading())
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            UpdateCriteria(CRITERIA_TYPE_LEARN_SKILL_LINE, _spell_idx->second->SkillLine);
            UpdateCriteria(CRITERIA_TYPE_LEARN_SKILLLINE_SPELLS, _spell_idx->second->SkillLine);
        }

        UpdateCriteria(CRITERIA_TYPE_LEARN_SPELL, spellId);
    }

    // Add BattlePet
    if (learning && !dependent && p_LearnBattlePet)
    {
        for (uint32 speciesId = 0; speciesId != sBattlePetSpeciesStore.GetNumRows(); ++speciesId)
        {
            BattlePetSpeciesEntry const* speciesInfo = sBattlePetSpeciesStore.LookupEntry(speciesId);
            if (!speciesInfo || speciesInfo->SummonSpellID != spellId)
                continue;

            BattlePet pet;
            pet.Slot = PETBATTLE_NULL_SLOT;
            pet.NameTimeStamp = 0;
            pet.Species = speciesInfo->ID;
            pet.DisplayModelID = 0;
            pet.Flags = 0;

            if (BattlePetTemplate const* temp = sObjectMgr->GetBattlePetTemplate(speciesInfo->ID))
            {
                pet.Breed = temp->Breed;
                pet.Quality = temp->Quality;
                pet.Level = temp->Level;
            }
            else
            {
                pet.Breed = 3;
                pet.Quality = BATTLEPET_QUALITY_COMMON;
                pet.Level = 1;
            }

            // Calculate XP for level
            pet.XP = 0;
            if (pet.Level > 1 && pet.Level < 100)
                pet.XP = g_BattlePetXPStore.LookupEntry(pet.Level - 1)->xp * g_BattlePetXPStore.LookupEntry(pet.Level - 1)->wins;

            // Calculate stats
            pet.UpdateStats();
            pet.Health = pet.InfoMaxHealth;

            pet.AddToPlayer(this);
            ReloadPetBattles();
            break;
        }
    }

    // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
    return active && !disabled;
}

void Player::AddTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already added - do not do anything
    if (itr != m_spells.end())
        return;
    PlayerSpell* newspell = new PlayerSpell;
    newspell->state     = PLAYERSPELL_TEMPORARY;
    newspell->active    = true;
    newspell->dependent = false;
    newspell->disabled  = false;
    m_spells[spellId]   = newspell;
}

void Player::RemoveTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already not in list - do not do anything
    if (itr == m_spells.end())
        return;
    // spell has other state than temporary - do not change it
    if (itr->second->state != PLAYERSPELL_TEMPORARY)
        return;
    delete itr->second;
    m_spells.erase(itr);
}

void Player::AddOverrideSpell(uint32 overridenSpellId, uint32 newSpellId)
{
    m_overrideSpells[overridenSpellId].insert(newSpellId);
}

void Player::RemoveOverrideSpell(uint32 overridenSpellId, uint32 newSpellId)
{
    auto overrides = m_overrideSpells.find(overridenSpellId);
    if (overrides == m_overrideSpells.end())
        return;

    overrides->second.erase(newSpellId);
    if (overrides->second.empty())
        m_overrideSpells.erase(overrides);
}

void Player::SetLastCastedSpell(uint32 p_LastCastedSpell)
{
    m_LastCastedSpell = p_LastCastedSpell;
    Player* l_Player = this;

    std::list<uint64>& l_List = l_Player->m_SpellHelper.GetUint64List()[eSpellHelpers::TwoLastCastedSpellsIDs];
    if (l_List.size() >= 2)
    {
        if (l_List.front() != l_List.back() && l_List.front() != p_LastCastedSpell && l_List.back() != p_LastCastedSpell && l_Player->GetActiveSpecializationID() == SPEC_MONK_WINDWALKER && l_Player->HasAura(211430))
            l_Player->CastSpell(l_Player, 211432, true);

        l_List.pop_front();
    }
    l_List.push_back(p_LastCastedSpell);
}

bool Player::IsNeedCastPassiveSpellAtLearn(SpellInfo const* spellInfo) const
{
    // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
    // talent dependent passives activated at form apply have proper stance data
    ShapeshiftForm form = GetShapeshiftForm();

    bool need_cast = (!spellInfo->Stances || (form && (spellInfo->Stances & (UI64LIT(1) << (form - 1)))) ||
        (!form && (spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT)));

    //Check CasterAuraStates
    return need_cast && (!spellInfo->CasterAuraState || HasAuraState(AuraStateType(spellInfo->CasterAuraState)));
}

void Player::learnSpell(uint32 p_SpellId, bool dependent, bool p_FromItemShop, bool p_Temp, uint32 fromSkill, bool p_ByPassSpec)
{
    PlayerSpellMap::iterator l_Itr = m_spells.find(p_SpellId);

    bool l_Disabled = (l_Itr != m_spells.end()) ? l_Itr->second->disabled : false;
    bool l_Active = l_Disabled ? l_Itr->second->active : true;

    bool l_Learning = addSpell(p_SpellId, l_Active, !p_Temp, dependent, false, false, false, true, p_FromItemShop, fromSkill, p_ByPassSpec);

    // prevent duplicated entires in spell book, also not send if not in world (loading)
    if (l_Learning && IsInWorld() && !(IsArtifactSpell(p_SpellId) && sSpellMgr->GetSpellInfo(p_SpellId)->IsPassive()))
    {
        bool l_SuppressMessaging = false;

        TalentsPlaceHoldersSpell l_PlacesHoldersSpell = sSpellMgr->GetTalentPlaceHoldersSpell();
        if (l_PlacesHoldersSpell.find(p_SpellId) != l_PlacesHoldersSpell.end())
            l_SuppressMessaging = true;

        WorldPacket l_Data(SMSG_LEARNED_SPELL);
        l_Data << uint32(1);                        ///< count of spell_id to send.
        l_Data << uint32(0);                        ///< Unk Legion
        l_Data << uint32(p_SpellId);                ///< SpellId
        l_Data.WriteBit(l_SuppressMessaging);       ///< SuppressMessaging
        l_Data.FlushBits();
        GetSession()->SendPacket(&l_Data);

        sScriptMgr->OnPlayerSpellLearned(this, p_SpellId);
    }

    // learn all disabled higher ranks and required spells (recursive)
    if (l_Disabled)
    {
        if (uint32 l_NextSpell = sSpellMgr->GetNextSpellInChain(p_SpellId))
        {
            PlayerSpellMap::iterator l_Iter = m_spells.find(l_NextSpell);
            if (l_Iter != m_spells.end() && l_Iter->second->disabled)
                learnSpell(l_NextSpell, false, false, false, fromSkill);
        }

        SpellsRequiringSpellMapBounds l_SpellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(p_SpellId);
        for (SpellsRequiringSpellMap::const_iterator l_Itr2 = l_SpellsRequiringSpell.first; l_Itr2 != l_SpellsRequiringSpell.second; ++l_Itr2)
        {
            PlayerSpellMap::iterator l_Iter2 = m_spells.find(l_Itr2->second);
            if (l_Iter2 != m_spells.end() && l_Iter2->second->disabled)
                learnSpell(l_Itr2->second, false, false, false, fromSkill);
        }
    }
}

void Player::removeSpell(uint32 spell_id, bool disabled, bool learn_low_rank)
{
    PlayerSpellMap::iterator itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;

    if (itr->second->state == PLAYERSPELL_REMOVED || (disabled && itr->second->disabled) || itr->second->state == PLAYERSPELL_TEMPORARY)
        return;

    // unlearn non talent higher ranks (recursive)
    if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
    {
        if (HasSpell(nextSpell)/* && !GetTalentSpellPos(nextSpell)*/)
            removeSpell(nextSpell, disabled, false);
    }
    //unlearn spells dependent from recently removed spells
    SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
    for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
        removeSpell(itr2->second, disabled);

    // re-search, it can be corrupted in prev loop
    itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;                                             // already unleared

    bool giveTalentPoints = disabled || !itr->second->disabled;

    bool cur_active    = itr->second->active;
    bool cur_dependent = itr->second->dependent;

    if (disabled)
    {
        itr->second->disabled = disabled;
        if (itr->second->state != PLAYERSPELL_NEW)
            itr->second->state = PLAYERSPELL_CHANGED;
    }
    else
    {
        if (itr->second->state == PLAYERSPELL_NEW)
        {
            delete itr->second;
            m_spells.erase(itr);
        }
        else
            itr->second->state = PLAYERSPELL_REMOVED;
    }

    RemoveOwnedAura(spell_id, GetGUID());

    // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return;

    // remove pet auras
    for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
        if (PetAura const* petSpell = sSpellMgr->GetPetAura(spell_id, i))
            RemovePetAura(petSpell);

    if (spellInfo->IsPrimaryProfessionFirstRank())
    {
        uint32 freeProfs = GetFreePrimaryProfessionPoints() + 1;
        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
        {
            SetFreePrimaryProfessions(freeProfs);
            m_PrimaryProfessionLearnt.erase(spellInfo->GetPrimaryProfessionSkill());
        }
    }

    // remove dependent skill
    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spell_id);
    if (spellLearnSkill)
    {
        uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spell_id);
        if (!prev_spell)                                    // first rank, remove skill
            SetSkill(spellLearnSkill->skill, 0, 0, 0);
        else
        {
            // search prev. skill setting by spell ranks chain
            SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
            while (!prevSkill && prev_spell)
            {
                prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
                prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
            }

            if (!prevSkill)                                 // not found prev skill setting, remove skill
                SetSkill(spellLearnSkill->skill, 0, 0, 0);
            else                                            // set to prev. skill setting values
            {
                uint32 skill_value = GetPureSkillValue(prevSkill->skill);
                uint32 skill_max_value = GetPureMaxSkillValue(prevSkill->skill);

                if (skill_value > prevSkill->value)
                    skill_value = prevSkill->value;

                uint32 new_skill_max_value = prevSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : prevSkill->maxvalue;

                if (skill_max_value > new_skill_max_value)
                    skill_max_value = new_skill_max_value;

                SetSkill(prevSkill->skill, prevSkill->step, skill_value, skill_max_value);
            }
        }
    }

    // remove dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spell_id);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
        removeSpell(itr2->second.spell, disabled);

    /// Remove areatrigger
    std::list<AreaTrigger*> l_AreaTriggerList;
    GetAreaTriggerList(l_AreaTriggerList, spell_id);
    if (!l_AreaTriggerList.empty())
    {
        for (auto l_Itr : l_AreaTriggerList)
            l_Itr->RemoveFromWorld();
    }

    // activate lesser rank in spellbook/action bar, and cast it if need
    bool prev_activate = false;

    if (uint32 prev_id = sSpellMgr->GetPrevSpellInChain(spell_id))
    {
        if (cur_active && spellInfo->IsRanked())
        {
            // need manually update dependence state (learn spell ignore like attempts)
            PlayerSpellMap::iterator prev_itr = m_spells.find(prev_id);
            if (prev_itr != m_spells.end())
            {
                if (prev_itr->second->dependent != cur_dependent)
                {
                    prev_itr->second->dependent = cur_dependent;
                    if (prev_itr->second->state != PLAYERSPELL_NEW)
                        prev_itr->second->state = PLAYERSPELL_CHANGED;
                }

                // now re-learn if need re-activate
                if (cur_active && !prev_itr->second->active && learn_low_rank)
                {
                    if (addSpell(prev_id, true, false, prev_itr->second->dependent, prev_itr->second->disabled))
                    {
                        // downgrade spell ranks in spellbook and action bar
                        WorldPacket l_Data(SMSG_SUPERCEDED_SPELLS);
                        l_Data << uint32(1);
                        l_Data << uint32(1);
                        l_Data << uint32(0);    ///< Favorite
                        l_Data << uint32(prev_id);
                        l_Data << uint32(spell_id);
                        GetSession()->SendPacket(&l_Data);
                        prev_activate = true;
                    }
                }
            }
        }
    }

    m_overrideSpells.erase(spell_id);

    if (spell_id == 46917 && m_canTitanGrip)
        SetCanTitanGrip(false);
    if (spell_id == 156910 && GetBeaconOfFaithTarget()) ///< Aura should be remove on Ally to not benefit of it on changing spec
    {
        Unit* l_Target = ObjectAccessor::FindUnit(GetBeaconOfFaithTarget());
        if (l_Target != nullptr)
            l_Target->RemoveAura(156910, this->GetGUID());
    }

    ControlList l_TempSummons = m_Controlled;

    switch(spell_id)
    {
        /// Jade Serpent Statue
        case 115313:
        {
            for (Unit* l_Summon : l_TempSummons)
                if (l_Summon->GetEntry() == 60849)
                    if (Creature* l_Creature = l_Summon->ToCreature())
                        l_Creature->DespawnOrUnsummon(1);

            break;
        }
        /// Black Ox Statue
        case 115315:
        {
            for (Unit* l_Summon : l_TempSummons)
                if (l_Summon->GetEntry() == 61146)
                    if (Creature* l_Creature = l_Summon->ToCreature())
                        l_Creature->DespawnOrUnsummon(1);

            break;
        }
        ///< Totem Mastery
        case 210643:
        {
            for (Unit* l_Summon : l_TempSummons)
                if (l_Summon->GetEntry() == 106317 || l_Summon->GetEntry() == 102392 || l_Summon->GetEntry() == 106321 || l_Summon->GetEntry() == 106319)
                    if (Creature* l_Creature = l_Summon->ToCreature())
                        l_Creature->DespawnOrUnsummon(1);

            break;
        }
        ///< Casting Circle
        case 221703:
        {
            RemoveAura(221705);
            break;
        }
    }

    if (m_canDualWield)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
        if (spellInfo->IsPassive())
        {
            for (int i = 0; i < spellInfo->EffectCount; i++)
            {
                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_DUAL_WIELD)
                {
                    SetCanDualWield(false);
                    break;
                }
            }
        }
    }

    if (sWorld->getBoolConfig(CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN))
        AutoUnequipOffhandIfNeed();

    bool l_SupressMessage = false;
    if (IsArtifactSpell(spell_id))
        l_SupressMessage = true;

    // remove from spell book if not replaced by lesser rank
    if (!prev_activate)
    {
        WorldPacket data(SMSG_UNLEARNED_SPELLS, 4 + 4);
        data << uint32(1);  // Count spells, always one by one
        data << uint32(spell_id);
        data.WriteBit(l_SupressMessage);
        GetSession()->SendPacket(&data);
    }

    sScriptMgr->OnPlayerSpellRemoved(this, spell_id);
}

void Player::ReduceSpellCooldown(uint32 p_SpellID, uint32 p_ModifyTime)
{
    SpellCooldowns::iterator itr = m_spellCooldowns.find(p_SpellID);
    if (itr == m_spellCooldowns.end())
        return;

    ACE_UINT64 currTime = 0;
    ACE_OS::gettimeofday().msec(currTime);
    if ((itr->second.end - uint64(p_ModifyTime)) > currTime)
    {
        uint64 endTime = itr->second.end - uint64(p_ModifyTime);
        SpellCooldown sc;
        sc.end = endTime;
        sc.itemid = 0;
        m_spellCooldowns.erase(itr);
        m_spellCooldowns.emplace(p_SpellID, sc);
    }
    else
    {
        RemoveSpellCooldown(p_SpellID, true);
        return;
    }

    WorldPacket l_Data(SMSG_MODIFY_COOLDOWN, 4 + 18 + 4);
    l_Data << uint32(p_SpellID);
    l_Data << int32(-static_cast<int32>(p_ModifyTime));
    l_Data.WriteBit(false);             ///< IsPetCooldown

    SendDirectMessage(&l_Data);
}

void Player::SendModifyCooldownRecoveryRate(uint32 p_SpellID, float p_AddedMod, float p_NewMod)
{
    WorldPacket l_Data(Opcodes::SMSG_MODIFY_COOLDOWN_RECOVERY_SPEED);

    l_Data << uint32(p_SpellID);
    l_Data << float(p_AddedMod);
    l_Data << float(p_NewMod);

    SendDirectMessage(&l_Data);
}

void Player::SendModifyChargeRecoveryRate(uint32 p_ChargeCategoryId, float p_AddedMod, float p_NewMod)
{
    WorldPacket l_Data(Opcodes::SMSG_MODIFY_CHARGE_RECOVERY_SPEED);

    l_Data << uint32(p_ChargeCategoryId);
    l_Data << float(p_AddedMod);
    l_Data << float(p_NewMod);

    l_Data.WriteBit(false); ///< IsPet
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::RemoveSpellCooldown(uint32 p_SpellId, bool p_Update /* = false */)
{
    auto l_Itr = m_spellCooldowns.find(p_SpellId);
    if (l_Itr != m_spellCooldowns.end())
    {
        m_spellCooldowns.erase(l_Itr);

        if (p_Update)
            SendClearCooldown(p_SpellId, this);
    }
}

void Player::RemoveArenaSpellCooldowns(bool p_RemoveActivePetCooldowns)
{
    SpellCooldowns::iterator l_Itr, l_Next;
    for (l_Itr = m_spellCooldowns.begin(); l_Itr != m_spellCooldowns.end(); l_Itr = l_Next)
    {
        l_Next = l_Itr;
        ++l_Next;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        uint32 l_Flags = (l_SpellInfo && l_SpellInfo->CategoryEntry) ? l_SpellInfo->CategoryEntry->Flags : 0;

        // check if spellentry is present and if the cooldown is less than 10 min
        if (l_SpellInfo &&
            l_SpellInfo->RecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            l_SpellInfo->CategoryRecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            (l_Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            // remove & notify
            RemoveSpellCooldown(l_Itr->first, true);
        }
    }

    /// Remove spell charge cooldown that have < 10 min CD
    for (auto l_Itr = m_CategoryCharges.begin(); l_Itr != m_CategoryCharges.end();)
    {
        SpellCategoryEntry const* l_SpellCategory = sSpellCategoryStore.LookupEntry(l_Itr->first);
        if (l_SpellCategory &&
            l_SpellCategory->ChargeRecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            (l_SpellCategory->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            l_Itr = ResetCharges(l_SpellCategory);
        }
        else
            l_Itr++;
    }

    // pet cooldowns
    if (p_RemoveActivePetCooldowns)
    {
        if (Pet* l_Pet = GetPet())
        {
            // notify player
            for (auto l_Itr = l_Pet->m_CreatureSpellCooldowns.begin(); l_Itr != l_Pet->m_CreatureSpellCooldowns.end(); l_Itr++)
                SendClearCooldown(l_Itr->first, l_Pet);

            // actually clear cooldowns
            l_Pet->m_CreatureSpellCooldowns.clear();
        }
    }
}

void Player::RemoveAllSpellCooldown()
{
    if (!m_spellCooldowns.empty())
    {
        WorldPacket l_Data(SMSG_CLEAR_COOLDOWNS, 4 + (m_spellCooldowns.size() * 4));
        l_Data << uint32(GetSpellCooldownMap().size());

        for (SpellCooldowns::const_iterator itr = GetSpellCooldownMap().begin(); itr != GetSpellCooldownMap().end(); ++itr)
            l_Data << uint32(itr->first);             ///< Spell ID

        l_Data.WriteBit(0); ///< OnHold ????
        SendDirectMessage(&l_Data);
        m_spellCooldowns.clear();
    }
}

void Player::RemoveSpellCooldownsWithTime(uint32 p_MinRecoveryTime)
{
    SpellCooldowns::iterator l_Itr, l_Next;
    for (l_Itr = m_spellCooldowns.begin(); l_Itr != m_spellCooldowns.end(); l_Itr = l_Next)
    {
        l_Next = l_Itr;

        ++l_Next;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        uint32 l_Flags = (l_SpellInfo && l_SpellInfo->CategoryEntry) ? l_SpellInfo->CategoryEntry->Flags : 0;

        /// Check if SpellEntry is present and if the cooldown is not more than the specified time
        if (l_SpellInfo && (l_SpellInfo->RecoveryTime > p_MinRecoveryTime || l_SpellInfo->CategoryRecoveryTime > p_MinRecoveryTime))
            continue;

        if (l_Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET)
            continue;

        /// Remove & notify
        RemoveSpellCooldown(l_Itr->first, true);
    }

    /// Remove spell charge with cooldown equal or more than the specified time
    for (auto l_Itr = m_CategoryCharges.begin(); l_Itr != m_CategoryCharges.end();)
    {
        SpellCategoryEntry const* l_SpellCategory = sSpellCategoryStore.LookupEntry(l_Itr->first);
        if (l_SpellCategory && l_SpellCategory->ChargeRecoveryTime <= p_MinRecoveryTime &&
            (l_SpellCategory->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            l_Itr = ResetCharges(l_SpellCategory);
        }
        else
            l_Itr++;
    }
}

void Player::_LoadSpellCooldowns(PreparedQueryResult result)
{
    // some cooldowns can be already set at aura loading...

    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, item, time FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        ACE_UINT64 curTime = 0;
        ACE_OS::gettimeofday().msec(curTime);

        do
        {
            Field* fields = result->Fetch();
            uint32 spell_id = fields[0].GetUInt32();
            uint32 item_id  = fields[1].GetUInt32();
            uint64 db_time = uint64(fields[2].GetUInt32()) * IN_MILLISECONDS;

            if (!sSpellMgr->GetSpellInfo(spell_id))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown spell %u in `character_spell_cooldown`, skipping.", GetGUIDLow(), spell_id);
                continue;
            }

            // skip outdated cooldown
            if (db_time <= curTime)
                continue;

            AddSpellCooldown(spell_id, item_id, (db_time - curTime));

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player (GUID: %u) spell %u, item %u cooldown loaded (%u secs).", GetGUIDLow(), spell_id, item_id, uint32(db_time-curTime));
        }
        while (result->NextRow());
    }
}

void Player::_LoadChargesCooldowns(PreparedQueryResult p_Result)
{
    if (p_Result)
    {
        ACE_UINT64 l_CurrTime = 0;
        ACE_OS::gettimeofday().msec(l_CurrTime);

        do
        {
            Field* l_Fields = p_Result->Fetch();
            uint32 l_CategoryId = 0;
            ChargeEntry l_Charges;

            l_CategoryId = l_Fields[0].GetUInt32();
            SpellCategoryEntry const* l_Category = sSpellCategoryStore.LookupEntry(l_CategoryId);
            if (l_Category == nullptr)
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown charges category %u registered, skipping.", GetGUIDLow(), l_CategoryId);
                continue;
            }

            l_Charges.RechargeStart = Clock::from_time_t(time_t(l_Fields[1].GetUInt32()));
            l_Charges.RechargeEnd = Clock::from_time_t(time_t(l_Fields[2].GetUInt32()));

            m_CategoryCharges[l_CategoryId].push_back(l_Charges);
        }
        while (p_Result->NextRow());
    }
}

void Player::_SaveSpellCooldowns(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    ACE_UINT64 curTime = 0;
    ACE_OS::gettimeofday().msec(curTime);
    uint64 infTime = curTime + infinityCooldownDelayCheck;

    bool first_round = true;
    std::ostringstream ss;

    // remove outdated and save active
    for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end();)
    {
        if (itr->second.end <= curTime)
            m_spellCooldowns.erase(itr++);
        else if (itr->second.end <= infTime)                 // not save locked cooldowns, it will be reset or set at reload
        {
            if (first_round)
            {
                ss << "INSERT INTO character_spell_cooldown (guid, spell, item, time) VALUES ";
                first_round = false;
            }
            // next new/changed record prefix
            else
                ss << ',';
            ss << '(' << GetRealGUIDLow() << ',' << itr->first << ',' << itr->second.itemid << ',' << uint64(itr->second.end / IN_MILLISECONDS) << ')';
            ++itr;
        }
        else
            ++itr;
    }
    // if something changed execute
    if (!first_round)
        trans->Append(ss.str().c_str());
}

void Player::_SaveChargesCooldowns(SQLTransaction& p_Transaction)
{
#ifdef CROSS
    InterRealmDatabasePool* l_Database = GetRealmDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_DEL_CHARGES_COOLDOWN);
    l_Statement->setUInt32(0, GetRealGUIDLow());
    p_Transaction->Append(l_Statement);

    for (auto const& p : m_CategoryCharges)
    {
        for (ChargeEntry const& l_Charge : p.second)
        {
            PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_INS_CHARGES_COOLDOWN);
            l_Statement->setUInt32(0, GetRealGUIDLow());
            l_Statement->setUInt32(1, p.first);
            l_Statement->setUInt32(2, uint32(Clock::to_time_t(l_Charge.RechargeStart)));
            l_Statement->setUInt32(3, uint32(Clock::to_time_t(l_Charge.RechargeEnd)));
            p_Transaction->Append(l_Statement);
        }
    }
}

uint32 Player::GetLastPotionItemId(SpellInfo const* p_SpellInfo) const
{
    /// Potion not linked to any category
    uint32 l_CategoryID = p_SpellInfo->CategoryEntry ? p_SpellInfo->CategoryEntry->Id : 0;
    if (!l_CategoryID)
        return 0;

    /// Potion not used yet
    auto const& l_Iter = m_LastPotions.find(l_CategoryID);
    if (l_Iter == m_LastPotions.end())
        return 0;

    return l_Iter->second.m_LastPotionItemID;
}

void Player::SetLastPotion(SpellInfo const* p_SpellInfo, Item const* p_CastItem)
{
    /// Potion not linked to any category
    uint32 l_CategoryID = p_SpellInfo->CategoryEntry ? p_SpellInfo->CategoryEntry->Id : 0;
    if (!l_CategoryID)
        return;

    /// Has already been set
    if (m_LastPotions.find(l_CategoryID) != m_LastPotions.end())
        return;

    LastPotion l_LastPotion;

    l_LastPotion.m_LastPotionGUID = p_CastItem->GetGUID();
    l_LastPotion.m_LastPotionItemID = p_CastItem->GetEntry();
    l_LastPotion.m_LastPotionSpellID = p_SpellInfo->Id;

    m_LastPotions[l_CategoryID] = l_LastPotion;
}

uint32 Player::GetRoleForGroup(uint32 specializationId) const
{
    if (!specializationId)
        specializationId = GetActiveSpecializationID();

    return GetRoleBySpecializationId(specializationId);
}

bool Player::IsHealer() const
{
    if ((GetRoleForGroup() != Roles::ROLE_HEALER))
        return false;

    switch (GetActiveSpecializationID())
    {
        case SpecIndex::SPEC_DRUID_RESTORATION:
        case SpecIndex::SPEC_MONK_MISTWEAVER:
        case SpecIndex::SPEC_PALADIN_HOLY:
        case SpecIndex::SPEC_SHAMAN_RESTORATION:
        case SpecIndex::SPEC_PRIEST_DISCIPLINE:
        case SpecIndex::SPEC_PRIEST_HOLY:
            return true;
        default:
            return false;
    }
}

bool Player::IsRangedDamageDealer(bool p_AllowHeal /*= true*/) const
{
    if ((GetRoleForGroup() != Roles::ROLE_DAMAGE && !(p_AllowHeal && GetRoleForGroup() == Roles::ROLE_HEALER)) || getClass() == Classes::CLASS_DEMON_HUNTER)
        return false;

    switch (getClass())
    {
        case Classes::CLASS_MAGE:
        case Classes::CLASS_WARLOCK:
            return true;
        default:
            break;
    }

    switch (GetActiveSpecializationID())
    {
        case SpecIndex::SPEC_DRUID_BALANCE:
        case SpecIndex::SPEC_PRIEST_SHADOW:
        case SpecIndex::SPEC_SHAMAN_ELEMENTAL:
        case SpecIndex::SPEC_HUNTER_BEASTMASTERY:
        case SpecIndex::SPEC_HUNTER_MARKSMANSHIP:
            return true;
        case SpecIndex::SPEC_DRUID_RESTORATION:
        case SpecIndex::SPEC_PRIEST_DISCIPLINE:
        case SpecIndex::SPEC_PRIEST_HOLY:
        case SpecIndex::SPEC_SHAMAN_RESTORATION:
            return p_AllowHeal;
        default:
            break;
    }

    return false;
}

/// 7.0.3 add Demon hunter
/// 7.3.5 add Holy paladin and Mistweaver monk as melee healer
bool Player::IsMeleeDamageDealer(bool p_AllowTank /*= false*/, bool p_AllowHeal /*= true*/) const
{
    if (GetRoleForGroup() != Roles::ROLE_DAMAGE && !(p_AllowTank && GetRoleForGroup() == Roles::ROLE_TANK) && !(p_AllowHeal && GetRoleForGroup() == Roles::ROLE_HEALER))
        return false;

    if (getClass() == Classes::CLASS_ROGUE || getClass() == Classes::CLASS_DEMON_HUNTER)
        return true;

    switch (GetActiveSpecializationID())
    {
        case SpecIndex::SPEC_DRUID_FERAL:
        case SpecIndex::SPEC_SHAMAN_ENHANCEMENT:
        case SpecIndex::SPEC_MONK_WINDWALKER:
        case SpecIndex::SPEC_WARRIOR_ARMS:
        case SpecIndex::SPEC_WARRIOR_FURY:
        case SpecIndex::SPEC_DK_UNHOLY:
        case SpecIndex::SPEC_DK_FROST:
        case SpecIndex::SPEC_PALADIN_RETRIBUTION:
        case SpecIndex::SPEC_HUNTER_SURVIVAL:
            return true;
        case SpecIndex::SPEC_DRUID_GUARDIAN:
        case SpecIndex::SPEC_MONK_BREWMASTER:
        case SpecIndex::SPEC_WARRIOR_PROTECTION:
        case SpecIndex::SPEC_DK_BLOOD:
        case SpecIndex::SPEC_PALADIN_PROTECTION:
            return p_AllowTank;
        case SpecIndex::SPEC_MONK_MISTWEAVER:
        case SpecIndex::SPEC_PALADIN_HOLY:
            return p_AllowHeal;
        default:
            break;
    }

    return false;
}

uint32 Player::GetRoleBySpecializationId(uint32 specializationId)
{
   if (specializationId)
   {
       if (ChrSpecializationsEntry const* spec = sChrSpecializationsStore.LookupEntry(specializationId))
           return spec->Role;
   }

    return ROLE_DAMAGE;
}

bool Player::IsActiveSpecTankSpec() const
{
    ChrSpecializationsEntry const* l_Entry = sChrSpecializationsStore.LookupEntry(GetActiveSpecializationID());

    if (!l_Entry)
        return false;

    return l_Entry->Role == Roles::ROLE_TANK;
}

Mail* Player::GetMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        if ((*itr)->messageID == id)
            return (*itr);

    return NULL;
}

void Player::SetObjectScale(float scale)
{
    Unit::SetObjectScale(scale);

    if (IsInWorld())
        SendMovementSetCollisionHeight(scale * GetCollisionHeight(IsMounted()));
}

void Player::BuildCreateUpdateBlockForPlayer(UpdateData* data, Player* target) const
{
    if (target == this)
    {
        for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }

        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        {
            if (m_items[i] == nullptr)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }
    }

    Unit::BuildCreateUpdateBlockForPlayer(data, target);
}

void Player::DestroyForPlayer(Player* target, bool onDeath) const
{
    Unit::DestroyForPlayer(target, onDeath);

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] == NULL)
            continue;

        m_items[i]->DestroyForPlayer(target);
    }

    if (target == this)
    {
        for (uint8 i = INVENTORY_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->DestroyForPlayer(target);
        }

        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        {
            if (m_items[i] == nullptr)
                continue;

            m_items[i]->DestroyForPlayer(target);
        }
    }
}

bool Player::HasSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        !itr->second->disabled);
}

bool Player::HasOverridedSpell(uint32 p_SpellID) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(p_SpellID);
    if (!(itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        !itr->second->disabled))
    {
        Unit::AuraEffectList const& l_AurEffList = GetAuraEffectsByType(AuraType::SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS);
        for (Unit::AuraEffectList::const_iterator l_Iter = l_AurEffList.begin(); l_Iter != l_AurEffList.end(); ++l_Iter)
        {
            /// If spell is overrided, consider it's learned
            if ((*l_Iter)->GetAmount() == p_SpellID)
                return true;
        }
    }

    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        !itr->second->disabled);
}

bool Player::HasActiveSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        itr->second->active && !itr->second->disabled);
}

SpellInfo const* Player::GetCastSpellInfo(SpellInfo const* spellInfo) const
{
    auto overrides = m_overrideSpells.find(spellInfo->Id);
    if (overrides != m_overrideSpells.end())
    {
        for (uint32 spellId : overrides->second)
        {
            if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo(spellId))
                return Unit::GetCastSpellInfo(newInfo);
        }
    }

    return Unit::GetCastSpellInfo(spellInfo);
}

/// 7.0.3 need to be removed the player learn talent at level up
TrainerSpellState Player::GetTrainerSpellState(TrainerSpell const* trainer_spell) const
{
    if (!trainer_spell)
        return TRAINER_SPELL_RED;

    bool hasSpell = true;
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        if (!HasSpell(trainer_spell->learnedSpell[i]))
        {
            hasSpell = false;
            break;
        }
    }
    // known spell
    if (hasSpell)
        return TRAINER_SPELL_GRAY;

    // check skill requirement
    if (trainer_spell->reqSkill && GetBaseSkillValue(trainer_spell->reqSkill) < trainer_spell->reqSkillValue)
        return TRAINER_SPELL_RED;

    // check level requirement
    if (getLevel() < trainer_spell->reqLevel)
        return TRAINER_SPELL_RED;

    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        // check race/class requirement
        if (!IsSpellFitByClassAndRace(trainer_spell->learnedSpell[i]))
            return TRAINER_SPELL_RED;

        if (uint32 prevSpell = sSpellMgr->GetPrevSpellInChain(trainer_spell->learnedSpell[i]))
        {
            // check prev.rank requirement
            if (prevSpell && !HasSpell(prevSpell))
                return TRAINER_SPELL_RED;
        }

        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(trainer_spell->learnedSpell[i]);
        for (SpellsRequiringSpellMap::const_iterator itr = spellsRequired.first; itr != spellsRequired.second; ++itr)
        {
            // check additional spell requirement
            if (!HasSpell(itr->second))
                return TRAINER_SPELL_RED;
        }
    }

    // check primary prof. limit
    // first rank of primary profession spell when there are no proffesions avalible is disabled
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;
        SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[i]);
        if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank() && (GetFreePrimaryProfessionPoints() == 0))
            return TRAINER_SPELL_GREEN_DISABLED;
    }

    return TRAINER_SPELL_GREEN;
}

/**
 * Deletes a character from the database
 *
 * The way, how the characters will be deleted is decided based on the config option.
 *
 * @see Player::DeleteOldCharacters
 *
 * @param playerguid       the low-GUID from the player which should be deleted
 * @param accountId        the account id from the player
 * @param updateRealmChars when this flag is set, the amount of characters on that realm will be updated in the realmlist
 * @param deleteFinally    if this flag is set, the config option will be ignored and the character will be permanently removed from the database
 */
#ifndef CROSS
void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmChars, bool deleteFinally)
{
    // for not existed account avoid update realm
    if (accountId == 0)
        updateRealmChars = false;

    uint32 charDelete_method = sWorld->getIntConfig(CONFIG_CHARDELETE_METHOD);
    uint32 charDelete_minLvl = sWorld->getIntConfig(CONFIG_CHARDELETE_MIN_LEVEL);

    // if we want to finally delete the character or the character does not meet the level requirement,
    // we set it to mode CHAR_DELETE_REMOVE
    if (deleteFinally || Player::GetLevelFromDB(playerguid) < charDelete_minLvl)
        charDelete_method = CHAR_DELETE_REMOVE;

    uint32 guid = GUID_LOPART(playerguid);

    if (CharacterInfo const* l_CharInfo = sWorld->GetCharacterInfo(guid))
    {
        if (Guild* guild = sGuildMgr->GetGuildById(l_CharInfo->GuildId))
            guild->DeleteMember(guid, false, false, true);
    }

    // Remove signs from petitions (also remove petitions if owner);
    RemovePetitionsAndSigns(playerguid, 10);

    switch (charDelete_method)
    {
        // Completely remove from the database
        case CHAR_DELETE_REMOVE:
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();

            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);

            if (resultMail)
            {
                do
                {
                    Field* mailFields = resultMail->Fetch();

                    uint32 mail_id       = mailFields[0].GetUInt32();
                    uint8 mailType       = mailFields[1].GetUInt8();
                    uint16 mailTemplateId= mailFields[2].GetUInt16();
                    uint32 sender        = mailFields[3].GetUInt32();
                    std::string subject  = mailFields[4].GetString();
                    std::string body     = mailFields[5].GetString();
                    uint64 money         = mailFields[6].GetUInt64();
                    bool has_items       = mailFields[7].GetBool();

                    // We can return mail now
                    // So firstly delete the old one
                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    // Mail is not from player
                    if (mailType != MAIL_NORMAL)
                    {
                        if (has_items)
                        {
                            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                            stmt->setUInt32(0, mail_id);
                            trans->Append(stmt);
                        }
                        continue;
                    }

                    MailDraft draft(subject, body);
                    if (mailTemplateId)
                        draft = MailDraft(mailTemplateId, false);    // items are already included

                    if (has_items)
                    {
                        // Data needs to be at first place for Item::LoadFromDB
                        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
                        stmt->setUInt32(0, mail_id);
                        PreparedQueryResult resultItems = CharacterDatabase.Query(stmt);
                        if (resultItems)
                        {
                            do
                            {
                                Field* itemFields = resultItems->Fetch();

                                uint32 item_guidlow = itemFields[ItemInstanceField::Guid].GetUInt32();
                                uint32 item_template = itemFields[ItemInstanceField::ItemEntry].GetUInt32();

                                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
                                if (!itemProto)
                                {
                                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                                    stmt->setUInt32(0, item_guidlow);
                                    trans->Append(stmt);
                                    sLog->outAshran("Player::DeleteFromDB delete item %u", item_guidlow);
                                    continue;
                                }

                                Item* pItem = NewItemOrBag(itemProto);
                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
                                {
                                    pItem->FSetState(ITEM_REMOVED);
                                    pItem->SaveToDB(trans);              // it also deletes item object!
                                    continue;
                                }

                                draft.AddItem(pItem);
                            }
                            while (resultItems->NextRow());
                        }
                    }

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    uint32 pl_account = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

                    draft.AddMoney(money).SendReturnToSender(pl_account, guid, sender, trans);
                }
                while (resultMail->NextRow());
            }

            // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
            // NOW we can finally clear other DB data related to character
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);

            if (resultPets)
            {
                do
                {
                    uint32 petguidlow = (*resultPets)[0].GetUInt32();
                    Pet::DeleteFromDB(petguidlow, g_RealmID);
                }
                while
                    (resultPets->NextRow());
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE_ALL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_GEMS_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            stmt->setUInt32(1, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_TRANSMOG_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            MS::Garrison::Manager::DeleteFromDB(playerguid, trans);

            MS::Utilities::CallBackPtr l_CharCreateCallback = nullptr;

            if (updateRealmChars)
            {
                l_CharCreateCallback = std::make_shared<MS::Utilities::Callback>([accountId](bool p_Success) -> void ///< p_Success is unused
                {
                    sWorld->UpdateRealmCharCount(accountId);
                });
            }

            CharacterDatabase.CommitTransaction(trans, sWorld->GetQueryCallbackMgr(), l_CharCreateCallback);
            break;
        }
        // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
        case CHAR_DELETE_UNLINK:
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_DELETE_INFO);

            stmt->setUInt32(0, guid);

            CharacterDatabase.Execute(stmt);
            break;
        }
        default:
            sLog->outError(LOG_FILTER_PLAYER, "Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
    }
}
#endif

/**
 * Characters which were kept back in the database after being deleted and are now too old (see config option "CharDelete.KeepDays"), will be completely deleted.
 *
 * @see Player::DeleteFromDB
 */
void Player::DeleteOldCharacters()
{
    uint32 keepDays = sWorld->getIntConfig(CONFIG_CHARDELETE_KEEP_DAYS);
    if (!keepDays)
        return;

#ifndef CROSS
    Player::DeleteOldCharacters(keepDays);
#else /* CROSS */
    //Player::DeleteOldCharacters(keepDays);
#endif /* CROSS */
}

/**
 * Characters which were kept back in the database after being deleted and are older than the specified amount of days, will be completely deleted.
 *
 * @see Player::DeleteFromDB
 *
 * @param keepDays overrite the config option by another amount of days
 */
void Player::DeleteOldCharacters(uint32 keepDays)
{
#ifndef CROSS
    sLog->outInfo(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
         sLog->outDebug(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
         do
         {
            Field* fields = result->Fetch();
            Player::DeleteFromDB(fields[0].GetUInt32(), fields[1].GetUInt32(), true, true);
         }
         while (result->NextRow());
    }
#endif
}

/* Preconditions:
  - a resurrectable corpse must not be loaded for the player (only bones)
  - the player must be in world
*/
void Player::BuildPlayerRepop()
{
    WorldPacket l_Data(SMSG_PRE_RESURRECT, 8);
    l_Data.appendPackGUID(GetGUID());
    GetSession()->SendPacket(&l_Data);

    if (getRace() == RACE_NIGHTELF)
        CastSpell(this, 20584, true);
    CastSpell(this, 8326, true);

    if (HasAura(84559) && !InBattleground() && !InArena())
        CastSpell(this, 84559, true); // The Quick and the Dead

    // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
    // there must be SMSG.STOP_MIRROR_TIMER
    // there we must send 888 opcode

    // the player cannot have a corpse already, only bones which are not returned by GetCorpse
    WorldLocation corpseLocation = GetCorpseLocation();
    if (corpseLocation.GetMapId() == GetMapId())
    {
        sLog->outError(LOG_FILTER_PLAYER, "BuildPlayerRepop: player %s(%d) already has a corpse", GetName(), GetGUIDLow());
        return;
    }

    // create a corpse and place it at the player's location
    InstanceScript* l_Instance = GetInstanceScript();

    bool l_CustomRelease = false;
    if (l_Instance && l_Instance->IsEncounterInProgress() && l_Instance->IsReleaseAllowed())
        l_CustomRelease = true;

    Corpse* l_Corpse = nullptr;
    if (!l_CustomRelease)
    {
        l_Corpse = CreateCorpse();
        if (!l_Corpse)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Error creating corpse for Player %s [%u]", GetName(), GetGUIDLow());
            return;
        }

        GetMap()->AddToMap(l_Corpse);
    }

    /// convert player body to ghost
    SetHealth(1);

    SetWaterWalking(true);

    if (!GetSession()->isLogingOut())
        SetRooted(false);

    /// BG - remove insignia related
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);

    /// to prevent cheating
    if (l_Corpse)
        l_Corpse->ResetGhostTime();

    StopMirrorTimers();                                         ///< disable timers(bars)

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, float(1.0f));     ///< see radius of death player?

    /// set and clear other
    SetByteValue(UNIT_FIELD_ANIM_TIER, UNIT_BYTES_1_OFFSET_ANIM_TIER, UNIT_BYTE1_FLAG_ALWAYS_STAND);
}

void Player::ResurrectPlayer(float p_RestorePercent, bool p_ApplySickness)
{
    /// remove spirit healer position
    WorldPacket l_Data(SMSG_DEATH_RELEASE_LOC, 4 * 4);
    l_Data << uint32(-1); ///< MapID
    l_Data << float(0);   ///< X
    l_Data << float(0);   ///< Y
    l_Data << float(0);   ///< Z
    GetSession()->SendPacket(&l_Data);

    // speed change, land walk

    // remove death flag + set aura
    SetByteValue(UNIT_FIELD_ANIM_TIER, UNIT_BYTES_1_OFFSET_ANIM_TIER, 0x00);
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);

    RemoveAurasDueToSpell(20584);                           ///< 30% speed bonuses
    RemoveAurasDueToSpell(8326);                            ///< SPELL_AURA_GHOST

    if (GetGuild() || HasAura(84559) || HasAura(83950))
        RemoveAurasDueToSpell(84559); // The Quick and the Dead

    if (getClass() == CLASS_MONK && HasAura(131562))
        RemoveAurasDueToSpell(131562);

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    setDeathState(ALIVE);

    SetWaterWalking(false, true);
    SetRooted(false);

    m_deathTimer = 0;

    // set health/powers (0- will be set in caller)
    if (p_RestorePercent > 0.0f)
    {
        /// Percentage from SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER
        const AuraEffectList & l_ResurrectedHealthByGuildMember = GetAuraEffectsByType(SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER);

        for (AuraEffectList::const_iterator l_It = l_ResurrectedHealthByGuildMember.begin(); l_It != l_ResurrectedHealthByGuildMember.end(); ++l_It)
            AddPct(p_RestorePercent, (*l_It)->GetAmount());

        SetHealth(uint32(GetMaxHealth()*p_RestorePercent));

        for (int l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
            SetPower((Powers)l_Power, GetDefaultValuePower((Powers)l_Power));

        SetPower(POWER_MANA,   uint32(GetMaxPower(POWER_MANA)   * p_RestorePercent));

    }

    /// Trigger update zone for alive state zone updates
    uint32 l_NewZone, l_NewArea;

    GetZoneAndAreaId(l_NewZone, l_NewArea, true);
    UpdateZone(l_NewZone, l_NewArea);

    sOutdoorPvPMgr->HandlePlayerResurrects(this, l_NewZone);

    if (InBattleground())
    {
        SpawnCorpseBones();
        if (Battleground * l_Battleground = GetBattleground())
            l_Battleground->HandlePlayerResurrect(this);
    }

    /// Update visibility
    UpdateObjectVisibility();

    SummonLastSummonedBattlePet();
    SummonLastSummonedPet();

    if (!p_ApplySickness || GetSession()->IsPremium())
        return;

    /// Characters from level 1-10 are not affected by resurrection sickness.
    /// Characters from level 11-19 will suffer from one minute of sickness
    /// for each level they are above 10.
    /// Characters level 20 and up suffer from ten minutes of sickness.
    int32 l_StartLevel = sWorld->getIntConfig(CONFIG_DEATH_SICKNESS_LEVEL);

    if (int32(getLevel()) >= l_StartLevel)
    {
        /// Set resurrection sickness
        CastSpell(this, 15007, true);

        /// Not full duration
        if (int32(getLevel()) < l_StartLevel + 9)
        {
            int32 l_Data = (int32(getLevel()) - l_StartLevel + 1)*MINUTE;

            Aura* l_Aura = GetAura(15007, GetGUID());

            if (l_Aura != nullptr)
            {
                l_Aura->SetDuration(l_Data*IN_MILLISECONDS);
            }
        }
    }
}

void Player::KillPlayer()
{
    if (IsFlying() && !GetTransport())
        i_motionMaster.MoveFall();

    SetRooted(true);

    StopMirrorTimers();                                     //disable timers(bars)

    setDeathState(CORPSE);
    //SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);

    SetUInt32Value(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
    ApplyModFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION));

    // 6 minutes until repop at graveyard
    m_deathTimer = 6 * MINUTE * IN_MILLISECONDS;

    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
    SendCorpseReclaimDelay();

    // don't create corpse at this moment, player might be falling

    // update visibility
    UpdateObjectVisibility();

    UnsummonCurrentBattlePetIfAny(true);
}

Corpse* Player::CreateCorpse()
{
    // prevent existence 2 corpse for player
    SpawnCorpseBones();

    uint32 _cfb1, _cfb2;

    Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
    SetPvPDeath(false);

    if (!corpse->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_CORPSE), this))
    {
        corpse->CleanBeforeGC();
        sGarbageCollector->Add(corpse);
        return nullptr;
    }

    m_CorpseLocation.WorldRelocate(*this);

    uint8 race          = getRace();
    uint8 skin          = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
    uint8 face          = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_FACE_ID);
    uint8 hairstyle     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_STYLE_ID);
    uint8 haircolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);

    _cfb1 = ((0x00) | (race << 8) | (getGender() << 16) | (skin << 24));
    _cfb2 = ((face) | (hairstyle << 8) | (haircolor << 16));

    corpse->SetUInt32Value(CORPSE_FIELD_SKIN_ID, _cfb1);
    corpse->SetUInt32Value(CORPSE_FIELD_FACIAL_HAIR_STYLE_ID, _cfb2);
    corpse->SetUInt32Value(CORPSE_FIELD_CUSTOM_DISPLAY_OPTION, GetUInt32Value(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION));

    uint32 flags = 0;

    if (HasByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_PVP))
        flags |= CORPSE_FLAG_PVP;

    if (InBattleground() && !InArena())
        flags |= CORPSE_FLAG_SKINNABLE;                      // to be able to remove insignia

    if (HasByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP))
        flags |= CORPSE_FLAG_FFA_PVP;

    corpse->SetUInt32Value(CORPSE_FIELD_FLAGS, flags);
    corpse->SetUInt32Value(CORPSE_FIELD_DISPLAY_ID, GetNativeDisplayId());
    corpse->SetUInt32Value(CORPSE_FIELD_FACTION_TEMPLATE, sChrRacesStore[getRace()]->FactionID);

    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; i++)
    {
        if (m_items[i])
        {
            uint32 l_ItemDisplayId = m_items[i]->GetVisibleEntry(this);
            uint32 l_ItemInventoryType;

            if (ItemEntry const* itemEntry = sItemStore.LookupEntry(m_items[i]->GetVisibleEntry(this)))
                l_ItemInventoryType = itemEntry->InventoryType;
            else
                l_ItemInventoryType = m_items[i]->GetTemplate()->GetInventoryType();
            corpse->SetUInt32Value(CORPSE_FIELD_ITEMS + i, l_ItemDisplayId | (l_ItemInventoryType << 24));
        }
    }

    // we do not need to save corpses for BG/arenas
    if (!GetMap()->IsBattlegroundOrArena())
        corpse->SaveToDB();

    // register for player, but not show
    GetMap()->AddCorpse(corpse);

    return corpse;
}

void Player::SpawnCorpseBones(bool p_TriggerSave /*= true*/)
{
    m_CorpseLocation.WorldRelocate();

    if (!GetMap())
        return;

    if (GetMap()->ConvertCorpseToBones(GetGUID()))
        if (p_TriggerSave && !GetSession()->PlayerLogoutWithSave()) // at logout we will already store the player
            SaveToDB();                                             // prevent loading as ghost without corpse
}

Corpse* Player::GetCorpse() const
{
    if (!GetMap())
        return nullptr;

    return GetMap()->GetCorpseByPlayer(GetGUID());
}

void Player::DurabilityLossAll(double percent, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityLoss(pItem, percent);

    if (inventory)
    {
        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityLoss(pItem, percent);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = GetBagByPos(i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityLoss(pItem, percent);
    }
}

void Player::DurabilityLoss(Item* item, double percent)
{
    if (GetSession()->IsPremium())
        return;

    if (!item)
        return;

    if (item->HasFlag(EItemFields::ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_NO_DURABILITY_LOSS))
        return;

    uint32 pMaxDurability = item ->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);

    if (!pMaxDurability)
        return;

    percent /= GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS);

    uint32 pDurabilityLoss = uint32(pMaxDurability*percent);

    if (pDurabilityLoss < 1)
        pDurabilityLoss = 1;

    DurabilityPointsLoss(item, pDurabilityLoss);
}

void Player::DurabilityPointsLossAll(int32 points, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityPointsLoss(pItem, points);

    if (inventory)
    {
        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityPointsLoss(pItem, points);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityPointsLoss(pItem, points);
    }
}

void Player::DurabilityPointsLoss(Item* item, int32 points)
{
    if (HasAuraType(AuraType::SPELL_AURA_PREVENT_DURABILITY_LOSS))
        return;

    int32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    int32 pOldDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
    int32 pNewDurability = pOldDurability - points;

    if (pNewDurability < 0)
        pNewDurability = 0;
    else if (pNewDurability > pMaxDurability)
        pNewDurability = pMaxDurability;

    if (pOldDurability != pNewDurability)
    {
        // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
        if (pNewDurability == 0 && pOldDurability > 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), false);

        item->SetUInt32Value(ITEM_FIELD_DURABILITY, pNewDurability);

        // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
        if (pNewDurability > 0 && pOldDurability == 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), true);

        item->SetState(ITEM_CHANGED, this);
    }
}

void Player::DurabilityPointLossForEquipSlot(EquipmentSlots slot)
{
    if (HasAuraType(SPELL_AURA_PREVENT_DURABILITY_LOSS_FROM_COMBAT))
        return;

    if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
        DurabilityPointsLoss(pItem, 1);
}

uint32 Player::DurabilityRepairAll(bool cost, float discountMod, bool guildBank)
{
    uint32 TotalCost = 0;
    // equipped, backpack, bags itself
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        TotalCost += DurabilityRepair(((INVENTORY_SLOT_BAG_0 << 8) | i), cost, discountMod, guildBank);

    // bank, buyback and keys not repaired

    // items in inventory bags
    for (uint8 j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; j++)
        for (uint8 i = 0; i < MAX_BAG_SIZE; i++)
            TotalCost += DurabilityRepair(((j << 8) | i), cost, discountMod, guildBank);
    return TotalCost;
}

uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank)
{
    Item* item = GetItemByPos(pos);

    uint32 TotalCost = 0;
    if (!item)
        return TotalCost;

    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    if (!maxDurability)
        return TotalCost;

    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);

    if (cost)
    {
        uint32 LostDurability = maxDurability - curDurability;
        if (LostDurability>0)
        {
            ItemTemplate const* ditemProto = item->GetTemplate();

            DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
            if (!dcost)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
                return TotalCost;
            }

            uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
            DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
            if (!dQualitymodEntry)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
                return TotalCost;
            }
            uint32 dmultiplier = 0;
            if (ditemProto->Class == ITEM_CLASS_WEAPON)
                dmultiplier = dcost->WeaponSubClassCost[ditemProto->GetSubClass()];
            else if (ditemProto->Class == ITEM_CLASS_ARMOR)
                dmultiplier = dcost->ArmorSubClassCost[ditemProto->GetSubClass()];

            uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod) * item->GetRepairCostMultiplier());

            costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));

            if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                costs = 1;

#ifdef CROSS
            /// @TODO: Handle guild bank repair in cross
#endif /* CROSS */
            if (guildBank)
#ifndef CROSS
            {
                if (GetGuildId() == 0)
                {
                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You are not member of a guild");
                    return TotalCost;
                }

                Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
                if (!guild)
                    return TotalCost;

                if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
                    return TotalCost;

                guild->GetAchievementMgr().UpdateCriteria(CRITERIA_TYPE_SPENT_GOLD_GUILD_REPAIRS, TotalCost, 0, 0, nullptr, this);

                TotalCost = costs;
            }
#else /* CROSS */
                return TotalCost;
#endif /* CROSS */
            else if (!HasEnoughMoney(uint64(costs)))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You do not have enough money");
                return TotalCost;
            }
            else
                ModifyMoney(-int64(costs), "Player::DurabilityRepair");
        }
    }

    item->SetUInt32Value(ITEM_FIELD_DURABILITY, maxDurability);
    item->SetState(ITEM_CHANGED, this);

    // reapply mods for total broken and repaired item if equipped
    if (IsEquipmentPos(pos) && !curDurability)
        _ApplyItemMods(item, pos & 255, true);
    return TotalCost;
}

class DelayedResurrection : public BasicEvent
{
    public:
        DelayedResurrection(uint64 p_Guid) : BasicEvent(), m_Guid(p_Guid) { }
        virtual ~DelayedResurrection() { }

        virtual bool Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
        {
            if (Player* l_Player = HashMapHolder<Player>::Find(m_Guid))
            {
                l_Player->ResurrectPlayer(0.8f);
                l_Player->SpawnCorpseBones();
            }

            return true;
        }

        virtual void Abort(uint64 p_EndTime) { }

    private:
        uint64 m_Guid;
};

void Player::RepopAtGraveyard(bool p_ForceGraveyard /*= false*/)
{
    // note: this can be called also when the player is alive
    // for example from WorldSession::HandleMovementOpcodes

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(GetAreaId());

    if (!zone)
    {
        sLog->outInfo(LOG_FILTER_PLAYER, "Player %u in null area; area id : %u", GetGUIDLow(), GetAreaId());
        return;
    }

    // Such zones are considered unreachable as a ghost and the player must be automatically revived
    if ((!isAlive() && zone && zone->Flags & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < GetMap()->GetMinHeight(GetPositionX(), GetPositionY()))
    {
        ResurrectPlayer(0.5f);
        SpawnCorpseBones();
    }

    bool l_Done = false;
    WorldSafeLocsEntry const* l_ClosestGrave = nullptr;

    if (Battleground* l_BG = GetBattleground())
        l_ClosestGrave = l_BG->GetClosestGraveYard(this);
#ifndef CROSS
    else if (IsInDraenorGarrison())
    {
        l_ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
    }
    /// Since WoD, when you die in a dungeon and you release your spirit, you are teleported alive at the entrance of the dungeon.
#endif

    else if (GetMap()->IsDungeon() && !p_ForceGraveyard)
    {
        float l_X       = 0.0f;
        float l_Y       = 0.0f;
        float l_Z       = 0.0f;
        float l_O       = 0.0f;
        uint32 l_MapID  = GetMapId();

        if (AreaTriggerStruct const* l_AreaTrigger = sObjectMgr->GetMapEntranceTrigger(l_MapID))
        {
            l_X     = l_AreaTrigger->target_X;
            l_Y     = l_AreaTrigger->target_Y;
            l_Z     = l_AreaTrigger->target_Z;
            l_O     = m_orientation;
            l_MapID = l_AreaTrigger->target_mapId;
        }

        bool l_CustomRelease = false;
        if (InstanceScript* l_Instance = GetInstanceScript())
        {
            l_CustomRelease = l_Instance->IsReleaseAllowed() && l_Instance->IsEncounterInProgress();
            l_Instance->RelocateResPosIfNeeded(l_X, l_Y, l_Z, l_O, l_MapID, this);
        }

        /// We don't have a map entrance trigger and there isn't a custom scripted graveyard
        /// Try to match with default graveyard database
        if (G3D::fuzzyEq(l_X, 0.0f) && G3D::fuzzyEq(l_Y, 0.0f) && G3D::fuzzyEq(l_Z, 0.0f) && G3D::fuzzyEq(l_O, 0.0f))
        {
            l_ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
            if (l_ClosestGrave && l_ClosestGrave->MapID == l_MapID)
            {
                l_X = l_ClosestGrave->x;
                l_Y = l_ClosestGrave->y;
                l_Z = l_ClosestGrave->z;
                l_O = l_ClosestGrave->o;
            }
        }

        TeleportToClosestGrave(l_X, l_Y, l_Z, l_O, l_MapID, !l_CustomRelease);

        /// Since WoD, you are resurrected in Dungeon with 100% life.
        if (!isAlive() && !l_CustomRelease)
            m_Events.AddEvent(new DelayedResurrection(GetGUID()), 1 * TimeConstants::IN_MILLISECONDS);

        l_Done = true;
    }
    /// PvP Duel Zone
    else if (GetAreaId() == 2401 && sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
         ResurrectPlayer(1);
         RegenerateAll();
    }
    else
    {
        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(GetZoneId()))
            l_ClosestGrave = bf->GetClosestGraveYard(this);
        /// These checks are here to avoid old Outdoor scripts without GetClosestGraveyard function
        else if (sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId()) != nullptr &&
            sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())->GetClosestGraveyard(this) != nullptr)
        {
            if (OutdoorPvP* l_OutdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())) ///< l_OutdoorPvP is unused
                l_ClosestGrave = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())->GetClosestGraveyard(this);
        }
        else
            l_ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
    }

    /// Stop countdown until repop
    m_deathTimer = 0;

    /// If no grave found, stay at the current location
    /// And don't show spirit healer location
    if (!l_Done)
    {
        if (l_ClosestGrave != nullptr)
            TeleportToClosestGrave(l_ClosestGrave);
        else if (l_ClosestGrave == nullptr && GetMapId() == 1803)
        {
            Battleground* l_BG = GetBattleground();
            if (l_BG == nullptr)
                TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());

            l_BG->RepopPlayerAtGraveyard(GetGUID());
        }
        else if (GetPositionZ() < GetMap()->GetMinHeight(GetPositionX(), GetPositionY()))
            TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());
    }

    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
}

void Player::TeleportToClosestGrave(float p_X, float p_Y, float p_Z, float p_O, uint32 p_MapId, bool p_Packet /*= true*/)
{
    TeleportTo(p_MapId, p_X, p_Y, p_Z, p_O);
    UpdateObjectVisibility();

    /// not send if alive, because it used in TeleportTo()
    if (isDead() && p_Packet)
    {
        WorldPacket l_Data(SMSG_DEATH_RELEASE_LOC, 4 * 4);  // show spirit healer position on minimap
        l_Data << p_MapId;
        l_Data << p_X;
        l_Data << p_Y;
        l_Data << p_Z;
        GetSession()->SendPacket(&l_Data);
    }
}

void Player::SendCemeteryList(bool p_OnMap)
{
    ByteBuffer l_Buffer(50);
    uint32 l_Counter = 0;

    uint32 l_ZoneID = GetZoneId();
    GraveYardContainer::const_iterator l_GraveLow  = sObjectMgr->GraveYardStore.lower_bound(l_ZoneID);
    GraveYardContainer::const_iterator l_GraveUP   = sObjectMgr->GraveYardStore.upper_bound(l_ZoneID);
    for (GraveYardContainer::const_iterator l_Iter = l_GraveLow; l_Iter != l_GraveUP; ++l_Iter)
    {
        ++l_Counter;
        l_Buffer << uint32(l_Iter->second.safeLocId);
    }

    WorldPacket l_Packet(SMSG_REQUEST_CEMETERY_LIST_RESPONSE, l_Buffer.size() + 4 + 1);
    l_Packet.WriteBit(p_OnMap);
    l_Packet.FlushBits();
    l_Packet << uint32(l_Counter);
    if (l_Counter)
        l_Packet.append(l_Buffer);
    GetSession()->SendPacket(&l_Packet);
}

bool Player::CanJoinConstantChannelInZone(ChatChannelsEntry const* channel, AreaTableEntry const* zone)
{
    if (channel->Flags & CHANNEL_DBC_FLAG_ZONE_DEP && zone->Flags & AREA_FLAG_ARENA_INSTANCE)
        return false;

    if ((channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY) && (!(zone->Flags & AREA_FLAG_SLAVE_CAPITAL)))
        return false;

    if ((channel->Flags & CHANNEL_DBC_FLAG_GUILD_REQ) && GetGuildId())
        return false;

    return true;
}

void Player::JoinedChannel(Channel* c)
{
    m_channels.push_back(c);
}

void Player::LeftChannel(Channel* c)
{
    m_channels.remove(c);
}

void Player::CleanupChannels()
{
    while (!m_channels.empty())
    {
        Channel* ch = *m_channels.begin();
        m_channels.erase(m_channels.begin());               // remove from player's channel list
        ch->Leave(GetGUID(), false);                        // not send to client, not remove from player's channel list
        if (ChannelMgr* cMgr = channelMgr(GetTeam()))
            cMgr->LeftChannel(ch->GetName());               // deleted channel if empty
    }
    sLog->outDebug(LOG_FILTER_CHATSYS, "Player: channels cleaned up!");
}

void Player::UpdateChatLocaleFiltering()
{
    for (auto l_It = m_channels.begin(); l_It != m_channels.end(); ++l_It)
    {
        Channel* l_Channel = (*l_It);

        if (l_Channel)
            l_Channel->UpdateChatLocaleFiltering(this);
    }
}

void Player::UpdateLocalChannels(uint32 newZone)
{
    if (GetSession()->PlayerLoading() && !IsBeingTeleportedFar())
        return;                                              // The client handles it automatically after loading, but not after teleporting

    AreaTableEntry const* current_zone = sAreaTableStore.LookupEntry(newZone);
    if (!current_zone)
        return;

    ChannelMgr* cMgr = channelMgr(GetTeam());
    if (!cMgr)
        return;

    std::string current_zone_name = current_zone->AreaNameLang->Get(sWorld->GetDefaultDb2Locale());

    for (uint32 i = 0; i < sChatChannelsStore.GetNumRows(); ++i)
    {
        if (ChatChannelsEntry const* channel = sChatChannelsStore.LookupEntry(i))
        {
            Channel* usedChannel = NULL;

            auto itr = std::find_if(m_channels.begin(), m_channels.end(), [&i](Channel const* var) { return var && var->GetChannelId() == i; });
            if (itr != m_channels.end())
                usedChannel = *itr;

            for (JoinedChannelsList::iterator itr = m_channels.begin(); itr != m_channels.end(); ++itr)
            {
                if ((*itr)->GetChannelId() == i)
                {
                    usedChannel = *itr;
                    break;
                }
            }

            Channel* removeChannel = NULL;
            Channel* joinChannel = NULL;
            bool sendRemove = true;

            if (CanJoinConstantChannelInZone(channel, current_zone))
            {
                if (!(channel->Flags & CHANNEL_DBC_FLAG_GLOBAL))
                {
                    if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
                        continue;                            // Already on the channel, as city channel names are not changing

                    char new_channel_name_buf[100];
                    char const* currentNameExt;

                    if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY)
                        currentNameExt = sObjectMgr->GetTrinityStringForDB2Locale(LANG_CHANNEL_CITY);
                    else
                        currentNameExt = current_zone_name.c_str();

                    snprintf(new_channel_name_buf, 100, channel->NameLang->Get(sWorld->GetDefaultDb2Locale()), currentNameExt);

                    joinChannel = cMgr->GetJoinChannel(new_channel_name_buf, channel->ID);
                    if (usedChannel)
                    {
                        if (joinChannel != usedChannel)
                        {
                            removeChannel = usedChannel;
                            sendRemove = false;              // Do not send leave channel, it already replaced at client
                        }
                        else
                            joinChannel = NULL;
                    }
                }
                else
                    joinChannel = cMgr->GetJoinChannel(channel->NameLang->Get(sWorld->GetDefaultDb2Locale()), channel->ID);
            }
            else
                removeChannel = usedChannel;

            if (joinChannel)
                joinChannel->Join(GetGUID(), "");            // Changed Channel: ... or Joined Channel: ...

            if (removeChannel)
            {
                removeChannel->Leave(GetGUID(), sendRemove); // Leave old channel
                std::string name = removeChannel->GetName(); // Store name, (*i)erase in LeftChannel
                LeftChannel(removeChannel);                  // Remove from player's channel list
                cMgr->LeftChannel(name);                     // Delete if empty
            }
        }
    }
}

void Player::LeaveLFGChannel()
{
    for (JoinedChannelsList::iterator i = m_channels.begin(); i != m_channels.end(); ++i)
    {
        if ((*i)->IsLFG())
        {
            (*i)->Leave(GetGUID());
            break;
        }
    }
}

void Player::HandleBaseModValue(BaseModGroup modGroup, BaseModType modType, float amount, bool apply)
{
    if (modGroup >= BASEMOD_END || uint8(modType) >= MOD_END)
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "ERROR in HandleBaseModValue(): non existed BaseModGroup of wrong BaseModType!");
        return;
    }

    switch (modType)
    {
        case FLAT_MOD:
            m_auraBaseMod[modGroup][modType] += apply ? amount : -amount;
            break;
        case PCT_MOD:
            ApplyPercentModFloatVar(m_auraBaseMod[modGroup][modType], amount, apply);
            break;
    }

    if (!CanModifyStats())
        return;

    switch (modGroup)
    {
        case CRIT_PERCENTAGE:              UpdateCritPercentage(WeaponAttackType::BaseAttack);                          break;
        case RANGED_CRIT_PERCENTAGE:       UpdateCritPercentage(WeaponAttackType::RangedAttack);                        break;
        case OFFHAND_CRIT_PERCENTAGE:      UpdateCritPercentage(WeaponAttackType::OffAttack);                           break;
        default: break;
    }
}

float Player::GetBaseModValue(BaseModGroup modGroup, BaseModType modType) const
{
    if (modGroup >= BASEMOD_END || uint8(modType) >= MOD_END)
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "trial to access non existed BaseModGroup or wrong BaseModType!");
        return 0.0f;
    }

    if (modType == PCT_MOD && m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][modType];
}

float Player::GetTotalBaseModValue(BaseModGroup modGroup) const
{
    if (modGroup >= BASEMOD_END)
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "wrong BaseModGroup in GetTotalBaseModValue()!");
        return 0.0f;
    }

    if (m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][FLAT_MOD] * m_auraBaseMod[modGroup][PCT_MOD];
}

float Player::GetRatingMultiplier(CombatRating cr) const
{
    CombatRatingsTableEntry const* l_Rating = g_CombatRatingsTable.LookupEntry(getLevel());

    if (!l_Rating)
        return 1.0f; ///< By default use minimum coefficient (not must be called)

    float l_Value = l_Rating->GetValue(cr);

    if (!l_Value)
        return 1.0f;                                        // By default use minimum coefficient (not must be called)

    return 1.0f / l_Value;
}

float Player::GetRatingBonusValue(CombatRating cr) const
{
    float baseResult = float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) * GetRatingMultiplier(cr);

    if (cr != CR_RESILIENCE_PLAYER_DAMAGE_TAKEN)
        return baseResult;

    //return float(1.0f - pow(0.99f, baseResult)) * 100.0f;
    return float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) / 1070; // temp hack ///< "TEMP" last see 01/08/2016
}

float Player::GetPvpHealingBonus() const
{
    // Pvp healing cannot work in dungeons
    if (Map* l_Map = GetMap())
        if (l_Map->IsDungeon())
            return 1.0f;

    float l_PvpPower = (1 + GetFloatValue(PLAYER_FIELD_PVP_POWER_HEALING) / 100);

    return l_PvpPower;
}

void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
{
    float oldRating = m_baseRatingValue[cr];
    m_baseRatingValue[cr] += (apply ? value : -value);

    // explicit affected values
    float const multiplier = GetRatingMultiplier(cr);
    float const oldVal = oldRating * multiplier;
    float const newVal = m_baseRatingValue[cr] * multiplier;
    switch (cr)
    {
        case CR_HASTE_MELEE:
        {
            ApplyAttackTimePercentMod(WeaponAttackType::BaseAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::OffAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::BaseAttack, newVal, true);
            ApplyAttackTimePercentMod(WeaponAttackType::OffAttack, newVal, true);
            if (getClass() == CLASS_DEATH_KNIGHT)
                UpdateAllRunesRegen();
            break;
        }
        case CR_HASTE_RANGED:
        {
            ApplyAttackTimePercentMod(WeaponAttackType::RangedAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::RangedAttack, newVal, true);
            break;
        }
        case CR_HASTE_SPELL:
        {
            ApplyCastTimePercentMod(oldVal, false);
            ApplyCastTimePercentMod(newVal, true);
            break;
        }
        default:
            break;
    }

    UpdateRating(cr);
}

void Player::UpdateRating(CombatRating p_CombatRating)
{
    /// Apply pct modifier from SPELL_AURA_INCREASE_RATING_PCT
    float l_Modifier = 1.0f;
    AuraEffectList const& l_ModRatingPCT = GetAuraEffectsByType(AuraType::SPELL_AURA_INCREASE_RATING_PCT);
    for (AuraEffectList::const_iterator l_Iter = l_ModRatingPCT.begin(); l_Iter != l_ModRatingPCT.end(); ++l_Iter)
    {
        if ((*l_Iter)->GetMiscValue() & (1 << p_CombatRating))
            l_Modifier += float((*l_Iter)->GetAmount()) / 100.0f;
    }

    int32 l_Amount = m_baseRatingValue[p_CombatRating] * l_Modifier;

    if (l_Amount < 0)
        l_Amount = 0;

    SetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + p_CombatRating, uint32(l_Amount));

    if (p_CombatRating >= CR_HASTE_MELEE && p_CombatRating <= CR_HASTE_SPELL)
    {
        float l_HastePct = l_Amount * GetRatingMultiplier(p_CombatRating);

        AuraEffectList const& l_HasteAuras = GetAuraEffectsByType(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK);
        for (AuraEffectList::const_iterator l_Iter = l_HasteAuras.begin(); l_Iter != l_HasteAuras.end(); ++l_Iter)
        {
            float l_Amount = (*l_Iter)->GetAmount();

            l_HastePct *= (1.0f + l_Amount / 100.0f);
            l_HastePct += l_Amount;
        }

        std::map<SpellGroup, int32> SameEffectSpellGroup;
        AuraEffectList const& l_MeleeSlowAuras = GetAuraEffectsByType(SPELL_AURA_MELEE_SLOW);
        for (AuraEffectList::const_iterator l_Iter = l_MeleeSlowAuras.begin(); l_Iter != l_MeleeSlowAuras.end(); ++l_Iter)
        {
            float l_Amount = (*l_Iter)->GetSpellInfo()->GetFloatAmount((*l_Iter)->GetAmount());

            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*l_Iter)->GetSpellInfo(), l_Amount, SameEffectSpellGroup))
            {
                l_HastePct *= (1.0f + l_Amount / 100.0f);
                l_HastePct += l_Amount;
            }
        }

        for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        {
            float l_Amount = itr->second;

            l_HastePct *= (1.0f + l_Amount / 100.0f);
            l_HastePct += l_Amount;
        }

        float l_Haste = 100.0f / (std::abs(l_HastePct) + 100.0f);

        if (l_HastePct < 0.0f)
            l_Haste = 1.0f / l_Haste;

        float l_OldHaste = GetFloatValue(EUnitFields::UNIT_FIELD_MOD_HASTE);

        /// Update haste percentage for client
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_SPELL_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_RANGED_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_HASTE_REGEN, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_CASTING_SPEED, l_Haste);

        /// Cooldowns can't go above the "base cooldown" of the spell because of negative haste (which is HasteValue > 1 here)
        if (HasHasteRatingRequirement(p_CombatRating))
            UpdateCooldowns(std::min(1.0f, l_OldHaste), std::min(1.0f, l_Haste), true);

        UpdateManaRegen();
        UpdateEnergyRegen();
        UpdateFocusRegen();
        UpdateAllRunesRegen();
    }

    bool l_AffectStats = CanModifyStats();

    switch (p_CombatRating)
    {
        case CR_DODGE:
            UpdateDodgePercentage();
            break;
        case CR_PARRY:
            UpdateParryPercentage();
            break;
        case CR_BLOCK:
            UpdateBlockPercentage();
            break;
        case CR_HIT_MELEE:
            UpdateMeleeHitChances();
            break;
        case CR_HIT_RANGED:
            UpdateRangedHitChances();
            break;
        case CR_HIT_SPELL:
            UpdateSpellHitChances();
            break;
        case CR_CRIT_MELEE:
            if (l_AffectStats)
            {
                UpdateCritPercentage(WeaponAttackType::BaseAttack);
                UpdateCritPercentage(WeaponAttackType::OffAttack);
            }
            break;
        case CR_CRIT_RANGED:
            if (l_AffectStats)
                UpdateCritPercentage(WeaponAttackType::RangedAttack);
            break;
        case CR_CRIT_SPELL:
            if (l_AffectStats)
                UpdateAllCritPercentages();
            UpdateDodgePercentage();
            break;
        case CR_SPEED:
            UpdateSpeedPercentage();
            break;
        case CR_MASTERY:                                    // Implemented in Player::UpdateMasteryPercentage
            UpdateMasteryPercentage();
            break;
        case CR_LIFESTEAL:
            UpdateLeechPercentage();
            break;
        case CR_VERSATILITY_DAMAGE_DONE:
        case CR_VERSATILITY_DAMAGE_TAKEN:
            UpdateVersatilityPercentage();
            break;
        case CR_AVOIDANCE:
            UpdateAvoidancePercentage();
            break;
        case CR_HASTE_MELEE:                                // Implemented in Player::ApplyRatingMod
        case CR_HASTE_RANGED:
        case CR_HASTE_SPELL:
        case CR_RESILIENCE_PLAYER_DAMAGE_TAKEN:
        case CR_RESILIENCE_CRIT_TAKEN:
        case CR_DEFENSE_SKILL:
        default:
            break;
    }
}

bool Player::HasHasteRatingRequirement(CombatRating p_CombatRating)
{
    switch (GetActiveSpecializationID())
    {
        case SPEC_PALADIN_PROTECTION:
        case SPEC_PALADIN_RETRIBUTION:
        case SPEC_WARRIOR_ARMS:
        case SPEC_WARRIOR_FURY:
        case SPEC_WARRIOR_PROTECTION:
        case SPEC_DRUID_FERAL:
        case SPEC_DRUID_GUARDIAN:
        case SPEC_DK_BLOOD:
        case SPEC_DK_FROST:
        case SPEC_DK_UNHOLY:
        case SPEC_DEMON_HUNTER_HAVOC:
        case SPEC_DEMON_HUNTER_VENGEANCE:
        case SPEC_ROGUE_ASSASSINATION:
        case SPEC_ROGUE_OUTLAW:
        case SPEC_ROGUE_SUBTLETY:
        case SPEC_SHAMAN_ELEMENTAL:
        case SPEC_MONK_WINDWALKER:
        case SPEC_MONK_BREWMASTER:
            if (p_CombatRating == CombatRating::CR_HASTE_MELEE)
                return true;
            break;
        case SPEC_HUNTER_BEASTMASTERY:
        case SPEC_HUNTER_MARKSMANSHIP:
        case SPEC_HUNTER_SURVIVAL:
            if (p_CombatRating == CombatRating::CR_HASTE_RANGED)
                return true;
            break;
        case SPEC_PALADIN_HOLY:
        case SPEC_MAGE_ARCANE:
        case SPEC_MAGE_FIRE:
        case SPEC_MAGE_FROST:
        case SPEC_DRUID_BALANCE:
        case SPEC_DRUID_RESTORATION:
        case SPEC_PRIEST_DISCIPLINE:
        case SPEC_PRIEST_HOLY:
        case SPEC_PRIEST_SHADOW:
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_SHAMAN_RESTORATION:
        case SPEC_WARLOCK_AFFLICTION:
        case SPEC_WARLOCK_DEMONOLOGY:
        case SPEC_WARLOCK_DESTRUCTION:
        case SPEC_MONK_MISTWEAVER:
            if (p_CombatRating == CombatRating::CR_HASTE_SPELL)
                return true;
            break;
        default:
            break;
    }
    return false;
}

void Player::UpdateAllRatings()
{
    for (int cr = 0; cr < MAX_COMBAT_RATING; ++cr)
        UpdateRating(CombatRating(cr));
}

void Player::SetRegularAttackTime()
{
    for (uint8 i = 0; i < WeaponAttackType::MaxAttack; ++i)
    {
        Item* tmpitem = GetWeaponForAttack(WeaponAttackType(i), true);
        if (tmpitem && !tmpitem->CantBeUse())
        {
            ItemTemplate const* proto = tmpitem->GetTemplate();
            if (proto->Delay)
                SetAttackTime(WeaponAttackType(i), proto->Delay);
        }
        else
            SetAttackTime(WeaponAttackType(i), BASE_ATTACK_TIME);  // If there is no weapon reset attack time to base (might have been changed from forms)
    }
}

//skill+step, checking for max value
bool Player::UpdateSkill(uint32 skill_id, uint32 step)
{
    if (!skill_id)
        return false;

    SkillStatusMap::iterator itr = mSkillStatus.find(skill_id);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return false;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

    if (!max || !value || value >= max)
        return false;

    if (value < max)
    {
        uint32 new_value = value + step;
        if (new_value > max)
            new_value = max;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, new_value);
        if (itr->second.uState != SKILL_NEW)
            itr->second.uState = SKILL_CHANGED;

        UpdateSkillEnchantments(skill_id, value, new_value);
        UpdateCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
        return true;
    }

    return false;
}

inline int SkillGainChance(uint32 SkillValue, uint32 GrayLevel, uint32 GreenLevel, uint32 YellowLevel)
{
    if (SkillValue >= GrayLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREY)*10;
    if (SkillValue >= GreenLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREEN)*10;
    if (SkillValue >= YellowLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_YELLOW)*10;
    return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10;
}

bool Player::UpdateCraftSkill(uint32 spellid)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateCraftSkill spellid %d", spellid);

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellid);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        if (_spell_idx->second->SkillLine)
        {
            uint32 SkillValue = GetPureSkillValue(_spell_idx->second->SkillLine);

            // Alchemy Discoveries here
            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(spellid);
            if (spellEntry && spellEntry->Mechanic == MECHANIC_DISCOVERY)
            {
                if (uint32 discoveredSpell = GetSkillDiscoverySpell(_spell_idx->second->SkillLine, spellid, this))
                    learnSpell(discoveredSpell, false);
            }

            uint32 craft_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_CRAFTING);
            int skill_gain_chance = SkillGainChance(SkillValue, _spell_idx->second->TrivialSkillLineRankHigh, (_spell_idx->second->TrivialSkillLineRankHigh + _spell_idx->second->TrivialSkillLineRankLow)/2, _spell_idx->second->TrivialSkillLineRankLow);

            // Since 4.0.x, we have bonus skill point reward with somes items ...
            if (_spell_idx->second && _spell_idx->second->NumSkillUps >craft_skill_gain && skill_gain_chance == sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10)
                craft_skill_gain = _spell_idx->second->NumSkillUps;

            auto skillId = _spell_idx->second->SkillLine;
            if (UpdateSkillPro(skillId, skill_gain_chance, craft_skill_gain))
            {
                if (SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(skillId))
                {
                    if (uint32 parentSkillId = skillEntry->ParentSkillLineID)
                        return UpdateSkillPro(parentSkillId, skill_gain_chance, craft_skill_gain);
                }

                return true;
            }

            return false;
        }
    }
    return false;
}

bool Player::UpdateGatherSkill(uint32 SkillId, uint32 SkillValue, uint32 RedLevel, uint32 Multiplicator)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateGatherSkill(SkillId %d SkillLevel %d RedLevel %d)", SkillId, SkillValue, RedLevel);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
    switch (SkillId)
    {
        case SKILL_HERBALISM:
        case SKILL_JEWELCRAFTING:
        case SKILL_INSCRIPTION:
            return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
        case SKILL_SKINNING:
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            else
                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS)), gathering_skill_gain);
        case SKILL_MINING:
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            else
                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS)), gathering_skill_gain);
    }
    return false;
}

bool Player::UpdateFishingSkill()
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateFishingSkill");

    uint32 SkillValue = GetPureSkillValue(SKILL_FISHING);

    int32 chance = SkillValue < 75 ? 100 : 2500/(SkillValue-50);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    return UpdateSkillPro(SKILL_FISHING, chance*10, gathering_skill_gain);
}

/// levels sync. with spell requirement for skill levels to learn
/// bonus abilities in sSkillLineAbilityStore
/// Used only to avoid scan DB2 at each skill grow
static uint32 g_BonusSkillLevels[] = {75, 150, 225, 300, 375, 450, 525, 600, 700, 800};
static const size_t g_BonusSkillLevelsSize = sizeof(g_BonusSkillLevels) / sizeof(uint32);

bool Player::UpdateSkillPro(uint16 p_SkillId, int32 p_Chance, uint32 p_Step)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateSkillPro(SkillId %d, Chance %3.1f%%)", p_SkillId, p_Chance / 10.0f);

    if (!p_SkillId)
        return false;

    if (p_Chance <= 0)                                         // speedup in 0 chance case
    {
        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", p_Chance / 10.0f);
        return false;
    }

    SkillStatusMap::iterator l_It = mSkillStatus.find(p_SkillId);
    if (l_It == mSkillStatus.end() || l_It->second.uState == SKILL_DELETED)
        return false;

    uint16 l_SkillField       = l_It->second.pos / 2;
    uint8  l_SkillFieldOffset = l_It->second.pos & 1; // itr->second.pos % 2

    uint16 l_CurrentSkillValue      = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + l_SkillField, l_SkillFieldOffset);
    uint16 l_CurrentSkillMaxValue   = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + l_SkillField, l_SkillFieldOffset);

    if (!l_CurrentSkillMaxValue || !l_CurrentSkillValue || l_CurrentSkillValue >= l_CurrentSkillMaxValue)
        return false;

    int32 l_Roll = irand(1, 1000);

    if (l_Roll <= p_Chance)
    {
        uint16 l_NewSkillValue = l_CurrentSkillValue + p_Step;
        if (l_NewSkillValue > l_CurrentSkillMaxValue)
            l_NewSkillValue = l_CurrentSkillMaxValue;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + l_SkillField, l_SkillFieldOffset, l_NewSkillValue);

        if (l_It->second.uState != SKILL_NEW)
            l_It->second.uState = SKILL_CHANGED;

        for (size_t l_I = 0; l_I < g_BonusSkillLevelsSize; ++l_I)
        {
            uint32 l_BonusSkillLevel = g_BonusSkillLevels[l_I];
            if (l_CurrentSkillValue < l_BonusSkillLevel && l_NewSkillValue >= l_BonusSkillLevel)
            {
                learnSkillRewardedSpells(p_SkillId, l_NewSkillValue);
                break;
            }
        }

        UpdateSkillEnchantments(p_SkillId, l_CurrentSkillValue, l_NewSkillValue);
        UpdateCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, p_SkillId);

        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% taken", p_Chance / 10.0f);

        return true;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", p_Chance / 10.0f);
    return false;
}

void Player::ModifySkillBonus(uint32 skillid, int32 val, bool talent)
{
    SkillStatusMap::const_iterator itr = mSkillStatus.find(skillid);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return;

    uint16 field = itr->second.pos / 2 + (talent ? PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET : PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET);
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 bonus = GetUInt16Value(field, offset);

    SetUInt16Value(field, offset, bonus + val);
}

void Player::UpdateSkillsForLevel()
{
    uint32 maxSkill = GetMaxSkillValueForLevel();

    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
    {
        if (itr->second.uState == SKILL_DELETED)
            continue;

        uint32 pskill = itr->first;
        SkillRaceClassInfoEntry const* rcEntry = GetSkillRaceClassInfo(pskill, getRace(), getClass());
        if (!rcEntry)
            continue;

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

        if (GetSkillRangeType(rcEntry) == SKILL_RANGE_LEVEL)
        {
            if (!IsWeaponSkill(rcEntry->SkillID))
            {
                uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

                /// update only level dependent max skill values
                if (max != 1)
                {
                    SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, maxSkill);
                    SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxSkill);
                    if (itr->second.uState != SKILL_NEW)
                        itr->second.uState = SKILL_CHANGED;
                }
            }
        }

        // Update level dependent skillline spells
        learnSkillRewardedSpells(rcEntry->SkillID, GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    }
}

void Player::UpdateSkillsToMaxSkillsForLevel()
{
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
    {
        if (itr->second.uState == SKILL_DELETED)
            continue;

        uint32 pskill = itr->first;
        SkillRaceClassInfoEntry const* rcEntry = GetSkillRaceClassInfo(pskill, getRace(), getClass());
        if (!rcEntry)
            continue;

        if (IsProfessionOrRidingSkill(rcEntry->SkillID))
            continue;

        if (IsWeaponSkill(rcEntry->SkillID))
            continue;

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

        if (max > 1)
        {
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, max);

            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_CHANGED;
        }
    }
}

// This functions sets a skill line value (and adds if doesn't exist yet)
// To "remove" a skill line, set it's values to zero
void Player::SetSkill(uint16 id, uint16 step, uint16 newVal, uint16 maxVal)
{
    if (!id)
        return;

    uint16 currVal;
    SkillStatusMap::iterator itr = mSkillStatus.find(id);

    //has skill
    if (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED)
    {
        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
        currVal = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
        if (newVal)
        {
            // if skill value is going down, update enchantments before setting the new value
            if (newVal < currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, id);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, newVal);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxVal);

            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_CHANGED;

            learnSkillRewardedSpells(id, newVal);
            // if skill value is going up, update enchantments after setting the new value
            if (newVal > currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            UpdateCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
            UpdateCriteria(CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
        }
        else                                                //remove
        {
            //remove enchantments needing this skill
            UpdateSkillEnchantments(id, currVal, 0);
            // clear skill fields
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, id);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

            // mark as deleted or simply remove from map if not saved yet
            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_DELETED;
            else
                mSkillStatus.erase(itr);

            // remove all spells that related to this skill
            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
                if (SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j))
                    if (pAbility->SkillLine == id)
                        removeSpell(sSpellMgr->GetFirstSpellInChain(pAbility->spellId));

            // Clear profession lines
            if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, 0);
            else if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, 0);
        }

        /// Backport wod unlearned skill ui fix
        if (step == 0 && newVal == 0 && maxVal == 0)
        {
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, id);
            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, 0);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, 0);
        }
    }
    else if (newVal)                                        //add
    {
        currVal = 0;
        for (uint32 i = 0; i < PLAYER_MAX_SKILLS; ++i)
        {
            uint16 field = i / 2;
            uint8 offset = i & 1; // i % 2

            uint32 l_SkillId = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset);

            if (!l_SkillId || l_SkillId == id)
            {
                SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(id);
                if (!skillEntry)
                {
                    sLog->outError(LOG_FILTER_GENERAL, "Skill not found in SkillLineStore: skill #%u", id);
                    return;
                }

                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, id);
                if (skillEntry->CategoryID == SKILL_CATEGORY_PROFESSION)
                {
                    if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, id);
                    else if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, id);
                }

                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, newVal);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxVal);

                UpdateSkillEnchantments(id, currVal, newVal);
                UpdateCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
                UpdateCriteria(CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);

                // insert new entry or update if not deleted old entry yet
                if (itr != mSkillStatus.end())
                {
                    itr->second.pos = i;
                    itr->second.uState = SKILL_CHANGED;
                }
                else
                    mSkillStatus.insert(SkillStatusMap::value_type(id, SkillStatusData(i, SKILL_NEW)));

                // apply skill bonuses
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

                // temporary bonuses
                AuraEffectList const& mModSkill = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL);
                for (AuraEffectList::const_iterator j = mModSkill.begin(); j != mModSkill.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);
                AuraEffectList const& mModSkill2 = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_VALUE);
                for (AuraEffectList::const_iterator j = mModSkill2.begin(); j != mModSkill2.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // permanent bonuses
                AuraEffectList const& mModSkillTalent = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_TALENT);
                for (AuraEffectList::const_iterator j = mModSkillTalent.begin(); j != mModSkillTalent.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // Learn all spells for skill
                learnSkillRewardedSpells(id, newVal);
                return;
            }
        }
    }
}

bool Player::HasSkill(uint32 skill) const
{
    if (!skill)
        return false;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    return (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED);
}

uint16 Player::GetSkillStep(uint16 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + itr->second.pos / 2, itr->second.pos & 1);
}

uint16 Player::GetSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);
}

uint16 Player::GetBaseSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
}

int16 Player::GetSkillPermBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset);
}

int16 Player::GetSkillTempBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset);
}

void Player::SendActionButtons(uint32 p_State) const
{
    WorldPacket l_Data(SMSG_UPDATE_ACTION_BUTTONS, 1 + (MAX_ACTION_BUTTONS * 8));

    for (uint8 l_Button = 0; l_Button < MAX_ACTION_BUTTONS; ++l_Button)
    {
        ActionButtonList::const_iterator l_Iter = m_actionButtons.find(l_Button);
        if (l_Iter != m_actionButtons.end() && l_Iter->second.uState != ACTIONBUTTON_DELETED)
            l_Data << uint64(l_Iter->second.packedData);
        else
            l_Data << uint64(0);
    }

    l_Data << uint8(p_State);

    GetSession()->SendPacket(&l_Data);

    sLog->outInfo(LOG_FILTER_NETWORKIO, "Action Buttons for '%u' spec '%u' Sent", GetGUIDLow(), GetActiveSpecializationID());
}

bool Player::IsActionButtonDataValid(uint8 button, uint32 action, uint8 type)
{
    if (button >= MAX_ACTION_BUTTONS)
    {
        sLog->outError(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: button must be < %u", action, button, GetName(), MAX_ACTION_BUTTONS);
        return false;
    }

    if (action >= MAX_ACTION_BUTTON_ACTION_VALUE)
    {
        sLog->outError(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: action must be < %u", action, button, GetName(), MAX_ACTION_BUTTON_ACTION_VALUE);
        return false;
    }

    switch (type)
    {
        case ACTION_BUTTON_SPELL:
            if (!sSpellMgr->GetSpellInfo(action))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Spell action %u not added into button %u for player %s: spell not exist", action, button, GetName());
                return false;
            }

            break;
        case ACTION_BUTTON_ITEM:
            if (!sObjectMgr->GetItemTemplate(action))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Item action %u not added into button %u for player %s: item not exist", action, button, GetName());
                return false;
            }
            break;
        default:
            break;                                          // other cases not checked at this moment
    }

    return true;
}

ActionButton* Player::addActionButton(uint8 button, uint32 action, uint8 type)
{
    if (!IsActionButtonDataValid(button, action, type))
        return NULL;

    // it create new button (NEW state) if need or return existed
    ActionButton& ab = m_actionButtons[button];

    // set data and update to CHANGED if not NEW
    ab.SetActionAndType(action, ActionButtonType(type));

    sLog->outInfo(LOG_FILTER_PLAYER_LOADING, "Player '%u' Added Action '%u' (type %u) to Button '%u'", GetGUIDLow(), action, type, button);
    return &ab;
}

void Player::removeActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return;

    if (buttonItr->second.uState == ACTIONBUTTON_NEW)
        m_actionButtons.erase(buttonItr);                   // new and not saved
    else
        buttonItr->second.uState = ACTIONBUTTON_DELETED;    // saved, will deleted at next save

    sLog->outInfo(LOG_FILTER_PLAYER_LOADING, "Action Button '%u' Removed from Player '%u'", button, GetGUIDLow());
}

ActionButton const* Player::GetActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return NULL;

    return &buttonItr->second;
}

int8 Player::GetFreeActionButton()
{
    // 12 is max button of first action bar
    for (uint8 i = 0; i < 12; i++)
        if (!GetActionButton(i))
            return i;

    return -1;
}

bool Player::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
{
    uint16 l_OldAreaID = GetBaseMap()->GetAreaId(GetPositionX(), GetPositionY(), GetPositionZ(), nullptr);

    if (!Unit::UpdatePosition(x, y, z, orientation, teleport))
        return false;

    uint16 l_NewAreaID = GetBaseMap()->GetAreaId(x, y, z, nullptr);
    UpdateWorldQuests(l_OldAreaID, l_NewAreaID);

    // group update
    if (GetGroup())
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);

    // code block for underwater state update
    // Unit::SetPosition() checks for validity and update our coordinates
    // so we re-fetch them instead of using "raw" coordinates from function params
    UpdateUnderwaterState(GetMap(), GetPositionX(), GetPositionY(), GetPositionZ());

    if (GetTrader() && !IsWithinDistInMap(GetTrader(), INTERACTION_DISTANCE))
        GetSession()->SendCancelTrade();

    CheckAreaExploreAndOutdoor();

    return true;
}

void Player::UpdateWorldQuest(MS::WorldQuest::Template const* p_WQuestTemplate, bool p_IsInArea)
{
    if (!p_WQuestTemplate)
        return;

    if (p_WQuestTemplate->GetWorldQuestType() == MS::WorldQuest::WorldQuestType::Bounty)
        return;

    if (AreaPOIEntry const* l_AreaPOIEntry = sPOIMgr->GetCurrentPOIEntryForGroup(ePOIGroups::BrokenShoreInvasions))
    {
        uint32 l_ZoneID = sMapMgr->GetZoneId(l_AreaPOIEntry->MapID, l_AreaPOIEntry->PositionX, l_AreaPOIEntry->PositionY, l_AreaPOIEntry->PositionZ);

        if (l_ZoneID && p_WQuestTemplate->GetQuestTemplate() && p_WQuestTemplate->GetQuestTemplate()->GetZoneOrSort() == l_ZoneID)
        {
            switch (p_WQuestTemplate->GetWorldQuestType())
            {
                case MS::WorldQuest::WorldQuestType::LegionInvasionWQ:
                case MS::WorldQuest::WorldQuestType::LegionInvasionEliteWQ:
                case MS::WorldQuest::WorldQuestType::EpicEliteWorldQuest:
                case MS::WorldQuest::WorldQuestType::Alchemy:
                case MS::WorldQuest::WorldQuestType::Blacksmithing:
                case MS::WorldQuest::WorldQuestType::Cooking:
                case MS::WorldQuest::WorldQuestType::Enchanting:
                case MS::WorldQuest::WorldQuestType::Engineering:
                case MS::WorldQuest::WorldQuestType::Fishing:
                case MS::WorldQuest::WorldQuestType::Herbalism:
                case MS::WorldQuest::WorldQuestType::Inscription:
                case MS::WorldQuest::WorldQuestType::Jewelcrafting:
                case MS::WorldQuest::WorldQuestType::Leatherworking:
                case MS::WorldQuest::WorldQuestType::Mining:
                case MS::WorldQuest::WorldQuestType::Skinning:
                case MS::WorldQuest::WorldQuestType::Tailoring:
                    break;
                default:
                    return;
            }
        }
    }

    uint32 l_Slot = FindQuestSlot(p_WQuestTemplate->GetID());
    bool l_CanBePicked = m_WorldQuestMgr->CanPickQuest(p_WQuestTemplate->GetID());
    bool l_HasReward = m_WorldQuestMgr->GetReward(p_WQuestTemplate->GetID());

    if (l_Slot < MAX_QUEST_LOG_SIZE && (!p_IsInArea || !l_HasReward))
    {
        SetQuestSlot(l_Slot, 0);
        RemoveActiveQuest(p_WQuestTemplate->GetID(), true);
    }
    else if (p_IsInArea && l_Slot >= MAX_QUEST_LOG_SIZE && l_CanBePicked)
    {
        if (const Quest * l_Quest = sObjectMgr->GetQuestTemplate(p_WQuestTemplate->GetID()))
        {
            if (p_WQuestTemplate->GetWorldQuestType() == MS::WorldQuest::WorldQuestType::DailyPvP)
            {
                /// Called to Battle
                AddAura(228194, this);

                if (auto l_WarnText = sObjectMgr->GetTrinityString(TrinityStrings::WorldQuestPvPFlagWarn, GetSession()->GetSessionDbLocaleIndex()))
                {
                    WorldPacket l_Packet;
                    BuildPlayerChat(&l_Packet, GetGUID(), ChatMsg::CHAT_MSG_RAID_BOSS_WHISPER, l_WarnText, 0);
                    GetSession()->SendPacket(&l_Packet);
                }
            }

            AddQuest(l_Quest, this);

            l_Slot = FindQuestSlot(p_WQuestTemplate->GetID());

            if (l_Slot < MAX_QUEST_LOG_SIZE)
            {
                for (auto const& l_Objective : l_Quest->QuestObjectives)
                {
                    SetQuestSlotCounter(l_Slot, l_Objective.Index, m_questObjectiveStatus[l_Objective.ID]);
                }
            }
        }
    }
}

void Player::UpdateWorldQuests(uint32 p_OldAreaId, uint32 p_NewAreaId)
{
    if (p_OldAreaId != p_NewAreaId && getLevel() >= 98)
    {
        /// Remove Called to Battle aura
        RemoveAurasDueToSpell(228194);

        for (auto l_Current : MS::WorldQuest::Template::GetAreaGroupMap())
        {
            auto l_Wquest = MS::WorldQuest::Template::GetTemplate(l_Current.first);
            if (!l_Wquest)
                continue;

            bool l_IsWithinArea = l_Wquest->GetAreaID() == p_NewAreaId || IsWithinAreaGroup(l_Current.second, p_NewAreaId);

            UpdateWorldQuest(l_Wquest, l_IsWithinArea);
        }

        static const std::unordered_set<uint32> _professionQuestTypes = { 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 130 };

        for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
        {
            uint32 questid = GetQuestSlotQuestId(i);
            if (!questid)
                continue;

            if (auto quest = sObjectMgr->GetQuestTemplate(questid))
            {
                if (quest->GetType() >= MS::WorldQuest::WorldQuestType::Bounty && 
                    ((_professionQuestTypes.find(quest->GetType()) != _professionQuestTypes.end() && quest->GetQuestMethod() == 3) || 
                    (!quest->completionsNpcs.empty() && quest->GetQuestMethod() == 3)))
                {
                    SetQuestSlot(i, 0);
                    RemoveActiveQuest(questid, true);
                }
            }
        }

        sScriptMgr->OnUpdateWorldQuests(this, p_OldAreaId, p_NewAreaId);
    }
}

void Player::SaveRecallPosition()
{
    m_recallMap = GetMapId();
    m_recallX = GetPositionX();
    m_recallY = GetPositionY();
    m_recallZ = GetPositionZ();
    m_recallO = GetOrientation();
}

void Player::SendDirectMessage(const WorldPacket* data)
{
    m_session->SendPacket(data);
}

//////////////////////////////////////////////////////////////////////////
/// Cinematic
//////////////////////////////////////////////////////////////////////////
void Player::StopCinematic()
{
    if (m_CinematicSequence && IsInWorld())
    {
        m_CinematicSequence         = NULL;
        m_InCinematic               = false;
        m_CinematicClientStartTime  = 0;

        m_lastFallZ = m_CinematicStartZ;

        Unit::UpdatePosition(m_CinematicStartX, m_CinematicStartY, m_CinematicStartZ, m_CinematicStartO, true);

        getHostileRefManager().setOnlineOfflineState(true);

        SetFall(true);

        RemoveAura(60190);
    }
}
void Player::SendCinematicStart(uint32 p_CinematicSequenceId)
{
    WorldPacket l_Data(SMSG_TRIGGER_CINEMATIC, 4);
    l_Data << uint32(p_CinematicSequenceId);
    SendDirectMessage(&l_Data);

    StopCinematic();

    m_CinematicSequence = const_cast<CinematicSequence*>(sCinematicSequenceMgr->GetSequence(p_CinematicSequenceId));

    if (m_CinematicSequence)
    {
        m_CinematicClientStartTime  = (getMSTime() - GetSession()->GetLatency()) + 1500;
        m_InCinematic               = true;

        m_CinematicStartX = m_positionX;
        m_CinematicStartY = m_positionY;
        m_CinematicStartZ = m_positionZ;
        m_CinematicStartO = GetOrientation();

        getHostileRefManager().setOnlineOfflineState(false);

        SetFall(false);

        AddAura(60190, this);
    }
}

void Player::SendMovieStart(uint32 MovieId)
{
    SetStunned(true);

    WorldPacket data(SMSG_TRIGGER_MOVIE, 4);
    data << uint32(MovieId);
    SendDirectMessage(&data);

    CurrentPlayedMovie = MovieId;
}

bool Player::CanMountAsPassenger(Player* l_DriverPlayer) const
{
    // Crossfaction mount
    if (GetTeam() != l_DriverPlayer->GetTeam())
    {
        if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ALLOW_TWO_SIDE_INTERACTION_MOUNT))
            return false;

        if (AreaTableEntry const* l_Zone = sAreaTableStore.LookupEntry(l_DriverPlayer->GetZoneId()))
        {
            if (l_Zone->Flags & AreaFlags::AREA_FLAG_CAPITAL && !l_Zone->IsSanctuary())
            {
                if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ALLOW_TWO_SIDE_INTERACTION_MOUNT_CAPITALS))
                    return false;
            }
        }
    }

    return true;
}

std::pair<bool, bool> Player::IsFightingWithDungeonBoss()
{
    if (!GetMap()->IsDungeon())
        return std::make_pair(false, false);

    bool l_IsBoss = false;
    bool l_IsOnlyFighter = true;

    UnitList l_TargetsInSight;
    JadeCore::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, GetMap()->GetVisibilityRange());
    JadeCore::UnitListSearcher<JadeCore::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, l_TargetsInSight, u_check);
    VisitNearbyObject(GetMap()->GetVisibilityRange(), searcher);

    for (Unit* l_Itr : l_TargetsInSight)
    {
        Creature* l_Npc = l_Itr->ToCreature();

        if (l_Npc && l_Npc->IsDungeonBoss() && l_Npc->isInCombat())
        {
            l_IsBoss = true;

            uint8 l_Count = 0;

            for (HostileReference* l_Threat : l_Npc->getThreatManager().getThreatList())
            {
                if (l_Count >= 2)
                {
                    l_IsOnlyFighter = false;
                    break;
                }

                Unit* l_Target = l_Threat->getTarget();

                if (l_Target && l_Target->IsPlayer())
                    l_Count++;
            }

            if (l_Count >= 2)
            {
                l_IsOnlyFighter = false;
                break;
            }

            break;
        }
    }

    return std::make_pair(l_IsBoss, l_IsOnlyFighter);
}

void Player::CombatStopWithInstances(bool p_IncludeCast)
{
    if (p_IncludeCast && IsNonMeleeSpellCasted(false))
        InterruptNonMeleeSpells(false);

    AttackStop();
    RemoveAllAttackers();

    SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel

    std::pair<bool, bool> l_IsFightingWithBoss = IsFightingWithDungeonBoss();

    if (l_IsFightingWithBoss.first)
    {
        if (l_IsFightingWithBoss.second)
            ClearInCombat();
    }
    else
        ClearInCombat();
}

void Player::CheckAreaExploreAndOutdoor()
{
    if (!isAlive())
        return;

    if (isInFlight())
        return;

    bool isOutdoor;
    uint32 l_AreaID = GetBaseMap()->GetAreaId(GetPositionX(), GetPositionY(), GetPositionZ(), &isOutdoor);
    AreaTableEntry const* areaEntry = sAreaTableStore.LookupEntry(l_AreaID);

    if (isOutdoor != m_IsOutdoors)
        sScriptMgr->OnSwitchOutdoorsState(this, isOutdoor);

    m_IsOutdoors = isOutdoor;

    if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !isOutdoor)
        RemoveAurasWithAttribute(SPELL_ATTR0_OUTDOORS_ONLY);

    if (!l_AreaID)
        return;

    if (!areaEntry)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player '%u' (%s) discovered unknown area (x: %f y: %f z: %f map: %u)",
            GetGUIDLow(), GetName(), GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
        return;
    }

    int offset = areaEntry->AreaBit / 32;

    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Wrong area flag %u in map data for (X: %f Y: %f) point to field PLAYER_FIELD_EXPLORED_ZONES + %u ( %u must be < %u ).", l_AreaID, GetPositionX(), GetPositionY(), offset, offset, PLAYER_EXPLORED_ZONES_SIZE);
        return;
    }

    uint32 val = (uint32)(1 << (areaEntry->AreaBit % 32));
    uint32 currFields = GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset);

    if (!(currFields & val))
    {
        SetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset, (uint32)(currFields | val));

        UpdateCriteria(CRITERIA_TYPE_EXPLORE_AREA);

        if (areaEntry->ExplorationLevel > 0)
        {
            if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            {
                SendExplorationExperience(l_AreaID, 0);
            }
            else
            {
                int32 diff = int32(getLevel()) - areaEntry->ExplorationLevel;
                uint32 XP = 0;

                float ExploreXpRate = 1;
                ExploreXpRate = sWorld->getRate(RATE_XP_EXPLORE);

                if (diff < -5)
                {
                    XP = uint32(sObjectMgr->GetBaseXP(getLevel()+5) * ExploreXpRate);
                }
                else if (diff > 5)
                {
                    int32 exploration_percent = (100-((diff-5)*5));
                    if (exploration_percent > 100)
                        exploration_percent = 100;
                    else if (exploration_percent < 0)
                        exploration_percent = 0;

                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * exploration_percent / 100 * ExploreXpRate);
                }
                else
                {
                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * ExploreXpRate);
                }

                if (GetSession()->IsPremium())
                    XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);

                GiveXP(XP, NULL);
                SendExplorationExperience(l_AreaID, XP);
            }
            sLog->outInfo(LOG_FILTER_PLAYER, "Player %u discovered a new area: %u", GetGUIDLow(), l_AreaID);
        }
    }
}

uint32 Player::TeamForRace(uint8 race)
{
    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race))
    {
        switch (rEntry->BaseLanguage)
        {
            case 1: return HORDE;
            case 7: return ALLIANCE;
            case 42: return PANDAREN_NEUTRAL;
        }
    }

    return ALLIANCE;
}

TeamId Player::TeamIdForRace(uint8 p_Race)
{
    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(p_Race))
    {
        switch (rEntry->BaseLanguage)
        {
            case 1:
                return TeamId::TEAM_HORDE;
            case 7:
                return TeamId::TEAM_ALLIANCE;
            case 42:
                return TeamId::TEAM_NEUTRAL;
            default:
                return TeamId::TEAM_ALLIANCE;
        }
    }

    return TeamId::TEAM_ALLIANCE;
}

void Player::SwitchToOppositeTeam(bool p_Apply)
{
    m_team = GetNativeTeam();

    if (p_Apply)
        m_team = (m_team == ALLIANCE) ? HORDE : ALLIANCE;
}

uint32 Player::GetBgQueueTeam() const
{
    if (HasAura(MercenarySpells::MercenaryContractHorde))
        return HORDE;

    if (HasAura(MercenarySpells::MercenaryContractAlliance))
        return ALLIANCE;

    return GetTeam();
}

uint32 Player::GetRacialSkillID(bool p_Mercenary) const
{
    uint32 l_SkillID = 0;

    switch (getRace(p_Mercenary))
    {
        case RACE_HUMAN:
            l_SkillID = SKILL_RACIAL_HUMAN;
            break;
        case RACE_GNOME:
            l_SkillID = SKILL_RACIAL_GNOME;
            break;
        case RACE_DWARF:
            l_SkillID = SKILL_RACIAL_DWARF;
            break;
        case RACE_NIGHTELF:
            l_SkillID = SKILL_RACIAL_NIGHT_ELF;
            break;
        case RACE_DRAENEI:
            l_SkillID = SKILL_RACIAL_DRAENEI;
            break;
        case RACE_WORGEN:
            l_SkillID = SKILL_RACIAL_WORGEN;
            break;
        case RACE_ORC:
            l_SkillID = SKILL_RACIAL_ORC;
            break;
        case RACE_UNDEAD_PLAYER:
            l_SkillID = SKILL_RACIAL_UNDEAD;
            break;
        case RACE_TAUREN:
            l_SkillID = SKILL_RACIAL_TAUREN;
            break;
        case RACE_TROLL:
            l_SkillID = SKILL_RACIAL_TROLL;
            break;
        case RACE_BLOODELF:
            l_SkillID = SKILL_RACIAL_BLOOD_ELF;
            break;
        case RACE_GOBLIN:
            l_SkillID = SKILL_RACIAL_GOBLIN;
            break;
        case RACE_PANDAREN_ALLIANCE:
        case RACE_PANDAREN_HORDE:
        case RACE_PANDAREN_NEUTRAL:
            l_SkillID = SKILL_RACIAL_PANDAREN;
            break;
        case RACE_VOID_ELF:
            l_SkillID = SKILL_RACIAL_VOID_ELF;
            break;
        case RACE_LIGHTFORGED_DRAENEI:
            l_SkillID = SKILL_RACIAL_LIGHTFORGED_DRAENEI;
            break;
        case RACE_NIGHTBORNE:
            l_SkillID = SKILL_RACIAL_NIGHTBOURNE;
            break;
        case RACE_HIGHMOUNTAIN_TAUREN:
            l_SkillID = SKILL_RACIAL_HIGHMOUNTAIN_TAUREN;
            break;
        default:
            break;
    }

    return l_SkillID;
}

void Player::DeactivateMercenary()
{
    uint64 l_RaceMask = getRaceMask(true);
    uint32 l_ClassMask = getClassMask();
    uint32 l_SkillID = GetRacialSkillID(true);

    std::vector<SkillLineAbilityEntry const*> const* l_SkillLineAbilities = GetSkillLineAbilitiesBySkill(l_SkillID);
    if (!l_SkillLineAbilities)
        return;

    for (SkillLineAbilityEntry const* l_Ability : *l_SkillLineAbilities)
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Ability->spellId);
        if (!l_SpellInfo)
            continue;

        if (l_Ability->Flags != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN)
            continue;

        // Check race if set
        if (l_Ability->RaceMask && !(l_Ability->RaceMask & l_RaceMask))
            continue;

        // Check class if set
        if (l_Ability->ClassMask && !(l_Ability->ClassMask & l_ClassMask))
            continue;

        // check level, skip class spells if not high enough
        if (getLevel() < l_SpellInfo->SpellLevel)
            continue;

        removeSpell(l_Ability->spellId);
    }

    SetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID, GetOriginalPlayerData());
    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE, GetOriginalRace());
    InitDisplayIds();

    l_RaceMask = getRaceMask();
    l_SkillID = GetRacialSkillID();

    l_SkillLineAbilities = GetSkillLineAbilitiesBySkill(l_SkillID);
    if (!l_SkillLineAbilities)
        return;

    for (SkillLineAbilityEntry const* l_Ability : *l_SkillLineAbilities)
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Ability->spellId);
        if (!l_SpellInfo)
            continue;

        if (l_Ability->Flags != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN)
            continue;

        if (l_Ability->RaceMask && !(l_Ability->RaceMask & l_RaceMask))
            continue;

        if (l_Ability->ClassMask && !(l_Ability->ClassMask & l_ClassMask))
            continue;

        if (getLevel() < l_SpellInfo->SpellLevel)
            continue;

        learnSpell(l_Ability->spellId, false);
    }
}

void Player::ActivateMercenary(uint8 p_MercenaryRace)
{
    /// ToDo: Randomly Generate Skin, Face, HairStyle, HairColor
    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE, p_MercenaryRace);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID, 0);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_FACE_ID, 0);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_STYLE_ID, 0);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID, 0);
    InitDisplayIds(p_MercenaryRace);

    uint64 l_RaceMask = getRaceMask();
    uint32 l_ClassMask = getClassMask();
    uint32 l_SkillID = GetRacialSkillID();

    std::vector<SkillLineAbilityEntry const*> const* l_SkillLineAbilities = GetSkillLineAbilitiesBySkill(l_SkillID);
    if (!l_SkillLineAbilities)
        return;

    for (SkillLineAbilityEntry const* l_Ability : *l_SkillLineAbilities)
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Ability->spellId);
        if (!l_SpellInfo)
            continue;

        if (l_Ability->Flags != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN)
            continue;

        if (l_Ability->RaceMask && !(l_Ability->RaceMask & l_RaceMask))
            continue;

        if (l_Ability->ClassMask && !(l_Ability->ClassMask & l_ClassMask))
            continue;

        if (getLevel() < l_SpellInfo->SpellLevel)
            continue;

        removeSpell(l_Ability->spellId);
    }

    l_RaceMask = getRaceMask(true);
    l_SkillID = GetRacialSkillID(true);

    l_SkillLineAbilities = GetSkillLineAbilitiesBySkill(l_SkillID);
    if (!l_SkillLineAbilities)
        return;

    for (SkillLineAbilityEntry const* l_Ability : *l_SkillLineAbilities)
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Ability->spellId);
        if (!l_SpellInfo)
            continue;


        // Check race if set
        if (l_Ability->RaceMask && !(l_Ability->RaceMask & l_RaceMask))
            continue;

        // Check class if set
        if (l_Ability->ClassMask && !(l_Ability->ClassMask & l_ClassMask))
            continue;

        // check level, skip class spells if not high enough
        if (getLevel() < l_SpellInfo->SpellLevel)
            continue;

        learnSpell(l_Ability->spellId, false);
    }
}

void Player::setFactionForRace(uint8 race)
{
    // temporary hack for rated bg factions
    if (HasAura(81748))
    {
        RemoveAura(81748);
        AddAura(81748, this);
        return;
    }
    else if (HasAura(81744))
    {
        RemoveAura(81744);
        AddAura(81744, this);
        return;
    }

    m_team = TeamForRace(race);

    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
    setFaction(rEntry ? rEntry->FactionID : 0);
}

ReputationRank Player::GetReputationRank(uint32 faction) const
{
    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction);
    return GetReputationMgr().GetRank(factionEntry);
}

/// Calculate total reputation percent player gain with quest/creature level
int32 Player::CalculateReputationGain(ReputationSource p_Source, uint32 p_CreatureOrQuestLevel, int32 p_Reputation, int32 faction, bool p_NoQuestBonus, bool p_IsWorldQuest)
{
    float l_Percent         = 100.0f;
    float l_ReputationMod   = 0.0f;
    if (!p_NoQuestBonus)
    {
        if (p_IsWorldQuest)
            GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_REPUTATION_GAIN, faction);
        else
            GetTotalAuraModifierByBothMiscValues(SPELL_AURA_MOD_REPUTATION_GAIN, faction, 0);
    }

    /// faction specific auras only seem to apply to kills
    if (p_Source == REPUTATION_SOURCE_KILL)
        l_ReputationMod += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction);

    if (int32 l_Modifier = GetReputationMgr().GetReputationModifier(faction))
        l_ReputationMod += float(l_Modifier);

    l_Percent += p_Reputation > 0 ? l_ReputationMod : -l_ReputationMod;

    float l_Rate;
    switch (p_Source)
    {
        case REPUTATION_SOURCE_KILL:
            l_Rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_KILL);
            break;

        case REPUTATION_SOURCE_QUEST:
        case REPUTATION_SOURCE_DAILY_QUEST:
        case REPUTATION_SOURCE_WEEKLY_QUEST:
        case REPUTATION_SOURCE_MONTHLY_QUEST:
        case REPUTATION_SOURCE_REPEATABLE_QUEST:
            l_Rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_QUEST);
            break;

        case REPUTATION_SOURCE_SPELL:
        default:
            l_Rate = 1.0f;
            break;
    }

    if (l_Rate != 1.0f && p_CreatureOrQuestLevel < JadeCore::XP::GetGrayLevel(getLevel()))
        l_Percent *= l_Rate;

    if (l_Percent <= 0.0f)
        return 0;

    /// Multiply result with the faction specific rate
    if (RepRewardRate const* repData = sObjectMgr->GetRepRewardRate(faction))
    {
        float l_ReputationRate = 0.0f;
        switch (p_Source)
        {
            case REPUTATION_SOURCE_KILL:
                l_ReputationRate = repData->creature_rate;
                break;

            case REPUTATION_SOURCE_QUEST:
            case REPUTATION_SOURCE_DAILY_QUEST:         ///< @TODO
            case REPUTATION_SOURCE_WEEKLY_QUEST:        ///< @TODO
            case REPUTATION_SOURCE_MONTHLY_QUEST:       ///< @TODO
            case REPUTATION_SOURCE_REPEATABLE_QUEST:    ///< @TODO
                l_ReputationRate = repData->quest_rate;
                break;

            case REPUTATION_SOURCE_SPELL:
                l_ReputationRate = repData->spell_rate;
                break;
        }

        /// for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
        if (l_ReputationRate <= 0.0f)
            return 0;

        l_Percent *= l_ReputationRate;
    }

    return CalculatePct(p_Reputation, l_Percent);
}

/// Calculates how many reputation points player gains in victim's enemy factions
void Player::RewardReputation(Unit* p_Victim, float p_Rate)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (p_Victim->ToCreature()->IsReputationGainDisabled())
        return;

    if (HasAura(186404)) ///< Sign of the Emissary (Weekly event bonus)
    {
        uint32 l_Zone = GetZoneId();
        uint32 l_Team = GetTeam();

        Creature* l_Creature = p_Victim->ToCreature();

        if (l_Creature == nullptr)
            return;

        if (l_Creature->GetMap()->IsMythic() || l_Creature->GetMap()->IsHeroic())
        {
            std::map<int32, int32>    l_ReputationByMap;
            l_ReputationByMap[6988] = 1515;                                 ///< Skyreach / Arakkoa Outcasts
            l_ReputationByMap[6912] = l_Team == ALLIANCE ? 1710 : 1708;     ///< Auchindoun  / Sha'tari Defense (Alliance), Laughing Skull (Horde)
            l_ReputationByMap[7109] = l_Team == ALLIANCE ? 1710 : 1708;     ///< The Everbloom  / Sha'tari Defense (Alliance), Laughing Skull (Horde)
            l_ReputationByMap[6932] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Shadowmoon Burial Grounds  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6984] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Grimrail Depot  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6951] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Iron Docks  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6874] = 1711;                                 ///< Bloodmaul Slag Mines  / Steamwheedle Preservation Society
            l_ReputationByMap[7307] = 1711;                                 ///< Upper Blackrock Spire  / Steamwheedle Preservation Society

            int32 l_FactionID = 0;
            for (auto& l_Reputation : l_ReputationByMap)
            {
                if (l_Zone == l_Reputation.first)
                    l_FactionID = l_Reputation.second;
            }

            if (l_FactionID)
            {
                int16 l_ReputationGain = 20;
                if (l_Creature->IsDungeonBoss())
                    l_ReputationGain = 400;

                FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(l_FactionID);
                uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
                if (factionEntry1)
                    GetReputationMgr().ModifyReputation(factionEntry1, l_ReputationGain);
            }
        }
    }

    ReputationOnKillEntry const* l_Reputation = sObjectMgr->GetReputationOnKilEntry(p_Victim->ToCreature()->GetCreatureTemplate()->Entry);

    if (GetChampioningFaction() && !l_Reputation && p_Victim->ToCreature())
    {
        /// Support for: Championing - http://www.wowwiki.com/Championing

        Map const* l_Map = GetMap();
        if (l_Map && l_Map->IsDungeon() && !l_Map->IsRaid())
        {
            AccessRequirement const* l_AccessRequirement = sObjectMgr->GetAccessRequirement(l_Map->GetId(), ((InstanceMap*)l_Map)->GetDifficultyID());
            if (l_AccessRequirement && l_AccessRequirement->levelMin >= 80)
            {
                uint32 l_ReputationGain = 0;

                switch (p_Victim->ToCreature()->GetCreatureTemplate()->rank)
                {
                    case CREATURE_ELITE_TRIVIAL:
                    case CREATURE_ELITE_NORMAL:
                    case CREATURE_ELITE_RARE:
                        l_ReputationGain = l_Map->GetDifficultyID() == DifficultyHeroic ? 5 : 3;
                        break;
                    case CREATURE_ELITE_ELITE:
                        l_ReputationGain = 15;
                        break;
                    case CREATURE_ELITE_RAREELITE:
                    case CREATURE_ELITE_WORLDBOSS:
                        l_ReputationGain = 300;
                        break;
                    default:
                        break;
                }

                if (l_ReputationGain)
                {
                    FactionEntry const* l_FactionEntry = sFactionStore.LookupEntry(GetChampioningFaction());

                    if (l_FactionEntry)
                        GetReputationMgr().ModifyReputation(l_FactionEntry, l_ReputationGain, true);
                }
            }
        }
    }

    if (!l_Reputation)
        return;

    uint32 l_Zone = GetZoneId();
    uint32 l_Team = GetTeam();
    float l_BonusReputationRate = 0;

    /// Thrallmar's Favor and Honor Hold's Favor
    if ((l_Zone == 3483 || l_Zone == 3562 || l_Zone == 3836 || l_Zone == 3713 || l_Zone == 3714) && (HasAura(32096) || HasAura(32098)))
        l_BonusReputationRate = 0.25;

    /// Cenarion Favor
    if ((l_Reputation->RepFaction1 == 609 || l_Reputation->RepFaction2 == 609) && HasAura(30754))
        l_BonusReputationRate = 0.25;

    if (l_Reputation->RepFaction1 && (!l_Reputation->TeamDependent || l_Team == ALLIANCE))
    {
        int32 l_StandingA = CalculateReputationGain(REPUTATION_SOURCE_KILL, p_Victim->getLevelForTarget(this), l_Reputation->RepValue1, l_Reputation->RepFaction1, false);
        l_StandingA = int32(float(l_StandingA) * (p_Rate + l_BonusReputationRate));

        if (FactionEntry const* l_FactionEntryA = sFactionStore.LookupEntry(l_Reputation->RepFaction1))
        {
            if (GetReputationMgr().GetRank(l_FactionEntryA) <= l_Reputation->ReputationMaxCap1)
                GetReputationMgr().ModifyReputation(l_FactionEntryA, l_StandingA);
        }
    }

    if (l_Reputation->RepFaction2 && (!l_Reputation->TeamDependent || l_Team == HORDE))
    {
        int32 l_StandingB = CalculateReputationGain(REPUTATION_SOURCE_KILL, p_Victim->getLevelForTarget(this), l_Reputation->RepValue2, l_Reputation->RepFaction2, false);
        l_StandingB = int32(float(l_StandingB) * (p_Rate + l_BonusReputationRate));

        if (FactionEntry const* l_FactionEntryB = sFactionStore.LookupEntry(l_Reputation->RepFaction2))
        {
            if (GetReputationMgr().GetRank(l_FactionEntryB) <= l_Reputation->ReputationMaxCap2)
                GetReputationMgr().ModifyReputation(l_FactionEntryB, l_StandingB);
        }
    }
}

//Calculate how many reputation points player gain with the quest
void Player::RewardReputation(Quest const* p_Quest)
{
    // quest reputation reward/loss
    for (uint8 l_I = 0; l_I < QUEST_REPUTATIONS_COUNT; ++l_I)
    {
        if (!p_Quest->RewardFactionId[l_I])
            continue;

        int32 l_Reputation = 0;
        bool l_NoQuestBonus = false;

        if (p_Quest->RewardFactionValueIdOverride[l_I])
        {
            l_Reputation = p_Quest->RewardFactionValueIdOverride[l_I] / 100;
            l_NoQuestBonus = true;
        }
        else
        {
            uint32 l_Row = ((p_Quest->RewardFactionValueId[l_I] < 0) ? 1 : 0) + 1;
            if (QuestFactionRewEntry const* questFactionRewEntry = sQuestFactionRewardStore.LookupEntry(l_Row))
            {
                uint32 field = abs(p_Quest->RewardFactionValueId[l_I]);
                l_Reputation = questFactionRewEntry->QuestRewFactionValue[field];
            }
        }

        if (!l_Reputation)
            continue;

        /// @TODO
        ///if (quest->IsDaily())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsWeekly())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_WEEKLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsMonthly())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_MONTHLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsRepeatable())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_REPEATABLE_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else

        MS::WorldQuest::Template const* l_Template = MS::WorldQuest::Template::GetTemplate(p_Quest->GetQuestId());

        l_Reputation = CalculateReputationGain(REPUTATION_SOURCE_QUEST, GetQuestLevel(p_Quest), l_Reputation, p_Quest->RewardFactionId[l_I], l_NoQuestBonus, l_Template);

        if (FactionEntry const* l_FactionEntry = sFactionStore.LookupEntry(p_Quest->RewardFactionId[l_I]))
            GetReputationMgr().ModifyReputation(l_FactionEntry, l_Reputation);
    }
}

Expansion Player::GetExpByLevel()
{
    uint8 level = getLevel();
    return (Expansion)JadeCore::GetExpansionForLevel(level);
}

void Player::RewardGuildReputation(Quest const* quest)
{
    if (!GetGuild())
        return;

    uint32 rep = 0;

    switch (GetExpByLevel())
    {
        case EXPANSION_VANILLA:                 rep = 25;
            break;
        case EXPANSION_THE_BURNING_CRUSADE:     rep = 50;
            break;
        case  EXPANSION_WRATH_OF_THE_LICH_KING: rep = 75;
            break;
        case EXPANSION_CATACLYSM:               rep = 100;
            break;
        case EXPANSION_MISTS_OF_PANDARIA:       rep = 150;
            break;
        case EXPANSION_WARLORDS_OF_DRAENOR:     rep = 200;      ///<    Not sure
            break;
        case EXPANSION_LEGION:                  rep = 250;      ///<    Not sure
            break;
        default:                                rep = 0;
            break;
    }

    rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, REP_GUILD, true);

    // Apply reputation multiplier from aura (not stacking-get highest)
    AddPct(rep, GetMaxPositiveAuraModifier(SPELL_AURA_MOD_GUID_REP_GAIN_PCT));

    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(REP_GUILD))
        GetReputationMgr().ModifyReputation(factionEntry, rep);
}

void Player::UpdateHonorFields()
{
    /// called when rewarding honor and at each save
    time_t now = time_t(time(NULL));
    time_t today = time_t(time(NULL) / DAY) * DAY;

    if (m_lastHonorUpdateTime < today)
    {
        time_t yesterday = today - DAY;

        uint16 kills_today = PAIR32_LOPART(GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));

        // update yesterday's contribution
        if (m_lastHonorUpdateTime >= yesterday)
        {
            // this is the first update today, reset today's contribution
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, MAKE_PAIR32(0, kills_today));
        }
        else
        {
            // no honor/kills yesterday or today, reset
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
        }
    }

    m_lastHonorUpdateTime = now;
}

///Calculate the amount of honor gained based on the victim
///and the size of the group for which the honor is divided
///An exact honor value can also be given (overriding the calcs)
uint32 Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvptoken, MS::Battlegrounds::RewardCurrencyType::Type p_RewardCurrencyType)
{
    // do not reward honor in arenas, but enable onkill spellproc
    Battleground* l_Bg = GetBattleground();
    if (InArena() && l_Bg != nullptr && !l_Bg->IsSkirmish() && p_RewardCurrencyType != MS::Battlegrounds::RewardCurrencyType::BattlegroundWin)
    {
        if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
            return 0;

        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
            return 0;

        return 1;
    }

    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
    if (HasAura(SPELL_AURA_PLAYER_INACTIVE))
        return 0;

    uint64 victim_guid = 0;
    uint32 victim_rank = 0;

    // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
    UpdateHonorFields();

    // Promote to float for calculations
    float honor_f = (float)honor;

    if (honor_f <= 0)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return 0;

        victim_guid = victim->GetGUID();

        if (Player* plrVictim = victim->ToPlayer())
        {
            if (GetTeam() == plrVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                return 0;

            uint8 k_level = getLevelForTarget(victim);
            uint8 k_grey = JadeCore::XP::GetGrayLevel(k_level);
            uint8 v_level = victim->getLevelForTarget(this);

            if (v_level <= k_grey)
                return 0;

            // PLAYER_CHOSEN_TITLE VALUES DESCRIPTION
            //  [0]      Just name
            //  [1..14]  Alliance honor titles and player name
            //  [15..28] Horde honor titles and player name
            //  [29..38] Other title and player name
            //  [39+]    Nothing
            uint32 victim_title = victim->GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE);
                                                        // Get Killer titles, CharTitlesEntry::bit_index
            // Ranks:
            //  title[1..14]  -> rank[5..18]
            //  title[15..28] -> rank[5..18]
            //  title[other]  -> 0
            if (victim_title == 0)
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
            else if (victim_title < 15)
                victim_rank = victim_title + 4;
            else if (victim_title < 29)
                victim_rank = victim_title - 14 + 4;
            else
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.

            honor_f = ceil(JadeCore::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));

            // count the number of playerkills in one day
            ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);
            // and those in a lifetime
            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
            UpdateCriteria(CRITERIA_TYPE_EARN_HONORABLE_KILL, 1, 0, 0, victim);
            UpdateCriteria(CRITERIA_TYPE_HK_CLASS, victim->getClass());
            UpdateCriteria(CRITERIA_TYPE_HK_RACE, victim->getRace());
            UpdateCriteria(CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
            UpdateCriteria(CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);
            UpdateCriteria(CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, 0, victim);

#ifndef CROSS
            /// @TODO: cross sync
            if (Guild* l_Guild = GetGuild())
                l_Guild->GetAchievementMgr().UpdateCriteria(CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, nullptr, this);
#endif
        }
        else
        {
            if (!victim->ToCreature()->isRacialLeader())
                return 0;

            honor_f = 1.0f;                                 // ??? need more info
            victim_rank = 19;                               // HK: Leader
        }
    }

    if (victim != NULL)
        if (groupsize > 1)
            honor_f /= groupsize;

    if (HasAura(eRecruitAFriendConstants::TrackerSpell))
        honor_f *= sRecruitAFriendMgr->GetFloatConstant(eRecruitAFriendConstants::RateHonor);

#ifndef CROSS
    if (GetSession()->IsPremium())
        honor_f *= sWorld->getRate(RATE_HONOR_PREMIUM);
#else
    if (InterRealmClient* client = GetSession()->GetInterRealmClient())
    {
        honor_f *= client->GetHonorRate();

        if (GetSession()->IsPremium())
            honor_f *= client->GetHonorPremiumRate();
    }
#endif

    // Back to int now
    honor = std::max(int32(honor_f), 1);
    // honor - for show honor points in log
    // victim_guid - for show victim name in log
    // victim_rank [1..4]  HK: <dishonored rank>
    // victim_rank [5..19] HK: <alliance\horde rank>
    // victim_rank [0, 20+] HK: <>

    // add honor points
    AuraEffectList const& l_AuraEffects = GetAuraEffectsByType(SPELL_AURA_MOD_REWARDED_HONOR_PCT);
    for (AuraEffect* l_AuraEffect : l_AuraEffects)
    {
        if (l_AuraEffect->GetMiscValue() & 512)
        {
            switch (p_RewardCurrencyType)
            {
                case MS::Battlegrounds::RewardCurrencyType::BattlegroundObjectif:
                case MS::Battlegrounds::RewardCurrencyType::BattlegroundWin:
                case MS::Battlegrounds::RewardCurrencyType::BattlegroundRated:
                    AddPct(honor, l_AuraEffect->GetAmount());
                    break;
                default:
                    break;
            }
        }
        if (l_AuraEffect->GetMiscValue() & 256)
        {
            switch (p_RewardCurrencyType)
            {
                /// Only called for skrimishes
                case MS::Battlegrounds::RewardCurrencyType::Arena:
                    AddPct(honor, l_AuraEffect->GetAmount());
                    break;
                default:
                    break;
            }
        }
        if (l_AuraEffect->GetMiscValue() & 1)
        {
            switch (p_RewardCurrencyType)
            {
                case MS::Battlegrounds::RewardCurrencyType::Kill:
                    AddPct(honor, l_AuraEffect->GetAmount());
                    break;
                default:
                    break;
            }
        }
    }

    AddPct(honor, GetTotalAuraModifier(AuraType::SPELL_AURA_MOD_REWARDED_HONOR_PCT_2));

    if (honor <= 0)
        return 0;

    GiveHonor(honor);

    WorldPacket data(SMSG_PVP_CREDIT, 4 + 16 + 2 + 4);
    data << uint32(honor);
    data.appendPackGUID(victim_guid);
    data << uint32(victim_rank);
    GetSession()->SendPacket(&data);

    if (InBattleground() && honor > 0)
    {
        if (Battleground* bg = GetBattleground())
        {
            bg->UpdatePlayerScore(this, NULL, SCORE_BONUS_HONOR, honor, false, p_RewardCurrencyType); //false: prevent looping
        }
    }

    if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE) && pvptoken)
    {
        if (!victim || victim == this || victim ->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return honor;

        if (victim->IsPlayer())
        {
            // Check if allowed to receive it in current map
            uint8 MapType = sWorld->getIntConfig(CONFIG_PVP_TOKEN_MAP_TYPE);
            if ((MapType == 1 && !InBattleground() && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 2 && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 3 && !InBattleground()))
                return honor;

            uint32 itemId = sWorld->getIntConfig(CONFIG_PVP_TOKEN_ID);
            int32 count = sWorld->getIntConfig(CONFIG_PVP_TOKEN_COUNT);

            if (GetOutdoorPvP())
                GetOutdoorPvP()->HandleRewardHonor(this);

            if (AddItem(itemId, count))
                ChatHandler(this).PSendSysMessage("You have been awarded a token for slaying another player.");
        }
    }
    return honor;
}

void Player::_LoadCurrency(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint16 currencyID = fields[0].GetUInt16();

        if (!sCurrencyTypesStore.LookupEntry(currencyID))
            continue;

        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_UNCHANGED;
        cur.weekCount = fields[1].GetUInt32();
        cur.totalCount = fields[2].GetUInt32();
        cur.seasonTotal = fields[3].GetUInt32();
        cur.flags = fields[4].GetUInt32();
        cur.weekCap = fields[5].GetUInt32();
        cur.needResetCap = fields[6].GetUInt8();

        /// Those currencies are not shown in "Currency" tab anymore
        switch (currencyID)
        {
            case 390: ///< CURRENCY_TYPE_HONOR_POINTS
            case 392: ///< CURRENCY_TYPE_CONQUEST_POINTS
            case CURRENCY_TYPE_JUSTICE_POINTS:
            case CURRENCY_TYPE_VALOR_POINTS:
                cur.flags &= ~0x04;
                break;
            default:
                break;
        }

        if (cur.needResetCap)
        {
            cur.weekCap = CalculateCurrencyWeekCap(currencyID);
            cur.needResetCap = false;
            cur.state = PLAYERCURRENCY_CHANGED;
        }

        _currencyStorage.insert(PlayerCurrenciesMap::value_type(currencyID, cur));

    }
    while (result->NextRow());
}

void Player::_LoadCurrencyCaps(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint16 l_CurrencyId = fields[0].GetUInt16();

        if (!sCurrencyTypesStore.LookupEntry(l_CurrencyId))
            continue;

        PlayerCurrencyCap l_Cap;
        l_Cap.currencyId = l_CurrencyId;
        l_Cap.sourceType = fields[1].GetUInt16();
        l_Cap.sourceId = fields[2].GetUInt32();
        l_Cap.value = fields[3].GetInt32();
        l_Cap.isChanged = false;

        _currencyCapsList.push_back(l_Cap);
    }
    while (result->NextRow());
}

void Player::_SaveCurrency(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
        if (!entry) // should never happen
            continue;

        switch (itr->second.state)
        {
            case PLAYERCURRENCY_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, itr->first);
                stmt->setUInt32(2, itr->second.weekCount);
                stmt->setUInt32(3, itr->second.totalCount);
                stmt->setUInt32(4, itr->second.seasonTotal);
                stmt->setUInt32(5, itr->second.flags);
                stmt->setUInt32(6, itr->second.weekCap);
                stmt->setUInt8(7, itr->second.needResetCap);
                trans->Append(stmt);
                break;
            case PLAYERCURRENCY_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_CURRENCY);
                stmt->setUInt32(0, itr->second.weekCount);
                stmt->setUInt32(1, itr->second.totalCount);
                stmt->setUInt32(2, itr->second.seasonTotal);
                stmt->setUInt32(3, itr->second.flags);
                stmt->setUInt32(4, itr->second.weekCap);
                stmt->setUInt8(5, itr->second.needResetCap);
                stmt->setUInt32(6, GetRealGUIDLow());
                stmt->setUInt16(7, itr->first);
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.state = PLAYERCURRENCY_UNCHANGED;
    }
}

void Player::_SaveCurrencyCaps(SQLTransaction& trans)
{
    for (auto& l_Cap : _currencyCapsList)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(l_Cap.currencyId);
        if (!entry)
            continue;

        if (!l_Cap.isChanged)
            continue;

        PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY_CAPS);
        l_Statement->setUInt32(0, GetRealGUIDLow());
        l_Statement->setUInt16(1, l_Cap.currencyId);
        l_Statement->setUInt16(2, l_Cap.sourceType);
        l_Statement->setUInt32(3, l_Cap.sourceId);
        l_Statement->setInt32(4, l_Cap.value);

        trans->Append(l_Statement);

        l_Cap.isChanged = false;
    }
}

void Player::SendCurrencies()
{
    WorldPacket l_Data(SMSG_SETUP_CURRENCY, 4 + (_currencyStorage.size() * (4 + 4 + 1 + 4 + 4 + 4)));

    l_Data << uint32(_currencyStorage.size());

    for (PlayerCurrenciesMap::const_iterator l_It = _currencyStorage.begin(); l_It != _currencyStorage.end(); ++l_It)
    {
        CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(l_It->first);

        if (!l_CurrencyEntry) // should never happen
            continue;

        uint32 l_WeekCount      = l_It->second.weekCount;
        uint32 l_WeekCap        = GetCurrencyWeekCap(l_CurrencyEntry->ID);
        uint32 l_SeasonTotal    = l_It->second.seasonTotal;
        uint32 l_MaxCurrency    = CalculateCurrencyTotalCap(l_CurrencyEntry->ID);

        l_Data << uint32(l_CurrencyEntry->ID);
        l_Data << uint32(l_It->second.totalCount);

        l_Data.WriteBit(l_WeekCount);
        l_Data.WriteBit(l_WeekCap);
        l_Data.WriteBit(l_SeasonTotal);
        l_Data.WriteBit(l_MaxCurrency);
        l_Data.WriteBits(l_It->second.flags, 5);
        l_Data.FlushBits();

        if (l_WeekCount)
            l_Data << uint32(l_WeekCount);

        if (l_WeekCap)
            l_Data << uint32(l_WeekCap);

        if (l_SeasonTotal)
            l_Data << uint32(l_SeasonTotal);

        if (l_MaxCurrency)
            l_Data << uint32(l_MaxCurrency);
    }

    GetSession()->SendPacket(&l_Data);
}
namespace RewardHonor
{
    enum : uint32
    {
        RewardRBG = 300,
        RewardRandomBG = 150,
        RewardArena = 100,
        RewardSkirmish = 80
    };
}

void Player::SendPvpRewards()
{
    WorldPacket l_Packet(SMSG_REQUEST_PVP_REWARDS_RESPONSE, 65);

    auto l_BuildPvpRewardDataForBracket = [&l_Packet, this](BattlegroundBracketType p_Bracket, uint32 p_Mask) -> void
    {
        uint32 l_HonorReward = g_HonorRewardPerBracket[(uint8)p_Bracket];

        /// First of the day bonus
        if (!HasWinInBracket(p_Bracket, true))
            l_HonorReward *= 2;

        l_Packet << (uint32)0;                  ///< Mask
        l_Packet << (uint32)0;                  ///< RewardMoney
        l_Packet << (uint32)0;                  ///< RewardXP
        l_Packet << (uint32)0;                  ///< ItemCount
        l_Packet << (uint32)0;                  ///< CurrencyCount
        l_Packet << (uint32)0;                  ///< QuantityCount
        l_Packet.WriteBit(false);               ///< unk
        l_Packet.WriteBit(false);               ///< unk
        l_Packet.WriteBit(false);               ///< unk
        l_Packet.WriteBit(l_HonorReward != 0);  ///< Honor

        if (l_HonorReward)
            l_Packet << uint32(l_HonorReward);

        l_Packet.FlushBits();
    };

    l_BuildPvpRewardDataForBracket(BattlegroundBracketType::RandomBattleground, 0x4BC9E950);

    l_Packet.WriteBit(GetDayWins((uint8)BattlegroundBracketType::Battleground10v10));   ///< have won today
    l_Packet.WriteBit(GetDayWins((uint8)BattlegroundBracketType::ArenaSkirmish));       ///< have won today
    l_Packet.WriteBit(GetDayWins((uint8)BattlegroundBracketType::Arena2v2));            ///< have won today
    l_Packet.WriteBit(GetDayWins((uint8)BattlegroundBracketType::Arena3v3));            ///< have won today

    l_BuildPvpRewardDataForBracket(BattlegroundBracketType::Battleground10v10,  0);
    l_BuildPvpRewardDataForBracket(BattlegroundBracketType::ArenaSkirmish, 0xA4DFCD60);
    l_BuildPvpRewardDataForBracket(BattlegroundBracketType::Arena2v2, 0);
    l_BuildPvpRewardDataForBracket(BattlegroundBracketType::Arena3v3, 0x57928278);

    GetSession()->SendPacket(&l_Packet);
}

uint32 Player::GetCurrency(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.totalCount / precision;
}

uint32 Player::GetCurrencyOnWeek(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.weekCount / precision;
}

uint32 Player::GetCurrencyOnSeason(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.seasonTotal / precision;
}

bool Player::HasCurrency(uint32 id, uint32 count) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    return itr != _currencyStorage.end() && itr->second.totalCount >= count;
}

void Player::ModifyCurrencyFlags(uint32 currencyId, uint8 flags)
{
    if (!currencyId)
        return;

    if (_currencyStorage.find(currencyId) == _currencyStorage.end())
        return;

    _currencyStorage[currencyId].flags = flags;

    if (_currencyStorage[currencyId].state != PLAYERCURRENCY_NEW)
        _currencyStorage[currencyId].state = PLAYERCURRENCY_CHANGED;
}

void Player::ModifyCurrencyAndSendToast(uint32 id, int32 count, bool printLog/* = true*/, bool ignoreMultipliers/* = false*/, bool ignoreLimit /* = false */)
{
    ModifyCurrency(id, count, printLog, ignoreMultipliers, ignoreLimit);

    switch (id)
    {
        case CURRENCY_TYPE_CONQUEST_META_ARENA_BG:
        case CURRENCY_TYPE_CONQUEST_META_RBG:
        case CURRENCY_TYPE_CONQUEST_META_ASHRAN:
            id = CURRENCY_TYPE_CONQUEST_POINTS;
        default:
            break;
    }

    SendDisplayToast(id, count, 0, DISPLAY_TOAST_METHOD_CURRENCY_OR_GOLD, TOAST_TYPE_NEW_CURRENCY, false, false);
}

int32 Player::ModifyCurrency(uint32 p_CurrencyID, int32 p_Count, bool p_SuppressLog /*= true*/, bool p_IgnoreMultipliers /*= false*/, bool p_IgnoreLimit /*= false*/, MS::Battlegrounds::RewardCurrencyType::Type p_RewardCurrencyType /*= None*/)
{
    if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ARENA_SEASON_IN_PROGRESS) && p_Count >= 0 &&
            (  p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_RBG
            || p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_ARENA_BG
            || p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_POINTS))
        return p_Count;

    CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(p_CurrencyID);
    if (!l_CurrencyEntry || !p_Count)
        return 0;

    if (!p_IgnoreMultipliers)
    {
        p_Count *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_CURRENCY_GAIN, p_CurrencyID);

        if (p_RewardCurrencyType)
        {
            float l_Multiplier = 1.0f;
            Unit::AuraEffectList const& l_ModPvpPercent = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_2);
            for (Unit::AuraEffectList::const_iterator i = l_ModPvpPercent.begin(); i != l_ModPvpPercent.end(); ++i)
            {
                if ((*i)->GetMiscValue() == p_CurrencyID && (*i)->GetMiscValueB() == p_RewardCurrencyType)
                    AddPct(l_Multiplier, (*i)->GetAmount());
            }
            p_Count *= l_Multiplier;
        }
    }

    int32 l_Precision = l_CurrencyEntry->Flags & CURRENCY_FLAG_HIGH_PRECISION ? CURRENCY_PRECISION : 1; ///< l_precision is never read 01/18/16
    uint32 l_OldTotalCount          = 0;
    uint32 l_OldWeekCount           = 0;
    uint32 l_OldSeasonTotalCount    = 0;
    uint32 l_MaxCurrency            = 0;

    PlayerCurrenciesMap::iterator l_CurrencyIT = _currencyStorage.find(p_CurrencyID);
    if (l_CurrencyIT == _currencyStorage.end())
    {
        PlayerCurrency l_NewCurrency;
        l_NewCurrency.state         = PLAYERCURRENCY_NEW;
        l_NewCurrency.totalCount    = 0;
        l_NewCurrency.weekCount     = 0;
        l_NewCurrency.seasonTotal   = 0;
        l_NewCurrency.flags         = 0;
        l_NewCurrency.weekCap       = CalculateCurrencyWeekCap(p_CurrencyID);
        l_NewCurrency.needResetCap  = false;

        _currencyStorage[p_CurrencyID] = l_NewCurrency;
        l_CurrencyIT = _currencyStorage.find(p_CurrencyID);

        l_OldTotalCount       = 0;
        l_OldWeekCount        = 0;
        l_OldSeasonTotalCount = 0;
    }
    else
    {
        l_OldTotalCount       = l_CurrencyIT->second.totalCount;
        l_OldWeekCount        = l_CurrencyIT->second.weekCount;
        l_OldSeasonTotalCount = l_CurrencyIT->second.seasonTotal;
    }

    if (!p_IgnoreMultipliers && HasAura(eRecruitAFriendConstants::TrackerSpell))
        p_Count *= sRecruitAFriendMgr->GetFloatConstant(eRecruitAFriendConstants::RateNethershards);

    sScriptMgr->OnPlayerModifyCurrency(this, p_CurrencyID, p_Count, p_IgnoreMultipliers);

    /// count can't be more then weekCap.
    uint32 l_WeekCap = GetCurrencyWeekCap(l_CurrencyEntry->ID);
    if (!p_IgnoreLimit && l_WeekCap && p_Count > int32(l_WeekCap))
        p_Count = l_WeekCap;

    int32 l_NewTotalCount = int32(l_OldTotalCount) + p_Count;
    if (l_NewTotalCount < 0)
        l_NewTotalCount = 0;

    int32 l_NewWeekCount = !p_IgnoreLimit ? (int32(l_OldWeekCount) + (p_Count > 0 ? p_Count : 0)) : int32(l_OldWeekCount);
    if (l_NewWeekCount < 0)
        l_NewWeekCount = 0;

    int32 l_NewSeasonTotalCount = !p_IgnoreLimit ? (int32(l_OldSeasonTotalCount) + (p_Count > 0 ? p_Count : 0)) : int32(l_OldSeasonTotalCount);

    if (!p_IgnoreLimit)
    {
        /// if we get more then weekCap just set to limit
        if (l_WeekCap && int32(l_WeekCap) < l_NewWeekCount)
        {
            l_NewWeekCount = int32(l_WeekCap);
            /// weekCap - oldWeekCount alwayt >= 0 as we set limit before!
            l_NewTotalCount = l_OldTotalCount + (l_WeekCap - l_OldWeekCount);
        }

        /// if we get more then totalCap set to maximum;
        uint32 l_TotalCap = CalculateCurrencyTotalCap(p_CurrencyID);
        if (l_TotalCap && int32(l_TotalCap) < l_NewTotalCount)
        {
            l_NewTotalCount = int32(l_TotalCap);
            l_NewWeekCount = l_WeekCap;
        }
    }

    if (l_NewWeekCount < 0)
        l_NewWeekCount = 0;
    if (l_NewTotalCount < 0)
        l_NewTotalCount = 0;

    if (p_CurrencyID == CURRENCY_TYPE_HONOR_POINTS || p_CurrencyID == CURRENCY_TYPE_JUSTICE_POINTS)
    {
        l_NewWeekCount = l_NewTotalCount;
        l_WeekCap = 0;
    }

    if (uint32(l_NewTotalCount) != l_OldTotalCount)
    {
        if (l_CurrencyIT->second.state != PLAYERCURRENCY_NEW)
            l_CurrencyIT->second.state = PLAYERCURRENCY_CHANGED;

        l_CurrencyIT->second.totalCount = l_NewTotalCount;
        l_CurrencyIT->second.weekCount = l_NewWeekCount;
        l_CurrencyIT->second.seasonTotal = l_NewSeasonTotalCount;

        // probably excessive checks
        if (IsInWorld() && !GetSession()->PlayerLoading())
        {
            if (p_Count > 0 && !p_IgnoreLimit)
                UpdateCriteria(CRITERIA_TYPE_CURRENCY, p_CurrencyID, p_Count);

            if (l_CurrencyEntry->CategoryID == CURRENCY_CATEGORY_META_CONQUEST)
            {
                // count was changed to week limit, now we can modify original points.
                ModifyCurrency(CURRENCY_TYPE_CONQUEST_POINTS, p_Count, p_SuppressLog);
                return p_Count;
            }

            if (p_CurrencyID == CURRENCY_TYPE_CONQUEST_POINTS)
                SendPvpRewards();

            /// Update archaeology projects
            if (l_CurrencyEntry->Flags & CURRENCY_FLAG_ARCHAEOLOGY_FRAGMENT && GetSkillValue(SKILL_ARCHAEOLOGY))
                m_archaeologyMgr.GenerateResearchProjects();

             // on new case just set init.
            if (l_OldTotalCount == 0 && l_CurrencyIT->second.state == PLAYERCURRENCY_NEW)
            {
                l_CurrencyIT->second.weekCap = CalculateCurrencyWeekCap(p_CurrencyID);
                SendCurrencies();
                return p_Count;
            }

            QuestObjectiveSatisfy(p_CurrencyID, p_Count, QUEST_OBJECTIVE_TYPE_CURRENCY);
            QuestObjectiveSatisfy(p_CurrencyID, p_Count, QUEST_OBJECTIVE_TYPE_HAVE_CURRENCY);
            QuestObjectiveSatisfy(p_CurrencyID, p_Count, QUEST_OBJECTIVE_TYPE_OBTAIN_CURRENCY);

            l_MaxCurrency = CalculateCurrencyTotalCap(p_CurrencyID);

            WorldPacket l_Packet(SMSG_UPDATE_CURRENCY);

            l_Packet << uint32(p_CurrencyID);
            l_Packet << uint32(l_NewTotalCount);
            l_Packet << uint32(l_CurrencyIT->second.flags);

            l_Packet.WriteBit(l_WeekCap != 0);
            l_Packet.WriteBit(l_CurrencyEntry->Flags & CURRENCY_FLAG_HAS_SEASON_COUNT);
            l_Packet.WriteBit(l_MaxCurrency);
            l_Packet.WriteBit(p_SuppressLog);
            l_Packet.FlushBits();

            if (l_WeekCap)
                l_Packet << uint32(l_NewWeekCount);

            if (l_CurrencyEntry->Flags & CURRENCY_FLAG_HAS_SEASON_COUNT)
                l_Packet << uint32(l_CurrencyIT->second.seasonTotal);

            if (l_MaxCurrency)
                l_Packet << uint32(l_MaxCurrency);

            GetSession()->SendPacket(&l_Packet);
        }
    }
    return p_Count;
}

void Player::SetCurrency(uint32 id, uint32 count, bool printLog /*= true*/)
{
    ModifyCurrency(id, int32(count) - GetCurrency(id, true), printLog);
}

uint32 Player::GetCurrencyWeekCap(uint32 id, bool usePrecision)
{
    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
    if (!entry)
        return 0;

    uint32 precision = (usePrecision && entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonTotal = 0;
        cur.flags = 0;
        cur.weekCap = CalculateCurrencyWeekCap(id);
        cur.needResetCap = false;
        _currencyStorage[id] = cur;
        itr = _currencyStorage.find(id);
    }

    return itr->second.weekCap / precision;
}

void Player::ResetCurrencyWeekCap()
{
    FinishWeek();                              // set played this week etc values to 0 in memory, too

    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        itr->second.weekCount = 0;
        itr->second.state = PLAYERCURRENCY_CHANGED;
        itr->second.weekCap = CalculateCurrencyWeekCap(itr->first);
    }

    WorldPacket data(SMSG_WEEKLY_RESET_CURRENCY, 0);
    SendDirectMessage(&data);
}

uint32 Player::CalculateCurrencyWeekCap(uint32 id)
{
    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);

    if (!entry)
        return 0;

    uint32 cap = entry->WeekCap;

    switch (entry->ID)
    {
        case CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_ASHRAN:
            cap = sWorld->getIntConfig(CONFIG_CURRENCY_ASHRAN_CONQUEST_POINTS_WEEK_CAP);
            break;
    }

    return cap;
}

uint32 Player::CalculateCurrencyTotalCap(uint32 p_CurrencyId)
{
    CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(p_CurrencyId);

    if (!l_CurrencyEntry)
        return 0;

    int32 l_CapValue = l_CurrencyEntry->TotalCap;

    for (auto& l_Cap : _currencyCapsList)
    {
        if (l_Cap.currencyId == p_CurrencyId)
            l_CapValue += l_Cap.value;
    }

    if (l_CapValue < 0)
        l_CapValue = 0;

    return l_CapValue;
}

bool Player::AddOrUpdateCurrencyTotalCap(uint32 p_CurrencyId, uint16 p_SourceType, uint32 p_SourceId, int32 p_Value)
{
    CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(p_CurrencyId);
    if (!l_CurrencyEntry)
        return false;

    PlayerCurrencyCaps::iterator l_CapItr = std::find_if(_currencyCapsList.begin(), _currencyCapsList.end(), [p_CurrencyId, p_SourceType, p_SourceId](PlayerCurrencyCap const& p_Cap) -> bool
    {
        return p_Cap.currencyId == p_CurrencyId && p_Cap.sourceType == p_SourceType && p_Cap.sourceId == p_SourceId;
    });

    if (l_CapItr != _currencyCapsList.end())
    {
        l_CapItr->value = p_Value;
    }
    else
    {
        PlayerCurrencyCap l_Cap;
        l_Cap.currencyId = p_CurrencyId;
        l_Cap.sourceType = p_SourceType;
        l_Cap.sourceId = p_SourceId;
        l_Cap.value = p_Value;
        l_Cap.isChanged = true;

        _currencyCapsList.push_back(l_Cap);
    }

    return true;
}

void Player::SetInGuild(uint32 guildId)
{
    if (guildId)
        SetGuidValue(OBJECT_FIELD_DATA, MAKE_NEW_GUID(guildId, 0, HIGHGUID_GUILD));
    else
        SetGuidValue(OBJECT_FIELD_DATA, 0);

    ApplyModFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GUILD_LEVEL_ENABLED, guildId != 0 && sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED));
    SetUInt16Value(OBJECT_FIELD_TYPE, 1, guildId != 0);
}

uint32 Player::GetGuildIdFromDB(uint64 guid, uint32 realmId)
{
#ifndef CROSS
    auto l_Database = &CharacterDatabase;
#else /* CROSS */
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(realmId)->GetDatabase();
#endif

    PreparedStatement* stmt = l_Database->GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt32(0, GUID_LOPART(guid));
    if (PreparedQueryResult result = l_Database->Query(stmt))
        return result->Fetch()[0].GetUInt32();

    return 0;
}

uint32 Player::GetZoneIdFromDB(uint64 guid)
{
    uint32 zone = 0;
#ifndef CROSS
    uint32 guidLow = GUID_LOPART(guid);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
    stmt->setUInt32(0, guidLow);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;

    Field* fields = result->Fetch();
    zone = fields[0].GetUInt16();

    if (!zone)
    {
        // stored zone is zero, use generic and slow zone detection
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
        stmt->setUInt32(0, guidLow);
        PreparedQueryResult result = CharacterDatabase.Query(stmt);

        if (!result)
            return 0;
        fields = result->Fetch();
        uint32 map = fields[0].GetUInt16();
        float posx = fields[1].GetFloat();
        float posy = fields[2].GetFloat();
        float posz = fields[3].GetFloat();

        if (!sMapStore.LookupEntry(map))
            return 0;

        zone = sMapMgr->GetZoneId(map, posx, posy, posz);

        if (zone > 0)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ZONE);

            stmt->setUInt16(0, uint16(zone));
            stmt->setUInt32(1, guidLow);

            CharacterDatabase.Execute(stmt);
        }
    }
#endif

    return zone;
}

uint32 Player::GetLevelFromDB(uint64 guid)
{
    uint8 level = 0;

#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_LEVEL);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;

    Field* fields = result->Fetch();
    level = fields[0].GetUInt8();
#endif

    return level;
}

void Player::UpdateArea(uint32 newArea)
{
    uint32 l_OldArea = m_areaUpdateId;

    /// Gurubashi Arena - Don't set FFA flag if Z pos above 23
    if (newArea == 2177 && m_positionZ > 23.0f)
        return;

    // FFA_PVP flags are area and not zone id dependent
    // so apply them accordingly
    m_areaUpdateId    = newArea;

    m_achievementMgr->UpdateCriteria(CRITERIA_TYPE_ENTER_AREA, newArea);
    m_achievementMgr->UpdateCriteria(CRITERIA_TYPE_LEAVE_AREA, l_OldArea);

    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    AreaTableEntry const* area = sAreaTableStore.LookupEntry(newArea);
    pvpInfo.inFFAPvPArea = (area && (area->Flags & AREA_FLAG_ARENA)) || InRatedBattleGround() || pvpInfo.forceFFA;
    pvpInfo.inNoPvPArea  = area && area->IsSanctuary();
    UpdatePvPState(true);

    UpdateAreaQuestTasks(newArea, l_OldArea);

    //Pandaria area update for monk level < 85
    if (area && getLevel() < 85 && getClass() == CLASS_MONK && GetMapId() == 870 && area->ContinentID == 870 &&
        newArea != 6081 && newArea != 6526 && newArea != 6527
        && GetZoneId() == 5841 && !isGameMaster())
        TeleportTo(870, 3818.55f, 1793.18f, 950.35f, GetOrientation());

    /// Class Hall restriction - prevents players of other classes to enter others class hall
    if (area && (newArea == eClassHallAreas::Paladin ||
        newArea == eClassHallAreas::Rogue || newArea == eClassHallAreas::Rogue2 ||
        newArea == eClassHallAreas::Hunter ||
        newArea == eClassHallAreas::DeathKnight ||
        newArea == eClassHallAreas::Druid || newArea == eClassHallAreas::Druid2 ||
        newArea == eClassHallAreas::Warrior ||
        newArea == eClassHallAreas::DemonHunter ||
        newArea == eClassHallAreas::Priest ||
        newArea == eClassHallAreas::Monk || newArea == eClassHallAreas::Monk2 ||
        newArea == eClassHallAreas::Mage ||
        newArea == eClassHallAreas::Warlock ||
        newArea == eClassHallAreas::Shaman || newArea == eClassHallAreas::Shaman2 || newArea == eClassHallAreas::Shaman3) && !isGameMaster())
    {
        std::vector<uint32>& l_Areas = g_ClassHalls[getClass()];
        bool l_CanEnter = std::find(l_Areas.begin(), l_Areas.end(), newArea) != l_Areas.end();
        if (!l_CanEnter)
        {
            switch (newArea)
            {
                case eClassHallAreas::Druid:
                case eClassHallAreas::Druid2:
                    AddAura(eClassHallSpells::ClassHallSpellDruid, this);
                    break;
                case eClassHallAreas::Hunter:
                    AddAura(eClassHallSpells::ClassHallSpellHunter, this);
                    break;
                case eClassHallAreas::DeathKnight:
                    AddAura(eClassHallSpells::ClassHallSpellDeathKnight, this);
                    break;
                case eClassHallAreas::Paladin:
                    AddAura(eClassHallSpells::ClassHallSpellPaladin, this);
                    break;
                default:
                {
                    ChatHandler(this).PSendSysMessage(TrinityStrings::WarnClassHall);
                    WorldLocation l_TeleportLoc;
                    l_TeleportLoc.m_mapId = m_homebindMapId;
                    l_TeleportLoc.Relocate(m_homebindX, m_homebindY, m_homebindZ, 0.0f);
                    AddDelayedEvent([this, l_TeleportLoc]() -> void
                    {
                        TeleportTo(l_TeleportLoc.GetMapId(), l_TeleportLoc.GetPositionX(), l_TeleportLoc.GetPositionY(), l_TeleportLoc.GetPositionZ(), l_TeleportLoc.GetOrientation());
                    }, 1);
                    break;
                }
            }
        }
    }

    UpdateAreaDependentAuras(newArea);

    // previously this was in UpdateZone (but after UpdateArea) so nothing will break
    if (area && area->IsSanctuary())    // in sanctuary
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_SANCTUARY);
        pvpInfo.inNoPvPArea = true;
        CombatStopWithPets();
    }
    else
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_SANCTUARY);

    uint32 const areaRestFlag = (GetTeam() == ALLIANCE) ? AREA_FLAG_REST_ZONE_ALLIANCE : AREA_FLAG_REST_ZONE_HORDE;
    if (area && area->Flags & areaRestFlag)
        SetRestFlag(REST_FLAG_IN_FACTION_AREA);
    else
        RemoveRestFlag(REST_FLAG_IN_FACTION_AREA);

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    if (l_OldArea != newArea)
    {
        uint64 l_Guid = GetGUID();

        sOutdoorPvPMgr->HandlePlayerLeaveArea(this, l_OldArea);
        sOutdoorPvPMgr->HandlePlayerEnterArea(this, newArea);
        sOutdoorPvPMgr->HandlePlayerUpdateArea(this, l_OldArea, newArea);
#ifndef CROSS

        /// Garrison phasing specific code
        if (GetDraenorGarrison()
            && GetDraenorGarrison()->GetGarrisonSiteLevelEntry()
            && (GetMapId() == MS::Garrison::GDraenor::Globals::BaseMap || GetMapId() == GetDraenorGarrison()->GetGarrisonSiteLevelEntry()->MapID || GetMapId() == MS::Garrison::GDraenor::ShipyardMapId::Alliance || GetMapId() == MS::Garrison::GDraenor::ShipyardMapId::Horde))
        {
            Map * l_Map = sMapMgr->FindBaseNonInstanceMap(MS::Garrison::GDraenor::Globals::BaseMap, 0);

            if (!l_Map)
                l_Map = sMapMgr->CreateBaseMap(MS::Garrison::GDraenor::Globals::BaseMap, 0);

            if (l_Map)
            {
                uint32 l_DraenorBaseMap_Zone;
                uint32 l_DraenorBaseMap_Area;

                l_Map->GetZoneAndAreaId(l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area, m_positionX, m_positionY, m_positionZ);
                const GarrSiteLevelEntry * l_GarrisonSiteEntry = GetDraenorGarrison()->GetGarrisonSiteLevelEntry();

                if (l_DraenorBaseMap_Area != MS::Garrison::GDraenor::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()] && IsInShipyard())
                {
                    AddMapTask(eTaskType::TaskSwitchToPhasedMap, [=]() -> void
                    {
                        if (IsInWorld())
                            _SetOutOfShipyard();
                        else
                            m_TaskInProgress = false;
                    });
                }
                else if (l_DraenorBaseMap_Area == MS::Garrison::GDraenor::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == MS::Garrison::GDraenor::Globals::BaseMap)
                {
                    AddMapTask(eTaskType::TaskSwitchToPhasedMap, [=]() -> void
                    {
                        if (IsInWorld())
                            _SetInShipyard();
                        else
                            m_TaskInProgress = false;
                    });
                }

                if (l_DraenorBaseMap_Area != MS::Garrison::GDraenor::gGarrisonInGarrisonAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == l_GarrisonSiteEntry->MapID)
                {
                    AddMapTask(eTaskType::TaskSwitchToPhasedMap, [=]() -> void
                    {
                        if (IsInWorld())
                            _GarrisonSetOut();
                        else
                            m_TaskInProgress = false;
                    });
                }
                else if (l_DraenorBaseMap_Area == MS::Garrison::GDraenor::gGarrisonInGarrisonAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == MS::Garrison::GDraenor::Globals::BaseMap)
                {
                    AddMapTask(eTaskType::TaskSwitchToPhasedMap, [=]() -> void
                    {
                        if (IsInWorld())
                            _GarrisonSetIn();
                        else
                            m_TaskInProgress = false;
                    });
                }
            }
        }
#endif /* not CROSS */
    }
}

void Player::_GarrisonSetIn()
{
    if (!GetDraenorGarrison())
        return;

    const GarrSiteLevelEntry* l_GarrisonSiteEntry = GetDraenorGarrison()->GetGarrisonSiteLevelEntry();

    if (!l_GarrisonSiteEntry)
        return;

    Difficulty l_DungeonDiff = DifficultyNormal;
    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    SwitchToPhasedMap(l_GarrisonSiteEntry->MapID);
    GetDraenorGarrison()->OnPlayerEnter();

    std::swap(l_DungeonDiff, m_dungeonDifficulty);
}

void Player::_GarrisonSetOut()
{
    if (!GetDraenorGarrison())
        return;

    GetDraenorGarrison()->OnPlayerLeave();
    GetDraenorGarrison()->_SetGarrisonScriptID(0);

    SwitchToPhasedMap(MS::Garrison::GDraenor::Globals::BaseMap);
}

void Player::_SetInShipyard()
{
    if (!GetDraenorGarrison() || !GetDraenorGarrison()->HasShipyard())
        return;

    Difficulty l_DungeonDiff = DifficultyNormal;
    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    SwitchToPhasedMap(GetDraenorGarrison()->GetShipyardMapId());

    std::swap(l_DungeonDiff, m_dungeonDifficulty);
}

void Player::_SetOutOfShipyard()
{
    if (!GetDraenorGarrison() || !GetDraenorGarrison()->HasShipyard())
        return;

    SwitchToPhasedMap(MS::Garrison::GDraenor::Globals::BaseMap);
}

void Player::UpdateZone(uint32 newZone, uint32 newArea)
{
    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);

    if (m_zoneUpdateId != newZone)
    {
        if (!GetTransport() && !GetVehicleKit() && !GetVehicle() && !(GetVehicle() && GetVehicle()->GetBase()->IsPlayer()) && !GetMap()->Instanceable()

            && GetMap() != sMapMgr->CreateMap(GetMapId(), newZone, this) && !(newZone == 6941 || newZone == 8392) && !m_IsInMapSwitch)
        {
            AddMapTask(eTaskType::TaskSwitchToPhasedMap, [this]() -> void
            {
                SwitchToPhasedMap(GetMapId());
            });
            return;
        }

        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerEnterZone(this, newZone);
        SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
    }

    // group update
    if (GroupPtr group = GetGroup())
    {
        SetGroupUpdateFlag(GROUP_UPDATE_FULL);
        if (GetSession() && group->isLFGGroup() && sLFGMgr->IsTeleported(GetGUID()))
        {
            group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member)
            {
                if (Player* member = l_Member->player)
                    GetSession()->SendNameQueryOpcode(member->GetGUID());
            });
        }
    }

    uint32 l_OldZone  = m_zoneUpdateId;
    m_zoneUpdateId    = newZone;
    m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;

    // zone changed, so area changed as well, update it
    UpdateArea(newArea);

    sScriptMgr->OnPlayerUpdateZone(this, newZone, l_OldZone, newArea);

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(newZone);
    if (!zone)
        return;

    if (sWorld->getBoolConfig(CONFIG_WEATHER) && !HasAuraType(SPELL_AURA_FORCE_WEATHER))
    {
        if (Weather* weather = WeatherMgr::FindWeather(zone->ID))
            weather->SendWeatherUpdateToPlayer(this);
        else
        {
            if (!WeatherMgr::AddWeather(zone->ID))
            {
                // send fine weather packet to remove old zone's weather
                WeatherMgr::SendFineWeatherUpdateToPlayer(this);
            }
        }
    }

    // in PvP, any not controlled zone (except zone->team == 6, default case)
    // in PvE, only opposition team capital
    switch (zone->FactionGroupMask)
    {
        case AREATEAM_ALLY:
            pvpInfo.inHostileArea = GetTeam() != ALLIANCE && (sWorld->IsPvPRealm() || zone->Flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_HORDE:
            pvpInfo.inHostileArea = GetTeam() != HORDE && (sWorld->IsPvPRealm() || zone->Flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_NONE:
            // overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
            pvpInfo.inHostileArea = sWorld->IsPvPRealm() || InBattleground() || zone->Flags & AREA_FLAG_WINTERGRASP;
            break;
        default:                                            // 6 in fact
            pvpInfo.inHostileArea = false;
            break;
    }

    if ((zone->Flags & AREA_FLAG_CAPITAL))                     // Is in a capital city
    {
        if (!pvpInfo.inHostileArea || zone->IsSanctuary())
            SetRestFlag(REST_FLAG_IN_CITY);

        pvpInfo.inNoPvPArea = true;
    }
    else
        RemoveRestFlag(REST_FLAG_IN_CITY);

    if (zone->ID == 876) ///< To enable switching talent in GMIsland/Box
        SetRestFlag(REST_FLAG_IN_CITY);

    UpdatePvPState();

    // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
    // if player resurrected at teleport this will be applied in resurrect code
    if (isAlive())
        DestroyZoneLimitedItem(true, newZone);

    // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
    AutoUnequipOffhandIfNeed();

    // recent client version not send leave/join channel packets for built-in local channels
    UpdateLocalChannels(newZone);

    UpdateZoneDependentAuras(newZone);

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
}

//If players are too far away from the duel flag... they lose the duel
void Player::CheckDuelDistance(time_t currTime)
{
    if (!m_Duel)
        return;

    uint64 duelFlagGUID = GetGuidValue(PLAYER_FIELD_DUEL_ARBITER);
    GameObject* obj = GetMap()->GetGameObject(duelFlagGUID);
    if (!obj)
        return;

    if (m_Duel->outOfBound == 0)
    {
        if (!IsWithinDistInMap(obj, 100))
        {
            m_Duel->outOfBound = currTime;

            WorldPacket data(SMSG_DUEL_OUT_OF_BOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
    }
    else
    {
        if (IsWithinDistInMap(obj, 80))
        {
            m_Duel->outOfBound = 0;

            WorldPacket data(SMSG_DUEL_INBOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
        else if (currTime >= (m_Duel->outOfBound+10))
            DuelComplete(DUEL_FLED);
    }
}

bool Player::IsOutdoorPvPActive()
{
    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
}

void Player::DuelComplete(DuelCompleteType p_DuelType)
{
    // duel not requested
    if (!m_Duel || m_Duel->m_IsInComplete || m_Duel->opponent->m_Duel->m_IsInComplete)
        return;

    m_Duel->m_IsInComplete = true;
    m_Duel->opponent->m_Duel->m_IsInComplete = true;

    // Say "duel has been canceled"
    if (p_DuelType == DUEL_INTERRUPTED)
    {
        WorldPacket l_Data(SMSG_DUEL_COMPLETE, (1));
        l_Data.WriteBit(m_Duel->started);       ///< Started
        l_Data.FlushBits();
        GetSession()->SendPacket(&l_Data);

        if (m_Duel->opponent->GetSession())
            m_Duel->opponent->GetSession()->SendPacket(&l_Data);
    }


    if (p_DuelType != DUEL_INTERRUPTED)
    {
        /// Opponent is always the winner ...
        std::string l_BeatenName = GetName();
        std::string l_WinnerName = m_Duel->opponent->GetName();

        WorldPacket l_Data(SMSG_DUEL_WINNER);
        l_Data.WriteBits(l_WinnerName.size(), 6);               ///< WinnerName Size
        l_Data.WriteBits(l_BeatenName.size(), 6);               ///< BeatenName Size
        l_Data.WriteBit(p_DuelType == DUEL_WON ? 0 : 1);        ///< Fled
        l_Data << uint32(g_RealmID);                            ///< WinnerVirtualRealmAddress
        l_Data << uint32(g_RealmID);                            ///< BeatenVirtualRealmAddress
        l_Data.WriteString(l_WinnerName);                       ///< WinnerName
        l_Data.WriteString(l_BeatenName);                       ///< BeatenName

        SendMessageToSet(&l_Data, true);
    }

    sScriptMgr->OnPlayerDuelEnd(m_Duel->opponent, this, p_DuelType);

    if (sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
        RemoveAllSpellCooldown();
        if (m_Duel->opponent != nullptr)
            m_Duel->opponent->RemoveAllSpellCooldown();
    }

    switch (p_DuelType)
    {
        case DUEL_FLED:
            // if initiator and opponent are on the same team
            // or initiator and opponent are not PvP enabled, forcibly stop attacking
            if (m_Duel->initiator->GetTeam() == m_Duel->opponent->GetTeam())
            {
                m_Duel->initiator->AttackStop();
                m_Duel->opponent->AttackStop();
            }
            else
            {
                if (!m_Duel->initiator->IsPvP())
                    m_Duel->initiator->AttackStop();
                if (!m_Duel->opponent->IsPvP())
                    m_Duel->opponent->AttackStop();
            }
            break;
        case DUEL_WON:
            UpdateCriteria(CRITERIA_TYPE_LOSE_DUEL, 1);
            if (m_Duel->opponent)
            {
                 m_Duel->opponent->UpdateCriteria(CRITERIA_TYPE_WIN_DUEL, 1);

                //Credit for quest Death's Challenge
                if (getClass() == CLASS_DEATH_KNIGHT && m_Duel->opponent->GetQuestStatus(12733) == QUEST_STATUS_INCOMPLETE)
                    m_Duel->opponent->CastSpell(m_Duel->opponent, 52994, true);
            }
            break;
        default:
            break;
    }

    // Victory emote spell
    if (p_DuelType != DUEL_INTERRUPTED && m_Duel->opponent)
        m_Duel->opponent->CastSpell(m_Duel->opponent, 52852, true);

    //Remove Duel Flag object
    GameObject* obj = GetMap()->GetGameObject(GetGuidValue(PLAYER_FIELD_DUEL_ARBITER));
    if (obj)
        m_Duel->initiator->RemoveGameObject(obj, true);

    /* remove auras */
    AuraApplicationMap &itsAuras = m_Duel->opponent->GetAppliedAuras();
    for (AuraApplicationMap::iterator i = itsAuras.begin(); i != itsAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && aura->GetCasterGUID() == GetGUID() && aura->GetApplyTime() >= m_Duel->startTime && !i->second->GetRemoveMode())
        {
            m_Duel->opponent->RemoveAura(i);
            i = itsAuras.begin();
        }
        else
            ++i;
    }

    AuraApplicationMap &myAuras = GetAppliedAuras();
    for (AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && m_Duel->opponent != nullptr && aura->GetCasterGUID() == m_Duel->opponent->GetGUID() && aura->GetApplyTime() >= m_Duel->startTime && !i->second->GetRemoveMode())
        {
            RemoveAura(i);
            i = myAuras.begin();
        }
        else
            ++i;
    }

    // cleanup combo points
    ClearComboPoints();
    m_Duel->opponent->ClearComboPoints();

    SendClearLossOfControl();
    m_Duel->opponent->SendClearLossOfControl();

    // Honor points after duel (the winner) - ImpConfig
    if (uint32 amount = sWorld->getIntConfig(CONFIG_HONOR_AFTER_DUEL))
        m_Duel->opponent->RewardHonor(NULL, 1, amount);

    //cleanups
    SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);
    m_Duel->opponent->SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
    m_Duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    delete m_Duel->opponent->m_Duel;
    m_Duel->opponent->m_Duel = NULL;
    delete m_Duel;
    m_Duel = NULL;
}

void Player::UpdateWeaponDamage(ItemTemplate const* p_Proto, uint8 p_Slot, bool p_Apply, Item* p_Item)
{
    if (!p_Proto->IsWeapon())
        return;

    WeaponAttackType l_AttType = WeaponAttackType::BaseAttack;

    if (p_Slot == EQUIPMENT_SLOT_MAINHAND && (
        p_Proto->InventoryType == INVTYPE_RANGED || p_Proto->InventoryType == INVTYPE_THROWN ||
        p_Proto->InventoryType == INVTYPE_RANGEDRIGHT))
    {
        l_AttType = WeaponAttackType::RangedAttack;
    }
    else if (p_Slot == EQUIPMENT_SLOT_OFFHAND)
        l_AttType = WeaponAttackType::OffAttack;

    if (CanUseAttackType(l_AttType))
        _ApplyWeaponDamage(p_Slot, p_Item, p_Apply, p_Item->GetItemLevel(this));

    // Dual Wield penalty
    if (CanModifyStats())
    {
        if (l_AttType == WeaponAttackType::OffAttack)
            UpdateDamagePhysical(WeaponAttackType::BaseAttack, !p_Apply);
        else if (l_AttType == WeaponAttackType::BaseAttack && CanUseAttackType(WeaponAttackType::OffAttack))
            UpdateDamagePhysical(WeaponAttackType::OffAttack, !p_Apply);
    }
}

//---------------------------------------------------------//
void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply, bool p_HandlePassives /*= true*/)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();

    if (!proto)
        return;

    // not apply/remove mods for broken item
    if (item->CantBeUse())
        return;

    /// When the player have pvp stats template aura, don't apply item mods
    /// Refresh the pvp stat template aura to update the amount based on the avergage ilevel equipped
    if (IsInBattleground())
    {
        /// Delay the recalculate operation to the next update because item isn't equipped yet so the avg item level isn't updated yet
        uint64 l_PlayerGuid = GetGUID();
        Map* l_Map = GetMap();
        GetMap()->AddTask([l_PlayerGuid, l_Map]() -> bool
        {
            Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGuid);
            if (!l_Player || l_Player->GetMap() != l_Map)
                return true;

            if (Aura* l_Aura = l_Player->GetAura(uint32(l_Player->SelectPvpStatsSpell())))
                l_Aura->RecalculateAmountOfEffects(true);

            /// Principe of wars
            if (Aura* l_AuraSecond = l_Player->GetAura(197912))
                l_AuraSecond->RecalculateAmountOfEffects(true);

            return true;
        });

        /// Need to update weapon damage
        if (proto->IsWeapon())
        {
            UpdateWeaponDamage(proto, slot, apply, item);
            ApplyEnchantment(item, apply);
        }
        return;
    }

    sLog->outInfo(LOG_FILTER_PLAYER_ITEMS, "applying mods for item %u ", item->GetGUIDLow());

    uint8 attacktype = Player::GetAttackBySlot(slot);

    if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
        CorrectMetaGemEnchants(slot, apply);

    if (attacktype < WeaponAttackType::MaxAttack)
        _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);

    _ApplyItemBonuses(item, slot, apply);

    if (p_HandlePassives)
        ApplyItemEquipSpell(item, apply);

    ApplyEnchantment(item, apply);
    UpdateWeaponDamage(proto, slot, apply, item);
}

void Player::_ApplyItemBonuses(Item const* item, uint8 slot, bool apply)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    /// Item ilvl is dynamic and can change between apply/remove
    /// We need to save it in order to get the ilvl used for the apply at remove
    if (!item->GetScaleIlvl() && apply)
        const_cast<Item*>(item)->SetScaleIlvl(item->GetItemLevel(this));

    uint32 l_Ilevel = item->GetScaleIlvl();

    if (!apply)
        const_cast<Item*>(item)->SetScaleIlvl(0);

    float l_CombatRatingMultiplier = 1.0f;
    if (CombatRatingsMultByILvl const* l_IlvlRating = g_CombatRatingMultByIlvl.LookupEntry(l_Ilevel))
    {
        switch (proto->GetInventoryType())
        {
            case INVTYPE_WEAPON:
            case INVTYPE_SHIELD:
            case INVTYPE_RANGED:
            case INVTYPE_2HWEAPON:
            case INVTYPE_WEAPONMAINHAND:
            case INVTYPE_WEAPONOFFHAND:
            case INVTYPE_HOLDABLE:
            case INVTYPE_RANGEDRIGHT:
                l_CombatRatingMultiplier = l_IlvlRating->WeaponMultiplier;
                break;
            case INVTYPE_TRINKET:
                l_CombatRatingMultiplier = l_IlvlRating->TrinketMultiplier;
                break;
            case INVTYPE_NECK:
            case INVTYPE_FINGER:
                l_CombatRatingMultiplier = l_IlvlRating->JewelryMultiplier;
                break;
            default:
                l_CombatRatingMultiplier = l_IlvlRating->ArmorMultiplier;
                break;
        }
    }

    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
    {
        int32 statType = item->GetItemStatType(i);
        if (statType == -1)
            continue;

        int32 val = std::max(0, item->GetItemStatValue(i, this, l_Ilevel));

        switch (statType)
        {
            case int32(ItemModType::MANA):
                HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::HEALTH):
                HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::AGILITY):
            {
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_AGILITY, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_AGILITY, BASE_PCT_EXCLUDE_CREATE)), apply);
                UpdateStatBuffFields(STAT_AGILITY);
                break;
            }
            case int32(ItemModType::STRENGTH):
            {
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_STRENGTH, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_PCT_EXCLUDE_CREATE)), apply);
                UpdateStatBuffFields(STAT_STRENGTH);
                break;
            }
            case int32(ItemModType::INTELLECT):
            {
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_INTELLECT, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT_EXCLUDE_CREATE)), apply);
                UpdateStatBuffFields(STAT_INTELLECT);
                break;
            }
            case int32(ItemModType::STAMINA):
                HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_STAMINA, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            case int32(ItemModType::DODGE_RATING):
                ApplyRatingMod(CR_DODGE, int32(val), apply);
                break;
            case int32(ItemModType::PARRY_RATING):
                ApplyRatingMod(CR_PARRY, int32(val), apply);
                break;
            case int32(ItemModType::BLOCK_RATING):
                ApplyRatingMod(CR_BLOCK, int32(val), apply);
                break;
            case int32(ItemModType::CRIT_RATING):
                ApplyRatingMod(CR_CRIT_MELEE, int32(val * l_CombatRatingMultiplier), apply);
                ApplyRatingMod(CR_CRIT_RANGED, int32(val * l_CombatRatingMultiplier), apply);
                ApplyRatingMod(CR_CRIT_SPELL, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::RESILIENCE_RATING):
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::HASTE_RATING):
                ApplyRatingMod(CR_HASTE_MELEE, int32(val * l_CombatRatingMultiplier), apply);
                ApplyRatingMod(CR_HASTE_RANGED, int32(val * l_CombatRatingMultiplier), apply);
                ApplyRatingMod(CR_HASTE_SPELL, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::ATTACK_POWER):
                HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
                break;
            case int32(ItemModType::VERSATILITY):
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, int32(val * l_CombatRatingMultiplier), apply);
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::MANA_REGENERATION):
                ApplyManaRegenBonus(int32(val), apply);
                break;
            case int32(ItemModType::SPELL_POWER):
                ApplySpellPowerBonus(int32(val), apply);
                break;
            case int32(ItemModType::HEALTH_REGEN):
                ApplyHealthRegenBonus(int32(val), apply);
                break;
            case int32(ItemModType::MASTERY_RATING):
                ApplyRatingMod(CR_MASTERY, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::EXTRA_ARMOR):
                HandleStatModifier(UNIT_MOD_BONUS_ARMOR, BASE_VALUE, float(val), apply);
                UpdateArmor();
                break;
            case int32(ItemModType::FIRE_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::FROST_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::HOLY_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::SHADOW_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::NATURE_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::ARCANE_RESISTANCE):
                HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(val), apply);
                break;
            case int32(ItemModType::PVP_POWER):
                ApplyRatingMod(CR_PVP_POWER, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::COMBAT_RATING_SPEED):
                ApplyRatingMod(CR_SPEED, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::COMBAT_RATING_LIFESTEAL):
                ApplyRatingMod(CR_LIFESTEAL, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::COMBAT_RATING_AVOIDANCE):
                ApplyRatingMod(CR_AVOIDANCE, int32(val * l_CombatRatingMultiplier), apply);
                break;
            case int32(ItemModType::AGILITY_OR_STRENGTH_OR_INTELLECT):
            {
                Stats stat = GetPrimaryStat();
                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(stat, float(val), apply);
                UpdateStatBuffFields(STAT_AGILITY);
                UpdateStatBuffFields(STAT_STRENGTH);
                UpdateStatBuffFields(STAT_INTELLECT);
                break;
            }
            case int32(ItemModType::AGILITY_OR_STRENGTH):
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_AGILITY && stat != STAT_STRENGTH)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(stat, float(val), apply);
                UpdateStatBuffFields(STAT_AGILITY);
                UpdateStatBuffFields(STAT_STRENGTH);
                break;
            }
            case int32(ItemModType::AGILITY_OR_INTELLECT):
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_AGILITY && stat != STAT_INTELLECT)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(stat, float(val), apply);
                UpdateStatBuffFields(STAT_AGILITY);
                UpdateStatBuffFields(STAT_INTELLECT);
                break;
            }
            case int32(ItemModType::STRENGTH_OR_INTELLECT):
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_INTELLECT && stat != STAT_STRENGTH)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(stat, float(val), apply);
                UpdateStatBuffFields(STAT_STRENGTH);
                UpdateStatBuffFields(STAT_INTELLECT);
                break;
            }
            case (int32)ItemModType::COMBAT_RATING_STURDINESS:
            {
                if (item->HasFlag(EItemFields::ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_NO_DURABILITY_LOSS))
                    break;

                const_cast<Item*>(item)->ApplyModFlag(EItemFields::ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_NO_DURABILITY_LOSS, apply);
                break;
            }
            default:
                break;
        }
    }

    uint32 armor = item->GetArmor(this, l_Ilevel);

    if (armor)
    {
        UnitModifierType modType = TOTAL_VALUE;
        if (proto->Class == ITEM_CLASS_ARMOR)
        {
            switch (proto->SubClass)
            {
                case ITEM_SUBCLASS_ARMOR_CLOTH:
                case ITEM_SUBCLASS_ARMOR_LEATHER:
                case ITEM_SUBCLASS_ARMOR_MAIL:
                case ITEM_SUBCLASS_ARMOR_PLATE:
                case ITEM_SUBCLASS_ARMOR_SHIELD:
                    modType = BASE_VALUE;
                break;
            }
        }
        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
    }
}

void Player::_ApplyWeaponDamage(uint8 slot, Item const* item, bool apply, uint32 p_Ilevel)
{
    ItemTemplate const* proto = item->GetTemplate();
    WeaponAttackType attType = WeaponAttackType::BaseAttack;
    float damage = 0.0f;

    if (slot == EQUIPMENT_SLOT_MAINHAND && (proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN || proto->InventoryType == INVTYPE_RANGEDRIGHT))
        attType = WeaponAttackType::RangedAttack;
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = WeaponAttackType::OffAttack;

    float minDamage = 0.0f;
    float maxDamage = 0.0f;
    proto->GetDamage(p_Ilevel, minDamage, maxDamage);

    uint32 l_BaseAttackSpeed = proto->Delay;

    if (getClass() == CLASS_DRUID)
    {
        ShapeshiftForm l_Form = GetShapeshiftForm();
        if (l_Form == FORM_CAT_FORM)
            l_BaseAttackSpeed = 1000;
        if (l_Form == FORM_BEAR_FORM)
            l_BaseAttackSpeed = 2500;
    }

    /// PvP Template enabled - Use template values for weapons base damages
    /// Weapon base damage change by weapon speed
    /// All thoses values are blizzlike ones for the patch 7.3.5 26365
    if (HasAura((uint32)PvPStatsSpells::SPEC_STAT_TEMPLATE_ALL_SPECS))
    {
        if (l_BaseAttackSpeed == 3600)
        {
            minDamage = 13368.1f;
            maxDamage = 13368.1f;

            if (GetActiveSpecializationID() == SPEC_MONK_MISTWEAVER || GetActiveSpecializationID() == SPEC_DRUID_RESTORATION)
            {
                minDamage /= 2;
                maxDamage /= 2;
            }
        }
        else if (l_BaseAttackSpeed == 3000)
        {
            minDamage = 11140.1f;
            maxDamage = 11140.1f;
        }
        else if (l_BaseAttackSpeed == 2600)
        {
            minDamage = 7502.63f;
            maxDamage = 7502.63f;
        }
        /// Bear form
        else if (l_BaseAttackSpeed == 2500)
        {
            minDamage = 4826.57f;
            maxDamage = 4826.57f;

            if (GetActiveSpecializationID() == SPEC_DRUID_FERAL)
            {
                minDamage = 7500.0f;
                maxDamage = 7500.0f;
            }
        }
        /// Feral form
        else if (l_BaseAttackSpeed == 1000)
        {
            minDamage = 1856.71f;
            maxDamage = 1856.71f;

            if (GetActiveSpecializationID() == SPEC_DRUID_FERAL)
            {
                minDamage = 2884;
                maxDamage = 2884;
            }
        }
        else ///< if (proto->Delay == 1800), also default value if the player doesn't equip a artifact
        {
            minDamage = 5192.58f;
            maxDamage = 5192.58f;
        }
    }

    if (minDamage > 0)
    {
        damage = apply ? minDamage : BASE_MINDAMAGE;
        SetBaseWeaponDamage(attType, MINDAMAGE, damage);
    }

    if (maxDamage  > 0)
    {
        damage = apply ? maxDamage : BASE_MAXDAMAGE;
        SetBaseWeaponDamage(attType, MAXDAMAGE, damage);
    }

    if (proto->Delay && !IsInFeralForm())
    {
        if (slot == EQUIPMENT_SLOT_MAINHAND && (
        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
        proto->InventoryType == INVTYPE_RANGEDRIGHT))
            SetAttackTime(WeaponAttackType::RangedAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_MAINHAND)
            SetAttackTime(WeaponAttackType::BaseAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_OFFHAND)
            SetAttackTime(WeaponAttackType::OffAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
    }

    if (CanModifyStats())
        UpdateDamagePhysical(attType);
}

void Player::_ApplyWeaponDependentAuraMods(Item* item, WeaponAttackType attackType, bool apply)
{
    AuraEffectList const& auraCritList = GetAuraEffectsByType(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
    for (AuraEffectList::const_iterator itr = auraCritList.begin(); itr != auraCritList.end(); ++itr)
        _ApplyWeaponDependentAuraCritMod(item, attackType, *itr, apply);

    AuraEffectList const& auraDamageFlatList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
    for (AuraEffectList::const_iterator itr = auraDamageFlatList.begin(); itr != auraDamageFlatList.end(); ++itr)
        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);

    AuraEffectList const& auraDamagePctList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
    for (AuraEffectList::const_iterator itr = auraDamagePctList.begin(); itr != auraDamagePctList.end(); ++itr)
        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);
}

void Player::_ApplyWeaponDependentAuraCritMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->CantBeUse() || !CanUseAttackType(attackType))
        return;

    // generic not weapon specific case processes in aura code
    if (aura->GetSpellInfo()->EquippedItemClass == -1)
        return;

    BaseModGroup mod = BASEMOD_END;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   mod = CRIT_PERCENTAGE;        break;
        case WeaponAttackType::OffAttack:    mod = OFFHAND_CRIT_PERCENTAGE;break;
        case WeaponAttackType::RangedAttack: mod = RANGED_CRIT_PERCENTAGE; break;
        default: return;
    }

    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetAmount()), apply);
}

void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->CantBeUse() || !CanUseAttackType(attackType))
        return;

    // ignore spell mods for not wands
    if ((aura->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) == 0 && (getClassMask() & CLASSMASK_WAND_USERS) == 0)
        return;

    // generic not weapon specific case processes in aura code
    if (aura->GetSpellInfo()->EquippedItemClass == -1)
        return;

    UnitMods unitMod = UNIT_MOD_END;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
        case WeaponAttackType::OffAttack:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
        case WeaponAttackType::RangedAttack: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
        default: return;
    }

    UnitModifierType unitModType = TOTAL_VALUE;
    switch (aura->GetAuraType())
    {
        case SPELL_AURA_MOD_DAMAGE_DONE:         unitModType = TOTAL_VALUE; break;
        case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE: unitModType = TOTAL_PCT;   break;
        default: return;
    }

    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
    {
        HandleStatModifier(unitMod, unitModType, float(aura->GetAmount()), apply);
        if (unitModType == TOTAL_VALUE)
            ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS, aura->GetAmount(), apply);
    }
}

void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
{
    if (!item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = proto->Spells[i];

        // no spell
        if (!spellData.SpellId)
            continue;

        // wrong triggering type
        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
            continue;

        // check if it is valid spell
        SpellInfo const* spellproto = sSpellMgr->GetSpellInfo(spellData.SpellId);
        if (!spellproto)
            continue;

        // Item doesn't need to be equipped
        if (spellData.SpellTrigger == ITEM_SPELLTRIGGER_ON_OBTAIN && spellproto->HasAura(SPELL_AURA_MOD_SKILL_VALUE))
            continue;

        ApplyEquipSpell(spellproto, item, apply, form_change);
    }
}

void Player::ApplyEquipSpell(SpellInfo const* spellInfo, Item* item, bool apply, bool form_change)
{
    if (apply)
    {
        if(item)
            m_SpellsFromItem.insert({item->GetGUID(), spellInfo->Id});

        if (IsInBattleground() && item && !item->GetArtifactManager())
            return;

        // Cannot be used in this stance/form
        if (spellInfo->CheckShapeshift(GetShapeshiftForm()) != SPELL_CAST_OK)
            return;

        if (form_change)                                    // check aura active state from other form
        {
            AuraApplicationMap const& auras = GetAppliedAuras();
            for (AuraApplicationMap::const_iterator itr = auras.lower_bound(spellInfo->Id); itr != auras.upper_bound(spellInfo->Id); ++itr)
                if (!item || itr->second->GetBase()->GetCastItemGUID() == item->GetGUID())
                    return;
        }

        sLog->outDebug(LOG_FILTER_PLAYER, "WORLD: cast %s Equip spellId - %i", (item ? "item" : "itemset"), spellInfo->Id);

        CastSpell(this, spellInfo, true, item);
    }
    else
    {
        if (item)
            m_SpellsFromItem.erase(item->GetGUID());

        if (form_change)                                     // check aura compatibility
        {
            // Cannot be used in this stance/form
            if (spellInfo->CheckShapeshift(GetShapeshiftForm()) == SPELL_CAST_OK)
                return;                                     // and remove only not compatible at form change
        }

        if (item)
            RemoveAurasDueToItemSpell(item, spellInfo->Id);  // un-apply all spells, not only at-equipped
        else
            RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
    }
}

void Player::UpdateEquipSpellsAtFormChange()
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] && !m_items[i]->CantBeUse() && CanUseAttackType(GetAttackBySlot(i)))
        {
            ApplyItemEquipSpell(m_items[i], false, true);     // remove spells that not fit to form
            ApplyItemEquipSpell(m_items[i], true, true);      // add spells that fit form but not active
        }
    }

    UpdateItemSetAuras(true);
}

void Player::UpdateItemSetAuras(bool formChange /*= false*/)
{
    // item set bonuses not dependent from item broken state
    for (size_t setindex = 0; setindex < ItemSetEff.size(); ++setindex)
    {
        ItemSetEffect* eff = ItemSetEff[setindex];
        if (!eff)
            continue;

        for (ItemSetSpellEntry const* itemSetSpell : eff->SetBonuses)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSetSpell->SpellID);

            if (!spellInfo)
                assert(false);

            if (itemSetSpell->SpecializationID && itemSetSpell->SpecializationID != GetActiveSpecializationID())
                ApplyEquipSpell(spellInfo, nullptr, false, false);  // item set aura is not for current spec
            else
            {
                ApplyEquipSpell(spellInfo, nullptr, false, formChange); // remove spells that not fit to form - removal is skipped if shapeshift condition is satisfied
                ApplyEquipSpell(spellInfo, nullptr, true, formChange);  // add spells that fit form but not active
            }
        }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
{
    if (!target || !target->isAlive() || target == this)
        return;

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // If usable, try to cast item spell
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (!item->CantBeUse() && CanUseAttackType(attType))
                if (ItemTemplate const* proto = item->GetTemplate())
                {
                    // Additional check for weapons
                    if (proto->Class == ITEM_CLASS_WEAPON)
                    {
                        // offhand item cannot proc from main hand hit etc
                        EquipmentSlots slot;
                        switch (attType)
                        {
                            case WeaponAttackType::BaseAttack:   slot = EQUIPMENT_SLOT_MAINHAND; break;
                            case WeaponAttackType::OffAttack:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
                            case WeaponAttackType::RangedAttack: slot = EQUIPMENT_SLOT_MAINHAND;   break;
                            default: slot = EQUIPMENT_SLOT_END; break;
                        }
                        if (slot != i)
                            continue;
                        // Check if item is useable (forms or disarm)
                        if (attType == WeaponAttackType::BaseAttack)
                            if (!IsUseEquipedWeapon(true) && !IsInFeralForm())
                                continue;
                    }
                    CastItemCombatSpell(target, attType, procVictim, procEx, item, proto);
                }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
{
    // Can do effect if any damage done to target
    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
    //if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
    {
        for (uint8 i = 0; i < MAX_ITEM_SPELLS; ++i)
        {
            _Spell const& spellData = proto->Spells[i];

            // no spell
            if (!spellData.SpellId)
                continue;

            // wrong triggering type
            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "WORLD: unknown Item spellid %i", spellData.SpellId);
                continue;
            }

            // not allow proc extra attack spell at extra attack
            if (m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
                return;

            float chance = (float)spellInfo->ProcChance;

            if (proto->SpellPPMRate)
            {
                if (spellData.SpellId == 52781) // Persuasive Strike
                {
                    switch (target->GetEntry())
                    {
                        default:
                            return;
                        case 28939:
                        case 28940:
                        case 28610:
                            break;
                    }
                }
                uint32 WeaponSpeed = GetAttackTime(attType);
                chance = GetPPMProcChance(WeaponSpeed, proto->SpellPPMRate, spellInfo);
            }
            else if (chance > 100.0f)
            {
                chance = GetWeaponProcChance();
            }

            if (roll_chance_f(chance))
            {
                sLog->outAshran("Player::CastItemCombatSpell %u", spellInfo->Id);
                CastSpell(target, spellInfo->Id, true, item);
            }
        }
    }

    // item combat enchantments
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        if (e_slot > ENGINEERING_ENCHANTMENT_SLOT && e_slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!pEnchant)
            continue;

        for (uint8 s = 0; s < MAX_ENCHANTMENT_SPELLS; ++s)
        {
            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
                continue;

            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);

            if (entry && entry->procEx)
            {
                // Check hit/crit/dodge/parry requirement
                if ((entry->procEx & procEx) == 0)
                    continue;
            }
            else
            {
                // Can do effect if any damage done to target
                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
                //if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
                    continue;
            }

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
                    GetGUIDLow(), GetName(), pEnchant->ID, pEnchant->spellid[s]);
                continue;
            }

            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : GetWeaponProcChance();

            if (entry)
            {
                if (entry->PPMChance)
                    chance = GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
                else if (entry->customChance)
                    chance = (float)entry->customChance;
            }

            // Apply spell mods
            ApplySpellMod(pEnchant->spellid[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);

            if (roll_chance_f(chance))
            {
                if (spellInfo->IsPositive())
                    CastSpell(this, spellInfo, true, item);
                else
                    CastSpell(target, spellInfo, true, item);
            }
        }
    }
}

void Player::CastItemUseSpell(Item* p_Item, SpellCastTargets const& p_Targets, Guid128 p_CastGUID, uint32 p_Misc, uint32 p_Misc2)
{
    ItemTemplate const* l_ItemTemplate = p_Item->GetTemplate();

    /// Special learning case
    if (l_ItemTemplate->Spells[0].SpellId == 483 || l_ItemTemplate->Spells[0].SpellId == 55884 || l_ItemTemplate->Spells[0].SpellId == 186228)
    {
        uint32 l_LearnedSpell   = l_ItemTemplate->Spells[0].SpellId;
        uint32 l_LearningSpell  = l_ItemTemplate->Spells[1].SpellId;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_LearnedSpell);
        if (!l_SpellInfo)
        {
            sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring ", l_ItemTemplate->ItemId, l_LearnedSpell);
            SendEquipError(InventoryResult::EQUIP_ERR_INTERNAL_BAG_ERROR, p_Item, nullptr);
            return;
        }

        TriggerCastData triggerData;
        triggerData.SubType = SPELL_CAST_TYPE_ITEM;

        Spell* l_Spell          = new Spell(this, l_SpellInfo, TriggerCastFlags::TRIGGERED_NONE);
        l_Spell->m_FromClient   = true;
        l_Spell->m_CastItem     = p_Item;
        l_Spell->SetSpellValue(SpellValueMod::SPELLVALUE_BASE_POINT0, l_LearningSpell);
        l_Spell->m_Misc[0] = p_Misc;
        l_Spell->m_Misc[1] = p_Misc2;
        l_Spell->SetCastGUID(p_CastGUID);
        l_Spell->SetTriggerCastData(triggerData);
        l_Spell->prepare(&p_Targets);
        return;
    }

    /// Use triggered flag only for items with many spell casts and for not first cast
    uint8 l_Count = 0;

    /// Item enchantments spells casted at use
    for (uint8 l_Slot = 0; l_Slot < EnchantmentSlot::MAX_ENCHANTMENT_SLOT; ++l_Slot)
    {
        if (l_Slot > EnchantmentSlot::ENGINEERING_ENCHANTMENT_SLOT && l_Slot < EnchantmentSlot::PROP_ENCHANTMENT_SLOT_0)    ///< Not holding enchantment id
            continue;

        uint32 l_EnchantID = p_Item->GetEnchantmentId(EnchantmentSlot(l_Slot));
        SpellItemEnchantmentEntry const* l_ItemEnchantEntry = sSpellItemEnchantmentStore.LookupEntry(l_EnchantID);
        if (!l_ItemEnchantEntry)
            continue;

        for (uint8 l_I = 0; l_I < MAX_ENCHANTMENT_SPELLS; ++l_I)
        {
            if (l_ItemEnchantEntry->type[l_I] != ItemEnchantmentType::ITEM_ENCHANTMENT_TYPE_USE_SPELL)
                continue;

            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_ItemEnchantEntry->spellid[l_I]);
            if (!l_SpellInfo)
            {
                sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell Enchant %i, cast unknown spell %i", l_ItemEnchantEntry->ID, l_ItemEnchantEntry->spellid[l_I]);
                continue;
            }

            TriggerCastData triggerData;
            triggerData.SubType = SPELL_CAST_TYPE_ITEM;

            Spell* l_Spell          = new Spell(this, l_SpellInfo, (l_Count > 0) ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE);
            l_Spell->m_FromClient   = true;
            l_Spell->m_CastItem     = p_Item;
            l_Spell->m_Misc[0]      = p_Misc;
            l_Spell->m_Misc[1]      = p_Misc2;
            l_Spell->SetCastGUID(p_CastGUID);
            l_Spell->SetTriggerCastData(triggerData);
            l_Spell->prepare(&p_Targets);

            ++l_Count;
        }
    }

    /// Item spells casted at use
    for (uint8 l_I = 0; l_I < MAX_ITEM_PROTO_SPELLS; ++l_I)
    {
        _Spell const& l_SpellData = l_ItemTemplate->Spells[l_I];

        /// No spell
        if (!l_SpellData.SpellId)
            continue;

        /// Wrong triggering type
        if (l_SpellData.SpellTrigger != ItemSpelltriggerType::ITEM_SPELLTRIGGER_ON_USE)
            continue;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellData.SpellId);
        if (!l_SpellInfo)
        {
            sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring", l_ItemTemplate->ItemId, l_SpellData.SpellId);
            continue;
        }

        TriggerCastData triggerData;
        triggerData.SubType   = SPELL_CAST_TYPE_ITEM;
        triggerData.miscData0 = p_Misc;
        triggerData.miscData1 = p_Misc2;

        Spell* l_Spell            = new Spell(this, l_SpellInfo, (l_Count > 0) ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE);
        l_Spell->m_FromClient     = true;
        l_Spell->m_CastItem       = p_Item;
        l_Spell->SetCastGUID(p_CastGUID);
        l_Spell->m_Misc[0]        = p_Misc;
        l_Spell->m_Misc[1]        = p_Misc2;
        l_Spell->SetTriggerCastData(triggerData);
        l_Spell->prepare(&p_Targets);

        ++l_Count;
    }
}

void Player::_RemoveAllItemMods()
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                RemoveItemsSetItem(this, proto);

            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], false);
            ApplyEnchantment(m_items[i], false);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < WeaponAttackType::MaxAttack)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), false);

            _ApplyItemBonuses(m_items[i], i, false);
        }
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods complete.");
}

void Player::_ApplyAllItemMods()
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < WeaponAttackType::MaxAttack)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), true);

            _ApplyItemBonuses(m_items[i], i, true);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                AddItemsSetItem(this, m_items[i]);

            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], true);
            ApplyEnchantment(m_items[i], true);
        }
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods complete.");
}

/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
    Called by remove insignia spell effect    */
void Player::RemovedInsignia(Player* looterPlr)
{
    if (!GetBattlegroundId() && GetMapId() != 1191 && !sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE)) ///< Specific handle for Ashran too
        return;

    // If not released spirit, do it !
    if (m_deathTimer > 0)
    {
        m_deathTimer = 0;
        BuildPlayerRepop();
        RepopAtGraveyard();
    }

    m_CorpseLocation.WorldRelocate();

    // We have to convert player corpse to bones, not to be able to resurrect there
    // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
    Corpse* bones = GetMap()->ConvertCorpseToBones(GetGUID(), true);
    if (!bones)
        return;

    // Now we must make bones lootable, and send player loot
    bones->SetFlag(CORPSE_FIELD_DYNAMIC_FLAGS, CORPSE_DYNFLAG_LOOTABLE);

    // We store the level of our player in the gold field
    // We retrieve this information at Player::SendLoot()
    bones->loot.Gold = getLevel();
    bones->lootRecipient = looterPlr;
    looterPlr->SendLoot(bones->GetGUID(), LOOT_INSIGNIA);
}

void Player::SendLootRelease(uint64 p_LootGuid)
{
    uint64 l_LootObject = MAKE_NEW_GUID(GUID_LOPART(p_LootGuid), 0, HIGHGUID_LOOT);

    WorldPacket data(SMSG_LOOT_RELEASE);
    data.appendPackGUID(l_LootObject);
    data.appendPackGUID(p_LootGuid);

    SendDirectMessage(&data);
}

uint64 Player::GetLootContainerGuidForCreature(Creature* p_Creature)
{
    uint64 l_LootContainerGuid = 0;

    /// Check group container first
    GroupPtr l_Group = GetGroup();
    if (l_Group && l_Group->GetLootMethod() != LootMethod::PERSONAL_LOOT)
    {
        auto l_Itr = p_Creature->m_LootContainers.find(l_Group->GetGUID());
        if (l_Itr != p_Creature->m_LootContainers.end())
        {
            Loot* loot = &l_Itr->second;

            l_LootContainerGuid = l_Group->GetGUID();

            /// Player isn't allowed to loot (wasn't in the radius when the creature was killed or wasn't in the group at the moment of the kill)
            /// Check personal loot container
            if (loot->AllowedPlayers.IsEnabled() && !loot->AllowedPlayers.HasPlayerGuid(GetGUID()))
                l_LootContainerGuid = 0;
        }
    }

    /// Check personal loot
    if (!l_LootContainerGuid)
    {
        auto l_Itr = p_Creature->m_LootContainers.find(GetGUID());
        if (l_Itr != p_Creature->m_LootContainers.end())
            l_LootContainerGuid = GetGUID();
    }

    return l_LootContainerGuid;
}

uint64 Player::GetLootContainerGuidForGameObject(GameObject* p_GameObject)
{
    uint64 l_LootContainerGuid = 0;

    /// Check group container first
    GroupPtr l_Group = GetGroup();
    if (l_Group && l_Group->GetLootMethod() != LootMethod::PERSONAL_LOOT)
    {
        auto l_Itr = p_GameObject->m_LootContainers.find(l_Group->GetGUID());
        if (l_Itr != p_GameObject->m_LootContainers.end())
        {
            Loot* loot = &l_Itr->second;

            l_LootContainerGuid = l_Group->GetGUID();

            /// Player isn't allowed to loot (wasn't in the radius when the creature was killed or wasn't in the group at the moment of the kill)
            /// Check personal loot container
            if (loot->AllowedPlayers.IsEnabled() && !loot->AllowedPlayers.HasPlayerGuid(GetGUID()))
                l_LootContainerGuid = 0;
        }
    }

    /// Check personal loot
    if (!l_LootContainerGuid)
    {
        auto l_Itr = p_GameObject->m_LootContainers.find(GetGUID());
        if (l_Itr != p_GameObject->m_LootContainers.end())
            l_LootContainerGuid = GetGUID();
    }

    return l_LootContainerGuid;
}

void Player::SendLoot(uint64 p_Guid, LootType p_LootType, bool p_FetchLoot)
{
    if (uint64 l_Guid = GetLootGUID())
        m_session->DoLootRelease(l_Guid);

    uint64 l_PlayerGuid = GetGUID();
    Loot* l_Loot = nullptr;
    PermissionTypes l_Permission = ALL_PERMISSION;

    if (IS_GAMEOBJECT_GUID(p_Guid))
    {
        GameObject* l_GameObject = GetMap()->GetGameObject(p_Guid);

        /// Not check distance for GO in case owned GO (fishing bobber case, for example)
        /// And permit out of range GO with no owner in case fishing hole
        if (!l_GameObject || (p_LootType != LOOT_FISHINGHOLE && (p_LootType != LOOT_FISHING || l_GameObject->GetOwnerGUID() != l_PlayerGuid)
            && !l_GameObject->IsWithinDistInMap(this, INTERACTION_DISTANCE)) || (p_LootType == LOOT_CORPSE && l_GameObject->GetRespawnTime() && l_GameObject->isSpawnedByDefault()))
        {
            SendLootRelease(p_Guid);
            return;
        }

        /// If gameobject is quest tracked and player already have it, player can't loot (cheat ?)
        uint32 l_TrackingQuest = l_GameObject->GetGOInfo()->GetTrackingQuestId();
        uint32 l_QuestBit      = GetQuestUniqueBitFlag(l_TrackingQuest);

        if (l_TrackingQuest && IsQuestBitFlaged(l_QuestBit))
        {
            SendLootRelease(p_Guid);
            return;
        }

        /// Loot aren't generated yet
        if ((l_GameObject->GetGOInfo()->IsOploteChest() || l_GameObject->getLootState() == GO_READY) && !GetMap()->IsLootedGameObject(l_GameObject->GetDBTableGUIDLow()))
        {
            uint32 l_LootID = l_GameObject->GetGOInfo()->GetLootId();

            /// TODO: fix this big hack
            if ((l_GameObject->GetEntry() == BG_AV_OBJECTID_MINE_N || l_GameObject->GetEntry() == BG_AV_OBJECTID_MINE_S))
            {
                if (Battleground* l_Battleground = GetBattleground())
                {
                    if (l_Battleground->GetTypeID(true) == BATTLEGROUND_AV)
                    {
                        if (!(((BattlegroundAV*)l_Battleground)->PlayerCanDoMineQuest(l_GameObject->GetEntry(), GetTeam())))
                        {
                            SendLootRelease(p_Guid);
                            return;
                        }
                    }
                }
            }

            if (m_ChestTimedLockout.find(l_GameObject->GetDBTableGUIDLow()) != m_ChestTimedLockout.end())
            {
                SendLootRelease(p_Guid);
                SendGameError(GameError::Type::ERR_USE_CANT_OPEN);
                return;
            }

            Difficulty l_Diff = GetMap()->GetDifficultyID();

            bool l_IsLootGenerated = false;

            /// Don't regenerate the loot container if there is already one for our player
            if (l_LootID)
            {
                GroupPtr l_Group = GetGroup();
                bool l_GroupRules = (l_Group && l_GameObject->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && l_GameObject->GetGOInfo()->chest.usegrouplootrules);

                std::set<Player*> l_AllowedContainers;
                if (GetMap()->GetDifficultyID() != Difficulty::DifficultyNone && l_Group && l_Group->GetLootMethod() == LootMethod::PERSONAL_LOOT)
                {
                    Map::PlayerList const& l_Players = l_GameObject->GetMap()->GetPlayers();
                    for (Map::PlayerList::const_iterator l_Itr = l_Players.begin(); l_Itr != l_Players.end(); ++l_Itr)
                    {
                        if (Player* l_Player = l_Itr->getSource())
                            l_AllowedContainers.insert(l_Player);
                    }
                }
                else
                    l_AllowedContainers.insert(this);

                for (Player* l_Looter : l_AllowedContainers)
                {
                    uint64 l_LootContainerGuid = l_Looter->GetGUID();

                    if (l_GameObject->m_LootContainers.find(l_LootContainerGuid) != l_GameObject->m_LootContainers.end())
                    {
                        if (l_GameObject->GetEntry() == 276503 || l_GameObject->GetEntry() == 277355)
                            sLog->outAshran("CHEST_LOOT %u player %u can't loot because loot container is already filled", l_GameObject->GetEntry(), l_Looter->GetGUID());
                        continue;
                    }

                    if (l_Looter->BossAlreadyLooted(l_GameObject))
                    {
                        if (l_GameObject->GetEntry() == 276503 || l_GameObject->GetEntry() == 277355)
                            sLog->outAshran("CHEST_LOOT %u player %u can't loot because BossAlreadyLooted", l_GameObject->GetEntry(), l_Looter->GetGUID());
                        continue;
                    }

                    l_IsLootGenerated = true;

                    if (l_Diff == Difficulty::DifficultyMythic ||
                        l_Diff == Difficulty::DifficultyRaidHeroic ||
                        l_Diff == Difficulty::DifficultyRaidNormal ||
                        l_Diff == Difficulty::DifficultyRaidMythic ||
                        l_Diff == Difficulty::DifficultyRaidLFR)
                        l_Looter->AddBossLooted(l_GameObject);

                    l_Loot = &l_GameObject->m_LootContainers[l_LootContainerGuid];
                    l_Loot->clear();
                    l_Loot->SetSource(l_GameObject->GetGUID());
                    l_Loot->m_PersonalLootFilter = GetMap()->IsDungeon();
                    l_Loot->Context              = GetMap()->GetLootItemContext(l_Looter);
                    l_Loot->SpawnMode            = GetMap()->GetSpawnMode();

                    /// Check current RR player and get next if necessary
                    if (l_GroupRules)
                        l_Group->UpdateLooterGuid(l_GameObject, true);
                    uint32 lootCounter = 0;
                    if (!l_Loot->FillLoot(l_LootID, LootTemplates_Gameobject, l_Looter, !l_GroupRules, lootCounter, false, l_GameObject->GetLootMode()))
                        l_Loot->FillLoot(l_GameObject->GetEntry(), LootTemplates_Gameobject, l_Looter, !l_GroupRules, lootCounter, false, l_GameObject->GetLootMode());

                    if (l_GameObject->GetEntry() == 276503 || l_GameObject->GetEntry() == 277355)
                    {
                        std::string l_LootList;
                        for (auto& l_ItemLoot : l_Loot->Items)
                            l_LootList += std::to_string(l_ItemLoot.itemid) + " ";

                        sLog->outAshran("CHEST_LOOT %u player %u loot list: %s", l_GameObject->GetEntry(), l_Looter->GetGUID(), l_LootList.c_str());
                    }

                    /// Get next RR player (for next loot)
                    if (l_GroupRules)
                        l_Group->UpdateLooterGuid(l_GameObject);

                    if (l_Loot)
                    {
                        uint32 l_MinGold = 0;
                        uint32 l_MaxGold = 0;

                        l_GameObject->GenerateMinMaxGold(l_MinGold, l_MaxGold);
                        l_Loot->generateMoneyLoot(l_MinGold, l_MaxGold);
                    }
                }

                if (l_Diff == Difficulty::DifficultyMythic ||
                    l_Diff == Difficulty::DifficultyRaidHeroic ||
                    l_Diff == Difficulty::DifficultyRaidNormal ||
                    l_Diff == Difficulty::DifficultyRaidMythic ||
                    l_Diff == Difficulty::DifficultyRaidLFR)
                    GetMap()->SaveLootedGameObject(l_GameObject->GetDBTableGUIDLow());

                if (l_GameObject->AI())
                    l_GameObject->AI()->HandleCustomLoot(this);
            }

            if (p_LootType == LOOT_FISHING)
            {
                l_Loot = &l_GameObject->m_LootContainers[l_PlayerGuid];
                l_GameObject->getFishLoot(l_Loot, this);
            }
            else
            {
                uint64 l_LootContainerGuid = GetLootContainerGuidForGameObject(l_GameObject);
                if (!l_LootContainerGuid)
                    return;

                l_Loot = &l_GameObject->m_LootContainers[l_LootContainerGuid];
            }

            switch (l_GameObject->GetGOInfo()->type)
            {
                case GAMEOBJECT_TYPE_CHEST:
                {
                    if (l_GameObject->GetGOInfo()->chest.usegrouplootrules)
                    {
                        if (GroupPtr l_Group = GetGroup())
                        {
                            switch (l_Group->GetLootMethod())
                            {
                                case GROUP_LOOT:
                                    /// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                                    l_Group->GroupLoot(l_Loot, l_GameObject);
                                    break;
                                case MASTER_LOOT:
                                    l_Group->MasterLoot(l_Loot, l_GameObject);
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    break;
                }
                case GAMEOBJECT_TYPE_GATHERING_NODE:
                {
                    uint32 l_Spell = l_GameObject->GetGOInfo()->gatheringNode.spell;

                    if (l_Spell && l_IsLootGenerated)
                        CastSpell(this, l_Spell, false);
                    break;
                }
            }

            l_GameObject->SetLootState(GO_ACTIVATED, this);
        }

        if (l_Loot == nullptr)
        {
            uint64 l_LootContainerGuid = GetLootContainerGuidForGameObject(l_GameObject);
            if (!l_LootContainerGuid)
            {
                SendLootRelease(p_Guid);
                SendGameError(GameError::Type::ERR_OBJECT_IS_BUSY);
                return;
            }

            l_Loot = &l_GameObject->m_LootContainers[l_LootContainerGuid];
        }

        if (l_GameObject->GetGoType() == GAMEOBJECT_TYPE_CHEST && GetZoneId() == 7543)	///< Broken shore chests, prevent farm of them with phasing switching
        {
            time_t l_ExpireLockoutTime = time(nullptr) + 6 * HOUR;
            m_ChestTimedLockout[l_GameObject->GetDBTableGUIDLow()] = l_ExpireLockoutTime;

            PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHEST_TIMED_LOCKOUT);
            l_Stmt->setUInt32(0, GetGUIDLow());
            l_Stmt->setUInt32(1, l_GameObject->GetDBTableGUIDLow());
            l_Stmt->setUInt32(2, l_ExpireLockoutTime);
            CharacterDatabase.Execute(l_Stmt);
        }

        if (l_GameObject->getLootState() == GO_ACTIVATED)
        {
            if (GroupPtr l_Group = GetGroup())
            {
                switch (l_Group->GetLootMethod())
                {
                    case MASTER_LOOT:
                        l_Permission = MASTER_PERMISSION;
                        break;
                    case FREE_FOR_ALL:
                        l_Permission = ALL_PERMISSION;
                        break;
                    default:
                        l_Permission = GROUP_PERMISSION;
                        break;
                }
            }
            else
                l_Permission = ALL_PERMISSION;
        }
    }
    else if (IS_ITEM_GUID(p_Guid))
    {
        Item* l_Item = GetItemByGuid(p_Guid);
        if (!l_Item)
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Permission = OWNER_PERMISSION;

        l_Loot = &l_Item->loot;

        if (!l_Item->m_lootGenerated)
        {
            l_Item->m_lootGenerated = true;
            l_Loot->clear();

            switch (p_LootType)
            {
                case LOOT_DISENCHANTING:
                {
                    if (l_Item->GetTemplate()->Flags2 & (uint32)ItemFlagsEX::DISENCHANT_TO_LOOT_TABLE)
                        l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Item, this, true, l_Loot->Gold != 0);
                    else
                        l_Loot->FillLoot(l_Item->GetDisenchantLoot(this)->Id, LootTemplates_Disenchant, this, true);
                    break;
                }
                case LOOT_PROSPECTING:
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Prospecting, this, true);
                    break;
                case LOOT_MILLING:
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Milling, this, true);
                    break;
                default:
                    l_Loot->generateMoneyLoot(l_Item->GetTemplate()->MinMoneyLoot, l_Item->GetTemplate()->MaxMoneyLoot);
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Item, this, true, l_Loot->Gold != 0);
                    break;
            }

            /// Handle Chaos Crystal
            /// It's have to be handle in a dynamic way because our disenchant loot system is based on item id, not quality/ilvl
            /// We should rewrite the disenchant system but we need a quick fix ...
            if (p_LootType == LOOT_DISENCHANTING)
            {
                if (l_Item->GetBonus()->Quality == ItemQualities::ITEM_QUALITY_EPIC)
                {
                    for (auto& l_ItemLoot : l_Loot->Items)
                    {
                        if (l_ItemLoot.itemid == 124441 || l_ItemLoot.itemid == 124440) ///< Arkhana || Leylight Shard
                            l_ItemLoot.itemid = 124442;     ///< Chaos Crystal

                        l_ItemLoot.count = 1;
                    }
                }
                /*else if (l_Item->GetBonus()->Quality == ItemQualities::ITEM_QUALITY_RARE)
                {
                    for (auto& l_ItemLoot : l_Loot->Items)
                    {
                        if (l_ItemLoot.itemid == 124440)    ///< Leylight Shard
                            l_ItemLoot.itemid = 124442;     ///< Chaos Crystal

                        l_ItemLoot.count = 1;
                    }
                }*/
            }
        }
    }
    /// Remove insignia
    else if (IS_CORPSE_GUID(p_Guid))
    {
        Corpse* l_Corpse = ObjectAccessor::GetCorpse(*this, p_Guid);
        if (!l_Corpse || !(p_LootType == LOOT_CORPSE || p_LootType == LOOT_INSIGNIA) || l_Corpse->GetType() != CORPSE_BONES)
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Loot = &l_Corpse->loot;

        if (!l_Corpse->lootForBody)
        {
            l_Corpse->lootForBody = true;

            uint32 l_Gold = l_Corpse->loot.Gold;
            l_Corpse->loot.clear();

            if (Battleground* l_Battleground = GetBattleground())
            {
                if (l_Battleground->GetTypeID(true) == BATTLEGROUND_AV)
                    l_Loot->FillLoot(1, LootTemplates_Creature, this, true);
            }
            else if (OutdoorPvP* l_OutdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId()))
            {
                if (l_OutdoorPvP->GetTypeId() == OutdoorPvPTypes::OUTDOOR_PVP_ASHRAN)
                    l_OutdoorPvP->FillCustomPvPLoots(this, *l_Loot, l_Corpse->GetOwnerGUID());
            }

            if (sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE) && !GetBattleground())
            {
                LootStoreItem l_StoreItem = LootStoreItem
                (
                    137642,                                           ///< item id (mark of honor)
                    LootItemType::LOOT_ITEM_TYPE_ITEM,                ///< LootType
                    30.0f,                                            ///< Chance or quest chance
                    LootModes::LOOT_MODE_DEFAULT,                     ///< LootMode
                    LootModes::LOOT_MODE_DEFAULT,                     ///< Group
                    1,                                                ///< MinCount (or Ref)
                    1,                                                ///< MaxCount
                    std::vector<uint32>(),                            ///< ItemBonuses
                    0,                                                ///< Difficulty Mask
                    0,                                                ///< RequiredAura
                    0                                                 ///< RequiredClass
                );

                l_Loot->Items.push_back(LootItem(l_StoreItem, ItemContext::None, l_Loot, this));
                l_Loot->UnlootedCount++;
            }

            /// It may need a better formula
            /// Now it works like this: lvl10: ~6copper, lvl70: ~9silver
            l_Corpse->loot.Gold = uint32(urand(50, 150) * 0.016f * pow(float(l_Gold) / 5.76f, 2.5f) * sWorld->getRate(RATE_DROP_MONEY));
        }

        if (l_Corpse->lootRecipient != this)
            l_Permission = NONE_PERMISSION;
        else
            l_Permission = OWNER_PERMISSION;
    }
    else
    {
        Creature* l_Creature = GetMap()->GetCreature(p_Guid);

        /// Must be in range and creature must be alive for pickpocket and must be dead for another loot
        if (!l_Creature || l_Creature->isAlive() != (p_LootType == LOOT_PICKPOCKETING) || (!l_Creature->IsWithinDistInMap(this, INTERACTION_DISTANCE) && !p_FetchLoot))
        {
            SendLootRelease(p_Guid);
            return;
        }

        if (p_LootType == LOOT_PICKPOCKETING && IsFriendlyTo(l_Creature))
        {
            SendLootRelease(p_Guid);
            return;
        }

        uint64 l_LootContainerGuid = GetGUID();
        GroupPtr l_Group = GetGroup();
        if (l_Group && l_Group->GetLootMethod() != LootMethod::PERSONAL_LOOT)
            l_LootContainerGuid = l_Group->GetGUID();

        l_Loot = &l_Creature->m_LootContainers[l_LootContainerGuid];
        l_Loot->LinkedLoot.clear();

        if (p_LootType == LOOT_PICKPOCKETING)
        {
            if (!l_Creature->lootForPickPocketed)
            {
                l_Creature->lootForPickPocketed = true;
                l_Loot->clear();

                if (uint32 l_LootID = l_Creature->GetCreatureTemplate()->pickpocketLootId)
                    l_Loot->FillLoot(l_LootID, LootTemplates_Pickpocketing, this, true);

                /// Generate extra money for pick pocket loot
                uint32 const l_A = urand(0, l_Creature->getLevelForTarget(this) / 2);
                uint32 const l_B = urand(0, getLevelForTarget(l_Creature) / 2);
                l_Loot->Gold = uint32(10 * (l_A + l_B) * sWorld->getRate(RATE_DROP_MONEY));
                l_Permission = OWNER_PERMISSION;
            }
        }
        else
        {
            /// Check all creature around, to see if we can loot it too
            std::list<Creature*> l_LinkedCreatures;
            l_LinkedCreatures.push_back(l_Creature);

            if (p_LootType == LOOT_CORPSE)
            {
                CellCoord l_CellCoord(JadeCore::ComputeCellCoord(GetPositionX(), GetPositionY()));
                Cell l_Cell(l_CellCoord);
                l_Cell.SetNoCreate();

                JadeCore::AllDeadCreaturesInRange l_Check(this, 50.0f, l_Creature->GetGUID());
                JadeCore::CreatureListSearcher<JadeCore::AllDeadCreaturesInRange> l_Searcher(this, l_LinkedCreatures, l_Check);
                TypeContainerVisitor<JadeCore::CreatureListSearcher<JadeCore::AllDeadCreaturesInRange>, GridTypeMapContainer> l_CellSearcher(l_Searcher);
                TypeContainerVisitor<JadeCore::CreatureListSearcher<JadeCore::AllDeadCreaturesInRange>, WorldTypeMapContainer> l_WorldSearcher(l_Searcher);

                l_Cell.Visit(l_CellCoord, l_CellSearcher, *(GetMap()),  *this, 50.0f);
                l_Cell.Visit(l_CellCoord, l_WorldSearcher, *(GetMap()), *this, 50.0f);
            }

            uint32 l_MaxSlots = l_Loot->Items.size() + l_Loot->QuestItems.size();
            l_Loot->AdditionalLinkedGold = 0;
            for (Creature* l_LinkedCreature : l_LinkedCreatures)
            {
                Loot* l_LinkedLoot = &l_LinkedCreature->m_LootContainers[l_LootContainerGuid];
                if (!l_LinkedCreature->lootForBody)
                {
                    l_LinkedCreature->lootForBody = true;

                    /// For creature, loot is filled when creature is killed.
                    if (GroupPtr l_Group = GetGroup())
                    {
                        switch (l_Group->GetLootMethod())
                        {
                            case GROUP_LOOT:
                                /// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                                l_Group->GroupLoot(l_LinkedLoot, l_LinkedCreature);
                                break;
                            case MASTER_LOOT:
                                l_Group->MasterLoot(l_LinkedLoot, l_LinkedCreature);
                                break;
                            default:
                                break;
                        }
                    }
                }

                PermissionTypes l_Perm = NONE_PERMISSION;

                /// TODO: handle this case with new radius loot system
                /// Possible only if creature->lootForBody && loot->empty() at spell cast check
                if (p_LootType == LOOT_SKINNING)
                {
                    l_LinkedLoot->clear();
                    l_LinkedLoot->FillLoot(l_LinkedCreature->GetCreatureTemplate()->SkinLootId, LootTemplates_Skinning, this, true);
                    l_Perm = OWNER_PERMISSION;
                }
                /// Set group rights only for loot_type != LOOT_SKINNING
                else
                {
                    if (GroupPtr l_Group = GetGroup())
                    {
                        switch (l_Group->GetLootMethod())
                        {
                            case MASTER_LOOT:
                                l_Perm = MASTER_PERMISSION;
                                break;
                            case FREE_FOR_ALL:
                                l_Perm = ALL_PERMISSION;
                                break;
                            case PERSONAL_LOOT:
                                l_Perm = OWNER_PERMISSION;
                                break;
                            default:
                                l_Perm = GROUP_PERMISSION;
                                break;
                        }
                    }
                    else
                        l_Perm = OWNER_PERMISSION;
                }

                if (l_LinkedCreature == l_Creature)
                    l_Permission = l_Perm;
                else
                {
                    if (l_Perm != NONE_PERMISSION)
                    {
                        l_LinkedLoot->AddLooter(l_PlayerGuid);
                        l_Loot->AdditionalLinkedGold += l_LinkedLoot->Gold;
                    }

                    uint32 l_ItemSlot = 0;
                    for (uint32 l_I = 0; l_I < l_LinkedLoot->Items.size(); l_I++)
                        l_Loot->addLinkedLoot(l_MaxSlots++, l_LinkedCreature->GetGUID(), l_I, l_Perm, false, l_ItemSlot++);

                    for (uint32 l_I = 0; l_I < l_LinkedLoot->QuestItems.size(); l_I++)
                        l_Loot->addLinkedLoot(l_MaxSlots++, l_LinkedCreature->GetGUID(), l_I, l_Perm, true, l_ItemSlot++);
                }
            }
        }
    }

    SetLootGUID(p_Guid);

    /// LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
    switch (p_LootType)
    {
        case LOOT_INSIGNIA:
            p_LootType = LOOT_SKINNING;
            break;
        case LOOT_FISHINGHOLE:
            p_LootType = LOOT_FISHING;
            break;
        default:
            break;
    }

    /// In WoD, more you have fishing skill more the fish is bigger
    if (p_LootType == LOOT_FISHING || p_LootType == LOOT_FISHINGHOLE)
    {
        uint32 l_SmallFishChance    = 100;
        uint32 l_MediumFishChance   = 0;
        uint32 l_BigFishChance      = 0;

        uint32 l_FishingSKill = GetSkillValue(SKILL_FISHING);

        /// http://www.wowhead.com/achievement=9462/draenor-angler#comments
        if (l_FishingSKill >= 100 && l_FishingSKill < 525)
        {
            l_SmallFishChance  = 80;
            l_MediumFishChance = 20;
        }
        else if (l_FishingSKill >= 525 && l_FishingSKill < 700)
        {
            l_SmallFishChance   = 10;
            l_MediumFishChance  = 50;
            l_BigFishChance     = 10;
        }
        else if (l_FishingSKill >= 650 && l_FishingSKill < 700)
        {
            l_SmallFishChance   = 0;
            l_MediumFishChance  = 50;
            l_BigFishChance     = 50;
        }
        else if (l_FishingSKill >= 700)
        {
            l_SmallFishChance   = 0;
            l_BigFishChance     = std::min((int32)100, (int32)(50 + ((50 / (950 - 700)) * (l_FishingSKill - 700))));
            l_MediumFishChance  = std::max((int32)0, (int32)(100 - l_BigFishChance));
        }

        enum class FishType
        {
            None,
            Small,
            Medium,
            Big
        };

        /// Fish with various size :
        /// -------------------------------------------
        /// - Crescent Saberfish
        /// - Blackwater Whiptail
        /// - Abyssal Gulper Eel
        /// - Sea Scorpion
        /// - Fire Ammonite
        /// - Blind Lake Sturgeon
        /// - Fat Sleeper
        /// - Jawless Skulker
        /// - Savage Piranha
        std::vector<uint32> l_SmallFish  { 111589, 111650, 111651, 111652, 111656, 111658, 111659, 111662, 118564 };
        std::vector<uint32> l_MediumFish { 111595, 111663, 111664, 111665, 111666, 111667, 111668, 111669, 118565 };
        std::vector<uint32> l_BigFish    { 111601, 111670, 111671, 111672, 111673, 111674, 111675, 111676, 118566 };

        auto GetFishType = [l_SmallFish, l_MediumFish, l_BigFish](uint32 p_ItemID) -> FishType
        {
            if (std::find(l_SmallFish.begin(), l_SmallFish.end(), p_ItemID) != l_SmallFish.end())
                return FishType::Small;
            if (std::find(l_MediumFish.begin(), l_MediumFish.end(), p_ItemID) != l_MediumFish.end())
                return FishType::Medium;
            if (std::find(l_BigFish.begin(), l_BigFish.end(), p_ItemID) != l_BigFish.end())
                return FishType::Big;

            return FishType::None;
        };

        std::vector<LootItem*> l_Fishs;

        for (uint32 l_I = 0; l_I < l_Loot->Items.size(); ++l_I)
        {
            LootItem* l_LootItem = &l_Loot->Items[l_I];
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_LootItem->itemid);

            if (!l_ItemTemplate)
                return;

            if (l_ItemTemplate->SubClass != ITEM_SUBCLASS_MEAT)
                continue;

            if (GetFishType(l_LootItem->itemid) == FishType::None)
                continue;

#ifdef _MSC_VER
            char* l_Size[] = { "None", "Small", "Medium", "Big" };
            ChatHandler(this).PSendSysMessage("Loot find fish %s(%u) size %s", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDb2Locale()), l_LootItem->itemid, l_Size[(int)GetFishType(l_LootItem->itemid)]);
            ChatHandler(this).PSendSysMessage("Loot removed fish %s(%u)", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDb2Locale()), l_LootItem->itemid);
#endif
            l_Fishs.push_back(l_LootItem);
            l_LootItem->needs_quest = true;
        }

        if (l_Fishs.size())
        {
            for (LootItem* l_LootItem : l_Fishs)
            {
                bool l_RoolResult = false;
                switch (GetFishType(l_LootItem->itemid))
                {
                    case FishType::Small:
                        l_RoolResult = roll_chance_i(l_SmallFishChance);
                        break;
                    case FishType::Medium:
                        l_RoolResult = roll_chance_i(l_MediumFishChance);
                        break;
                    case FishType::Big:
                        l_RoolResult = roll_chance_i(l_BigFishChance);
                        break;
                    default:
                        break;
                }

                if (l_RoolResult)
                {
#ifdef _MSC_VER
                    ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_LootItem->itemid);
                    ChatHandler(this).PSendSysMessage("Loot added fish %s(%u)", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDb2Locale()), l_LootItem->itemid);
#endif
                    l_LootItem->needs_quest = false;
                }
            }
        }
    }

    ///< Waste Not, Want Not
    if (HasAura(255656))
    {
        for (uint32 l_I = 0; l_I < l_Loot->Items.size(); ++l_I)
        {
            LootItem* l_LootItem = &l_Loot->Items[l_I];
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_LootItem->itemid);

            if (!l_ItemTemplate)
                continue;

            if (l_ItemTemplate->Class != ITEM_CLASS_TRADE_GOODS)
                continue;

            if (l_ItemTemplate->SubClass != ITEM_SUBCLASS_MEAT)
                continue;

            float l_LootChance = frand(15.0f, 20.0f); ///< TODO: Getted chance from http://www.wowhead.com/spell=255656/waste-not-want-not#comments . May be it's not correct

            if (roll_chance_f(l_LootChance))
                l_LootItem->count *= 2; ///< TODO: Player gets double loot. May be it's not correct, need more info
        }
    }

    /// Need know merged fishing/corpse loot type for achievements
    l_Loot->Type = p_LootType;

    WorldPacket l_Data(SMSG_LOOT_RESPONSE, 4 * 1024);
    l_Data << LootView(*l_Loot, this, p_LootType, p_Guid, l_Permission);
    SendDirectMessage(&l_Data);

    /// Add 'this' player as one of the players that are looting 'loot'
    if (l_Permission != NONE_PERMISSION)
        l_Loot->AddLooter(l_PlayerGuid);

    if (p_LootType == LOOT_CORPSE && !IS_ITEM_GUID(p_Guid))
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
}

void Player::SendNotifyLootMoneyRemoved()
{
    ObjectGuid l_Guid = MAKE_NEW_GUID(GUID_LOPART(GetLootGUID()), 0, HIGHGUID_LOOT);

    sObjectMgr->setLootViewGUID(l_Guid, GetLootGUID());

    WorldPacket l_Data(SMSG_COIN_REMOVED);
    l_Data.appendPackGUID(l_Guid);
    GetSession()->SendPacket(&l_Data);
}

void Player::SendNotifyLootItemRemoved(uint8 p_LootSlot)
{
    ObjectGuid l_Guid       = GetLootGUID();
    ObjectGuid l_LootGuid   = MAKE_NEW_GUID(GUID_LOPART(l_Guid), 0, HIGHGUID_LOOT);

    WorldPacket l_Data(SMSG_LOOT_REMOVED);

    l_Data.appendPackGUID(l_Guid);
    l_Data.appendPackGUID(l_LootGuid);
    l_Data << uint8(p_LootSlot);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
{
    WorldPacket data(SMSG_UPDATE_WORLD_STATE, 4 + 4 + 1);
    data << Field;
    data << Value;
    data.WriteBit(0); ///< Hidden
    data.FlushBits();
    GetSession()->SendPacket(&data);

    SetWorldState(Field, Value);
}

void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
{
    // data depends on zoneid/mapid...
    Battleground* bg = GetBattleground();
    uint32 mapid = GetMapId();
    OutdoorPvP* pvp = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(zoneid);
    InstanceScript* instance = GetInstanceScript();

    sLog->outDebug(LOG_FILTER_NETWORKIO, "Sending SMSG_INIT_WORLD_STATES to Map: %u, Zone: %u", mapid, zoneid);

    ByteBuffer l_Buffer(10 * 1024);
    l_Buffer << uint32(12605) << uint32(0x1);
    l_Buffer << uint32(0x8d8) << uint32(0x0);                   // 1
    l_Buffer << uint32(0x8d7) << uint32(0x0);                   // 2
    l_Buffer << uint32(0x8d6) << uint32(0x0);                   // 3
    l_Buffer << uint32(0x8d5) << uint32(0x0);                   // 4
    l_Buffer << uint32(0x8d4) << uint32(0x0);                   // 5
    l_Buffer << uint32(0x8d3) << uint32(0x0);                   // 6

    if (mapid == 530)                                       // Outland
    {
        l_Buffer << uint32(0x9bf) << uint32(0x0);               // 7
        l_Buffer << uint32(0x9bd) << uint32(0xF);               // 8
        l_Buffer << uint32(0x9bb) << uint32(0xF);               // 9
    }

    if (mapid == 1669)                                      ///< Argus
    {
        enum eQuests
        {
            TheBurningHeart         = 48199,
            LordOfTheSpire          = 47993,
            TheSigilOfAwakening     = 48107,
            ShadowOfTheTriumvirate  = 47416,
            SeatOfTheTriumvirateTheCrestOfKnowledge = 47654
        };

        /// Set Correct WQ Visibles
        if (GetQuestRewardStatus(eQuests::SeatOfTheTriumvirateTheCrestOfKnowledge))
            l_Buffer << uint32(14023) << uint32(5);
        else if (GetQuestRewardStatus(eQuests::ShadowOfTheTriumvirate))
            l_Buffer << uint32(14023) << uint32(4);
        else if (GetQuestRewardStatus(eQuests::TheSigilOfAwakening))
            l_Buffer << uint32(14023) << uint32(3);
        else if (GetQuestRewardStatus(eQuests::LordOfTheSpire))
            l_Buffer << uint32(14023) << uint32(2);
        else if (GetQuestRewardStatus(eQuests::TheBurningHeart))
            l_Buffer << uint32(14023) << uint32(1);
    }

    // insert <field> <value>
    switch (zoneid)
    {
        case 1:                                             // Dun Morogh
        case 11:                                            // Wetlands
        case 12:                                            // Elwynn Forest
        case 38:                                            // Loch Modan
        case 40:                                            // Westfall
        case 51:                                            // Searing Gorge
        case 1519:                                          // Stormwind City
        case 1537:                                          // Ironforge
        case 2257:                                          // Deeprun Tram
        case 3703:                                          // Shattrath City
            break;
        case 1377:                                          // Silithus
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                // states are always shown
                l_Buffer << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
                l_Buffer << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
                l_Buffer << uint32(2317) << uint32(0x0); // 9 max silithyst
            }
            // dunno about these... aq opening event maybe?
            l_Buffer << uint32(2322) << uint32(0x0); // 10 sandworm N
            l_Buffer << uint32(2323) << uint32(0x0); // 11 sandworm S
            l_Buffer << uint32(2324) << uint32(0x0); // 12 sandworm SW
            l_Buffer << uint32(2325) << uint32(0x0); // 13 sandworm E
            break;
        case 2597:                                          // Alterac Valley
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x7ae) << uint32(0x1);           // 7 snowfall n
                l_Buffer << uint32(0x532) << uint32(0x1);           // 8 frostwolfhut hc
                l_Buffer << uint32(0x531) << uint32(0x0);           // 9 frostwolfhut ac
                l_Buffer << uint32(0x52e) << uint32(0x0);           // 10 stormpike firstaid a_a
                l_Buffer << uint32(0x571) << uint32(0x0);           // 11 east frostwolf tower horde assaulted -unused
                l_Buffer << uint32(0x570) << uint32(0x0);           // 12 west frostwolf tower horde assaulted - unused
                l_Buffer << uint32(0x567) << uint32(0x1);           // 13 frostwolfe c
                l_Buffer << uint32(0x566) << uint32(0x1);           // 14 frostwolfw c
                l_Buffer << uint32(0x550) << uint32(0x1);           // 15 irondeep (N) ally
                l_Buffer << uint32(0x544) << uint32(0x0);           // 16 ice grave a_a
                l_Buffer << uint32(0x536) << uint32(0x0);           // 17 stormpike grave h_c
                l_Buffer << uint32(0x535) << uint32(0x1);           // 18 stormpike grave a_c
                l_Buffer << uint32(0x518) << uint32(0x0);           // 19 stoneheart grave a_a
                l_Buffer << uint32(0x517) << uint32(0x0);           // 20 stoneheart grave h_a
                l_Buffer << uint32(0x574) << uint32(0x0);           // 21 1396 unk
                l_Buffer << uint32(0x573) << uint32(0x0);           // 22 iceblood tower horde assaulted -unused
                l_Buffer << uint32(0x572) << uint32(0x0);           // 23 towerpoint horde assaulted - unused
                l_Buffer << uint32(0x56f) << uint32(0x0);           // 24 1391 unk
                l_Buffer << uint32(0x56e) << uint32(0x0);           // 25 iceblood a
                l_Buffer << uint32(0x56d) << uint32(0x0);           // 26 towerp a
                l_Buffer << uint32(0x56c) << uint32(0x0);           // 27 frostwolfe a
                l_Buffer << uint32(0x56b) << uint32(0x0);           // 28 froswolfw a
                l_Buffer << uint32(0x56a) << uint32(0x1);           // 29 1386 unk
                l_Buffer << uint32(0x569) << uint32(0x1);           // 30 iceblood c
                l_Buffer << uint32(0x568) << uint32(0x1);           // 31 towerp c
                l_Buffer << uint32(0x565) << uint32(0x0);           // 32 stoneh tower a
                l_Buffer << uint32(0x564) << uint32(0x0);           // 33 icewing tower a
                l_Buffer << uint32(0x563) << uint32(0x0);           // 34 dunn a
                l_Buffer << uint32(0x562) << uint32(0x0);           // 35 duns a
                l_Buffer << uint32(0x561) << uint32(0x0);           // 36 stoneheart bunker alliance assaulted - unused
                l_Buffer << uint32(0x560) << uint32(0x0);           // 37 icewing bunker alliance assaulted - unused
                l_Buffer << uint32(0x55f) << uint32(0x0);           // 38 dunbaldar south alliance assaulted - unused
                l_Buffer << uint32(0x55e) << uint32(0x0);           // 39 dunbaldar north alliance assaulted - unused
                l_Buffer << uint32(0x55d) << uint32(0x0);           // 40 stone tower d
                l_Buffer << uint32(0x3c6) << uint32(0x0);           // 41 966 unk
                l_Buffer << uint32(0x3c4) << uint32(0x0);           // 42 964 unk
                l_Buffer << uint32(0x3c2) << uint32(0x0);           // 43 962 unk
                l_Buffer << uint32(0x516) << uint32(0x1);           // 44 stoneheart grave a_c
                l_Buffer << uint32(0x515) << uint32(0x0);           // 45 stonheart grave h_c
                l_Buffer << uint32(0x3b6) << uint32(0x0);           // 46 950 unk
                l_Buffer << uint32(0x55c) << uint32(0x0);           // 47 icewing tower d
                l_Buffer << uint32(0x55b) << uint32(0x0);           // 48 dunn d
                l_Buffer << uint32(0x55a) << uint32(0x0);           // 49 duns d
                l_Buffer << uint32(0x559) << uint32(0x0);           // 50 1369 unk
                l_Buffer << uint32(0x558) << uint32(0x0);           // 51 iceblood d
                l_Buffer << uint32(0x557) << uint32(0x0);           // 52 towerp d
                l_Buffer << uint32(0x556) << uint32(0x0);           // 53 frostwolfe d
                l_Buffer << uint32(0x555) << uint32(0x0);           // 54 frostwolfw d
                l_Buffer << uint32(0x554) << uint32(0x1);           // 55 stoneh tower c
                l_Buffer << uint32(0x553) << uint32(0x1);           // 56 icewing tower c
                l_Buffer << uint32(0x552) << uint32(0x1);           // 57 dunn c
                l_Buffer << uint32(0x551) << uint32(0x1);           // 58 duns c
                l_Buffer << uint32(0x54f) << uint32(0x0);           // 59 irondeep (N) horde
                l_Buffer << uint32(0x54e) << uint32(0x0);           // 60 irondeep (N) ally
                l_Buffer << uint32(0x54d) << uint32(0x1);           // 61 mine (S) neutral
                l_Buffer << uint32(0x54c) << uint32(0x0);           // 62 mine (S) horde
                l_Buffer << uint32(0x54b) << uint32(0x0);           // 63 mine (S) ally
                l_Buffer << uint32(0x545) << uint32(0x0);           // 64 iceblood h_a
                l_Buffer << uint32(0x543) << uint32(0x1);           // 65 iceblod h_c
                l_Buffer << uint32(0x542) << uint32(0x0);           // 66 iceblood a_c
                l_Buffer << uint32(0x540) << uint32(0x0);           // 67 snowfall h_a
                l_Buffer << uint32(0x53f) << uint32(0x0);           // 68 snowfall a_a
                l_Buffer << uint32(0x53e) << uint32(0x0);           // 69 snowfall h_c
                l_Buffer << uint32(0x53d) << uint32(0x0);           // 70 snowfall a_c
                l_Buffer << uint32(0x53c) << uint32(0x0);           // 71 frostwolf g h_a
                l_Buffer << uint32(0x53b) << uint32(0x0);           // 72 frostwolf g a_a
                l_Buffer << uint32(0x53a) << uint32(0x1);           // 73 frostwolf g h_c
                l_Buffer << uint32(0x539) << uint32(0x0);           // 74 frostwolf g a_c
                l_Buffer << uint32(0x538) << uint32(0x0);           // 75 stormpike grave h_a
                l_Buffer << uint32(0x537) << uint32(0x0);           // 76 stormpike grave a_a
                l_Buffer << uint32(0x534) << uint32(0x0);           // 77 frostwolf hut h_a
                l_Buffer << uint32(0x533) << uint32(0x0);           // 78 frostwolf hut a_a
                l_Buffer << uint32(0x530) << uint32(0x0);           // 79 stormpike first aid h_a
                l_Buffer << uint32(0x52f) << uint32(0x0);           // 80 stormpike first aid h_c
                l_Buffer << uint32(0x52d) << uint32(0x1);           // 81 stormpike first aid a_c
            }
            break;
        case 3277:                                          // Warsong Gulch
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x62d) << uint32(0x0);       // 7 1581 alliance flag captures
                l_Buffer << uint32(0x62e) << uint32(0x0);       // 8 1582 horde flag captures
                l_Buffer << uint32(0x609) << uint32(0x0);       // 9 1545 unk, set to 1 on alliance flag pickup...
                l_Buffer << uint32(0x60a) << uint32(0x0);       // 10 1546 unk, set to 1 on horde flag pickup, after drop it's -1
                l_Buffer << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
                l_Buffer << uint32(0x641) << uint32(0x3);       // 12 1601 unk (max flag captures?)
                l_Buffer << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                l_Buffer << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        case 3358:                                          // Arathi Basin
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AB)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x6e7) << uint32(0x0);       // 7 1767 stables alliance
                l_Buffer << uint32(0x6e8) << uint32(0x0);       // 8 1768 stables horde
                l_Buffer << uint32(0x6e9) << uint32(0x0);       // 9 1769 unk, ST?
                l_Buffer << uint32(0x6ea) << uint32(0x0);       // 10 1770 stables (show/hide)
                l_Buffer << uint32(0x6ec) << uint32(0x0);       // 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
                l_Buffer << uint32(0x6ed) << uint32(0x0);       // 12 1773 farm (show/hide)
                l_Buffer << uint32(0x6ee) << uint32(0x0);       // 13 1774 farm color
                l_Buffer << uint32(0x6ef) << uint32(0x0);       // 14 1775 gold mine color, may be FM?
                l_Buffer << uint32(0x6f0) << uint32(0x0);       // 15 1776 alliance resources
                l_Buffer << uint32(0x6f1) << uint32(0x0);       // 16 1777 horde resources
                l_Buffer << uint32(0x6f2) << uint32(0x0);       // 17 1778 horde bases
                l_Buffer << uint32(0x6f3) << uint32(0x0);       // 18 1779 alliance bases
                l_Buffer << uint32(0x6f4) << uint32(0x7d0);     // 19 1780 max resources (2000)
                l_Buffer << uint32(0x6f6) << uint32(0x0);       // 20 1782 blacksmith color
                l_Buffer << uint32(0x6f7) << uint32(0x0);       // 21 1783 blacksmith (show/hide)
                l_Buffer << uint32(0x6f8) << uint32(0x0);       // 22 1784 unk, bs?
                l_Buffer << uint32(0x6f9) << uint32(0x0);       // 23 1785 unk, bs?
                l_Buffer << uint32(0x6fb) << uint32(0x0);       // 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
                l_Buffer << uint32(0x6fc) << uint32(0x0);       // 25 1788 gold mine (0 - conflict, 1 - horde)
                l_Buffer << uint32(0x6fd) << uint32(0x0);       // 26 1789 gold mine (1 - show/0 - hide)
                l_Buffer << uint32(0x6fe) << uint32(0x0);       // 27 1790 gold mine color
                l_Buffer << uint32(0x700) << uint32(0x0);       // 28 1792 gold mine color, wtf?, may be LM?
                l_Buffer << uint32(0x701) << uint32(0x0);       // 29 1793 lumber mill color (0 - conflict, 1 - horde contr)
                l_Buffer << uint32(0x702) << uint32(0x0);       // 30 1794 lumber mill (show/hide)
                l_Buffer << uint32(0x703) << uint32(0x0);       // 31 1795 lumber mill color color
                l_Buffer << uint32(0x732) << uint32(0x1);       // 32 1842 stables (1 - uncontrolled)
                l_Buffer << uint32(0x733) << uint32(0x1);       // 33 1843 gold mine (1 - uncontrolled)
                l_Buffer << uint32(0x734) << uint32(0x1);       // 34 1844 lumber mill (1 - uncontrolled)
                l_Buffer << uint32(0x735) << uint32(0x1);       // 35 1845 farm (1 - uncontrolled)
                l_Buffer << uint32(0x736) << uint32(0x1);       // 36 1846 blacksmith (1 - uncontrolled)
                l_Buffer << uint32(0x745) << uint32(0x2);       // 37 1861 unk
                l_Buffer << uint32(0x7a3) << uint32(0x708);     // 38 1955 warning limit (1800)
            }
            break;
        case 3820:                                          // Eye of the Storm
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xac1) << uint32(0x0);       // 7  2753 Horde Bases
                l_Buffer << uint32(0xac0) << uint32(0x0);       // 8  2752 Alliance Bases
                l_Buffer << uint32(0xab6) << uint32(0x0);       // 9  2742 Mage Tower - Horde conflict
                l_Buffer << uint32(0xab5) << uint32(0x0);       // 10 2741 Mage Tower - Alliance conflict
                l_Buffer << uint32(0xab4) << uint32(0x0);       // 11 2740 Fel Reaver - Horde conflict
                l_Buffer << uint32(0xab3) << uint32(0x0);       // 12 2739 Fel Reaver - Alliance conflict
                l_Buffer << uint32(0xab2) << uint32(0x0);       // 13 2738 Draenei - Alliance conflict
                l_Buffer << uint32(0xab1) << uint32(0x0);       // 14 2737 Draenei - Horde conflict
                l_Buffer << uint32(0xab0) << uint32(0x0);       // 15 2736 unk // 0 at start
                l_Buffer << uint32(0xaaf) << uint32(0x0);       // 16 2735 unk // 0 at start
                l_Buffer << uint32(0xaad) << uint32(0x0);       // 17 2733 Draenei - Horde control
                l_Buffer << uint32(0xaac) << uint32(0x0);       // 18 2732 Draenei - Alliance control
                l_Buffer << uint32(0xaab) << uint32(0x1);       // 19 2731 Draenei uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaaa) << uint32(0x0);       // 20 2730 Mage Tower - Alliance control
                l_Buffer << uint32(0xaa9) << uint32(0x0);       // 21 2729 Mage Tower - Horde control
                l_Buffer << uint32(0xaa8) << uint32(0x1);       // 22 2728 Mage Tower uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaa7) << uint32(0x0);       // 23 2727 Fel Reaver - Horde control
                l_Buffer << uint32(0xaa6) << uint32(0x0);       // 24 2726 Fel Reaver - Alliance control
                l_Buffer << uint32(0xaa5) << uint32(0x1);       // 25 2725 Fel Reaver uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaa4) << uint32(0x0);       // 26 2724 Boold Elf - Horde control
                l_Buffer << uint32(0xaa3) << uint32(0x0);       // 27 2723 Boold Elf - Alliance control
                l_Buffer << uint32(0xaa2) << uint32(0x1);       // 28 2722 Boold Elf uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xac5) << uint32(0x1);       // 29 2757 Flag (1 - show, 0 - hide) - doesn't work exactly this way!
                l_Buffer << uint32(0xad2) << uint32(0x1);       // 30 2770 Horde top-stats (1 - show, 0 - hide) // 02 -> horde picked up the flag
                l_Buffer << uint32(0xad1) << uint32(0x1);       // 31 2769 Alliance top-stats (1 - show, 0 - hide) // 02 -> alliance picked up the flag
                l_Buffer << uint32(0xabe) << uint32(0x0);       // 32 2750 Horde resources
                l_Buffer << uint32(0xabd) << uint32(0x0);       // 33 2749 Alliance resources
                l_Buffer << uint32(0xa05) << uint32(0x8e);      // 34 2565 unk, constant?
                l_Buffer << uint32(0xaa0) << uint32(0x0);       // 35 2720 Capturing progress-bar (100 -> empty (only grey), 0 -> blue|red (no grey), default 0)
                l_Buffer << uint32(0xa9f) << uint32(0x0);       // 36 2719 Capturing progress-bar (0 - left, 100 - right)
                l_Buffer << uint32(0xa9e) << uint32(0x0);       // 37 2718 Capturing progress-bar (1 - show, 0 - hide)
                l_Buffer << uint32(0xc0d) << uint32(0x17b);     // 38 3085 unk
                // and some more ... unknown
            }
            break;
        // any of these needs change! the client remembers the prev setting!
        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
        case 3483:                                          // Hellfire Peninsula
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x9ba) << uint32(0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
                l_Buffer << uint32(0x9b9) << uint32(0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
                l_Buffer << uint32(0x9b5) << uint32(0x0);           // 12 // show neutral broken hill icon      // 2485
                l_Buffer << uint32(0x9b4) << uint32(0x1);           // 13 // show icon above broken hill        // 2484
                l_Buffer << uint32(0x9b3) << uint32(0x0);           // 14 // show ally broken hill icon         // 2483
                l_Buffer << uint32(0x9b2) << uint32(0x0);           // 15 // show neutral overlook icon         // 2482
                l_Buffer << uint32(0x9b1) << uint32(0x1);           // 16 // show the overlook arrow            // 2481
                l_Buffer << uint32(0x9b0) << uint32(0x0);           // 17 // show ally overlook icon            // 2480
                l_Buffer << uint32(0x9ae) << uint32(0x0);           // 18 // horde pvp objectives captured      // 2478
                l_Buffer << uint32(0x9ac) << uint32(0x0);           // 19 // ally pvp objectives captured       // 2476
                l_Buffer << uint32(2475)  << uint32(100); //: ally / horde slider grey area                              // show only in direct vicinity!
                l_Buffer << uint32(2474)  << uint32(50);  //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
                l_Buffer << uint32(2473)  << uint32(0);   //: ally / horde slider display                                // show only in direct vicinity!
                l_Buffer << uint32(0x9a8) << uint32(0x0);           // 20 // show the neutral stadium icon      // 2472
                l_Buffer << uint32(0x9a7) << uint32(0x0);           // 21 // show the ally stadium icon         // 2471
                l_Buffer << uint32(0x9a6) << uint32(0x1);           // 22 // show the horde stadium icon        // 2470
            }
            break;
        case 3518:                                          // Nagrand
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(2503) << uint32(0x0);    // 10
                l_Buffer << uint32(2502) << uint32(0x0);    // 11
                l_Buffer << uint32(2493) << uint32(0x0);    // 12
                l_Buffer << uint32(2491) << uint32(0x0);    // 13

                l_Buffer << uint32(2495) << uint32(0x0);    // 14
                l_Buffer << uint32(2494) << uint32(0x0);    // 15
                l_Buffer << uint32(2497) << uint32(0x0);    // 16

                l_Buffer << uint32(2762) << uint32(0x0);    // 17
                l_Buffer << uint32(2662) << uint32(0x0);    // 18
                l_Buffer << uint32(2663) << uint32(0x0);    // 19
                l_Buffer << uint32(2664) << uint32(0x0);    // 20

                l_Buffer << uint32(2760) << uint32(0x0);    // 21
                l_Buffer << uint32(2670) << uint32(0x0);    // 22
                l_Buffer << uint32(2668) << uint32(0x0);    // 23
                l_Buffer << uint32(2669) << uint32(0x0);    // 24

                l_Buffer << uint32(2761) << uint32(0x0);    // 25
                l_Buffer << uint32(2667) << uint32(0x0);    // 26
                l_Buffer << uint32(2665) << uint32(0x0);    // 27
                l_Buffer << uint32(2666) << uint32(0x0);    // 28

                l_Buffer << uint32(2763) << uint32(0x0);    // 29
                l_Buffer << uint32(2659) << uint32(0x0);    // 30
                l_Buffer << uint32(2660) << uint32(0x0);    // 31
                l_Buffer << uint32(2661) << uint32(0x0);    // 32

                l_Buffer << uint32(2671) << uint32(0x0);    // 33
                l_Buffer << uint32(2676) << uint32(0x0);    // 34
                l_Buffer << uint32(2677) << uint32(0x0);    // 35
                l_Buffer << uint32(2672) << uint32(0x0);    // 36
                l_Buffer << uint32(2673) << uint32(0x0);    // 37
            }
            break;
        case 3519:                                          // Terokkar Forest
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xa41) << uint32(0x0);           // 10 // 2625 capture bar pos
                l_Buffer << uint32(0xa40) << uint32(0x14);          // 11 // 2624 capture bar neutral
                l_Buffer << uint32(0xa3f) << uint32(0x0);           // 12 // 2623 show capture bar
                l_Buffer << uint32(0xa3e) << uint32(0x0);           // 13 // 2622 horde towers controlled
                l_Buffer << uint32(0xa3d) << uint32(0x5);           // 14 // 2621 ally towers controlled
                l_Buffer << uint32(0xa3c) << uint32(0x0);           // 15 // 2620 show towers controlled
                l_Buffer << uint32(0xa88) << uint32(0x0);           // 16 // 2696 SE Neu
                l_Buffer << uint32(0xa87) << uint32(0x0);           // 17 // SE Horde
                l_Buffer << uint32(0xa86) << uint32(0x0);           // 18 // SE Ally
                l_Buffer << uint32(0xa85) << uint32(0x0);           // 19 //S Neu
                l_Buffer << uint32(0xa84) << uint32(0x0);           // 20 S Horde
                l_Buffer << uint32(0xa83) << uint32(0x0);           // 21 S Ally
                l_Buffer << uint32(0xa82) << uint32(0x0);           // 22 NE Neu
                l_Buffer << uint32(0xa81) << uint32(0x0);           // 23 NE Horde
                l_Buffer << uint32(0xa80) << uint32(0x0);           // 24 NE Ally
                l_Buffer << uint32(0xa7e) << uint32(0x0);           // 25 // 2686 N Neu
                l_Buffer << uint32(0xa7d) << uint32(0x0);           // 26 N Horde
                l_Buffer << uint32(0xa7c) << uint32(0x0);           // 27 N Ally
                l_Buffer << uint32(0xa7b) << uint32(0x0);           // 28 NW Ally
                l_Buffer << uint32(0xa7a) << uint32(0x0);           // 29 NW Horde
                l_Buffer << uint32(0xa79) << uint32(0x0);           // 30 NW Neutral
                l_Buffer << uint32(0x9d0) << uint32(0x5);           // 31 // 2512 locked time remaining seconds first digit
                l_Buffer << uint32(0x9ce) << uint32(0x0);           // 32 // 2510 locked time remaining seconds second digit
                l_Buffer << uint32(0x9cd) << uint32(0x0);           // 33 // 2509 locked time remaining minutes
                l_Buffer << uint32(0x9cc) << uint32(0x0);           // 34 // 2508 neutral locked time show
                l_Buffer << uint32(0xad0) << uint32(0x0);           // 35 // 2768 horde locked time show
                l_Buffer << uint32(0xacf) << uint32(0x1);           // 36 // 2767 ally locked time show
            }
            break;
        case 3521:                                          // Zangarmarsh
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x9e1) << uint32(0x0);           // 10 //2529
                l_Buffer << uint32(0x9e0) << uint32(0x0);           // 11
                l_Buffer << uint32(0x9df) << uint32(0x0);           // 12
                l_Buffer << uint32(0xa5d) << uint32(0x1);           // 13 //2653
                l_Buffer << uint32(0xa5c) << uint32(0x0);           // 14 //2652 east beacon neutral
                l_Buffer << uint32(0xa5b) << uint32(0x1);           // 15 horde
                l_Buffer << uint32(0xa5a) << uint32(0x0);           // 16 ally
                l_Buffer << uint32(0xa59) << uint32(0x1);           // 17 // 2649 Twin spire graveyard horde  12???
                l_Buffer << uint32(0xa58) << uint32(0x0);           // 18 ally     14 ???
                l_Buffer << uint32(0xa57) << uint32(0x0);           // 19 neutral  7???
                l_Buffer << uint32(0xa56) << uint32(0x0);           // 20 // 2646 west beacon neutral
                l_Buffer << uint32(0xa55) << uint32(0x1);           // 21 horde
                l_Buffer << uint32(0xa54) << uint32(0x0);           // 22 ally
                l_Buffer << uint32(0x9e7) << uint32(0x0);           // 23 // 2535
                l_Buffer << uint32(0x9e6) << uint32(0x0);           // 24
                l_Buffer << uint32(0x9e5) << uint32(0x0);           // 25
                l_Buffer << uint32(0xa00) << uint32(0x0);           // 26 // 2560
                l_Buffer << uint32(0x9ff) << uint32(0x1);           // 27
                l_Buffer << uint32(0x9fe) << uint32(0x0);           // 28
                l_Buffer << uint32(0x9fd) << uint32(0x0);           // 29
                l_Buffer << uint32(0x9fc) << uint32(0x1);           // 30
                l_Buffer << uint32(0x9fb) << uint32(0x0);           // 31
                l_Buffer << uint32(0xa62) << uint32(0x0);           // 32 // 2658
                l_Buffer << uint32(0xa61) << uint32(0x1);           // 33
                l_Buffer << uint32(0xa60) << uint32(0x1);           // 34
                l_Buffer << uint32(0xa5f) << uint32(0x0);           // 35
            }
            break;
        case 3698:                                          // Nagrand Arena
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xa0f) << uint32(0x0);           // 7
                l_Buffer << uint32(0xa10) << uint32(0x0);           // 8
                l_Buffer << uint32(0xa11) << uint32(0x0);           // 9 show
            }
            break;
        case 8482:                                          // Blade's Edge Arena 7.1.5
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BEA)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        case 3968:                                          // Ruins of Lordaeron
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RL)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xbb8) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xbb9) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xbba) << uint32(0x0);           // 9 show
            }
            break;
        case 4378:                                          // Dalaran Sewers
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DS)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3601) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(3600) << uint32(0x0);           // 8 green
                l_Buffer << uint32(3610) << uint32(0x0);           // 9 show
            }
            break;
        case 4384:                                          // Strand of the Ancients
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SA)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                // 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
                l_Buffer << uint32(0xf09) << uint32(0x0);       // 7  3849 Gate of Temple
                l_Buffer << uint32(0xe36) << uint32(0x0);       // 8  3638 Gate of Yellow Moon
                l_Buffer << uint32(0xe27) << uint32(0x0);       // 9  3623 Gate of Green Emerald
                l_Buffer << uint32(0xe24) << uint32(0x0);       // 10 3620 Gate of Blue Sapphire
                l_Buffer << uint32(0xe21) << uint32(0x0);       // 11 3617 Gate of Red Sun
                l_Buffer << uint32(0xe1e) << uint32(0x0);       // 12 3614 Gate of Purple Ametyst

                l_Buffer << uint32(0xdf3) << uint32(0x0);       // 13 3571 bonus timer (1 - on, 0 - off)
                l_Buffer << uint32(0xded) << uint32(0x0);       // 14 3565 Horde Attacker
                l_Buffer << uint32(0xdec) << uint32(0x0);       // 15 3564 Alliance Attacker
                // End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
                l_Buffer << uint32(0xde9) << uint32(0x0);       // 16 3561 C
                l_Buffer << uint32(0xde8) << uint32(0x0);       // 17 3560 B
                l_Buffer << uint32(0xde7) << uint32(0x0);       // 18 3559 A
                l_Buffer << uint32(0xe35) << uint32(0x0);       // 19 3637 East g - Horde control
                l_Buffer << uint32(0xe34) << uint32(0x0);       // 20 3636 West g - Horde control
                l_Buffer << uint32(0xe33) << uint32(0x0);       // 21 3635 South g - Horde control
                l_Buffer << uint32(0xe32) << uint32(0x0);       // 22 3634 East g - Alliance control
                l_Buffer << uint32(0xe31) << uint32(0x0);       // 23 3633 West g - Alliance control
                l_Buffer << uint32(0xe30) << uint32(0x0);       // 24 3632 South g - Alliance control
                l_Buffer << uint32(0xe2f) << uint32(0x0);       // 25 3631 Chamber of Ancients - Horde control
                l_Buffer << uint32(0xe2e) << uint32(0x0);       // 26 3630 Chamber of Ancients - Alliance control
                l_Buffer << uint32(0xe2d) << uint32(0x0);       // 27 3629 Beach1 - Horde control
                l_Buffer << uint32(0xe2c) << uint32(0x0);       // 28 3628 Beach2 - Horde control
                l_Buffer << uint32(0xe2b) << uint32(0x0);       // 29 3627 Beach1 - Alliance control
                l_Buffer << uint32(0xe2a) << uint32(0x0);       // 30 3626 Beach2 - Alliance control
                // and many unks...
            }
            break;
        case 4406:                                          // Ring of Valor
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xe10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xe11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xe1a) << uint32(0x0);           // 9 show
            }
            break;
        case 4710:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_IC)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4221) << uint32(1); // 7 BG_IC_ALLIANCE_RENFORT_SET
                l_Buffer << uint32(4222) << uint32(1); // 8 BG_IC_HORDE_RENFORT_SET
                l_Buffer << uint32(4226) << uint32(300); // 9 BG_IC_ALLIANCE_RENFORT
                l_Buffer << uint32(4227) << uint32(300); // 10 BG_IC_HORDE_RENFORT
                l_Buffer << uint32(4322) << uint32(1); // 11 BG_IC_GATE_FRONT_H_WS_OPEN
                l_Buffer << uint32(4321) << uint32(1); // 12 BG_IC_GATE_WEST_H_WS_OPEN
                l_Buffer << uint32(4320) << uint32(1); // 13 BG_IC_GATE_EAST_H_WS_OPEN
                l_Buffer << uint32(4323) << uint32(1); // 14 BG_IC_GATE_FRONT_A_WS_OPEN
                l_Buffer << uint32(4324) << uint32(1); // 15 BG_IC_GATE_WEST_A_WS_OPEN
                l_Buffer << uint32(4325) << uint32(1); // 16 BG_IC_GATE_EAST_A_WS_OPEN
                l_Buffer << uint32(4317) << uint32(1); // 17 unknown

                l_Buffer << uint32(4301) << uint32(1); // 18 BG_IC_DOCKS_UNCONTROLLED
                l_Buffer << uint32(4296) << uint32(1); // 19 BG_IC_HANGAR_UNCONTROLLED
                l_Buffer << uint32(4306) << uint32(1); // 20 BG_IC_QUARRY_UNCONTROLLED
                l_Buffer << uint32(4311) << uint32(1); // 21 BG_IC_REFINERY_UNCONTROLLED
                l_Buffer << uint32(4294) << uint32(1); // 22 BG_IC_WORKSHOP_UNCONTROLLED
                l_Buffer << uint32(4243) << uint32(1); // 23 unknown
                l_Buffer << uint32(4345) << uint32(1); // 24 unknown
            }
            break;
        // The Ruby Sanctum
        case 4987:
            if (instance && mapid == 724)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(5049) << uint32(50);             // 9 WORLDSTATE_CORPOREALITY_MATERIAL
                l_Buffer << uint32(5050) << uint32(50);             // 10 WORLDSTATE_CORPOREALITY_TWILIGHT
                l_Buffer << uint32(5051) << uint32(0);              // 11 WORLDSTATE_CORPOREALITY_TOGGLE
            }
            break;
        // Icecrown Citadel
        case 4812:
            if (instance && mapid == 631)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4903) << uint32(0);              // 9  WORLDSTATE_SHOW_TIMER (Blood Quickening weekly)
                l_Buffer << uint32(4904) << uint32(30);             // 10 WORLDSTATE_EXECUTION_TIME
                l_Buffer << uint32(4940) << uint32(0);              // 11 WORLDSTATE_SHOW_ATTEMPTS
                l_Buffer << uint32(4941) << uint32(50);             // 12 WORLDSTATE_ATTEMPTS_REMAINING
                l_Buffer << uint32(4942) << uint32(50);             // 13 WORLDSTATE_ATTEMPTS_MAX
            }
            break;
        // The Culling of Stratholme
        case 4100:
            if (instance && mapid == 595)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3479) << uint32(0);              // 9  WORLDSTATE_SHOW_CRATES
                l_Buffer << uint32(3480) << uint32(0);              // 10 WORLDSTATE_CRATES_REVEALED
                l_Buffer << uint32(3504) << uint32(0);              // 11 WORLDSTATE_WAVE_COUNT
                l_Buffer << uint32(3931) << uint32(25);             // 12 WORLDSTATE_TIME_GUARDIAN
                l_Buffer << uint32(3932) << uint32(0);              // 13 WORLDSTATE_TIME_GUARDIAN_SHOW
            }
            break;
        // The Oculus
        case 4228:
            if (instance && mapid == 578)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3524) << uint32(0); // 9 WORLD_STATE_CENTRIFUGE_CONSTRUCT_SHOW
                l_Buffer << uint32(3486) << uint32(0); // 10 WORLD_STATE_CENTRIFUGE_CONSTRUCT_AMOUNT
            }
            break;
        // Ulduar
        case 4273:
            if (instance && mapid == 603)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4132) << uint32(0);              // 9  WORLDSTATE_SHOW_CRATES
                l_Buffer << uint32(4131) << uint32(0);              // 10 WORLDSTATE_CRATES_REVEALED
            }
            break;
        // Twin Peaks
        case 5031:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TP)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x62d) << uint32(0x0);       //  7 1581 alliance flag captures
                l_Buffer << uint32(0x62e) << uint32(0x0);       //  8 1582 horde flag captures
                l_Buffer << uint32(0x609) << uint32(0x0);       //  9 1545 unk
                l_Buffer << uint32(0x60a) << uint32(0x0);       // 10 1546 unk
                l_Buffer << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
                l_Buffer << uint32(0x641) << uint32(0x3);       // 12 1601 unk
                l_Buffer << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                l_Buffer << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        // Battle for Gilneas
        case 5449:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BFG)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        // Halls of Reflection
        case 4820:
            if (instance && mapid == 668)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4884) << uint32(0);              // 9 WORLD_STATE_HOR_WAVES_ENABLED
                l_Buffer << uint32(4882) << uint32(0);              // 10 WORLD_STATE_HOR_WAVE_COUNT
            }
            break;
        case 5833:
            l_Buffer << uint32(0x1958) << uint32(0x1);
            l_Buffer << uint32(0x1959) << uint32(0x4);
            break;
        // Silvershard Mines
        case 6126:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SM)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x1924) << uint32(1);            // SM_MINE_CARTS_DISPLAY
                l_Buffer << uint32(0x1925) << uint32(0);            // SM_ALLIANCE_RESOURCES
                l_Buffer << uint32(0x1926) << uint32(0);            // SM_HORDE_RESOURCES
                l_Buffer << uint32(0x1927) << uint32(1);            // SM_MINE_CART_1
                l_Buffer << uint32(0x1928) << uint32(1);            // SM_MINE_CART_2
                l_Buffer << uint32(0x1929) << uint32(1);            // SM_DISPLAY_ALLIANCE_RESSOURCES
                l_Buffer << uint32(0x192a) << uint32(1);            // SM_MINE_CART_3
                l_Buffer << uint32(0x192b) << uint32(1);            // SM_DISPLAY_HORDE_RESSOURCES
                l_Buffer << uint32(0x1adb) << uint32(0);            // SM_DISPLAY_PROGRESS_BAR
                l_Buffer << uint32(0x1adc) << uint32(0);            // SM_PROGRESS_BAR_STATUS
                l_Buffer << uint32(0x1add) << uint32(0);            // SM_UNK
            }
            break;
        // Tol'Viron Arena
        case 6296:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xE10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xE11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xE1A) << uint32(0x0);           // 9 show
            }
            break;
        // The Tiger's Peak
        case 6732:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TTP)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xE10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xE11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xE1A) << uint32(0x0);           // 9 show
            }
            break;
        // Deepwind Gorge
        case 6665:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DG)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(7938) << uint32(1);          // WORLDSTATE_DG_GOLBIN_MINE
                l_Buffer << uint32(7939) << uint32(1);          // WORLDSTATE_DG_CENTER_MINE
                l_Buffer << uint32(7935) << uint32(1);          // WORLDSTATE_DG_PANDA_MINE
                l_Buffer << uint32(8230) << uint32(0);          // WORLDSTATE_DG_BASE_ALLIANCE
                l_Buffer << uint32(8231) << uint32(0);          // WORLDSTATE_DG_BASE_HORDE
                l_Buffer << uint32(7880) << uint32(0);          // WORLDSTATE_DG_SCORE_ALLIANCE
                l_Buffer << uint32(7881) << uint32(0);          // WORLDSTATE_DG_SCORE_HORDE
                l_Buffer << uint32(7904) << uint32(1);          // WORLDSTATE_DG_CART_ALLIANCE
                l_Buffer << uint32(7887) << uint32(1);          // WORLDSTATE_DG_CART_HORDE
            }
            break;
        // Seething Shore
        case 9136:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SEETHING_SHORE)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(13846) << uint32(1500);      // Max Score of the Battleground
                l_Buffer << uint32(13845) << uint32(0);         // Score of the Alliance
                l_Buffer << uint32(13856) << uint32(0);         // Score of the Horde
            }
            break;
        // Ashran
        case 6941:
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ASHRAN)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(521) << uint32(0);
                l_Buffer << uint32(522) << uint32(0);
                l_Buffer << uint32(523) << uint32(0);
                l_Buffer << uint32(524) << uint32(0);
                l_Buffer << uint32(1581) << uint32(0);
                l_Buffer << uint32(1582) << uint32(0);
                l_Buffer << uint32(1723) << uint32(0);
                l_Buffer << uint32(1724) << uint32(0);
                l_Buffer << uint32(1941) << uint32(0);
                l_Buffer << uint32(1942) << uint32(0);
                l_Buffer << uint32(1943) << uint32(0);
                l_Buffer << uint32(2259) << uint32(0);
                l_Buffer << uint32(2260) << uint32(0);
                l_Buffer << uint32(2261) << uint32(0);
                l_Buffer << uint32(2262) << uint32(0);
                l_Buffer << uint32(2263) << uint32(0);
                l_Buffer << uint32(2264) << uint32(0);
                l_Buffer << uint32(2265) << uint32(142);
                l_Buffer << uint32(2851) << uint32(0);
                l_Buffer << uint32(3085) << uint32(379);
                l_Buffer << uint32(3191) << uint32(16);
                l_Buffer << uint32(3327) << uint32(0);
                l_Buffer << uint32(3426) << uint32(3);
                l_Buffer << uint32(3600) << uint32(0);
                l_Buffer << uint32(3601) << uint32(0);
                l_Buffer << uint32(3610) << uint32(1);
                l_Buffer << uint32(3695) << uint32(0);
                l_Buffer << uint32(3710) << uint32(0);
                l_Buffer << uint32(3781) << uint32(0);
                l_Buffer << uint32(3801) << uint32(1);
                l_Buffer << uint32(3826) << uint32(4);
                l_Buffer << uint32(3901) << uint32(3);
                l_Buffer << uint32(4020) << uint32(1094);
                l_Buffer << uint32(4021) << uint32(7);
                l_Buffer << uint32(4022) << uint32(3);
                l_Buffer << uint32(4023) << uint32(4);
                l_Buffer << uint32(4024) << uint32(825);
                l_Buffer << uint32(4025) << uint32(269);
                l_Buffer << uint32(4062) << uint32(0);
                l_Buffer << uint32(4131) << uint32(60);
                l_Buffer << uint32(4273) << uint32(0);
                l_Buffer << uint32(4354) << uint32(time(NULL));
                l_Buffer << uint32(4375) << uint32(0);
                l_Buffer << uint32(4417) << uint32(1);
                l_Buffer << uint32(4418) << uint32(50);
                l_Buffer << uint32(4419) << uint32(0);
                l_Buffer << uint32(4485) << uint32(0);
                l_Buffer << uint32(4486) << uint32(0);
                l_Buffer << uint32(4862) << uint32(1000);
                l_Buffer << uint32(4863) << uint32(300);
                l_Buffer << uint32(4864) << uint32(100);
                l_Buffer << uint32(5037) << uint32(6);
                l_Buffer << uint32(5071) << uint32(6);
                l_Buffer << uint32(5115) << uint32(0);
                l_Buffer << uint32(5192) << uint32(0);
                l_Buffer << uint32(5193) << uint32(0);
                l_Buffer << uint32(5194) << uint32(0);
                l_Buffer << uint32(5195) << uint32(0);
                l_Buffer << uint32(5196) << uint32(0);
                l_Buffer << uint32(5332) << uint32(time(NULL));
                l_Buffer << uint32(5333) << uint32(0);
                l_Buffer << uint32(5334) << uint32(1);
                l_Buffer << uint32(5344) << uint32(0);
                l_Buffer << uint32(5360) << uint32(0);
                l_Buffer << uint32(5361) << uint32(0);
                l_Buffer << uint32(5508) << uint32(1);
                l_Buffer << uint32(5677) << uint32(0);
                l_Buffer << uint32(5678) << uint32(0);
                l_Buffer << uint32(5679) << uint32(0);
                l_Buffer << uint32(5684) << uint32(0);
                l_Buffer << uint32(6078) << uint32(0);
                l_Buffer << uint32(6095) << uint32(0);
                l_Buffer << uint32(6164) << uint32(35);
                l_Buffer << uint32(6174) << uint32(0);
                l_Buffer << uint32(6267) << uint32(25);
                l_Buffer << uint32(6306) << uint32(0);
                l_Buffer << uint32(6436) << uint32(0);
                l_Buffer << uint32(6895) << uint32(10);
                l_Buffer << uint32(6897) << uint32(10);
                l_Buffer << uint32(6898) << uint32(10);
                l_Buffer << uint32(7022) << uint32(0);
                l_Buffer << uint32(7242) << uint32(82);
                l_Buffer << uint32(7243) << uint32(1);
                l_Buffer << uint32(7244) << uint32(82);
                l_Buffer << uint32(7245) << uint32(1);
                l_Buffer << uint32(7511) << uint32(0);
                l_Buffer << uint32(7617) << uint32(5);
                l_Buffer << uint32(7618) << uint32(5);
                l_Buffer << uint32(7671) << uint32(0);
                l_Buffer << uint32(7738) << uint32(0);
                l_Buffer << uint32(7752) << uint32(0);
                l_Buffer << uint32(7774) << uint32(0);
                l_Buffer << uint32(7796) << uint32(0);
                l_Buffer << uint32(7797) << uint32(0);
                l_Buffer << uint32(7876) << uint32(0);
                l_Buffer << uint32(8012) << uint32(1);
                l_Buffer << uint32(8295) << uint32(15);
                l_Buffer << uint32(8306) << uint32(20);
                l_Buffer << uint32(8307) << uint32(20);
                l_Buffer << uint32(8391) << uint32(0);
                l_Buffer << uint32(8524) << uint32(0);
                l_Buffer << uint32(8525) << uint32(0);
                l_Buffer << uint32(8526) << uint32(0);
                l_Buffer << uint32(8527) << uint32(0);
                l_Buffer << uint32(8528) << uint32(0);
                l_Buffer << uint32(8529) << uint32(0);
                l_Buffer << uint32(8712) << uint32(0);
                l_Buffer << uint32(8722) << uint32(0);
                l_Buffer << uint32(8859) << uint32(0);
                l_Buffer << uint32(8860) << uint32(0);
                l_Buffer << uint32(8861) << uint32(0);
                l_Buffer << uint32(8862) << uint32(0);
                l_Buffer << uint32(8863) << uint32(1);
                l_Buffer << uint32(8890) << uint32(0);
                l_Buffer << uint32(8892) << uint32(0);
                l_Buffer << uint32(8911) << uint32(10);
                l_Buffer << uint32(8933) << uint32(65);
                l_Buffer << uint32(8934) << uint32(5);
                l_Buffer << uint32(8935) << uint32(1);
                l_Buffer << uint32(8938) << uint32(0);
                l_Buffer << uint32(8945) << uint32(time(NULL));
                l_Buffer << uint32(8946) << uint32(0);
                l_Buffer << uint32(8949) << uint32(1);
                l_Buffer << uint32(8950) << uint32(0);
                l_Buffer << uint32(8955) << uint32(0);
            }
            break;
        /// - Kotmogu Temple BG
        case 6051:
        {
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_KT)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        }
        ///< Upper Blackrock Spire
        case 7307:
        {
            if (instance && mapid == 1358)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(9524) << uint32(0);              // WorldStateChickenTimer
                l_Buffer << uint32(9523) << uint32(0);              // WorldStateEnableChicken
            }

            break;
        }
        /// Highmaul
        case 6996:
        {
            if (instance && mapid == 1228)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(9722) << uint32(0); /// Iron Bombers - activation
                l_Buffer << uint32(9723) << uint32(0); /// Iron Bombers remaining
                l_Buffer << uint32(9724) << uint32(0); /// Drunken Bileslinger - activation
                l_Buffer << uint32(9725) << uint32(0); /// Drunken Bileslinger remaining
            }

            break;
        }
        case 7107:
        {
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TARRENMILL)
                pvp->FillInitialWorldStates(l_Buffer);
            break;
        }
        /// Blackrook Hold Arena
        case BATTLEGROUND_BRH_ZONEID:
        {
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BRH)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        }
        /// Nagrand Arena 2
        /*case BATTLEGROUND_NA2_ZONEID:
        {
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA2)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        }*/
        /// Ashamane's Fall Arena
        case BATTLEGROUND_AF_ZONEID:
        {
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AF)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        }
        case 8025: ///< The Nighthold
        {
            if (instance && mapid == 1530)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(11880) << uint32(0); ///< Skorpyron Achievement
            }

            break;
        }
        default:
            l_Buffer << uint32(0x914) << uint32(0x0);           // 7
            l_Buffer << uint32(0x913) << uint32(0x0);           // 8
            l_Buffer << uint32(0x912) << uint32(0x0);           // 9
            l_Buffer << uint32(0x915) << uint32(0x0);           // 10
            break;
    }

    auto const& l_ActiveWorldQuests = sWorldQuestGenerator->GetActiveWorldQuests();
    l_ActiveWorldQuests.safe_foreach(true, [&l_Buffer](MS::WorldQuest::ActiveWorldQuestsList::const_iterator& p_Itr) -> void
    {
        if (uint32 l_ID = p_Itr->second->m_Template->GetWorldStateID())
            l_Buffer << uint32(l_ID) << uint32(p_Itr->second->m_Template->GetWorldStateValue());
    });

    l_Buffer << uint32(12368) << uint32(1); ///< Signalizes that legion world bosses are available

    uint32 l_WorldStateCount = l_Buffer.size() / 8;
    l_Buffer.rpos(0);

    for (uint32 l_I = 0; l_I < l_WorldStateCount; ++l_I)
    {
        uint32 l_Field, l_Value;
        l_Buffer >> l_Field >> l_Value;

        SetWorldState(l_Field, l_Value);
    }

    WorldPacket data(SMSG_INIT_WORLD_STATES, 4 + 4 + 4 + 4 + l_Buffer.size());
    data << uint32(mapid);                                  // mapid
    data << uint32(zoneid);                                 // zone id
    data << uint32(areaid);                                 // area id, new 2.1.0
    data << uint32(l_WorldStateCount);
    data.append(l_Buffer);

    GetSession()->SendPacket(&data);

    SendBGWeekendWorldStates();
}

void Player::SendBGWeekendWorldStates()
{
    for (uint32 i = 1; i < sBattlemasterListStore.GetNumRows(); ++i)
    {
        BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(i);
        if (bl && bl->HolidayWorldState)
        {
            if (MS::Battlegrounds::BattlegroundMgr::IsBGWeekend((BattlegroundTypeId)bl->ID))
                SendUpdateWorldState(bl->HolidayWorldState, 1);
            else
                SendUpdateWorldState(bl->HolidayWorldState, 0);
        }
    }
}

uint32 Player::GetXPRestBonus(uint32 xp)
{
    uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus

    if (rested_bonus > xp)                                   // max rested_bonus == xp or (r+x) = 200% xp
        rested_bonus = xp;

    ModRestBonus(-(float)rested_bonus);

    sLog->outInfo(LOG_FILTER_PLAYER, "Player gain %u xp (+ %u Rested Bonus). Rested points=%f", xp+rested_bonus, rested_bonus, GetRestBonus());
    return rested_bonus;
}

void Player::SetBindPoint(uint64 p_Guid)
{
    WorldPacket l_Data(SMSG_BINDER_CONFIRM, 2 + 16);
    l_Data.appendPackGUID(p_Guid);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendTalentWipeConfirm(uint64 guid, uint32 cost)
{
    WorldPacket l_Data(SMSG_RESPEC_WIPE_CONFIRM);
    l_Data << uint8(0);                           ///< 0 : talent 1 : specialization
    l_Data << uint32(cost);
    l_Data.appendPackGUID(guid);

    GetSession()->SendPacket(&l_Data);
}

/*********************************************************/
/***                    STORAGE SYSTEM                 ***/
/*********************************************************/
void Player::SetVirtualItemSlot(uint8 i, Item* item)
{
    ASSERT(i < 3);
    if (i < 2 && item)
    {
        if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
            return;
        uint32 charges = item->GetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT);
        if (charges == 0)
            return;
        if (charges > 1)
            item->SetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT, charges-1);
        else if (charges <= 1)
        {
            ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
            item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
        }
    }
}

void Player::SetSheath(SheathState sheathed)
{
    switch (sheathed)
    {
        case SHEATH_STATE_UNARMED:                          // no prepared weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_MELEE:                            // prepared melee weapon
            SetVirtualItemSlot(0, GetWeaponForAttack(WeaponAttackType::BaseAttack, true));
            SetVirtualItemSlot(1, GetWeaponForAttack(WeaponAttackType::OffAttack, true));
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_RANGED:                           // prepared ranged weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, GetWeaponForAttack(WeaponAttackType::RangedAttack, true));
            break;
        default:
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
    }

    Unit::SetSheath(sheathed);                              // this must visualize Sheath changing for other players...
}

uint8 Player::GetGuessedEquipSlot(ItemTemplate const* proto) const
{
    switch (proto->InventoryType)
    {
        case INVTYPE_HEAD:
            return EQUIPMENT_SLOT_HEAD;
        case INVTYPE_NECK:
            return EQUIPMENT_SLOT_NECK;
        case INVTYPE_SHOULDERS:
            return EQUIPMENT_SLOT_SHOULDERS;
        case INVTYPE_BODY:
            return EQUIPMENT_SLOT_BODY;
        case INVTYPE_CHEST:
            return EQUIPMENT_SLOT_CHEST;
        case INVTYPE_ROBE:
            return EQUIPMENT_SLOT_CHEST;
        case INVTYPE_WAIST:
            return EQUIPMENT_SLOT_WAIST;
        case INVTYPE_LEGS:
            return EQUIPMENT_SLOT_LEGS;
        case INVTYPE_FEET:
            return EQUIPMENT_SLOT_FEET;
        case INVTYPE_WRISTS:
            return EQUIPMENT_SLOT_WRISTS;
        case INVTYPE_HANDS:
            return EQUIPMENT_SLOT_HANDS;
        case INVTYPE_FINGER:
            return EQUIPMENT_SLOT_FINGER1;
        case INVTYPE_TRINKET:
            return EQUIPMENT_SLOT_TRINKET1;
        case INVTYPE_CLOAK:
            return EQUIPMENT_SLOT_BACK;
        case INVTYPE_WEAPON:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_SHIELD:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_RANGED:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_2HWEAPON:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_TABARD:
            return EQUIPMENT_SLOT_TABARD;
        case INVTYPE_WEAPONMAINHAND:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_WEAPONOFFHAND:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_HOLDABLE:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_THROWN:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_RANGEDRIGHT:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_BAG:
            return INVENTORY_SLOT_BAG_START;
        default:
            return NULL_SLOT;
    }
}

uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) const
{
    uint8 playerClass = getClass();

    uint8 slots[4];
    slots[0] = NULL_SLOT;
    slots[1] = NULL_SLOT;
    slots[2] = NULL_SLOT;
    slots[3] = NULL_SLOT;
    switch (proto->InventoryType)
    {
        case INVTYPE_HEAD:
            slots[0] = EQUIPMENT_SLOT_HEAD;
            break;
        case INVTYPE_NECK:
            slots[0] = EQUIPMENT_SLOT_NECK;
            break;
        case INVTYPE_SHOULDERS:
            slots[0] = EQUIPMENT_SLOT_SHOULDERS;
            break;
        case INVTYPE_BODY:
            slots[0] = EQUIPMENT_SLOT_BODY;
            break;
        case INVTYPE_CHEST:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_ROBE:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_WAIST:
            slots[0] = EQUIPMENT_SLOT_WAIST;
            break;
        case INVTYPE_LEGS:
            slots[0] = EQUIPMENT_SLOT_LEGS;
            break;
        case INVTYPE_FEET:
            slots[0] = EQUIPMENT_SLOT_FEET;
            break;
        case INVTYPE_WRISTS:
            slots[0] = EQUIPMENT_SLOT_WRISTS;
            break;
        case INVTYPE_HANDS:
            slots[0] = EQUIPMENT_SLOT_HANDS;
            break;
        case INVTYPE_FINGER:
            slots[0] = EQUIPMENT_SLOT_FINGER1;
            slots[1] = EQUIPMENT_SLOT_FINGER2;
            break;
        case INVTYPE_TRINKET:
            slots[0] = EQUIPMENT_SLOT_TRINKET1;
            slots[1] = EQUIPMENT_SLOT_TRINKET2;
            break;
        case INVTYPE_CLOAK:
            slots[0] = EQUIPMENT_SLOT_BACK;
            break;
        case INVTYPE_WEAPON:
        {
            slots[0] = EQUIPMENT_SLOT_MAINHAND;

            // suggest offhand slot only if know dual wielding
            // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
            if (CanDualWield() && proto->ItemId != 128908)   ///< Fury artifact weapon cannot go OFFHAND
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        }
        case INVTYPE_SHIELD:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_RANGED:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            break;
        case INVTYPE_2HWEAPON:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (CanDualWield() && CanTitanGrip() && proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF && proto->ItemId != 128908)   ///< Fury artifact weapon cannot go OFFHAND
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_TABARD:
            slots[0] = EQUIPMENT_SLOT_TABARD;
            break;
        case INVTYPE_WEAPONMAINHAND:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            break;
        case INVTYPE_WEAPONOFFHAND:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_HOLDABLE:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_RANGEDRIGHT:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            break;
        case INVTYPE_BAG:
            slots[0] = INVENTORY_SLOT_BAG_START + 0;
            slots[1] = INVENTORY_SLOT_BAG_START + 1;
            slots[2] = INVENTORY_SLOT_BAG_START + 2;
            slots[3] = INVENTORY_SLOT_BAG_START + 3;
            break;
        default:
            return NULL_SLOT;
    }

    if (slot != NULL_SLOT)
    {
        if (swap || !GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
            for (uint8 i = 0; i < 4; ++i)
                if (slots[i] == slot)
                    return slot;
    }
    else
    {
        // search free slot at first
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && !GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]))
                // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
                if (slots[i] != EQUIPMENT_SLOT_OFFHAND || !IsTwoHandUsed())
                    return slots[i];

        // if not found free and can swap return first appropriate from used
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && swap)
                return slots[i];
    }

    // no free position
    return NULL_SLOT;
}

InventoryResult Player::CanUnequipItems(uint32 item, uint32 count) const
{
    uint32 tempcount = 0;

    InventoryResult res = EQUIP_ERR_OK;

    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                InventoryResult ires = CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false);
                if (ires == EQUIP_ERR_OK)
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return EQUIP_ERR_OK;
                }
                else
                    res = ires;
            }

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = GetItemByPos(i, j))
                    if (pItem->GetEntry() == item)
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return EQUIP_ERR_OK;
                    }

    // not found req. item count and have unequippable items
    return res;
}

uint32 Player::GetItemCount(uint32 item, bool inBankAlso, Item* skipItem, bool isVoidStorageAlso) const
{
    uint32 count = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCount(item, skipItem);

    if (skipItem && skipItem->GetTemplate()->GemProperties)
        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                    count += pItem->GetGemCountWithID(item);

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    if (skipItem && skipItem->GetTemplate()->GemProperties)
        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                    count += pItem->GetGemCountWithID(item);

    if (inBankAlso)
    {
        // checking every item from 39 to 74 (including bank bags)
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                count += pBag->GetItemCount(item, skipItem);

        if (skipItem && skipItem->GetTemplate()->GemProperties)
            for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
                if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                        count += pItem->GetGemCountWithID(item);
    }

    if (isVoidStorageAlso)
    {
        count += GetVoidStorageItemsCount(item);
    }

    return count;
}

uint32 Player::GetItemCountWithLimitCategory(uint32 limitCategory, Item* skipItem) const
{
    uint32 count = 0;
    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    return count;
}

Item* Player::GetItemByGuid(uint64 guid) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;
    return NULL;
}

Item* Player::GetItemByPos(uint16 pos) const
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    return GetItemByPos(bag, slot);
}

Item* Player::GetItemByPos(uint8 bag, uint8 slot) const
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot < PLAYER_SLOT_END && (slot < BUYBACK_SLOT_START || slot >= BUYBACK_SLOT_END))
        return m_items[slot];
    else if (Bag* pBag = GetBagByPos(bag))
        return pBag->GetItemByPos(slot);

    return NULL;
}

Bag* Player::GetBagByPos(uint8 bag) const
{
    if ((bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        || (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END))
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
            return item->ToBag();
    return NULL;
}

Item* Player::GetWeaponForAttack(WeaponAttackType attackType, bool useable /*= false*/) const
{
    uint8 slot;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   slot = EQUIPMENT_SLOT_MAINHAND; break;
        case WeaponAttackType::OffAttack:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
        case WeaponAttackType::RangedAttack: slot = EQUIPMENT_SLOT_MAINHAND;   break;
        default: return NULL;
    }

    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_WEAPON)
        return NULL;

    if (!useable)
        return item;

    if (item->IsBroken())
        return nullptr;

    if (item->CantBeUse() || IsInFeralForm())
        return NULL;

    return item;
}

Item* Player::GetShield(bool useable) const
{
    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_ARMOR)
        return NULL;

    if (!useable)
        return item;

    if (item->IsBroken())
        return nullptr;

    if (item->CantBeUse())
        return NULL;

    return item;
}

Item* Player::GetChildItemByGuid(uint64 guid) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    return nullptr;
}

uint8 Player::GetAttackBySlot(uint8 slot)
{
    switch (slot)
    {
        case EQUIPMENT_SLOT_MAINHAND: return WeaponAttackType::BaseAttack;
        case EQUIPMENT_SLOT_OFFHAND:  return WeaponAttackType::OffAttack;
        default:                      return WeaponAttackType::MaxAttack;
    }
}

bool Player::IsInventoryPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot == NULL_SLOT)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END))
        return true;
    if (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= CHILD_EQUIPMENT_SLOT_START && slot < CHILD_EQUIPMENT_SLOT_END))
        return true;
    return false;
}

bool Player::IsEquipmentPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot < EQUIPMENT_SLOT_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    if (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsReagentBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= REAGENT_BANK_SLOT_BAG_START && slot < REAGENT_BANK_SLOT_BAG_END))
        return true;
    if (bag >= REAGENT_BANK_SLOT_BAG_START && bag < REAGENT_BANK_SLOT_BAG_END)
        return true;

    return false;
}

bool Player::IsBagPos(uint16 pos)
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsChildEquipmentPos(uint8 bag, uint8 slot)
{
    return bag == INVENTORY_SLOT_BAG_0 && (slot >= CHILD_EQUIPMENT_SLOT_START && slot < CHILD_EQUIPMENT_SLOT_END);
}

bool Player::IsValidPos(uint8 bag, uint8 slot, bool explicit_pos)
{
    // post selected
    if (bag == NULL_BAG && !explicit_pos)
        return true;

    if (bag == INVENTORY_SLOT_BAG_0)
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        // equipment
        if (slot < EQUIPMENT_SLOT_END)
            return true;

        // bag equip slots
        if (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END)
            return true;

        // backpack slots
        if (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END)
            return true;

        // bank main slots
        if (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END)
            return true;

        // bank bag slots
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
            return true;

        // reagent bank bag slots
        if (slot >= REAGENT_BANK_SLOT_BAG_START && slot < REAGENT_BANK_SLOT_BAG_END)
            return true;

        return false;
    }

    // bag content slots
    // bank bag content slots
    if (Bag* pBag = GetBagByPos(bag))
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        return slot < pBag->GetBagSize();
    }

    // where this?
    return false;
}

uint32 Player::GetLegendaryCounts() const
{
    uint32 l_Count = 0;

    for (uint8 l_I = EQUIPMENT_SLOT_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I);
        if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel +  l_Item->GetBonus()->ItemLevelBonus) > 800)
            l_Count++;
    }

    for (uint8 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; l_I++)
    {
        if (Bag* pBag = GetBagByPos(l_I))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* l_Item = GetItemByPos(l_I, j);
                if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel + l_Item->GetBonus()->ItemLevelBonus) > 800)
                    l_Count++;
            }
        }
    }

    for (uint8 l_I = CHILD_EQUIPMENT_SLOT_START; l_I < CHILD_EQUIPMENT_SLOT_END; l_I++)
    {
        Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I);
        if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel + l_Item->GetBonus()->ItemLevelBonus) > 800)
            l_Count++;
    }

    for (uint8 l_I = BANK_SLOT_ITEM_START; l_I < BANK_SLOT_ITEM_END; l_I++)
    {
        Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I);
        if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel + l_Item->GetBonus()->ItemLevelBonus) > 800)
            l_Count++;
    }

    for (uint8 l_I = BANK_SLOT_BAG_START; l_I < BANK_SLOT_BAG_END; l_I++)
    {
        if (Bag* pBag = GetBagByPos(l_I))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* l_Item = GetItemByPos(l_I, j);
                if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel + l_Item->GetBonus()->ItemLevelBonus) > 800)
                    l_Count++;
            }
        }
    }

    for (uint8 l_I = REAGENT_BANK_SLOT_BAG_START; l_I < REAGENT_BANK_SLOT_BAG_END; l_I++)
    {
        Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I);
        if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && (l_Item->GetTemplate()->ItemLevel + l_Item->GetBonus()->ItemLevelBonus) > 800)
            l_Count++;
    }

    return l_Count;
}

bool Player::HasItemCount(uint32 p_ItemID, uint32 p_Count /*= 1*/, bool p_Bank /*= false*/, bool p_ReagentBank /*= false*/, bool p_VoidStorage /*= false*/) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= p_Count)
                return true;
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* pItem = GetItemByPos(i, j);
                if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= p_Count)
                        return true;
                }
            }
        }
    }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= p_Count)
                return true;
        }
    }

    if (p_Bank)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= p_Count)
                    return true;
            }
        }
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            if (Bag* pBag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                {
                    Item* pItem = GetItemByPos(i, j);
                    if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= p_Count)
                            return true;
                    }
                }
            }
        }
    }

    if (p_Bank || p_ReagentBank)
    {
        for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == p_ItemID && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= p_Count)
                    return true;
            }
        }
    }

    if (p_VoidStorage)
    {
        if (GetVoidStorageItemsCount(p_ItemID) >= p_Count)
            return true;
    }

    return false;
}

bool Player::HasItemOrGemWithIdEquipped(uint32 item, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (pProto && pProto->GemProperties)
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (i == except_slot)
                continue;

            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetTemplate()->Socket[0].Color)
            {
                tempcount += pItem->GetGemCountWithID(item);
                if (tempcount >= count)
                    return true;
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithLimitCategoryEquipped(uint32 limitCategory, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (!pItem)
            continue;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (!pProto)
            continue;

        if (pProto->ItemLimitCategory == limitCategory)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }

        if (pProto->Socket[0].Color || pItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
        {
            tempcount += pItem->GetGemCountWithLimitCategory(limitCategory);
            if (tempcount >= count)
                return true;
        }
    }

    return false;
}

InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count) const
{
    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    if (pItem && pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // no maximum
    if ((pProto->MaxCount <= 0 && pProto->ItemLimitCategory == 0) || pProto->MaxCount == 2147483647)
        return EQUIP_ERR_OK;

    if (pProto->MaxCount > 0)
    {
        uint32 curcount = GetItemCount(pProto->ItemId, true, pItem);
        if (curcount + count > uint32(pProto->MaxCount))
        {
            if (no_space_count)
                *no_space_count = count + curcount - pProto->MaxCount;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // check unique-equipped limit
    if (pProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(pProto->ItemLimitCategory);

        if (!limitEntry)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_EQUIPPABLE;
        }

        uint8 l_MaxCount = limitEntry->GetMaxCount(this);

        if (limitEntry->mode == ITEM_LIMIT_CATEGORY_MODE_HAVE)
        {
            uint32 curcount = GetItemCountWithLimitCategory(pProto->ItemLimitCategory, pItem);
            if (curcount + count > uint32(l_MaxCount))
            {
                if (no_space_count)
                    *no_space_count = count + curcount - l_MaxCount;
                return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS;
            }
        }
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const
{
    Item* pItem2 = GetItemByPos(bag, slot);

    // ignore move item (this slot will be empty at move)
    if (pItem2 == pSrcItem)
        pItem2 = NULL;

    uint32 need_space;

    if (pSrcItem)
    {
        if (pSrcItem->IsNotEmptyBag() && !IsBagPos(uint16(bag) << 8 | slot))
            return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

        if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD) && !IsEquipmentPos(bag, slot) && !IsChildEquipmentPos(bag, slot))
            return EQUIP_ERR_WRONG_BAG_TYPE_2;

        if (!pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD) && IsChildEquipmentPos(bag, slot))
            return EQUIP_ERR_WRONG_BAG_TYPE_2;
    }

    // empty specific slot - check item fit to slot
    if (!pItem2 || swap)
    {
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            // prevent cheating
            if ((slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END) || slot >= PLAYER_SLOT_END)
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }
        else
        {
            Bag* pBag = GetBagByPos(bag);
            if (!pBag)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            ItemTemplate const* pBagProto = pBag->GetTemplate();
            if (!pBagProto)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (slot >= pBagProto->ContainerSlots)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (!ItemCanGoIntoBag(pProto, pBagProto))
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }

        // non empty stack with space
        need_space = pProto->GetMaxStackSize();
    }
    // non empty slot, check item type
    else
    {
        // can be merged at least partly
        InventoryResult res  = pItem2->CanBeMergedPartlyWith(pProto);
        if (res != EQUIP_ERR_OK)
            return res;

        // free stack space or infinity
        need_space = pProto->GetMaxStackSize() - pItem2->GetCount();
    }

    if (need_space > count)
        need_space = count;

    ItemPosCount newPosition = ItemPosCount((bag << 8) | slot, need_space);
    if (!newPosition.isContainedIn(dest))
    {
        dest.push_back(newPosition);
        count -= need_space;
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InBag(uint8 bag, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    // skip specific bag already processed in first called CanStoreItem_InBag
    if (bag == skip_bag)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // skip not existed bag or self targeted bag
    Bag* pBag = GetBagByPos(bag);
    if (!pBag || pBag == pSrcItem)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (pSrcItem)
    {
        if (pSrcItem->IsNotEmptyBag())
            return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

        if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
            return EQUIP_ERR_WRONG_BAG_TYPE_2;
    }

    ItemTemplate const* pBagProto = pBag->GetTemplate();
    if (!pBagProto)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // specialized bag mode or non-specilized
    if (non_specialized != (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (!ItemCanGoIntoBag(pProto, pBagProto))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    for (uint32 j = 0; j < pBag->GetBagSize(); j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(bag, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((bag << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 slot_end, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    //this is never called for non-bag slots so we can do this
    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    for (uint32 j = slot_begin; j < slot_end; j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (INVENTORY_SLOT_BAG_0 == skip_bag && j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((INVENTORY_SLOT_BAG_0 << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count) const
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, entry, count);

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return swap ? EQUIP_ERR_CANT_SWAP :EQUIP_ERR_ITEM_NOT_FOUND;
    }

    if (pItem)
    {
        // item used
        if (pItem->m_lootGenerated)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_LOOT_GONE;
        }

        if (pItem->IsBindedNotWith(this))
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_OWNER;
        }
    }

    // check count of items (skip for auto move for same player from bank)
    uint32 no_similar_count = 0;                            // can't store this amount similar items
    InventoryResult res = CanTakeMoreSimilarItems(entry, count, pItem, &no_similar_count);
    if (res != EQUIP_ERR_OK)
    {
        if (count == no_similar_count)
        {
            if (no_space_count)
                *no_space_count = no_similar_count;
            return res;
        }
        count -= no_similar_count;
    }

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)               // inventory
            {
                res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }

                res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            else                                            // equipped bag
            {
                // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        // search free slot in bag for place to
        if (bag == INVENTORY_SLOT_BAG_0)                     // inventory
        {
            if (pItem && pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
            {
                res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            else if (pProto->IsCraftingReagent() && HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED))
            {
                res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }

            res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
        else                                                // equipped bag
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        if (pProto->BagFamily)
        {
            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // search free slot - special bag case
    if (pProto->BagFamily)
    {
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    if (pItem && pItem->IsNotEmptyBag())
        return EQUIP_ERR_BAG_IN_BAG;

    if (pItem && pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
    {
        res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }
    else if (pProto->IsCraftingReagent() && HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED))
    {
        res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, false, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // search free slot
    res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
    {
        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return res;
    }

    if (count == 0)
    {
        if (no_similar_count == 0)
            return EQUIP_ERR_OK;

        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    if (no_space_count)
        *no_space_count = count + no_similar_count;

    return EQUIP_ERR_INV_FULL;
}

InventoryResult Player::CanEquipChildItem(Item* parentItem) const
 {
    Item* childItem = GetChildItemByGuid(parentItem->GetChildItem());
    if (!childItem)
        return EQUIP_ERR_OK;

    ItemChildEquipmentEntry const* childEquipement = GetItemChildEquipment(parentItem->GetEntry());
    if (!childEquipement)
        return EQUIP_ERR_OK;

    Item* dstItem = GetItemByPos(INVENTORY_SLOT_BAG_0, childEquipement->TargetSlot);
    if (!dstItem)
        return EQUIP_ERR_OK;

    uint16 childDest = (INVENTORY_SLOT_BAG_0 << 8) | childEquipement->TargetSlot;
    InventoryResult msg = CanUnequipItem(childDest, !childItem->IsBag());
    if (msg != EQUIP_ERR_OK)
        return msg;

    // check dest->src move possibility
    uint16 src = parentItem->GetPos();
    ItemPosCountVec dest;
    if (IsInventoryPos(src))
    {
        msg = CanStoreItem(parentItem->GetBagSlot(), NULL_SLOT, dest, dstItem, true);
        if (msg != EQUIP_ERR_OK)
            msg = CanStoreItem(NULL_BAG, NULL_SLOT, dest, dstItem, true);
    }
    else if (IsBankPos(src))
    {
        msg = CanBankItem(parentItem->GetBagSlot(), NULL_SLOT, dest, dstItem, true);
        if (msg != EQUIP_ERR_OK)
            msg = CanBankItem(NULL_BAG, NULL_SLOT, dest, dstItem, true);
    }
    else if (IsEquipmentPos(src))
        return EQUIP_ERR_CANT_SWAP;

    return msg;
 }

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanStoreItems(Item** pItems, int count) const
{
    Item* pItem2;

    // fill space table
    int inv_slot_items[INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START];
    int inv_bags[INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START][MAX_BAG_SIZE];

    memset(inv_slot_items, 0, sizeof(int) * (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));
    memset(inv_bags, 0, sizeof(int) * (INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START) * MAX_BAG_SIZE);

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->IsInTrade())
            inv_slot_items[i - INVENTORY_SLOT_ITEM_START] = pItem2->GetCount();
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                pItem2 = GetItemByPos(i, j);
                if (pItem2 && !pItem2->IsInTrade())
                    inv_bags[i - INVENTORY_SLOT_BAG_START][j] = pItem2->GetCount();
            }

    // check free space for all items
    for (int k = 0; k < count; ++k)
    {
        Item* pItem = pItems[k];

        // no item
        if (!pItem)
            continue;

        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItems %i. item = %u, count = %u", k + 1, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();

        // strange item
        if (!pProto)
            return EQUIP_ERR_ITEM_NOT_FOUND;

        // item used
        if (pItem->m_lootGenerated)
            return EQUIP_ERR_LOOT_GONE;

        // item it 'bind'
        if (pItem->IsBindedNotWith(this))
            return EQUIP_ERR_NOT_OWNER;

        ItemTemplate const* pBagProto;

        // item is 'one item only'
        InventoryResult res = CanTakeMoreSimilarItems(pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        // search stack for merge to
        if (pProto->Stackable != 1)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
            {
                pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, t);
                if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_slot_items[t-INVENTORY_SLOT_ITEM_START] + pItem->GetCount() <= pProto->GetMaxStackSize())
                {
                    inv_slot_items[t-INVENTORY_SLOT_ITEM_START] += pItem->GetCount();
                    b_found = true;
                    break;
                }
            }
            if (b_found)
                continue;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    if (ItemCanGoIntoBag(pItem->GetTemplate(), bag->GetTemplate()))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            pItem2 = GetItemByPos(t, j);
                            if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_bags[t-INVENTORY_SLOT_BAG_START][j] + pItem->GetCount() <= pProto->GetMaxStackSize())
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] += pItem->GetCount();
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // special bag case
        if (pProto->BagFamily)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    pBagProto = bag->GetTemplate();

                    // not plain container check
                    if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER) &&
                        ItemCanGoIntoBag(pProto, pBagProto))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // search free slot
        bool b_found = false;
        for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
        {
            if (inv_slot_items[t-INVENTORY_SLOT_ITEM_START] == 0)
            {
                inv_slot_items[t-INVENTORY_SLOT_ITEM_START] = 1;
                b_found = true;
                break;
            }
        }
        if (b_found)
            continue;

        // search free slot in bags
        for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
        {
            if (Bag* bag = GetBagByPos(t))
            {
                pBagProto = bag->GetTemplate();

                // special bag already checked
                if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER))
                    continue;

                for (uint32 j = 0; j < bag->GetBagSize(); j++)
                {
                    if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                    {
                        inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                        b_found = true;
                        break;
                    }
                }
            }
        }

        // no free slot found?
        if (!b_found)
            return EQUIP_ERR_INV_FULL;
    }

    return EQUIP_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanEquipNewItem(uint8 slot, uint16 &dest, uint32 item, bool swap) const
{
    dest = 0;
    Item* pItem = Item::CreateItem(item, 1, this);
    if (pItem)
    {
        InventoryResult result = CanEquipItem(slot, dest, pItem, swap);
        delete pItem;
        return result;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool swap, bool not_loading) const
{
    dest = 0;
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanEquipItem slot = %u, item = %u, count = %u", slot, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            // item used
            if (pItem->m_lootGenerated)
                return EQUIP_ERR_LOOT_GONE;

            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            if (pProto->ArtifactID && getLevel() < 98)
                return EQUIP_ERR_NOT_EQUIPPABLE;

            // check count of items (skip for auto move for same player from bank)
            InventoryResult res = CanTakeMoreSimilarItems(pItem);
            if (res != EQUIP_ERR_OK)
                return res;

            // check this only in game
            if (not_loading)
            {
                /// According to IDA this is checked from Artifact.db2
                if (uint32 l_ArtifactID = pProto->ArtifactID)
                {
                    ArtifactEntry const* l_ArtifactEntry = sArtifactStore.LookupEntry(l_ArtifactID);

                    /// Fishing artifact
                    if (uint16 l_SpecID = l_ArtifactEntry->SpecializationID)
                    {
                        if (l_SpecID != GetActiveSpecializationID())
                        {
                            /// Retail message
                            return EQUIP_ERR_CANT_USE_ITEM;
                        }
                    }
                }

                if (this->HasAura(27827))
                    return EQUIP_ERR_PLAYER_DEAD;

                // May be here should be more stronger checks; STUNNED checked
                // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
                if (HasUnitState(UNIT_STATE_STUNNED))
                    return EQUIP_ERR_GENERIC_STUNNED;

                // do not allow equipping gear except weapons, offhands, projectiles, relics in
                // - combat
                // - in-progress arenas
                if (!pProto->CanChangeEquipStateInCombat())
                {
                    if (isInCombat())
                        return EQUIP_ERR_NOT_IN_COMBAT;

                    if (Battleground* bg = GetBattleground())
                        if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                            return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
                }

                if (pProto->Class == ITEM_CLASS_WEAPON && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;

                if (isInCombat()&& (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer != 0)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;         // maybe exist better err

                if (IsNonMeleeSpellCasted(false) && (!pProto->ArtifactID || (pProto->ArtifactID && (m_currentSpells[CURRENT_CHANNELED_SPELL] && !m_currentSpells[CURRENT_CHANNELED_SPELL]->GetSpellInfo()->HasEffect(SPELL_EFFECT_TALENT_SPEC_SELECT)))))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;

                ///< You can't equip in challenge with Burst or Grievous Wound
                if (GetMap() && GetMap()->IsChallengeMode())
                {
                    if (HasAura(ChallengeSpells::ChallengerGrievousWound) || HasAura(ChallengeSpells::ChallengerBurst))
                        return EQUIP_ERR_CLIENT_LOCKED_OUT;
                }
            }

            uint8 eslot = FindEquipSlot(pProto, slot, swap);
            if (eslot == NULL_SLOT)
                return EQUIP_ERR_NOT_EQUIPPABLE;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;

            if (!swap && GetItemByPos(INVENTORY_SLOT_BAG_0, eslot))
                return EQUIP_ERR_NO_SLOT_AVAILABLE;

            // if swap ignore item (equipped also)
            InventoryResult res2 = CanEquipUniqueItem(pItem, swap ? eslot : uint8(NULL_SLOT));
            if (res2 != EQUIP_ERR_OK)
                return res2;

            // check unique-equipped special item classes
            if (pProto->Class == ITEM_CLASS_QUIVER)
                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
                    if (Item* pBag = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                        if (pBag != pItem)
                            if (ItemTemplate const* pBagProto = pBag->GetTemplate())
                                if (pBagProto->Class == pProto->Class && (!swap || pBag->GetSlot() != eslot))
                                    return (pBagProto->SubClass == ITEM_SUBCLASS_AMMO_POUCH)
                                        ? EQUIP_ERR_ONLY_ONE_AMMO
                                        : EQUIP_ERR_ONLY_ONE_QUIVER;

            uint32 type = pProto->InventoryType;

            if (eslot == EQUIPMENT_SLOT_OFFHAND)
            {
                // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
                if (type == INVTYPE_WEAPON && pProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
                    return EQUIP_ERR_2HSKILLNOTFOUND;
                else if (type == INVTYPE_WEAPON)
                {
                    if (!CanDualWield() && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_WEAPONOFFHAND)
                {
                    if (!CanDualWield() && !(pProto->Flags3 & int32(ItemFlagsEX2::ALWAYS_ALLOW_DUAL_WIELD)) && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_2HWEAPON)
                {
                    if ((!CanDualWield() || !CanTitanGrip()) && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }

                if (IsTwoHandUsed() && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                    return EQUIP_ERR_2HANDED_EQUIPPED;
            }

            // equip two-hand weapon case (with possible unequip 2 items)
            /// Ranged weapons are two hands weapons since MoP
            if (type == INVTYPE_2HWEAPON || type == INVTYPE_RANGEDRIGHT)
            {
                if (eslot == EQUIPMENT_SLOT_OFFHAND)
                {
                    if (!CanTitanGrip() && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                        return EQUIP_ERR_NOT_EQUIPPABLE;
                }
                else if (eslot != EQUIPMENT_SLOT_MAINHAND)
                    return EQUIP_ERR_NOT_EQUIPPABLE;

                if (!CanTitanGrip() && !pProto->ArtifactID && !pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                {
                    // offhand item must can be stored in inventory for offhand item and it also must be unequipped
                    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                    ItemPosCountVec off_dest;
                    if (offItem && (!not_loading ||
                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
                        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_INV_FULL;
                }
            }
            dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
            return EQUIP_ERR_OK;
        }
    }

    return !swap ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_CANT_SWAP;
}

InventoryResult Player::CanUnequipItem(uint16 pos, bool swap) const
{
    // Applied only to equipped items and bank bags
    if (!IsEquipmentPos(pos) && !IsBagPos(pos))
        return EQUIP_ERR_OK;

    Item* pItem = GetItemByPos(pos);

    // Applied only to existed equipped item
    if (!pItem)
        return EQUIP_ERR_OK;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUnequipItem slot = %u, item = %u, count = %u", pos, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (this->HasAura(27827))
        return EQUIP_ERR_PLAYER_DEAD;

    // do not allow unequipping gear except weapons, offhands, projectiles, relics in
    // - combat
    // - in-progress arenas
    if (!pProto->CanChangeEquipStateInCombat())
    {
        if (isInCombat())
            return EQUIP_ERR_NOT_IN_COMBAT;

        if (Battleground* bg = GetBattleground())
            if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
    }

    if ((pProto->Class & ITEM_CLASS_WEAPON) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
        return EQUIP_ERR_CLIENT_LOCKED_OUT;

    if (!swap && pItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());
    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // Currency tokens are not supposed to be swapped out of their hidden bag
    if (pItem->IsCurrencyToken())
    {
        sLog->outError(LOG_FILTER_PLAYER, "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
                GetName(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->ItemId);
        return EQUIP_ERR_CANT_SWAP;
    }

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);
    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
        {
            if (!pItem->IsBag())
                return EQUIP_ERR_WRONG_SLOT;

            if (slot - BANK_SLOT_BAG_START >= GetBankBagSlotCount())
                return EQUIP_ERR_NO_BANK_SLOT;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;
        }

        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        if (pItem->IsNotEmptyBag())
            return EQUIP_ERR_BAG_IN_BAG;

        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)
            {
                res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
            else
            {
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        // search free slot in bag
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
        else
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;

        // in special bags
        if (pProto->BagFamily)
        {
            for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free place in special bag
    if (pProto->BagFamily)
    {
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free space
    res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
            return EQUIP_ERR_OK;
    }
    return EQUIP_ERR_BANK_FULL;
}

bool Player::IsItemSupplies(ItemTemplate const *p_BagProto) const
{
    switch (p_BagProto->SubClass)
    {
        case ITEM_SUBCLASS_HERB_CONTAINER:
        case ITEM_SUBCLASS_ENGINEERING_CONTAINER:
        case ITEM_SUBCLASS_GEM_CONTAINER:
        case ITEM_SUBCLASS_ENCHANTING_CONTAINER:
        case ITEM_SUBCLASS_MINING_CONTAINER:
        case ITEM_SUBCLASS_LEATHERWORKING_CONTAINER:
        case ITEM_SUBCLASS_INSCRIPTION_CONTAINER:
        case ITEM_SUBCLASS_TACKLE_CONTAINER:
        case ITEM_SUBCLASS_COOKING_CONTAINER:
        case ITEM_SUBCLASS_ENCHANTING_CONTAINER_2:
        case ITEM_SUBCLASS_MATERIALS_CONTAINER:
        case ITEM_SUBCLASS_ITEM_ENCHANTMENT_CONTAINER:
        case ITEM_SUBCLASS_WEAPON_ENCHANTMENT_CONTAINER:
            return true;
    }
    return false;
}

InventoryResult Player::CanReagentBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanReagentBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    if ((pProto->Flags2 & int32(ItemFlagsEX::USED_IN_A_TRADESKILL)) == 0)
        return EQUIP_ERR_WRONG_SLOT;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);

    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);

        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, true, pItem, bag, slot);

        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // search free space
    res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, false, pItem, bag, slot);

    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    return EQUIP_ERR_BANK_FULL;
}

InventoryResult Player::CanUseItem(Item* pItem, bool not_loading) const
{
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUseItem item = %u", pItem->GetEntry());

        if (!isAlive() && not_loading)
            return EQUIP_ERR_PLAYER_DEAD;

        if (getLevel() < pItem->GetRequiredLevel())
            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            InventoryResult res = CanUseItem(pProto, pItem->GetRequiredLevel());
            if (res != EQUIP_ERR_OK)
                return res;

            if (pItem->GetSkill() != 0)
            {
                bool allowEquip = false;
                uint32 itemSkill = pItem->GetSkill();
                // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
                if (pProto->Quality == ITEM_QUALITY_HEIRLOOM && pProto->Class == ITEM_CLASS_ARMOR && !HasSkill(itemSkill))
                {
                    switch (getClass())
                    {
                        case CLASS_HUNTER:
                        case CLASS_SHAMAN:
                            allowEquip = (itemSkill == SKILL_MAIL);
                            break;
                        case CLASS_PALADIN:
                        case CLASS_WARRIOR:
                            allowEquip = (itemSkill == SKILL_PLATE_MAIL);
                            break;
                    }
                }
                if (!allowEquip && GetSkillValue(itemSkill) == 0)
                    return EQUIP_ERR_PROFICIENCY_NEEDED;
            }

            if (pProto->RequiredReputationFaction && uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank)
                return EQUIP_ERR_CANT_EQUIP_REPUTATION;

            return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanUseItem(ItemTemplate const* proto, uint32 p_ScaledLevel /*= 0*/) const
{
    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
    if (proto)
    {
        if ((proto->Flags2 & int32(ItemFlagsEX::HORDE)) && GetTeam() != HORDE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->Flags2 & int32(ItemFlagsEX::ALLIANCE)) && GetTeam() != ALLIANCE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if (proto->RequiredSkill != 0)
        {
            if (GetSkillValue(proto->RequiredSkill) == 0)
                return EQUIP_ERR_PROFICIENCY_NEEDED;
            else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
                return EQUIP_ERR_CANT_EQUIP_SKILL;
        }

        if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
            return EQUIP_ERR_PROFICIENCY_NEEDED;

        if (getLevel() < (p_ScaledLevel > 0 ? p_ScaledLevel : proto->RequiredLevel))
            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;

        // If World Event is not active, prevent using event dependant items
        if (proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
            return EQUIP_ERR_CLIENT_LOCKED_OUT;

        return EQUIP_ERR_OK;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanRollForItemInLFG(ItemTemplate const* proto, WorldObject const* lootedObject) const
{
    LfgDungeonSet const& dungeons = sLFGMgr->GetSelectedDungeons(GetGUID());
    if (dungeons.empty())
        return EQUIP_ERR_OK;    // not using LFG

    GroupPtr l_Group = GetGroup();
    if (!l_Group || !l_Group->isLFGGroup())
        return EQUIP_ERR_OK;    // not in LFG group

    // check if looted object is inside the lfg dungeon
    bool lootedObjectInDungeon = false;
    Map const* map = lootedObject->GetMap();
    if (uint32 dungeonId = sLFGMgr->GetDungeon(l_Group->GetGUID(), true))
        if (LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId))
            if (uint32(dungeon->map) == map->GetId() && dungeon->difficulty == uint32(map->GetDifficultyID()))
                lootedObjectInDungeon = true;

    if (!lootedObjectInDungeon)
        return EQUIP_ERR_OK;

    if (!proto)
        return EQUIP_ERR_ITEM_NOT_FOUND;

    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
    {
        SKILL_AXES,             SKILL_TWO_HANDED_AXES, SKILL_BOWS,   SKILL_GUNS,              SKILL_MACES,
        SKILL_TWO_HANDED_MACES, SKILL_POLEARMS,        SKILL_SWORDS, SKILL_TWO_HANDED_SWORDS, SKILL_WARGLAIVES,
        SKILL_STAVES,           0,                     0,            SKILL_FIST_WEAPONS,      0,
        SKILL_DAGGERS,          0,                     0,            SKILL_CROSSBOWS,         SKILL_WANDS,
        SKILL_FISHING
    }; ///< Copy from Item::GetSkill()

    /// Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
        return EQUIP_ERR_CANT_EQUIP_EVER;

    if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->RequiredSkill != 0)
    {
        if (!GetSkillValue(proto->RequiredSkill))
            return EQUIP_ERR_PROFICIENCY_NEEDED;
        else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
            return EQUIP_ERR_CANT_EQUIP_SKILL;
    }

    uint8 _class = getClass();

    if (proto->Class == ITEM_CLASS_WEAPON && GetSkillValue(item_weapon_skills[proto->GetSkill()]) == 0)
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass > ITEM_SUBCLASS_ARMOR_MISCELLANEOUS && proto->SubClass < ITEM_SUBCLASS_ARMOR_COSMETIC && proto->InventoryType != INVTYPE_CLOAK)
    {
        if (_class == CLASS_WARRIOR || _class == CLASS_PALADIN || _class == CLASS_DEATH_KNIGHT)
        {
            if (getLevel() < 40)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }
        else if (_class == CLASS_HUNTER || _class == CLASS_SHAMAN)
        {
            if (getLevel() < 40)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }

        if (_class == CLASS_ROGUE || _class == CLASS_DRUID)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;

        if (_class == CLASS_MAGE || _class == CLASS_PRIEST || _class == CLASS_WARLOCK)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_CLOTH)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
    }

    return EQUIP_ERR_OK;
}

Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId, std::vector<uint32> const& p_Bonuses)
{
    AllowedLooterSet allowedLooters;
    return StoreNewItem(dest, item, update, randomPropertyId, allowedLooters, p_Bonuses);
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId, AllowedLooterSet& allowedLooters, std::vector<uint32> const& p_Bonuses)
{
    uint32 count = 0;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end(); ++itr)
        count += itr->count;

    Item* pItem = Item::CreateItem(item, count, this);
    if (pItem)
    {
        /// Don't do the check now
        /// Prevent our current item dest to be filled by a instant item quest reward (like world quest, quest bonus etc)
        AddDelayedEvent([this, item, count]() -> void
        {
            ItemAddedQuestCheck(item, count);
        }, 1);

        UpdateCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
        UpdateCriteria(CRITERIA_TYPE_OWN_ITEM, item, 1);

        if (randomPropertyId)
            pItem->SetItemRandomProperties(randomPropertyId);

        pItem->AddItemBonuses(p_Bonuses);

        pItem = StoreItem(dest, pItem, update);

        if (pItem->GetTemplate()->Quality == ITEM_QUALITY_HEIRLOOM)
            if (HeirloomEntry const* l_HeirloomEntry = GetHeirloomEntryByItemID(pItem->GetTemplate()->ItemId))
                AddHeirloom(l_HeirloomEntry, pItem->HasCustomFlags(ItemCustomFlags::FromStore));

        if (!pItem->GetModifier(ItemModifiers::ITEM_MODIFIER_ARTIFACT_KNOWLEDGE_LEVEL))
        {
            if (allowedLooters.size() > 1 && pItem->GetTemplate()->GetMaxStackSize() == 1 && pItem->IsSoulBound())
            {
                pItem->SetSoulboundTradeable(allowedLooters);
                pItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());
                AddTradeableItem(pItem);

                // save data
                std::ostringstream ss;
                AllowedLooterSet::const_iterator itr = allowedLooters.begin();
                ss << *itr;
                for (++itr; itr != allowedLooters.end(); ++itr)
                    ss << ' ' << *itr;


                PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_ITEM_BOP_TRADE);
                stmt->setUInt32(0, pItem->GetRealGUIDLow());
                stmt->setString(1, ss.str());
                RealmDatabase.Execute(stmt);
            }
        }

        if (ItemChildEquipmentEntry const* childItemEntry = GetItemChildEquipment(item))
        {
            if (ItemTemplate const* childTemplate = sObjectMgr->GetItemTemplate(childItemEntry->ChildItemID))
            {
                ItemPosCountVec childDest;
                CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, childDest, childTemplate, count, false, nullptr, NULL_BAG, NULL_SLOT);
                if (Item* childItem = StoreNewItem(childDest, childTemplate->ItemId, update, 0))
                {
                    childItem->SetGuidValue(ITEM_FIELD_CREATOR, pItem->GetGUID());
                    childItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD);
                    pItem->SetChildItem(childItem->GetGUID());
                }
            }
        }
    }

    /// Save Inventory of the player each time he got a new item to prevent rollback / item losts after a server crash
    /// Delay it to the next update to ensure the item have all bonus added (they are added to the item after StoreNewItem)
    /// Lead to item lost for some reasons
    /*AddDelayedEvent([=]()-> void
    {
        SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
        SaveInventoryAndGoldToDB(l_Transaction);
        CharacterDatabase.CommitTransaction(l_Transaction);
    }, 0);*/

    return pItem;
}

Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
{
    if (!pItem)
        return NULL;

    Item* lastItem = pItem;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end();)
    {
        uint16 pos = itr->pos;
        uint32 count = itr->count;

        ++itr;

        if (itr == dest.end())
        {
            lastItem = _StoreItem(pos, pItem, count, false, update);
            break;
        }

        lastItem = _StoreItem(pos, pItem, count, true, update);
    }

    AutoUnequipChildItem(lastItem);
    UpdateItemLevel();
    return lastItem;
}

void Player::EquipChildItem(uint8 parentBag, uint8 parentSlot, Item* parentItem)
{
    if (ItemChildEquipmentEntry const* itemChildEquipment = GetItemChildEquipment(parentItem->GetEntry()))
    {
        if (Item* childItem = GetChildItemByGuid(parentItem->GetChildItem()))
        {
            uint16 childDest = (INVENTORY_SLOT_BAG_0 << 8) | itemChildEquipment->TargetSlot;
            if (childItem->GetPos() != childDest)
            {
                Item* dstItem = GetItemByPos(childDest);
                if (!dstItem)                                      // empty slot, simple case
                {
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                    EquipItem(childDest, childItem, true);
                    AutoUnequipOffhandIfNeed();
                }
                else                                                    // have currently equipped item, not simple case
                {
                    uint8 dstbag = dstItem->GetBagSlot();
                    uint8 dstslot = dstItem->GetSlot();

                    InventoryResult msg = CanUnequipItem(childDest, !childItem->IsBag());
                    if (msg != EQUIP_ERR_OK)
                    {
                        SendEquipError(msg, dstItem);
                        return;
                    }

                    // check dest->src move possibility but try to store currently equipped item in the bag where the parent item is
                    ItemPosCountVec sSrc;
                    uint16 eSrc = 0;
                    if (IsInventoryPos(parentBag, parentSlot))
                    {
                        msg = CanStoreItem(parentBag, NULL_SLOT, sSrc, dstItem, true);
                        if (msg != EQUIP_ERR_OK)
                            msg = CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dstItem, true);
                    }
                    else if (IsBankPos(parentBag, parentSlot))
                    {
                        msg = CanBankItem(parentBag, NULL_SLOT, sSrc, dstItem, true);
                        if (msg != EQUIP_ERR_OK)
                            msg = CanBankItem(NULL_BAG, NULL_SLOT, sSrc, dstItem, true);
                    }
                    else if (IsEquipmentPos(parentBag, parentSlot))
                    {
                        msg = CanEquipItem(parentSlot, eSrc, dstItem, true);
                        if (msg == EQUIP_ERR_OK)
                            msg = CanUnequipItem(eSrc, true);
                    }

                    if (msg != EQUIP_ERR_OK)
                    {
                        SendEquipError(msg, dstItem, childItem);
                        return;
                    }

                    // now do moves, remove...
                    RemoveItem(dstbag, dstslot, false);
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), false);

                    // add to dest
                    EquipItem(childDest, childItem, true);

                    // add to src
                    if (IsInventoryPos(parentBag, parentSlot))
                        StoreItem(sSrc, dstItem, true);
                    else if (IsBankPos(parentBag, parentSlot))
                        BankItem(sSrc, dstItem, true);
                    else if (IsEquipmentPos(parentBag, parentSlot))
                        EquipItem(eSrc, dstItem, true);

                    AutoUnequipOffhandIfNeed();
                }
            }
        }
    }
 }

 void Player::AutoUnequipChildItem(Item* parentItem, bool p_Log /*=false*/)
 {
    if (ItemChildEquipmentEntry const* itemChildEquipment = GetItemChildEquipment(parentItem->GetEntry()))
    {
        if (Item* childItem = GetChildItemByGuid(parentItem->GetChildItem()))
        {
            if (IsChildEquipmentPos(childItem->GetPos()))
                return;

            ItemPosCountVec dest;
            uint32 count = childItem->GetCount();
            InventoryResult result = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, childItem->GetTemplate(), count, false, childItem, NULL_BAG, NULL_SLOT);

            if (result != EQUIP_ERR_OK)
                return;

            RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
            StoreItem(dest, childItem, true);
            return;
        }

        return;
    }
 }


// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::_StoreItem(uint16 pos, Item* pItem, uint32 count, bool clone, bool update)
{
    if (!pItem)
        return NULL;

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: StoreItem bag = %u, slot = %u, item = %u, count = %u, guid = %u", bag, slot, pItem->GetEntry(), count, pItem->GetGUIDLow());

    Item* pItem2 = GetItemByPos(bag, slot);
    if (!pItem2)
    {
        if (clone)
            pItem = pItem->CloneItem(count, this);
        else
            pItem->SetCount(count);

        if (!pItem)
            return NULL;

        if (pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
            pItem->SetBinding(true);

        Bag* pBag = (bag == INVENTORY_SLOT_BAG_0) ? NULL : GetBagByPos(bag);
        if (!pBag)
        {
            for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
            {
                if (m_items[i] == pItem)
                {
                    ACE_Stack_Trace trace;
                    sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
                }
            }
            m_items[slot] = pItem;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());

            pItem->SetSlot(slot);
            pItem->SetContainer(NULL);
        }
        else
            pBag->StoreItem(slot, pItem, update);

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        pItem->SetState(ITEM_CHANGED, this);
        if (pBag)
            pBag->SetState(ITEM_CHANGED, this);

        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        if (uint32 l_ArtifactID = pItem->GetTemplate()->ArtifactID)
        {
            MS::Artifact::Manager* l_Artifact = GetOrGenerateNewArtifactHolder(l_ArtifactID);
            pItem->SetArtifactMgr(l_Artifact);
            l_Artifact->SetItemOwner(pItem);
        }

        const ItemTemplate* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_OBTAIN && proto->Spells[i].SpellId > 0) // On obtain trigger
                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                    if (!HasAura(proto->Spells[i].SpellId))
                        CastSpell(this, proto->Spells[i].SpellId, true, pItem);

        return pItem;
    }
    else
    {
        if (pItem2->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem2->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem2->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
            pItem2->SetBinding(true);

        pItem2->SetCount(pItem2->GetCount() + count);
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        if (!clone)
        {
            if (pItem != pItem2)
            {
                // delete item (it not in any slot currently)
                if (IsInWorld() && update)
                {
                    pItem->RemoveFromWorld();
                    pItem->DestroyForPlayer(this);
                }

                RemoveEnchantmentDurations(pItem);
                RemoveItemDurations(pItem);

                pItem->SetOwnerGUID(GetGUID());                 // prevent error at next SetState in case trade/mail/buy from vendor
                pItem->SetNotRefundable(this);
                pItem->ClearSoulboundTradeable(this);
                RemoveTradeableItem(pItem);
                if (pItem->GetEntry() == 138019)
                    sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (1)");
                pItem->SetState(ITEM_REMOVED, this);
            }
        }

        AddEnchantmentDurations(pItem2);

        pItem2->SetState(ITEM_CHANGED, this);

        const ItemTemplate* proto = pItem2->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_OBTAIN && proto->Spells[i].SpellId > 0) // On obtain trigger
                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                    if (!HasAura(proto->Spells[i].SpellId))
                        CastSpell(this, proto->Spells[i].SpellId, true, pItem2);

        return pItem2;
    }
}

Item* Player::EquipNewItem(uint16 pos, uint32 item, bool update)
{
    if (Item* pItem = Item::CreateItem(item, 1, this))
    {
        ItemAddedQuestCheck(item, 1);
        UpdateCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, 1);
        return EquipItem(pos, pItem, update);
    }

    return NULL;
}

Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
{
    if (pItem->GetTemplate()->Flags3 & int32(ItemFlagsEX2::PVP_TOURNAMENT_GEAR))
    {
        if (!GetBattleground() || !GetBattleground()->IsWargame())
            pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
    }
    else if (GetBattleground() && GetBattleground()->UseTournamentRules())
        pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);

    AddEnchantmentDurations(pItem);
    AddItemDurations(pItem);

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    Item* pItem2 = GetItemByPos(bag, slot);

    float l_HealthPct = GetHealthPct();

    if (!pItem2)
    {
        VisualizeItem(slot, pItem);

        if (isAlive())
        {
            ItemTemplate const* pProto = pItem->GetTemplate();

            if (MS::Artifact::Manager* l_Manager = pItem->GetArtifactManager())
            {
                l_Manager->OnEquip();
            }

            // item set bonuses applied only at equip and removed at unequip, and still active for broken items
            if (pProto && pProto->ItemSet)
                AddItemsSetItem(this, pItem);

            _ApplyItemMods(pItem, slot, true);

            if (pProto && isInCombat() && (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer == 0)
            {
                uint32 cooldownSpell = getClass() == CLASS_ROGUE ? 6123 : 6119;
                SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(cooldownSpell);

                if (!spellProto)
                    sLog->outError(LOG_FILTER_PLAYER, "Weapon switch cooldown spell %u couldn't be found in Spell.db2", cooldownSpell);
                else
                {
                    m_weaponChangeTimer = spellProto->StartRecoveryTime;

                    GetGlobalCooldownMgr().AddGlobalCooldown(spellProto, m_weaponChangeTimer);

                    WorldPacket data(SMSG_SPELL_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
                    data.appendPackGUID(GetGUID());
                    data << uint8(CooldownFlags::CooldownFlagIncludeGCD);
                    data << uint32(1);
                    data << uint32(cooldownSpell);
                    data << uint32(0);
                    data << float(1.0f);

                    GetSession()->SendPacket(&data);
                }
            }
        }

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        ApplyEquipCooldown(pItem);
    }
    else
    {
        pItem2->SetCount(pItem2->GetCount() + pItem->GetCount());
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        // delete item (it not in any slot currently)
        //pItem->DeleteFromDB();
        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetOwnerGUID(GetGUID());                     // prevent error at next SetState in case trade/mail/buy from vendor
        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);
        pItem->SetState(ITEM_REMOVED, this);
        if (pItem->GetEntry() == 138019)
            sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (2)");
        pItem2->SetState(ITEM_CHANGED, this);

        ApplyEquipCooldown(pItem2);

        return pItem2;
    }

    if (GetHealthPct() != l_HealthPct)
        SetHealth(CountPctFromMaxHealth(l_HealthPct));

    // only for full equip instead adding to stack
    UpdateCriteria(CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
    UpdateCriteria(CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);

    // Assassin's Resolve - 84601
    if (getClass() == CLASS_ROGUE && GetActiveSpecializationID() == SPEC_ROGUE_ASSASSINATION)
    {
        Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
        Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

        if (((mainItem && mainItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER) || (offItem && offItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)))
        {
            if (HasAura(84601))
                RemoveAura(84601);

            CastSpell(this, 84601, true);
        }
        else
            RemoveAura(84601);
    }
    /// Single-Minded Fury - 81099
    if (getClass() == CLASS_WARRIOR && GetActiveSpecializationID() == SPEC_WARRIOR_FURY)
    {
        if (HasAura(81099))
        {
            RemoveAura(81099);
            AddAura(81099, this);
        }
    }

    /// Recalculate Armor Specialization Amounts
    AuraEffectList l_AuraModTotalStat = GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
    for (AuraEffect* l_AuraEffect : l_AuraModTotalStat)
        l_AuraEffect->RecalculateAmount();

    // close gossips
    PlayerTalkClass->ClearMenus();
    PlayerTalkClass->SendCloseGossip();
    UpdateItemLevel();

    return pItem;
}

void Player::QuickEquipItem(uint16 pos, Item* pItem)
{
    if (pItem)
    {
        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        uint8 slot = pos & 255;
        VisualizeItem(slot, pItem);

        if (uint32 l_ArtifactID = pItem->GetTemplate()->ArtifactID)
        {
            MS::Artifact::Manager* l_Artifact = GetOrGenerateNewArtifactHolder(l_ArtifactID);
            pItem->SetArtifactMgr(l_Artifact);
            l_Artifact->SetItemOwner(pItem);
            l_Artifact->OnEquip();
        }

        if (IsInWorld())
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
            AutoUnequipChildItem(pItem);
        }

        UpdateCriteria(CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
        UpdateCriteria(CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
    }
}

void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
{
    if (slot >= EQUIPMENT_SLOT_END)
        return;

    if (pItem)

    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 0, pItem->GetVisibleEntry(this));
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 0, pItem->GetVisibleAppearanceModID(this));
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 1, pItem->GetVisibleItemVisual(this));
    }
    else
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 0, 0);
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 0);
    }
}

void Player::SetBackPackAutoSortDisabled(bool p_Disabled)
{
    m_BackPackAutoSortDisabled = p_Disabled;

    SetUInt32Value(EPlayerFields::PLAYER_FIELD_INSERT_ITEMS_LEFT_TO_RIGHT, uint32(m_BackPackAutoSortDisabled));
}

void Player::VisualizeItem(uint8 slot, Item* pItem)
{
    if (!pItem)
        return;

    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
    if (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
    {
        pItem->SetBinding(true);

        if (IsInWorld())
            GetSession()->GetCollectionMgr()->AddItemAppearance(pItem);
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
    {
        if (m_items[i] == pItem)
        {
            ACE_Stack_Trace trace;
            sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
        }
    }

    m_items[slot] = pItem;
    SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());
    pItem->SetSlot(slot);
    pItem->SetContainer(NULL);

    if (slot < EQUIPMENT_SLOT_END)
        SetVisibleItemSlot(slot, pItem);

    pItem->SetState(ITEM_CHANGED, this);
}

void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
{
    // note: removeitem does not actually change the item
    // it only takes the item out of storage temporarily
    // note2: if removeitem is to be used for delinking
    // the item must be removed from the player's updatequeue

    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);
        RemoveTradeableItem(pItem);

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();
                // item set bonuses applied only at equip and removed at unequip, and still active for broken items

                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);

                if (MS::Artifact::Manager* l_Artifact = pItem->GetArtifactManager())
                {
                    l_Artifact->OnUnequip();
                }

                // remove item dependent auras and casts (only weapon and armor slots)
                if (slot < EQUIPMENT_SLOT_END)
                {
                    RemoveItemDependentAurasAndCasts(pItem);

                    // remove held enchantments
                    if (slot == EQUIPMENT_SLOT_MAINHAND)
                    {
                        if (pItem->GetItemSuffixFactor())
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
                        }
                        else
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
                        }
                    }
                }
            }

            m_items[slot] = NULL;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);

            if (slot < EQUIPMENT_SLOT_END)
                SetVisibleItemSlot(slot, NULL);

            /// Recalculate Armor Specialization Amounts
            AuraEffectList l_AuraModTotalStat = GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
            for (AuraEffect* l_AuraEffect : l_AuraModTotalStat)
                l_AuraEffect->RecalculateAmount();
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        if (slot < EquipmentSlots::EQUIPMENT_SLOT_END)
            sScriptMgr->OnPlayerAfterUnequipItem(this, pItem);

        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, 0);
        pItem->SetSlot(NULL_SLOT);
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
    }
    UpdateItemLevel();
}

// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
{
    if (Item* it = GetItemByPos(bag, slot))
    {
        ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
        RemoveItem(bag, slot, update);
        it->SetNotRefundable(this, false, nullptr, false);
        it->RemoveFromUpdateQueueOf(this);
        GetSession()->GetCollectionMgr()->RemoveTemporaryAppearance(it);
        if (it->IsInWorld())
        {
            it->RemoveFromWorld();
            it->DestroyForPlayer(this);
        }
    }
}

// Common operation need to add item from inventory without delete in trade, guild bank, mail....
void Player::MoveItemToInventory(ItemPosCountVec const& dest, Item* pItem, bool update, bool in_characterInventoryDB)
{
    // update quest counters
    ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
    UpdateCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());

    // store item
    Item* pLastItem = StoreItem(dest, pItem, update);

    // only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
    if (pLastItem == pItem)
    {
        // update owner for last item (this can be original item with wrong owner
        if (pLastItem->GetOwnerGUID() != GetGUID())
            pLastItem->SetOwnerGUID(GetGUID());

        // if this original item then it need create record in inventory
        // in case trade we already have item in other player inventory
        pLastItem->SetState(in_characterInventoryDB ? ITEM_CHANGED : ITEM_NEW, this);
    }

    if (pLastItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
        AddTradeableItem(pLastItem);
}

void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
{
    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
        sScriptMgr->OnItemDestroyed(this, pItem);

        // Also remove all contained items if the item is a bag.
        // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
        if (pItem->IsNotEmptyBag())
            for (uint8 i = 0; i < MAX_BAG_SIZE; ++i)
                DestroyItem(slot, i, update);

        if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_WRAPPED))
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_GIFT);
            stmt->setUInt32(0, pItem->GetRealGUIDLow());
            RealmDatabase.Execute(stmt);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);

        const ItemTemplate* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_OBTAIN && proto->Spells[i].SpellId > 0) // On obtain trigger
                RemoveAurasDueToSpell(proto->Spells[i].SpellId);

        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);

            // equipment and equipped bags can have applied bonuses
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();

                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);
            }

            if (slot < EQUIPMENT_SLOT_END)
            {
                // remove item dependent auras and casts (only weapon and armor slots)
                RemoveItemDependentAurasAndCasts(pItem);

                // equipment visual show
                SetVisibleItemSlot(slot, NULL);
            }

            m_items[slot] = NULL;
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        if (slot < EquipmentSlots::EQUIPMENT_SLOT_END)
            sScriptMgr->OnPlayerAfterUnequipItem(this, pItem);

        if (IsInWorld())
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, 0);
        pItem->SetSlot(NULL_SLOT);
        if (pItem->GetEntry() == 138019)
            sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (3)");
        pItem->SetState(ITEM_REMOVED, this);
    }
}

void Player::DestroyItemCount(uint32 item, uint32 count, bool update, bool unequip_check)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item = %u, count = %u", item, count);
    uint32 remcount = 0;

    if (item == 138019)
        sLog->outAshran("Mythic Keystone delete [2]");

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    // all items in inventory can unequipped
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    if (!unequip_check || CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false) == EQUIP_ERR_OK)
                    {
                        remcount += pItem->GetCount();
                        DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                        if (remcount >= count)
                            return;
                    }
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank
    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in regeant bank
    for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank bags
    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    // all keys can be unequipped
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }
}

void Player::DestroyZoneLimitedItem(bool update, uint32 new_zone)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyZoneLimitedItem in map %u and area %u", GetMapId(), new_zone);

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

void Player::DestroyConjuredItems(bool update)
{
    // used when entering arena
    // destroys all conjured items
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyConjuredItems");

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsConjuredConsumable())
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

Item* Player::GetItemByEntry(uint32 entry) const
{
    // in inventory
    for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEntry() == entry)
                        return pItem;

    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    return NULL;
}

void Player::DestroyItemCount(Item* pItem, uint32 &count, bool update)
{
    if (!pItem)
        return;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(), pItem->GetEntry(), count);

    if (pItem->GetCount() <= count)
    {
        count -= pItem->GetCount();

        DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), update);
    }
    else
    {
        ItemRemovedQuestCheck(pItem->GetEntry(), count);
        pItem->SetCount(pItem->GetCount() - count);
        count = 0;
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
        pItem->SetState(ITEM_CHANGED, this);
    }
}

void Player::SplitItem(uint16 src, uint16 dst, uint32 count)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    if (pSrcItem->m_lootGenerated)                           // prevent split looting item (item
    {
        //best error message found for attempting to split while looting
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split all items (can be only at cheating)
    if (pSrcItem->GetCount() == count)
    {
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split more existed items (can be only at cheating)
    if (pSrcItem->GetCount() < count)
    {
        SendEquipError(EQUIP_ERR_TOO_FEW_TO_SPLIT, pSrcItem, NULL);
        return;
    }

    //! If trading
    if (TradeData* tradeData = GetTradeData())
    {
        //! If current item is in trade window (only possible with packet spoofing - silent return)
        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
            return;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SplitItem bag = %u, slot = %u, item = %u, count = %u", dstbag, dstslot, pSrcItem->GetEntry(), count);
    Item* pNewItem = pSrcItem->CloneItem(count, this);
    if (!pNewItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    if (IsInventoryPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        StoreItem(dest, pNewItem, true);
    }
    else if (IsBankPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        BankItem(dest, pNewItem, true);
    }
    else if (IsReagentBankPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanReagentBankItem(dstbag, dstslot, dest, pNewItem, false);

        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);

        pSrcItem->SetState(ITEM_CHANGED, this);
        BankItem(dest, pNewItem, true);
    }
    else if (IsEquipmentPos(dst))
    {
        // change item amount before check (for unique max count check), provide space for splitted items
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        uint16 dest;
        InventoryResult msg = CanEquipItem(dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        EquipItem(dest, pNewItem, true);
        AutoUnequipOffhandIfNeed();
    }
}

void Player::SwapItem(uint16 src, uint16 dst)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    Item* pDstItem = GetItemByPos(dstbag, dstslot);

    /// If we want to swap the same item it is useless.
    if (pSrcItem == pDstItem)
        return;

    if (!pSrcItem)
        return;

    uint8 l_RemoveSlot = PLAYER_SLOT_END;
    bool l_Bypass = false;
    Item* l_DestArtifact = nullptr;
    if (dstbag == INVENTORY_SLOT_BAG_0 && (dstslot == EQUIPMENT_SLOT_MAINHAND || dstslot == EQUIPMENT_SLOT_OFFHAND))
    {
        if (pSrcItem->IsArtifactOrArtifactChild(this))
        {
            Item* l_OtherHandItem;

            if (dstslot == EQUIPMENT_SLOT_MAINHAND)
                l_OtherHandItem = GetItemByPos(dstbag, EQUIPMENT_SLOT_OFFHAND);

            if (dstslot == EQUIPMENT_SLOT_OFFHAND)
                l_OtherHandItem = GetItemByPos(dstbag, EQUIPMENT_SLOT_MAINHAND);

            if (pDstItem && pDstItem->IsArtifactOrArtifactChild(this))
            {
                if (pDstItem->HasFlag(EItemFields::ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                {
                    l_DestArtifact = GetItemByGuid(pDstItem->GetGuidValue(ITEM_FIELD_CREATOR));
                    l_RemoveSlot = l_DestArtifact->GetSlot();
                }
                else
                    l_DestArtifact = pDstItem;
            }
            else if (l_OtherHandItem && l_OtherHandItem->IsArtifactOrArtifactChild(this))
            {
                l_DestArtifact = l_OtherHandItem;
                l_RemoveSlot = (dstslot == EQUIPMENT_SLOT_MAINHAND) ? EQUIPMENT_SLOT_OFFHAND : EQUIPMENT_SLOT_MAINHAND;
            }

            if (l_DestArtifact)
            {
                if (l_DestArtifact->GetChildItem())
                    AutoUnequipChildItem(l_DestArtifact);
                l_Bypass = true;
            }
        }
    }

    if (!l_Bypass)
    {
        if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
        {
            if (Item* parentItem = GetItemByGuid(pSrcItem->GetGuidValue(ITEM_FIELD_CREATOR)))
            {
                if (IsEquipmentPos(src))
                {
                    AutoUnequipChildItem(parentItem);   // we need to unequip child first since it cannot go into whatever is going to happen next
                    SwapItem(dst, src);                 // src is now empty
                    SwapItem(parentItem->GetPos(), dst);// dst is now empty
                    return;
                }
            }
        }
        else if (pDstItem && pDstItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
        {
            if (Item* parentItem = GetItemByGuid(pDstItem->GetGuidValue(ITEM_FIELD_CREATOR)))
            {
                if (IsEquipmentPos(dst))
                {
                    if (GetChildItemByGuid(parentItem->GetChildItem()) != pDstItem)
                    {
                        sLog->outAshran("Player::SwapItem: Infinite loop reason found. Player guid %u", GetGUIDLow());
                        return;
                    }

                    AutoUnequipChildItem(parentItem, true);   // we need to unequip child first since it cannot go into whatever is going to happen next
                    sLog->outAshran("SwapItem:: Dest Item = %u", GetItemByPos(dst) ? GetItemByPos(dst)->GetEntry() : 0);
                    SwapItem(src, dst);                 // dst is now empty
                    SwapItem(parentItem->GetPos(), src);// src is now empty
                    return;
                }
            }
        }

        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SwapItem bag = %u, slot = %u, item = %u", dstbag, dstslot, pSrcItem->GetEntry());

        if (!isAlive())
        {
            SendEquipError(EQUIP_ERR_PLAYER_DEAD, pSrcItem, pDstItem);
            return;
        }

        // close gossips
        PlayerTalkClass->ClearMenus();
        PlayerTalkClass->SendCloseGossip();

        // SRC checks
        if (pSrcItem->m_lootGenerated)                           // prevent swap looting item
        {
            //best error message found for attempting to swap while looting
            SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pSrcItem, NULL);
            return;
        }

        // check unequip potability for equipped items and bank bags
        if (IsEquipmentPos(src) || IsBagPos(src))
        {
            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
            InventoryResult msg = CanUnequipItem(src, !IsBagPos(src) || IsBagPos(dst) || (pDstItem && pDstItem->ToBag() && pDstItem->ToBag()->IsEmpty()));
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, pDstItem);
                return;
            }
            RemoveAuraDependentItem(pSrcItem);
        }

        // prevent put equipped/bank bag in self
        if (IsBagPos(src) && srcslot == dstbag)
        {
            SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
            return;
        }

        // prevent equipping bag in the same slot from its inside
        if (IsBagPos(dst) && srcbag == dstslot)
        {
            SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
            return;
        }

        //! If trading
        if (TradeData* tradeData = GetTradeData())
        {
            //! If current item is in trade window (only possible with packet spoofing - silent return)
            if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
                TradeCancel(true);
        }

        // DST checks
        if (pDstItem)
        {
            if (pDstItem->m_lootGenerated)                       // prevent swap looting item
            {
                //best error message found for attempting to swap while looting
                SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pDstItem, NULL);
                return;
            }

            // check unequip potability for equipped items and bank bags
            if (IsEquipmentPos(dst) || IsBagPos(dst))
            {
                // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
                InventoryResult msg = CanUnequipItem(dst, !IsBagPos(dst) || IsBagPos(src) || (pSrcItem->ToBag() && pSrcItem->ToBag()->IsEmpty()));
                if (msg != EQUIP_ERR_OK)
                {
                    SendEquipError(msg, pSrcItem, pDstItem);
                    return;
                }
            }
        }

        // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
        // or swap empty bag with another empty or not empty bag (with items exchange)

        // Move case
        if (!pDstItem)
        {
            if (IsInventoryPos(dst))
            {
                ItemPosCountVec dest;
                InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pSrcItem, false);
                if (msg != EQUIP_ERR_OK)
                {
                    SendEquipError(msg, pSrcItem, NULL);
                    return;
                }
                RemoveItem(srcbag, srcslot, true);
                StoreItem(dest, pSrcItem, true);
                if (IsBankPos(src))
                    ItemAddedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
            }
            else if (IsBankPos(dst))
            {
                ItemPosCountVec dest;
                InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pSrcItem, false);
                if (msg != EQUIP_ERR_OK)
                {
                    SendEquipError(msg, pSrcItem, NULL);
                    return;
                }

                RemoveItem(srcbag, srcslot, true);
                BankItem(dest, pSrcItem, true);
                ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
            }
            else if (IsReagentBankPos(dst))
            {
                ItemPosCountVec dest;
                InventoryResult msg = CanReagentBankItem(dstbag, dstslot, dest, pSrcItem, false);
                if (msg != EQUIP_ERR_OK)
                {
                    SendEquipError(msg, pSrcItem, NULL);
                    return;
                }

                RemoveItem(srcbag, srcslot, true);
                BankItem(dest, pSrcItem, true);
                ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
            }
            else if (IsEquipmentPos(dst))
            {
                if (pSrcItem->ToBag() && GetTrader())
                {
                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, NULL);
                    return;
                }

                uint16 dest;
                InventoryResult msg = CanEquipItem(dstslot, dest, pSrcItem, false);

                if (msg == EQUIP_ERR_OK && IsEquipmentPos(dst) && pSrcItem->GetChildItem())
                    msg = CanEquipChildItem(pSrcItem);

                if (msg != EQUIP_ERR_OK)
                {
                    SendEquipError(msg, pSrcItem, NULL);
                    return;
                }

                RemoveItem(srcbag, srcslot, true);
                EquipItem(dest, pSrcItem, true);

                if (pSrcItem->GetChildItem())
                    EquipChildItem(srcbag, srcslot, pSrcItem);

                AutoUnequipOffhandIfNeed();
            }

            // Assassin's Resolve - 84601
            if (getClass() == CLASS_ROGUE && GetActiveSpecializationID() == SPEC_ROGUE_ASSASSINATION)
            {
                Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
                Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

                if (((mainItem && mainItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER) || (offItem && offItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)))
                {
                    if (HasAura(84601))
                        RemoveAura(84601);

                    CastSpell(this, 84601, true);
                }
                else
                    RemoveAura(84601);
            }

            return;
        }

        // attempt merge to / fill target item
        if (!pSrcItem->IsBag() && !pDstItem->IsBag())
        {
            InventoryResult msg;
            ItemPosCountVec sDest;
            uint16 eDest = 0;
            if (IsInventoryPos(dst))
                msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
            else if (IsBankPos(dst))
                msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, false);
            else if (IsReagentBankPos(dst))
                msg = CanReagentBankItem(dstbag, dstslot, sDest, pSrcItem, false);
            else if (IsEquipmentPos(dst))
                msg = CanEquipItem(dstslot, eDest, pSrcItem, false);
            else
                return;

            if (msg == EQUIP_ERR_OK && IsEquipmentPos(dst) && pSrcItem->GetChildItem())
                msg = CanEquipChildItem(pSrcItem);

            // can be merge/fill
            if (msg == EQUIP_ERR_OK)
            {
                if (pSrcItem->GetCount() + pDstItem->GetCount() <= pSrcItem->GetTemplate()->GetMaxStackSize())
                {
                    RemoveItem(srcbag, srcslot, true);

                    if (IsInventoryPos(dst))
                        StoreItem(sDest, pSrcItem, true);
                    else if (IsBankPos(dst))
                        BankItem(sDest, pSrcItem, true);
                    else if (IsReagentBankPos(dst))
                        BankItem(sDest, pSrcItem, true);
                    else if (IsEquipmentPos(dst))
                    {
                        EquipItem(eDest, pSrcItem, true);

                        if (pSrcItem->GetChildItem())
                            EquipChildItem(srcbag, srcslot, pSrcItem);

                        AutoUnequipOffhandIfNeed();
                    }
                }
                else
                {
                    pSrcItem->SetCount(pSrcItem->GetCount() + pDstItem->GetCount() - pSrcItem->GetTemplate()->GetMaxStackSize());
                    pDstItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
                    pSrcItem->SetState(ITEM_CHANGED, this);
                    pDstItem->SetState(ITEM_CHANGED, this);
                    if (IsInWorld())
                    {
                        pSrcItem->SendUpdateToPlayer(this);
                        pDstItem->SendUpdateToPlayer(this);
                    }
                }
                SendRefundInfo(pDstItem);
                return;
            }
        }
    }

    // impossible merge/fill, do real swap
    InventoryResult msg = EQUIP_ERR_OK;

    // check src->dest move possibility
    ItemPosCountVec sDest;
    uint16 eDest = 0;
    if (IsInventoryPos(dst))
        msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsReagentBankPos(dst))
        msg = CanReagentBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        msg = CanEquipItem(dstslot, eDest, pSrcItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest, true);
    }

    if (msg == EQUIP_ERR_OK && IsEquipmentPos(dst) && pSrcItem->GetChildItem() && !l_Bypass)
        msg = CanEquipChildItem(pSrcItem);

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pSrcItem, pDstItem);
        return;
    }

    // check dest->src move possibility
    ItemPosCountVec sDest2;
    uint16 eDest2 = 0;
    Item* l_RealDestItem = l_DestArtifact ? l_DestArtifact : pDstItem;
    if (IsInventoryPos(src))
        msg = CanStoreItem(srcbag, srcslot, sDest2, l_RealDestItem, true);
    else if (IsBankPos(src))
        msg = CanBankItem(srcbag, srcslot, sDest2, l_RealDestItem, true);
    else if (IsReagentBankPos(src))
        msg = CanReagentBankItem(srcbag, srcslot, sDest2, l_RealDestItem, true);
    else if (IsEquipmentPos(src))
    {
        msg = CanEquipItem(srcslot, eDest2, l_RealDestItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest2, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pDstItem, pSrcItem);
        return;
    }

    // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
    if (Bag* srcBag = pSrcItem->ToBag())
    {
        if (Bag* dstBag = (pDstItem ? pDstItem->ToBag() : nullptr))
        {
            if (GetTrader())
            {
                SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                return;
            }

            Bag* emptyBag = NULL;
            Bag* fullBag = NULL;
            if (srcBag->IsEmpty() && !IsBagPos(src))
            {
                emptyBag = srcBag;
                fullBag  = dstBag;
            }
            else if (dstBag->IsEmpty() && !IsBagPos(dst))
            {
                emptyBag = dstBag;
                fullBag  = srcBag;
            }

            // bag swap (with items exchange) case
            if (emptyBag && fullBag)
            {
                ItemTemplate const* emptyProto = emptyBag->GetTemplate();

                uint32 count = 0;

                for (uint32 i=0; i < fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    ItemTemplate const* bagItemProto = bagItem->GetTemplate();
                    if (!bagItemProto || !ItemCanGoIntoBag(bagItemProto, emptyProto))
                    {
                        // one from items not go to empty target bag
                        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
                        return;
                    }

                    ++count;
                }

                if (count > emptyBag->GetBagSize())
                {
                    // too small targeted bag
                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                    return;
                }

                // Items swap
                count = 0;                                      // will pos in new bag
                for (uint32 i = 0; i< fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    fullBag->RemoveItem(i, true);
                    emptyBag->StoreItem(count, bagItem, true);
                    bagItem->SetState(ITEM_CHANGED, this);

                    ++count;
                }
            }
        }
    }

    // now do moves, remove...
    RemoveItem(dstbag, l_RemoveSlot != PLAYER_SLOT_END ? l_RemoveSlot : dstslot, (l_RemoveSlot != dstslot && l_RemoveSlot != PLAYER_SLOT_END) ? true : false);
    RemoveItem(srcbag, srcslot, false);

    // add to dest
    if (IsInventoryPos(dst))
        StoreItem(sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        BankItem(sDest, pSrcItem, true);
    else if (IsReagentBankPos(dst))
        BankItem(sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        EquipItem(eDest, pSrcItem, true);
        //if (pSrcItem->GetChildItem())
        //    EquipChildItem(srcbag, srcslot, pSrcItem);
    }

    // add to src
    if (IsInventoryPos(src))
        StoreItem(sDest2, l_RealDestItem, true);
    else if (IsBankPos(src))
        BankItem(sDest2, l_RealDestItem, true);
    else if (IsReagentBankPos(src))
        BankItem(sDest2, l_RealDestItem, true);
    else if (IsEquipmentPos(src))
    {
        EquipItem(eDest2, l_RealDestItem, true);
        //if (pDstItem && pDstItem->GetChildItem())
        //    EquipChildItem(dstbag, dstslot, l_RealDestItem);
    }

    // Process child items here to prevent bugs
    {
        if (IsEquipmentPos(dst) && pSrcItem->GetChildItem())
            EquipChildItem(srcbag, srcslot, pSrcItem);

        if (IsEquipmentPos(src) && pDstItem && pDstItem->GetChildItem())
            EquipChildItem(dstbag, dstslot, l_RealDestItem);
    }

    // if player is moving bags and is looting an item inside this bag
    // release the loot
    if (GetLootGUID())
    {
        bool released = false;
        if (IsBagPos(src))
        {
            Bag* bag = pSrcItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // so we don't need to look at dstBag
                        break;
                    }
                }
            }
        }

        if (!released && IsBagPos(dst) && pDstItem)
        {
            Bag* bag = pDstItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // not realy needed here ///< yeah because released is never read 01/18/16
                        break;
                    }
                }
            }
        }
    }
    AutoUnequipOffhandIfNeed();
}

void Player::AddItemToBuyBackSlot(Item* pItem)
{
    if (pItem)
    {
        uint32 slot = m_currentBuybackSlot;
        // if current back slot non-empty search oldest or free
        if (m_items[slot])
        {
            uint32 oldest_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP);
            uint32 oldest_slot = BUYBACK_SLOT_START;

            for (uint32 i = BUYBACK_SLOT_START+1; i < BUYBACK_SLOT_END; ++i)
            {
                // found empty
                if (!m_items[i])
                {
                    slot = i; ///< slot is never read 01/18/16
                    break;
                }

                uint32 i_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + i - BUYBACK_SLOT_START);

                if (oldest_time > i_time)
                {
                    oldest_time = i_time;
                    oldest_slot = i;
                }
            }

            // find oldest
            slot = oldest_slot;
        }

        RemoveItemFromBuyBackSlot(slot, true);
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: AddItemToBuyBackSlot item = %u, slot = %u", pItem->GetEntry(), slot);

        for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        {
            if (m_items[i] == pItem)
            {
                ACE_Stack_Trace trace;
                sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
            }
        }
        m_items[slot] = pItem;
        time_t base = time(NULL);
        uint32 etime = uint32(base - m_logintime + (30 * 3600));
        uint32 eslot = slot - BUYBACK_SLOT_START;

        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (BUYBACK_SLOT_START * 4) + (eslot * 4), pItem->GetGUID());
        if (ItemTemplate const* proto = pItem->GetTemplate())
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, proto->SellPrice * pItem->GetCount());
        else
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, (uint32)etime);

        // move to next (for non filled list is move most optimized choice)
        if (m_currentBuybackSlot < BUYBACK_SLOT_END - 1)
            ++m_currentBuybackSlot;
    }
}

Item* Player::GetItemFromBuyBackSlot(uint32 slot)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: GetItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
        return m_items[slot];
    return NULL;
}

void Player::RemoveItemFromBuyBackSlot(uint32 slot, bool del)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
    {
        Item* pItem = m_items[slot];
        if (pItem)
        {
            pItem->RemoveFromWorld();
            if (del)
            {
                if (pItem->GetEntry() == 138019)
                    sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (4)");
                pItem->SetState(ITEM_REMOVED, this);
            }
        }

        m_items[slot] = NULL;

        uint32 eslot = slot - BUYBACK_SLOT_START;
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (BUYBACK_SLOT_START * 4) + (slot * 4), 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, 0);

        // if current backslot is filled set to now free slot
        if (m_items[m_currentBuybackSlot])
            m_currentBuybackSlot = slot;
    }
}

void Player::SendEquipError(InventoryResult p_BagResult, Item* p_ItemA, Item* p_ItemB, uint32 itemid)
{
    if (p_BagResult != EQUIP_ERR_OK)
    {
        WorldPacket l_Data(SMSG_INVENTORY_CHANGE_FAILURE, 100);
        l_Data << uint8(p_BagResult);
        l_Data.appendPackGUID(p_ItemA ? p_ItemA->GetGUID() : 0);
        l_Data.appendPackGUID(p_ItemB ? p_ItemB->GetGUID() : 0);
        l_Data << uint8(0);                                   // bag type subclass, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2

        switch (p_BagResult)
        {
            case InventoryResult::EQUIP_ERR_CANT_EQUIP_LEVEL_I:
            case InventoryResult::EQUIP_ERR_PURCHASE_LEVEL_TOO_LOW:
            {
                ItemTemplate const* l_ItemTemplate = p_ItemA ? p_ItemA->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);

                if (p_ItemA)
                    l_Data << int32(p_ItemA->GetRequiredLevel());
                else if (l_ItemTemplate)
                    l_Data << int32(l_ItemTemplate->RequiredLevel);
                else
                    l_Data << int32(0);

                break;
            }

            case InventoryResult::EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM:

                l_Data.appendPackGUID(0); ///< SrcContainer
                l_Data << int32(0);       ///< SrcSlot
                l_Data.appendPackGUID(0); ///<data << DstContainer
                break;

            case InventoryResult::EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS:
            case InventoryResult::EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED_IS:
            case InventoryResult::EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS:
            {
                ItemTemplate const* l_ItemTemplate = p_ItemA ? p_ItemA->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
                l_Data << int32(l_ItemTemplate ? l_ItemTemplate->ItemLimitCategory : 0);
                break;
            }

            default:
                break;
        }

        GetSession()->SendPacket(&l_Data);
    }
}

void Player::SendBuyError(BuyResult msg, Creature* creature, uint32 item, uint32 /*param*/)
{
    WorldPacket data(SMSG_BUY_FAILED, (8+4+4+1));
    ObjectGuid guid = creature ? creature->GetGUID() : 0;

    data.appendPackGUID(guid);
    data << uint32(item);
    data << uint8(msg);

    GetSession()->SendPacket(&data);
}

void Player::SendSellError(SellResult msg, Creature* creature, uint64 guid)
{
    ObjectGuid itemGuid = guid;
    ObjectGuid npcGuid = creature ? creature->GetGUID() : 0;
    WorldPacket data(SMSG_SELL_ITEM);

    data.appendPackGUID(npcGuid);
    data.appendPackGUID(itemGuid);
    data << uint8(msg);

    GetSession()->SendPacket(&data);
}

void Player::TradeCancel(bool sendback)
{
    if (m_trade)
    {
        Player* trader = m_trade->GetTrader();

        // send yellow "Trade canceled" message to both traders
        if (sendback)
            GetSession()->SendCancelTrade();

        trader->GetSession()->SendCancelTrade();

        // cleanup
        delete m_trade;
        m_trade = NULL;
        delete trader->m_trade;
        trader->m_trade = NULL;
    }
}

void Player::UpdateSoulboundTradeItems()
{
    if (m_itemSoulboundTradeable.empty())
        return;

    // also checks for garbage data
    for (ItemDurationList::iterator itr = m_itemSoulboundTradeable.begin(); itr != m_itemSoulboundTradeable.end();)
    {
        ASSERT(*itr);
        if ((*itr)->GetOwnerGUID() != GetGUID())
        {
            m_itemSoulboundTradeable.erase(itr++);
            continue;
        }
        if ((*itr)->CheckSoulboundTradeExpire())
        {
            m_itemSoulboundTradeable.erase(itr++);
            continue;
        }
        ++itr;
    }
}

void Player::AddTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.push_back(item);
}

//TODO: should never allow an item to be added to m_itemSoulboundTradeable twice
void Player::RemoveTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.remove(item);
}

void Player::UpdateItemDuration(uint32 time, bool realtimeonly)
{
    if (m_itemDuration.empty())
        return;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Player::UpdateItemDuration(%u, %u)", time, realtimeonly);

    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end();)
    {
        Item* item = *itr;
        ++itr;                                              // current element can be erased in UpdateDuration

        if (!realtimeonly || item->GetTemplate()->Flags & int32(ItemFlags::REAL_DURATION))
            item->UpdateDuration(this, time);
    }
}

void Player::UpdateEnchantTime(uint32 time)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr=next)
    {
        ASSERT(itr->item);
        next = itr;
        if (!itr->item->GetEnchantmentId(itr->slot))
        {
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration <= time)
        {
            ApplyEnchantment(itr->item, itr->slot, false, false);
            itr->item->ClearEnchantment(itr->slot);
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration > time)
        {
            itr->leftduration -= time;
            ++next;
        }
    }
}

void Player::AddEnchantmentDurations(Item* item)
{
    for (int x = 0; x < MAX_ENCHANTMENT_SLOT; ++x)
    {
        if (x > ENGINEERING_ENCHANTMENT_SLOT && x < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        if (!item->GetEnchantmentId(EnchantmentSlot(x)))
            continue;

        uint32 duration = item->GetEnchantmentDuration(EnchantmentSlot(x));
        if (duration > 0)
            AddEnchantmentDuration(item, EnchantmentSlot(x), duration);
    }
}

void Player::RemoveEnchantmentDurations(Item* item)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end();)
    {
        if (itr->item == item)
        {
            // save duration in item
            item->SetEnchantmentDuration(EnchantmentSlot(itr->slot), itr->leftduration, this);
            itr = m_enchantDuration.erase(itr);
        }
        else
            ++itr;
    }
}

void Player::RemoveArenaEnchantments(EnchantmentSlot slot)
{
    // remove enchantments from equipped items first to clean up the m_enchantDuration list
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr = next)
    {
        next = itr;
        if (itr->slot == slot)
        {
            if (itr->item && itr->item->GetEnchantmentId(slot))
            {
                // Poisons and DK runes are enchants which are allowed on arenas
                if (sSpellMgr->IsArenaAllowedEnchancment(itr->item->GetEnchantmentId(slot)))
                {
                    ++next;
                    continue;
                }
                // remove from stats
                ApplyEnchantment(itr->item, slot, false, false);
                // remove visual
                itr->item->ClearEnchantment(slot);
            }
            // remove from update list
            next = m_enchantDuration.erase(itr);
        }
        else
            ++next;
    }

    // remove enchants from inventory items
    // NOTE: no need to remove these from stats, since these aren't equipped
    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEnchantmentId(slot))
                pItem->ClearEnchantment(slot);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEnchantmentId(slot))
                        pItem->ClearEnchantment(slot);
}

// duration == 0 will remove item enchant
void Player::AddEnchantmentDuration(Item* item, EnchantmentSlot slot, uint32 duration)
{
    if (!item)
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
    {
        if (itr->item == item && itr->slot == slot)
        {
            itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
            m_enchantDuration.erase(itr);
            break;
        }
    }
    if (item && duration > 0)
    {
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), item->GetGUID(), slot, uint32(duration/1000));
        m_enchantDuration.push_back(EnchantDuration(item, slot, duration));
    }
}

void Player::ApplyEnchantment(Item* item, bool apply)
{
    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
        ApplyEnchantment(item, EnchantmentSlot(slot), apply);

    //ApplyItemUpgrade(item, apply);
}

void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
{
    if (!item || !item->IsEquipped())
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    uint32 enchant_id = item->GetEnchantmentId(slot);
    if (!enchant_id)
        return;

    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
    if (!pEnchant)
        return;

    if (!ignore_condition && pEnchant->ConditionID && !EnchantmentFitsRequirements(pEnchant->ConditionID, -1))
        return;

    if (pEnchant->requiredLevel > getLevel())
        return;

    if (pEnchant->requiredSkill > 0 && pEnchant->requiredSkillValue > GetSkillValue(pEnchant->requiredSkill))
        return;

    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3))
    {
        if (!item->GetSocketColor(slot - SOCK_ENCHANTMENT_SLOT))
        {
            SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
            if (!pPrismaticEnchant || (pPrismaticEnchant->requiredSkill > 0 && pPrismaticEnchant->requiredSkillValue > GetSkillValue(pPrismaticEnchant->requiredSkill)))
                return;
        }

        if (ItemDynamicFieldGems const* gem = item->GetGem(uint16(slot - SOCK_ENCHANTMENT_SLOT)))
            if (ItemTemplate const* gemTemplate = sObjectMgr->GetItemTemplate(gem->ItemId))
                if (gemTemplate->RequiredSkill && GetSkillValue(gemTemplate->RequiredSkill) < gemTemplate->RequiredSkillRank)
                    return;
    }

    if (!item->CantBeUse())
    {
        for (int s = 0; s < MAX_ENCHANTMENT_SPELLS; ++s)
        {
            uint32 enchant_display_type = pEnchant->type[s];
            uint32 enchant_amount = CalculateEnchantmentBonus(pEnchant, pEnchant->amount[s], s, getLevel());
            uint32 enchant_spell_id = pEnchant->spellid[s];

            switch (enchant_display_type)
            {
                case ITEM_ENCHANTMENT_TYPE_NONE:
                    break;
                case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
                    // processed in Player::CastItemCombatSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND && (
                        item->GetTemplate()->InventoryType == INVTYPE_RANGED || item->GetTemplate()->InventoryType == INVTYPE_THROWN ||
                        item->GetTemplate()->InventoryType == INVTYPE_RANGEDRIGHT))
                        HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
                    if (enchant_spell_id)
                    {
                        if (apply)
                        {
                            int32 basepoints = 0;
                            // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
                            if (item->GetItemRandomPropertyId() < 0)
                            {
                                ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                                if (item_rand)
                                {
                                    // Search enchant_amount
                                    for (int k = 0; k < 5; ++k)
                                    {
                                        if (item_rand->Enchantment[k] == enchant_id)
                                        {
                                            basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                            break;
                                        }
                                    }
                                }
                            }
                            // Cast custom spell vs all equal basepoints got from enchant_amount
                            if (basepoints)
                                CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
                            else
                                CastSpell(this, enchant_spell_id, true, item);
                        }
                        else
                            RemoveAurasDueToItemSpell(item, enchant_spell_id);
                    }
                    break;
                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:

                    if (pEnchant->m_ScalingClass)
                    {
                        int32 scalingClass = pEnchant->m_ScalingClass;
                        if ((GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL) || GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL)) && pEnchant->m_ScalingClassRestricted)
                            scalingClass = pEnchant->m_ScalingClassRestricted;

                        uint8 minLevel = pEnchant->Flags & 0x20 ? 1 : 60;
                        uint8 scalingLevel = getLevel();
                        uint8 maxLevel = uint8(pEnchant->m_MaxLevel ? pEnchant->m_MaxLevel : GT_MAX_LEVEL);

                        if (minLevel > getLevel())
                            scalingLevel = minLevel;
                        else if (maxLevel < getLevel())
                            scalingLevel = maxLevel;

                        if (SpellScalingTableEntry const* l_SpellScaling = g_SpellScalingTable.LookupEntry(scalingLevel))
                            enchant_amount = round(pEnchant->m_EffectScalingPoints[s] * GetSpellScalingColumnForClass(l_SpellScaling, scalingClass));
                     }

                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand)
                        {
                            for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
                            {
                                if (item_rand->Enchantment[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_STAT:
                {
                    if (pEnchant->m_ScalingClass)
                    {
                        int32 scalingClass = pEnchant->m_ScalingClass;
                        if ((GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL) || GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL)) && pEnchant->m_ScalingClassRestricted)
                            scalingClass = pEnchant->m_ScalingClassRestricted;

                        uint8 minLevel = pEnchant->Flags & 0x20 ? 1 : 60;
                        uint8 scalingLevel = getLevel();
                        uint8 maxLevel = uint8(pEnchant->m_MaxLevel ? pEnchant->m_MaxLevel : GT_MAX_LEVEL);

                        if (minLevel > getLevel())
                            scalingLevel = minLevel;
                        else if (maxLevel < getLevel())
                            scalingLevel = maxLevel;

                        if (SpellScalingTableEntry const* l_SpellScaling = g_SpellScalingTable.LookupEntry(scalingLevel))
                            enchant_amount = round(pEnchant->m_EffectScalingPoints[s] * GetSpellScalingColumnForClass(l_SpellScaling, scalingClass));
                     }

                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand_suffix)
                        {
                            for (int k = 0; k < 5; ++k)
                            {
                                if (item_rand_suffix->Enchantment[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand_suffix->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
                    switch (enchant_spell_id)
                    {
                        case int32(ItemModType::MANA):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case int32(ItemModType::HEALTH):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case int32(ItemModType::AGILITY):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u AGILITY", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
                            break;
                        case int32(ItemModType::STRENGTH):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STRENGTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
                            break;
                        case int32(ItemModType::INTELLECT):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u INTELLECT", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
                            break;
                        case int32(ItemModType::STAMINA):
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STAMINA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
                            break;
                        case int32(ItemModType::DODGE_RATING):
                            ApplyRatingMod(CR_DODGE, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u DODGE", enchant_amount);
                            break;
                        case int32(ItemModType::PARRY_RATING):
                            ApplyRatingMod(CR_PARRY, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u PARRY", enchant_amount);
                            break;
                        case int32(ItemModType::BLOCK_RATING):
                            ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SHIELD_BLOCK", enchant_amount);
                            break;
                        case int32(ItemModType::CRIT_RATING):
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u CRITICAL", enchant_amount);
                            break;
                        case int32(ItemModType::RESILIENCE_RATING):
                            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RESILIENCE", enchant_amount);
                            break;
                        case int32(ItemModType::HASTE_RATING):
                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HASTE", enchant_amount);
                            break;
                        case int32(ItemModType::ATTACK_POWER):
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ATTACK_POWER", enchant_amount);
                            break;
                        case int32(ItemModType::VERSATILITY):
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, enchant_amount, apply);
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u VERSATILITY", enchant_amount);
                            break;
                        case int32(ItemModType::MANA_REGENERATION):
                            ApplyManaRegenBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA_REGENERATION", enchant_amount);
                            break;
                        case int32(ItemModType::SPELL_POWER):
                            ApplySpellPowerBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_POWER", enchant_amount);
                            break;
                        case int32(ItemModType::HEALTH_REGEN):
                            ApplyHealthRegenBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH_REGENERATION", enchant_amount);
                            break;
                        case int32(ItemModType::MASTERY_RATING):
                            ApplyRatingMod(CR_MASTERY, int32(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MASTERY_RATING", enchant_amount);
                            break;
                        case int32(ItemModType::FIRE_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u FIRE RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::FROST_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u FROST RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::HOLY_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HOLY RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::SHADOW_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SHADOW RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::NATURE_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u NATURE RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::ARCANE_RESISTANCE):
                            HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ARCANE RESISTANCE", enchant_amount);
                            break;
                        case int32(ItemModType::PVP_POWER):
                            ApplyRatingMod(CR_PVP_POWER, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u PVP POWER", enchant_amount);
                            break;
                        case int32(ItemModType::AGILITY_OR_STRENGTH_OR_INTELLECT):
                        {
                            Stats stat = GetPrimaryStat();
                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case int32(ItemModType::AGILITY_OR_STRENGTH):
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_AGILITY && stat != STAT_STRENGTH)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case int32(ItemModType::AGILITY_OR_INTELLECT):
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_AGILITY && stat != STAT_INTELLECT)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case int32(ItemModType::STRENGTH_OR_INTELLECT):
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_INTELLECT && stat != STAT_STRENGTH)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
                {
                    if (getClass() == CLASS_SHAMAN)
                    {
                        float addValue = 0.0f;
                        if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
                        }
                        else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
                        }
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_ARTIFACT_POWER_BONUS_RANK_BY_TYPE:
                    if (MS::Artifact::Manager* l_Artifact = GetCurrentlyEquippedArtifact())
                        l_Artifact->UpdatePowerBonusRankByType(pEnchant->spellid[s], pEnchant->amount[s], apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_ARTIFACT_POWER_BONUS_RANK_BY_ID:
                    if (MS::Artifact::Manager* l_Artifact = GetCurrentlyEquippedArtifact())
                        l_Artifact->UpdatePowerBonusRankById(pEnchant->spellid[s], pEnchant->amount[s], apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
                    // processed in Player::CastItemUseSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
                    // nothing do..
                    break;
                case ITEM_ENCHANTMENT_TYPE_BONUS_LIST_ID:
                case ITEM_ENCHANTMENT_TYPE_BONUS_LIST_CURVE:
                    break;
                default:
                    sLog->outError(LOG_FILTER_PLAYER, "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
                    break;
            }                                               /*switch (enchant_display_type)*/
        }                                                   /*for*/
    }

    // visualize enchantment at player and equipped items
    if (slot == PERM_ENCHANTMENT_SLOT || slot == TEMP_ENCHANTMENT_SLOT)
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (item->GetSlot() * 2) + 1, 1, item->GetVisibleItemVisual(this));

    if (apply_dur)
    {
        if (apply)
        {
            // set duration
            uint32 duration = item->GetEnchantmentDuration(slot);
            if (duration > 0)
                AddEnchantmentDuration(item, slot, duration);
        }
        else
        {
            // duration == 0 will remove EnchantDuration
            AddEnchantmentDuration(item, slot, 0);
        }
    }
}

void Player::UpdateSkillEnchantments(uint16 skill_id, uint16 curr_value, uint16 new_value)
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            for (uint8 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
            {
                if (slot > ENGINEERING_ENCHANTMENT_SLOT && slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
                    continue;

                uint32 ench_id = m_items[i]->GetEnchantmentId(EnchantmentSlot(slot));
                if (!ench_id)
                    continue;

                SpellItemEnchantmentEntry const* Enchant = sSpellItemEnchantmentStore.LookupEntry(ench_id);
                if (!Enchant)
                    return;

                if (Enchant->requiredSkill == skill_id)
                {
                    // Checks if the enchantment needs to be applied or removed
                    if (curr_value < Enchant->requiredSkillValue && new_value >= Enchant->requiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                    else if (new_value < Enchant->requiredSkillValue && curr_value >= Enchant->requiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                }

                // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
                // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
                if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
                    && !m_items[i]->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
                {
                    SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(m_items[i]->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));

                    if (pPrismaticEnchant && pPrismaticEnchant->requiredSkill == skill_id)
                    {
                        if (curr_value < pPrismaticEnchant->requiredSkillValue && new_value >= pPrismaticEnchant->requiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                        else if (new_value < pPrismaticEnchant->requiredSkillValue && curr_value >= pPrismaticEnchant->requiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                    }
                }
            }
        }
    }
}

void Player::SendEnchantmentDurations()
{
    for (EnchantDurationList::const_iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), itr->item->GetGUID(), itr->slot, uint32(itr->leftduration) / 1000);
}

void Player::SendItemDurations()
{
    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
        (*itr)->SendTimeUpdate(this);
}

void Player::SendDisplayToast(uint32 p_Entry, uint32 p_Count, uint32 p_Args, DisplayToastMethod p_Method, ToastTypes p_Type, bool p_BonusRoll, bool p_Mailed, std::vector<uint32> const& p_ItemBonus)
{
    ItemTemplate const* l_ItemTpl = sObjectMgr->GetItemTemplate(p_Entry);

    if (!l_ItemTpl && p_Entry && p_Type == TOAST_TYPE_NEW_ITEM)
        return;

    WorldPacket l_Data(SMSG_DISPLAY_TOAST, 30);
    l_Data << uint64(p_Count);
    l_Data << uint8(p_Method);                  ///< DisplayToastMethod
    l_Data << uint32(p_Type == TOAST_TYPE_MONEY ? 0 : p_Count);

    l_Data.WriteBit(p_BonusRoll);               ///< Bonuses
    l_Data.WriteBits(p_Type, 2);                ///< Context

    if (p_Type == TOAST_TYPE_NEW_ITEM)
    {
        l_Data.WriteBit(p_Mailed);
        l_Data.FlushBits();

        Item::BuildDynamicItemDatas(l_Data, p_Entry, p_ItemBonus);

        l_Data << uint32(GetLootSpecId());          ///< LootSpec
        l_Data << uint32(0);                        ///< Quantity
    }
    else
        l_Data.FlushBits();

    if (p_Type == TOAST_TYPE_NEW_CURRENCY)
        l_Data << uint32(p_Entry);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendDisplayToast(Item* p_Item, uint32 p_Count, uint32 p_Args, bool p_BonusRoll /*= true*/, bool p_Mailed /*= false*/)
{
    if (p_Item == nullptr)
        return;

    WorldPacket l_Data(SMSG_DISPLAY_TOAST, 30);
    l_Data << uint64(p_Count);
    l_Data << uint8(DisplayToastMethod::DISPLAY_TOAST_METHOD_LOOT);
    l_Data << uint32(0);

    l_Data.WriteBit(p_BonusRoll);
    l_Data.WriteBits(ToastTypes::TOAST_TYPE_NEW_ITEM, 2);

    l_Data.WriteBit(p_Mailed);
    l_Data.FlushBits();

    Item::BuildDynamicItemDatas(l_Data, p_Item);

    l_Data << uint32(GetLootSpecId());          ///< LootSpec
    l_Data << uint32(0);                        ///< Quantity

    GetSession()->SendPacket(&l_Data);
}

void Player::SendNewItem(Item* p_Item, uint32 p_Quantity, bool p_Received, bool p_Created, bool p_Broadcast, uint32 p_EncounterID /*= 0*/, ItemContext p_Context /*= ItemContext::None*/, bool p_IsBonusRoll /*= false*/)
{
    /// Prevent crash
    if (!p_Item)
        return;

    sScriptMgr->OnPlayerItemLooted(this, p_Item);

    WorldPacket l_Data(Opcodes::SMSG_ITEM_PUSH_RESULT, 16 + 2 + 1 + 4 + 100 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 16 + 2 + 1);

    l_Data.appendPackGUID(GetGUID());                               ///< Player GUID
    l_Data << uint8(p_Item->GetBagSlot());                          ///< Slot

    l_Data << uint32(0);                                            ///< SlotInBag
    l_Data << uint32(0);                                            ///< QuestLogItemID
    l_Data << uint32(p_Quantity);                                   ///< Quantity
    l_Data << uint32(GetItemCount(p_Item->GetEntry()));             ///< QuantityInInventory
    l_Data << uint32(p_EncounterID);                                ///< DungeonEncounterID
    l_Data << uint32(0);                                            ///< BattlePetSpeciesID
    l_Data << uint32(0);                                            ///< BattlePetBreedID
    l_Data << uint32(0);                                            ///< BattlePetBreedQuality
    l_Data << uint32(0);                                            ///< BattlePetLevel
    l_Data.appendPackGUID(p_Item->GetGUID());                       ///< Item GUID

    l_Data.WriteBit(p_Received);                                    ///< Pushed
    l_Data.WriteBit(p_Created);                                     ///< Created
    l_Data.WriteBits(p_EncounterID ? 3 : 1, 3);                     ///< DisplayText
    l_Data.WriteBit(p_IsBonusRoll);                                 ///< IsBonusRoll
    l_Data.WriteBit(p_EncounterID != 0 && !p_IsBonusRoll);          ///< IsEncounterLoot
    l_Data.FlushBits();

    Item::BuildDynamicItemDatas(l_Data, p_Item, p_Context);
    l_Data.FlushBits();

    GroupPtr l_Group = GetGroup();
    if (p_Broadcast && l_Group)
        l_Group->BroadcastPacket(&l_Data, true);
    else
        GetSession()->SendPacket(&l_Data);

#ifndef CROSS
    if (p_Item->GetTemplate()->Flags & (int32)ItemFlags::REPORT_TO_GUILD_CHAT)
    {
        if (Guild* l_Guild = GetGuild())
            l_Guild->SendItemAcquired(this, p_Item);
    }
#endif
}

/*********************************************************/
/***                    GOSSIP SYSTEM                  ***/
/*********************************************************/
void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool showQuests /*= false*/)
{
    PlayerMenu* menu = PlayerTalkClass;
    menu->ClearMenus();

    menu->GetGossipMenu().SetMenuId(menuId);

    GossipMenuItemsMapBounds menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(menuId);

    // if default menuId and no menu options exist for this, use options from default options
    if (menuItemBounds.first == menuItemBounds.second && menuId == GetDefaultGossipMenuForSource(source))
        menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);

    uint32 npcflags = 0;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        npcflags = source->GetUInt32Value(UNIT_FIELD_NPC_FLAGS);
        if (showQuests && npcflags & UNIT_NPC_FLAG_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());
    }

    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
        if (showQuests && source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());

    for (GossipMenuItemsContainer::const_iterator itr = menuItemBounds.first; itr != menuItemBounds.second; ++itr)
    {
        bool canTalk = true;
        if (!sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            continue;

        if (Creature* creature = source->ToCreature())
        {
            if (!(itr->second.OptionNpcflag & npcflags))
                continue;

            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_ARMORER:
                    canTalk = false;                       // added in special mode
                    break;
                case GOSSIP_OPTION_SPIRITHEALER:
                    if (!isDead())
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_VENDOR:
                {
                    VendorItemData const* vendorItems = creature->GetVendorItems();
                    if (!vendorItems || vendorItems->Empty())
                    {
                        sLog->outError(LOG_FILTER_SQL, "Creature %u (Entry: %u) have UNIT_NPC_FLAG_VENDOR but have empty trading item list.", creature->GetGUIDLow(), creature->GetEntry());
                        canTalk = false;
                    }
                    break;
                }
                case GOSSIP_OPTION_TRAINER:
                    if (!creature->isCanTrainingOf(this, false))
                        canTalk = false;
                    break;
                /// dosent exist anymore 7.0.3
                case GOSSIP_OPTION_LEARNDUALSPEC:
                    canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNTALENTS:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNPETTALENTS:
                    if (!GetPet() || GetPet()->getPetType() != HUNTER_PET || GetPet()->m_spells.size() <= 1 || creature->GetCreatureTemplate()->trainer_type != TRAINER_TYPE_PETS || creature->GetCreatureTemplate()->trainer_class != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNSPECIALIZATION:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_TAXIVENDOR:
                    if (GetSession()->SendLearnNewTaxiNode(creature))
                        return;
                    break;
                case GOSSIP_OPTION_BATTLEFIELD:
                    if (!creature->isCanInteractWithBattleMaster(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_STABLEPET:
                    if (getClass() != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_QUESTGIVER:
                    canTalk = false;
                    break;
                case GOSSIP_OPTION_GOSSIP:
                case GOSSIP_OPTION_SPIRITGUIDE:
                case GOSSIP_OPTION_INNKEEPER:
                case GOSSIP_OPTION_BANKER:
                case GOSSIP_OPTION_PETITIONER:
                case GOSSIP_OPTION_TABARDDESIGNER:
                case GOSSIP_OPTION_AUCTIONEER:
                case GOSSIP_OPTION_ADVENTURE_MAP:
                case GOSSIP_OPTION_ARTIFACT_RESPEC:
                    break;                                  // no checks
                case GOSSIP_OPTION_OUTDOORPVP:
                    if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
                        canTalk = false;
                    break;
                default:
                    sLog->outError(LOG_FILTER_SQL, "Creature entry %u have unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuId);
                    canTalk = false;
                    break;
            }
        }
        else if (GameObject* go = source->ToGameObject())
        {
            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_GOSSIP:
                    if (go->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && go->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
                        canTalk = false;
                    break;
                default:
                    canTalk = false;
                    break;
            }
        }

        if (canTalk)
        {
            std::string strOptionText = itr->second.OptionText;
            std::string strBoxText = itr->second.BoxText;

            LocaleConstant locale = GetSession()->GetSessionDbLocaleIndex();
            if (locale >= 0)
            {
                if (BroadcastTextEntry const* l_OptionBroadcastText = sBroadcastTextStore.LookupEntry(itr->second.OptionBroadcastTextID))
                    strOptionText = GetBroadcastTextValue(l_OptionBroadcastText, locale, getGender());
                else if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(MAKE_PAIR64(menuId, itr->second.OptionIndex)))
                    ObjectMgr::GetLocaleString(no->OptionText, locale, strOptionText);

                if (BroadcastTextEntry const* l_BoxBroadcastText = sBroadcastTextStore.LookupEntry(itr->second.BoxBroadcastTextID))
                    strBoxText = GetBroadcastTextValue(l_BoxBroadcastText, locale, getGender());
                else if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(MAKE_PAIR64(menuId, itr->second.OptionIndex)))
                    ObjectMgr::GetLocaleString(no->BoxText, locale, strBoxText);
            }

            menu->GetGossipMenu().AddMenuItem(itr->second.OptionIndex, itr->second.OptionIcon, strOptionText, 0, itr->second.OptionType, strBoxText, itr->second.BoxMoney, itr->second.BoxCoded);
            menu->GetGossipMenu().AddGossipMenuItemData(itr->second.OptionIndex, itr->second.ActionMenuId, itr->second.ActionPoiId);
        }
    }
}

void Player::SendPreparedGossip(WorldObject* source)
{
    if (!source)
        return;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        // in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
        if (!source->ToCreature()->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }
    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        // probably need to find a better way here
        if (!PlayerTalkClass->GetGossipMenu().GetMenuId() && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }

    // in case non empty gossip menu (that not included quests list size) show it
    // (quest entries from quest menu will be included in list)

    uint32 textId = GetGossipTextId(source);

    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
        textId = GetGossipTextId(menuId, source);

    PlayerTalkClass->SendGossipMenu(textId, source->GetGUID());
}

void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 menuId)
{
    GossipMenu& gossipMenu = PlayerTalkClass->GetGossipMenu();

    // if not same, then something funky is going on
    if (menuId != gossipMenu.GetMenuId())
        return;

    GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
    if (!item)
        return;

    uint32 gossipOptionId = item->OptionType;
    uint64 guid = source->GetGUID();

    if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        if (gossipOptionId > GOSSIP_OPTION_QUESTGIVER)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player guid %u request invalid gossip option for GameObject entry %u", GetGUIDLow(), source->GetEntry());
            return;
        }
    }

    GossipMenuItemData const* menuItemData = gossipMenu.GetItemData(gossipListId);
    if (!menuItemData)
        return;

    int32 cost = int32(item->BoxMoney);
    if (!HasEnoughMoney(int64(cost)))
    {
        SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
        PlayerTalkClass->SendCloseGossip();
        return;
    }

    switch (gossipOptionId)
    {
        case GOSSIP_OPTION_GOSSIP:
        {
            if (menuItemData->GossipActionPoi)
                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);

            if (menuItemData->GossipActionMenuId)
            {
                PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
                SendPreparedGossip(source);
            }

            break;
        }
        case GOSSIP_OPTION_OUTDOORPVP:
            sOutdoorPvPMgr->HandleGossipOption(this, source->GetGUID(), gossipListId);
            break;
        case GOSSIP_OPTION_SPIRITHEALER:
            if (isDead())
                source->ToCreature()->CastSpell(source->ToCreature(), 17251, true, NULL, nullptr, GetGUID());
            break;
        case GOSSIP_OPTION_QUESTGIVER:
            PrepareQuestMenu(guid);
            SendPreparedQuest(guid);
            break;
        case GOSSIP_OPTION_VENDOR:
        case GOSSIP_OPTION_ARMORER:
            GetSession()->SendListInventory(guid);
            break;
        case GOSSIP_OPTION_STABLEPET:
            GetSession()->SendStablePet(guid);
            break;
        case GOSSIP_OPTION_TRAINER:
            GetSession()->SendTrainerList(guid);
            break;
        /// dosent exist anymore 7.0.3
        case GOSSIP_OPTION_LEARNDUALSPEC:
            break;
        case GOSSIP_OPTION_UNLEARNTALENTS:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, false);
            break;
        case GOSSIP_OPTION_UNLEARNPETTALENTS:
            PlayerTalkClass->SendCloseGossip();
            //ResetPetTalents();
            break;
         case GOSSIP_OPTION_UNLEARNSPECIALIZATION:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, true);
            break;
        case GOSSIP_OPTION_TAXIVENDOR:
            GetSession()->SendTaxiMenu(source->ToCreature());
            break;
        case GOSSIP_OPTION_INNKEEPER:
            PlayerTalkClass->SendCloseGossip();
            SetBindPoint(guid);
            break;
        case GOSSIP_OPTION_BANKER:
            GetSession()->SendShowBank(guid);
            break;
#ifndef CROSS
        case GOSSIP_OPTION_PETITIONER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendPetitionShowList(guid);
            break;
#endif /* not CROSS */
        case GOSSIP_OPTION_TABARDDESIGNER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendTabardVendorActivate(GetSession()->GetPlayer()->GetGUID());
            break;
        case GOSSIP_OPTION_AUCTIONEER:
#ifndef CROSS
            GetSession()->SendAuctionHello(guid, source->ToCreature());
#else /* CROSS */
            /// @TODO: Send notification to realm core and handle it
            /// We don't need it atm
            //GetSession()->SendAuctionHello(guid, source->ToCreature());
#endif /* CROSS */
            break;
        case GOSSIP_OPTION_SPIRITGUIDE:
            PrepareGossipMenu(source);
            SendPreparedGossip(source);
            break;
        case GOSSIP_OPTION_BATTLEFIELD:
        {
            BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());

            if (bgTypeId == BATTLEGROUND_TYPE_NONE)
            {
                sLog->outError(LOG_FILTER_PLAYER, "a user (guid %u) requested battlegroundlist from a npc who is no battlemaster", GetGUIDLow());
                return;
            }

            GetSession()->SendBattleGroundList(guid, bgTypeId);
            break;
        }
        case GOSSIP_OPTION_ADVENTURE_MAP:
        {
            GetSession()->SendAdventureMapOpen(guid);
            break;
        }
        case GOSSIP_OPTION_ARTIFACT_RESPEC:
            GetSession()->SendArtifactRespec(guid);
            break;
    }

    ModifyMoney(-cost, "OnGossipSelect (source :" + std::to_string(source->GetEntry()) + ")");
}

uint32 Player::GetGossipTextId(WorldObject* source)
{
    if (!source)
        return DEFAULT_GOSSIP_MESSAGE;

    return GetGossipTextId(GetDefaultGossipMenuForSource(source), source);
}

uint32 Player::GetGossipTextId(uint32 menuId, WorldObject* source)
{
    uint32 textId = DEFAULT_GOSSIP_MESSAGE;

    if (!menuId)
        return textId;

    GossipMenusMapBounds menuBounds = sObjectMgr->GetGossipMenusMapBounds(menuId);

    for (GossipMenusContainer::const_iterator itr = menuBounds.first; itr != menuBounds.second; ++itr)
    {
        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.conditions))
            textId = itr->second.text_id;
    }

    return textId;
}

uint32 Player::GetDefaultGossipMenuForSource(WorldObject* source)
{
    switch (source->GetTypeId())
    {
        case TYPEID_UNIT:
            return source->ToCreature()->GetCreatureTemplate()->GossipMenuId;
        case TYPEID_GAMEOBJECT:
            return source->ToGameObject()->GetGOInfo()->GetGossipMenuId();
        default:
            break;
    }

    return 0;
}

/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/
void Player::PrepareQuestMenu(uint64 guid)
{
    QuestRelationBounds objectQR;
    QuestRelationBounds objectQIR;

    // pets also can have quests
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (creature)
    {
        objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
        objectQIR = sObjectMgr->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
    }
    else
    {
        //we should obtain map pointer from GetMap() in 99% of cases. Special case
        //only for quests which cast teleport spells on player
        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
        ASSERT(_map);
        GameObject* pGameObject = _map->GetGameObject(guid);
        if (pGameObject)
        {
            objectQR  = sObjectMgr->GetGOQuestRelationBounds(pGameObject->GetEntry());
            objectQIR = sObjectMgr->GetGOQuestInvolvedRelationBounds(pGameObject->GetEntry());
        }
        else
            return;
    }

    QuestMenu &qm = PlayerTalkClass->GetQuestMenu();
    qm.ClearMenu();

    std::set<uint32> l_AddedQuests;

    for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
    {
        uint32 quest_id = i->second;
        QuestStatus status = GetQuestStatus(quest_id);

        if (l_AddedQuests.find(quest_id) != l_AddedQuests.end())
            continue;

        if (status == QUEST_STATUS_COMPLETE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 4);
        }
        else if (status == QUEST_STATUS_INCOMPLETE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 4);
        }
        //else if (status == QUEST_STATUS_AVAILABLE)
        //    qm.AddMenuItem(quest_id, 2);
    }

    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
    {
        uint32 quest_id = i->second;
        Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
        if (!quest)
            continue;

        if (l_AddedQuests.find(quest_id) != l_AddedQuests.end())
            continue;

        if (!CanTakeQuest(quest, false))
            continue;

        if (GetQuestStatus(quest_id) == QUEST_STATUS_NONE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 2);
        }
    }
}

void Player::SendPreparedQuest(uint64 guid)
{
    QuestMenu& questMenu = PlayerTalkClass->GetQuestMenu();
    if (questMenu.Empty())
        return;

    // single element case
    if (questMenu.GetMenuItemCount() == 1)
    {
        QuestMenuItem const& qmi0 = questMenu.GetItem(0);
        uint32 questId = qmi0.QuestId;

        // Auto open -- maybe also should verify there is no greeting
        if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
        {
            if (qmi0.QuestIcon == 4)
                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
            // Send completable on repeatable and autoCompletable quest if player don't have quest
            // @todo: verify if check for !quest->IsDaily() is really correct (possibly not)
            else
            {
                Object* object = ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT | TYPEMASK_ITEM);
                if (!object || (!object->hasQuest(questId) && !object->hasInvolvedQuest(questId)))
                {
                    PlayerTalkClass->SendCloseGossip();
                    return;
                }

                PlayerTalkClass->SendQuestGiverQuestDetails(quest, guid);
            }
        }
    }
    // multiple entries
    else
    {
        QEmote qe;
        qe._Delay = 0;
        qe._Emote = 0;
        std::string title = "";

        // need pet case for some quests
        Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
        if (creature)
        {
            uint32 textid = GetGossipTextId(creature);
            GossipText const* gossiptext = sObjectMgr->GetGossipText(textid);
            if (!gossiptext)
            {
                qe._Delay = 0;                              //TEXTEMOTE_MESSAGE;              //zyg: player emote
                qe._Emote = 0;                              //TEXTEMOTE_HELLO;                //zyg: NPC emote
                title = "";
            }
            else
            {
                qe = gossiptext->Emotes[0];

                if (!gossiptext->Text_0.empty())
                {
                    title = gossiptext->Text_0;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_0[0], loc_idx, title);
                }
                else
                {
                    title = gossiptext->Text_1;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_1[0], loc_idx, title);
                }
            }
        }
        PlayerTalkClass->SendQuestGiverQuestList(qe, title, guid);
    }
}

bool Player::IsActiveQuest(uint32 quest_id) const
{
    return m_QuestStatus.find(quest_id) != m_QuestStatus.end();
}

Quest const* Player::GetNextQuest(uint64 p_Guid, Quest const* p_Quest)
{
    QuestRelationBounds l_ObjectQR;

    WorldObject* l_Object = ObjectAccessor::GetWorldObject(*this, p_Guid);

    if (l_Object == nullptr)
        return nullptr;

    switch (l_Object->GetTypeId())
    {
        case TYPEID_UNIT:
        {
            if (Creature* l_Creature = l_Object->ToCreature())
                l_ObjectQR = sObjectMgr->GetCreatureQuestRelationBounds(l_Creature->GetEntry());

            break;
        }
        case TYPEID_PLAYER:
        {
            if (Player* l_Player = l_Object->ToPlayer())
                return sObjectMgr->GetQuestTemplate(p_Quest->GetNextQuestInChain());

            break;
        }
        case TYPEID_GAMEOBJECT:
        {
            if (GameObject* l_Gob = l_Object->ToGameObject())
                l_ObjectQR = sObjectMgr->GetGOQuestRelationBounds(l_Gob->GetEntry());

            break;
        }
        default:
            break;
    }

    uint32 l_NextQuestID = p_Quest->GetNextQuestInChain();

    for (QuestRelations::const_iterator l_Itr = l_ObjectQR.first; l_Itr != l_ObjectQR.second; ++l_Itr)
    {
        if (l_Itr->second == l_NextQuestID)
            return sObjectMgr->GetQuestTemplate(l_NextQuestID);
    }

    return NULL;
}

bool Player::CanSeeStartQuest(Quest const* quest)
{
    if (!DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this) && SatisfyQuestClass(quest, false) && SatisfyQuestRace(quest, false) &&
        SatisfyQuestSkill(quest, false) && SatisfyQuestExclusiveGroup(quest, false) && SatisfyQuestReputation(quest, false) &&
        SatisfyQuestPreviousQuest(quest, false) && SatisfyQuestNextChain(quest, false) &&
        SatisfyQuestPrevChain(quest, false) && SatisfyQuestDay(quest) && SatisfyQuestWeek(quest, false) &&
        SatisfyQuestMonth(quest, false) && SatisfyQuestSeasonal(quest, false) && SatisfyQuestConditions(quest, false))
    {
        return getLevel() + sWorld->getIntConfig(CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF) >= quest->GetMinLevel();
    }

    return false;
}

bool Player::CanTakeQuest(Quest const* p_Quest, bool p_Message)
{
    if (DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, p_Quest->GetQuestId(), this))
        return false;

    if (!SatisfyQuestStatus(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestConditions(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestPreviousQuest(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestExclusiveGroup(p_Quest, p_Message)) ///< Todo
        return false;

    if (!SatisfyQuestNextChain(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestPrevChain(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestClass(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestRace(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestLevel(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestSkill(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestReputation(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestTimed(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestDay(p_Quest))
        return false;

    if (!SatisfyQuestWeek(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestMonth(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestSeasonal(p_Quest, p_Message))
        return false;

    if (!SatisfyQuestTeam(p_Quest))
        return false;

    return true;
}

bool Player::CanAddQuest(Quest const* quest, bool msg)
{
    if (!SatisfyQuestLog(msg))
        return false;

    uint32 srcitem = quest->GetSrcItemId();
    if (srcitem > 0)
    {
        ItemPosCountVec dest;
        InventoryResult msg2 = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);

        // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
        if (msg2 == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else if (msg2 != EQUIP_ERR_OK)
        {
            SendEquipError(msg2, NULL, NULL, srcitem);
            return false;
        }
    }
    return true;
}

bool Player::IsQuestObjectiveComplete(Quest const* p_Quest, QuestObjective const* p_Objective)
{
    if (p_Objective->Type == QUEST_OBJECTIVE_PROGRESS_BAR)
    {
        float l_Progress = 0.0f;
        for (QuestObjective const& l_OtherObjective : p_Quest->QuestObjectives)
        {
            if (l_OtherObjective.ID == p_Objective->ID)
                continue;

            if (l_OtherObjective.Flags & QUEST_OBJECTIVE_FLAG_PART_OF_PROGRESS_BAR)
                l_Progress += float(GetQuestObjectiveCounter(l_OtherObjective.ID) * l_OtherObjective.ProgressBarWeight);
        }

        if (l_Progress >= 100.0f)
        {
            /// Complete the QUEST_OBJECTIVE_PROGRESS_BAR
            if (m_questObjectiveStatus[p_Objective->ID] == 0)
            {
                m_questObjectiveStatus[p_Objective->ID] = 1;
                m_QuestStatusSave[p_Quest->GetQuestId()] = true;

                sScriptMgr->OnObjectiveValidate(this, p_Quest->GetQuestId(), p_Objective->ID);
            }
            return true;
        }

        return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_NPC
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_ITEM
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_GO
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_PLAYER
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_NPC_INTERACT
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_HAVE_CURRENCY
        || p_Objective->Type == QUEST_OBJECTIVE_TYPE_OBTAIN_CURRENCY)
    {
        if (GetQuestObjectiveCounter(p_Objective->ID) < uint32(p_Objective->Amount))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_CURRENCY)
    {
        if (!HasCurrency(p_Objective->ObjectID, p_Objective->Amount))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_SPELL)
    {
        if (!HasSpell(p_Objective->ObjectID))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_FACTION_MIN)
    {
        uint32 l_RepFactionID = p_Objective->ObjectID;

        if (l_RepFactionID && GetReputationMgr().GetReputation(l_RepFactionID) < p_Objective->Amount)
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX)
    {
        uint32 l_RepFactionID = p_Objective->ObjectID;

        if (l_RepFactionID && GetReputationMgr().GetReputation(l_RepFactionID) > p_Objective->Amount)
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_MONEY)
    {
        if (!HasEnoughMoney(int64(p_Objective->Amount)))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_AREATRIGGER)
    {
        if (!GetQuestObjectiveCounter(p_Objective->ID))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_PET_TRAINER_DEFEAT)
    {
        /// @TODO implement these objective type correctly
        if (GetQuestObjectiveCounter(p_Objective->ID) < uint32(p_Objective->Amount))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_PET_BATTLE_ELITE)
    {
        /// @TODO implement these objective type correctly
        if (GetQuestObjectiveCounter(p_Objective->ID) < uint32(p_Objective->Amount))
            return false;
    }
    else if (p_Objective->Type == QUEST_OBJECTIVE_TYPE_PET_BATTLE_PVP)
    {
        /// @TODO implement these objective type correctly
        if (GetQuestObjectiveCounter(p_Objective->ID) < uint32(p_Objective->Amount))
            return false;
    }

    return true;
}

bool Player::CanCompleteQuest(uint32 p_QuestID)
{
    if (p_QuestID)
    {
        Quest const* l_Quest = sObjectMgr->GetQuestTemplate(p_QuestID);

        if (!l_Quest)
            return false;

        if (!l_Quest->IsRepeatable() && !l_Quest->IsSeasonal() && m_RewardedQuests.find(p_QuestID) != m_RewardedQuests.end())
            return false;                                   // not allow re-complete quest

        // auto complete quest
        if (l_Quest->IsAutoComplete() && CanTakeQuest(l_Quest, false))
            return true;

        QuestStatusMap::iterator itr = m_QuestStatus.find(p_QuestID);
        if (itr == m_QuestStatus.end())
            return false;

        QuestStatusData &q_status = itr->second;

        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
        {
            if (l_Quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT) && !q_status.Explored)
                return false;

            if (l_Quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && q_status.Timer == 0)
                return false;

            for (auto const& l_Objective : l_Quest->QuestObjectives)
            {
                if (l_Objective.Flags & QUEST_OBJECTIVE_FLAG_PART_OF_PROGRESS_BAR || l_Objective.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL)
                    continue;

               if (!IsQuestObjectiveComplete(l_Quest, &l_Objective))
                    return false;
            }

            return true;
        }
    }
    return false;
}

bool Player::CanCompleteRepeatableQuest(const Quest * p_Quest)
{
    // Solve problem that player don't have the quest and try complete it.
    // if repeatable she must be able to complete event if player don't have it.
    // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
    if (!CanTakeQuest(p_Quest, false))
        return false;

    for (auto const& l_Objective : p_Quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
        {
            if (!HasItemCount(l_Objective.Amount, l_Objective.Amount))
                return false;
        }
    }

    if (!CanRewardQuest(p_Quest, false))
        return false;

    return true;
}

bool Player::CanRewardQuest(Quest const* p_Quest, bool msg)
{
    // not auto complete quest and not completed quest (only cheating case, then ignore without message)
    if (!p_Quest->IsDFQuest() && !p_Quest->IsAutoComplete() && GetQuestStatus(p_Quest->GetQuestId()) != QUEST_STATUS_COMPLETE)
        return false;

    // daily quest can't be rewarded (25 daily quest already completed)
    if (!SatisfyQuestDay(p_Quest) || !SatisfyQuestWeek(p_Quest, true) || !SatisfyQuestMonth(p_Quest, true) || !SatisfyQuestSeasonal(p_Quest, true))
        return false;

    // rewarded and not repeatable quest (only cheating case, then ignore without message)
    if (GetQuestRewardStatus(p_Quest->GetQuestId()))
        return false;

    if (!SatisfyQuestSkill(p_Quest, msg))
        return false;

    for (auto const& l_Objective : p_Quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_OPTIONAL))
        {
            if (GetItemCount(l_Objective.ObjectID) < uint32(l_Objective.Amount))
            {
                if (msg)
                    SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, l_Objective.ObjectID);

                return false;
            }
        }
        else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CURRENCY)
        {
            if (!HasCurrency(l_Objective.ObjectID, l_Objective.Amount))
                return false;
        }
        else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY)
        {
            if (!HasEnoughMoney(uint64(l_Objective.Amount)))
                return false;
        }
    }

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, uint32 p_Reward, bool msg)
{
    // prevent receive reward with quest items in bank or for not completed quest
    if (!CanRewardQuest(quest, msg))
        return false;

    if (quest->GetRewItemsCount() > 0)
    {
        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
        {
            if (quest->RewardItemId[i])
            {
                ItemPosCountVec dest;
                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardItemId[i], quest->RewardItemIdCount[i]);
                if (res != EQUIP_ERR_OK)
                {
                    SendEquipError(res, NULL, NULL, quest->RewardItemId[i]);
                    return false;
                }
            }
        }
    }

    /// - Quest have dynamic reward, skip legacy choice
    if (quest->GetQuestPackageID() != 0)
    {
        /// - Check if the reward is in dynamic reward list, and if player can take it (class/spec)
        for (QuestPackageItemEntry const* l_DynamicReward : quest->DynamicRewards)
        {
            if (l_DynamicReward->ItemID != p_Reward)
                continue;

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_DynamicReward->ItemID);
            if (!l_ItemTemplate)
                return false;

            /// Hackfix, but fix lot of quests since the selection work client-side
            /// See quest 24970 with a hunter
            {
                /// - We have find the reward, check if player can store it
                ItemPosCountVec l_Dest;
                InventoryResult l_Result = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemID, l_DynamicReward->ItemCount);
                if (l_Result != EQUIP_ERR_OK)
                {
                    SendEquipError(l_Result, NULL, NULL, l_DynamicReward->ItemID);
                    return false;
                }

                return true;
            }

            uint32 l_Specialization = GetActiveSpecializationID();
            if (!l_Specialization)
                l_Specialization = GetDefaultSpecId();

            switch (l_DynamicReward->FilterType)
            {
                case uint8(PackageItemRewardType::SpecializationReward):
                    if (!l_ItemTemplate->HasSpec((SpecIndex)l_Specialization, getLevel()))
                    {
                        GetSession()->SendNotification(LANG_NO_SPE_FOR_DYNAMIC_REWARD);
                        return false;
                    }
                    break;
                case uint8(PackageItemRewardType::ClassReward):
                    if (!l_ItemTemplate->HasClassSpec(getClass(), getLevel()))
                        return false;
                    break;
                case uint8(PackageItemRewardType::DefaultHiddenReward):                             ///< Yes, player can cheat to have it instead of his own specific item, but it's useless for him
                case uint8(PackageItemRewardType::NoRequire):
                    break;
                // Not implemented PackageItemRewardType
                default:
                    sLog->outError(LogFilterType::LOG_FILTER_PLAYER_ITEMS, "Not implemented PackageItemRewardType %u for quest %u", l_DynamicReward->FilterType, quest->GetQuestId());
                    continue;
            }

            /// - We have find the reward, check if player can store it
            ItemPosCountVec l_Dest;
            InventoryResult l_Result = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemID, l_DynamicReward->ItemCount);
            if (l_Result != EQUIP_ERR_OK)
            {
                SendEquipError(l_Result, NULL, NULL, l_DynamicReward->ItemID);
                return false;
            }
            return true;
        }

        if (p_Reward == 0)
            return true;

        return false;
    }

    if (quest->GetRewChoiceItemsCount() > 0)
    {
        if (quest->RewardChoiceItemId[p_Reward])
        {
            ItemPosCountVec dest;
            InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardChoiceItemId[p_Reward], quest->RewardChoiceItemCount[p_Reward]);
            if (res != EQUIP_ERR_OK)
            {
                SendEquipError(res, NULL, NULL, quest->RewardChoiceItemId[p_Reward]);
                return false;
            }
        }
    }

    return true;
}

void Player::HandleAutoCompleteQuest(Quest const* p_Quest)
{
    if (p_Quest->IsAutoComplete())
    {
        for (auto const& l_Objective : p_Quest->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
            {
                uint32 id = l_Objective.ObjectID;
                uint32 count = l_Objective.Amount;

                if (!id || !count)
                    continue;

                uint32 curItemCount = GetItemCount(id, true);

                ItemPosCountVec dest;
                uint8 msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count - curItemCount);
                if (msg == EQUIP_ERR_OK)
                {
                    Item* item = StoreNewItem(dest, id, true);
                    SendNewItem(item, count - curItemCount, true, false);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC)
            {
                int32 creature = l_Objective.ObjectID;
                uint32 creaturecount = l_Objective.Amount;

                if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
                {
                    for (uint16 z = 0; z < creaturecount; ++z)
                        KilledMonster(cInfo, 0);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_GO)
            {
                for (uint16 z = 0; z < l_Objective.Amount; ++z)
                    CastedCreatureOrGO(l_Objective.ObjectID, 0, 0);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_SPELL)
            {
                /// @TODO
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MIN || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX)
            {
                if (GetReputationMgr().GetReputation(l_Objective.ObjectID) < l_Objective.Amount)
                {
                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(l_Objective.ObjectID))
                        GetReputationMgr().SetReputation(factionEntry, l_Objective.Amount);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE)
            {
                QuestObjectiveSatisfy(l_Objective.ObjectID, l_Objective.Amount, l_Objective.Type);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_PROGRESS_BAR)
            {

            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_HAVE_CURRENCY)
            {
                if (!l_Objective.ObjectID || !l_Objective.Amount)
                    continue;

                ModifyCurrency(l_Objective.ObjectID, l_Objective.Amount);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_OBTAIN_CURRENCY)
            {
                if (!l_Objective.ObjectID || !l_Objective.Amount)
                    continue;

                ModifyCurrency(l_Objective.ObjectID, l_Objective.Amount);
            }
        }

        CompleteQuest(p_Quest->GetQuestId());
    }
}

void Player::AddQuest(Quest const* quest, Object* questGiver)
{
    uint16 log_slot = FindQuestSlot(0);

    if (log_slot >= MAX_QUEST_LOG_SIZE) // Player does not have any free slot in the quest log
        return;

    uint32 quest_id = quest->GetQuestId();

    // if not exist then created with set uState == NEW and rewarded=false
    QuestStatusData& questStatusData = m_QuestStatus[quest_id];

    // check for repeatable quests status reset
    bool l_Reset = true;

    /// Don't reset emissary quests, this is done manually at emissary reset
    if (MS::WorldQuest::Template const* l_Template = MS::WorldQuest::Template::GetTemplate(quest_id))
    {
        if (l_Template->GetWorldQuestType() == MS::WorldQuest::WorldQuestType::Bounty && questStatusData.Status != QUEST_STATUS_NONE)
            l_Reset = false;
    }

    if (l_Reset)
    {
        questStatusData.Status = QUEST_STATUS_INCOMPLETE;
        questStatusData.Explored = false;
    }

    for (auto const& l_Objective : quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MIN || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX)
        {
            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(l_Objective.ObjectID))
                GetReputationMgr().SetVisible(factionEntry);
        }

        if (l_Reset && l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE)
        {
            if (auto const& l_Tree = sCriteriaMgr->GetCriteriaTree(l_Objective.ObjectID))
            {
                ResetCriteriaTree(l_Tree);

                if (l_Tree->Children.empty())
                    continue;

                auto l_Criteria = l_Tree->Children[0]->Criteria;

                if (!l_Criteria)
                    continue;

                if (l_Criteria->Entry->Type == CRITERIA_TYPE_COMPLETE_GARRISON_MISSION)
                {
                    if (quest_id != 43928 && quest_id != 43899 && quest_id != 43698)
                    {
                        if (auto l_Garr = GetGarrison())
                            l_Garr->AddMission(l_Criteria->Entry->Asset.GarrMissionID);
                    }
                }
                else if (l_Criteria->Entry->Type == CRITERIA_TYPE_RECRUIT_GARRISON_FOLLOWER)
                {
                    if (auto l_Garr = GetGarrison())
                        if (l_Garr->GetFollower(l_Criteria->Entry->Asset.GarrMissionID))
                        {
                            AddDelayedEvent([this, l_Objective]()->void
                            {
                                QuestObjectiveSatisfy(l_Objective.ObjectID, l_Objective.Amount, l_Objective.Type, 0);
                            }, 1000);
                        }
                }
            }
        }

        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_HAVE_CURRENCY)
        {
            uint32 l_Amount = std::min(GetCurrency(l_Objective.ObjectID, true), uint32(l_Objective.Amount));

            if (l_Amount)
            {
                AddDelayedEvent([this, l_Objective, l_Amount]()->void
                    {
                        QuestObjectiveSatisfy(l_Objective.ObjectID, l_Amount, l_Objective.Type, 0);
                    }, 1000);
            }
        }
    

        // not all Quest Objective types need to be tracked, some such as reputation are handled/checked externally
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_SPELL
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MIN
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_AREATRIGGER)
            continue;

        m_questObjectiveStatus.insert(std::make_pair(l_Objective.ID, uint32(0)));
    }

    GiveQuestSourceItem(quest);
    AdjustQuestReqItemCount(quest);

    uint32 qtime = 0;
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        uint32 limittime = quest->GetLimitTime();

        // shared timed quest
        if (questGiver && questGiver->IsPlayer())
            limittime = questGiver->ToPlayer()->getQuestStatusMap()[quest_id].Timer / IN_MILLISECONDS;

        AddTimedQuest(quest_id);
        questStatusData.Timer = limittime * IN_MILLISECONDS;
        qtime = static_cast<uint32>(time(NULL)) + limittime;
    }
    else
        questStatusData.Timer = 0;

    SetQuestSlot(log_slot, quest_id, qtime);

    m_QuestStatusSave[quest_id] = true;

    StartCriteriaTimer(CRITERIA_TIMED_TYPE_QUEST, quest_id);

    //starting initial quest script
    if (questGiver && quest->GetQuestStartScript() != 0)
        GetMap()->ScriptsStart(sQuestStartScripts, quest->GetQuestStartScript(), questGiver, this);

    CheckSpellAreaOnQuestStatusChange(quest_id);

    sScriptMgr->OnPhaseUpdate(this, quest->GetQuestId(), true);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    UpdateForQuestWorldObjects();

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->OnQuestStarted(quest);
#endif

    sScriptMgr->OnQuestAccept(this, quest);
    SmartScript l_QuestScript;
    l_QuestScript.OnInitialize(this, nullptr, quest);
    l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_ACCEPTED, this);

    if (quest->QuestObjectives.empty() && CanCompleteQuest(quest_id))
        CompleteQuest(quest_id);

    if (quest->InProgressPhaseID)
        SetInPhase(quest->InProgressPhaseID, true, true);

    HandleAutoCompleteQuest(quest);
}

void Player::CompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_COMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
        {
            if (m_WorldQuestMgr->GetReward(quest_id) && MS::WorldQuest::Template::GetTemplate(quest_id) && MS::WorldQuest::Template::GetTemplate(quest_id)->GetWorldQuestType() != MS::WorldQuest::WorldQuestType::Bounty)
                m_WorldQuestMgr->Reward(quest_id, 0);
            else if (qInfo->HasFlag(QUEST_FLAGS_AUTO_REWARDED))
                RewardQuest(qInfo, 0, this, false);
            else
                SendQuestComplete(qInfo);

            sScriptMgr->OnQuestComplete(this, qInfo);
            SmartScript l_QuestScript;
            l_QuestScript.OnInitialize(this, nullptr, qInfo);
            l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_COMPLETION, this);
        }

#ifndef CROSS
        if (Guild* l_Guild = GetGuild())
            l_Guild->GetAchievementMgr().UpdateCriteria(CRITERIA_TYPE_COMPLETE_QUESTS_GUILD, 1, 0, 0, nullptr, this);
#endif
    }
}

void Player::IncompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_INCOMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            RemoveQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
    }
}

void Player::RewardQuest(Quest const* p_Quest, uint32 p_Reward, Object* p_QuestGiver, bool p_Announce)
{
    Map* l_ThreadLocalMap = Map::GetCurrentMapThread();
    if (GetMap() && l_ThreadLocalMap && l_ThreadLocalMap != GetMap())
    {
        sLog->outExtChat("#jarvis-log", "danger", true, "Threadguard triggered for Unit (GUID = %u) (Map (Id : %u) modifying Map (Id : %u))", GetGUIDLow(), l_ThreadLocalMap->GetId(), GetMap()->GetId());
        if (sWorld->getBoolConfig(CONFIG_ENABLE_UNSAFE_SPELL_AURA_HOOK_STACK_TRACE))
        {
            ACE_Stack_Trace l_StackTrace;
            sLog->outExtChat("#jarvis-log", "danger", true, l_StackTrace.c_str());
        }
    }

    //this THING should be here to protect code from quest, which cast on player far teleport as a reward
    //should work fine, cause far teleport will be executed in Player::Update()
    SetCanDelayTeleport(true);

    uint32 l_QuestId = p_Quest->GetQuestId();

    for (auto const& l_Objective : p_Quest->QuestObjectives)
    {
        switch (l_Objective.Type)
        {
            case QUEST_OBJECTIVE_TYPE_ITEM:
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_OPTIONAL))
                {
                    if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Objective.ObjectID))
                    {
                        if (!l_ItemProto->IsQuestItem())
                        {
                            if (l_ItemProto->ItemId == 138019)
                                sLog->outAshran("RewardQuest delete mythic keystone");

                            DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true);
                        }
                    }
                }
                break;
            }
            case QUEST_OBJECTIVE_TYPE_CURRENCY:
            {
                ModifyCurrency(l_Objective.ObjectID, -int32(l_Objective.Amount));
                break;
            }
            case QUEST_OBJECTIVE_TYPE_MONEY:
            {
                ModifyMoney(-int64(l_Objective.Amount), "Player::RewardQuest QUEST_OBJECTIVE_TYPE_MONEY " + std::to_string(p_Quest->GetQuestId()));
                break;
            }
            default:
                break;
        }
    }

    if (!p_Quest->HasFlag2(QUEST_FLAGS_EX_KEEP_ADDITIONAL_ITEMS))
    {
        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
        {
            if (p_Quest->RequiredSourceItemId[i])
            {
                uint32 count = p_Quest->RequiredSourceItemCount[i];
                if (p_Quest->RequiredSourceItemId[i] == 138019)
                    sLog->outAshran("RewardQuest delete mythic keystone (2)");
                DestroyItemCount(p_Quest->RequiredSourceItemId[i], count ? count : 9999, true);
            }
        }
    }

    RemoveTimedQuest(l_QuestId);

    if (p_Quest->GetRewItemsCount() > 0)
    {
        for (uint32 l_I = 0; l_I < p_Quest->GetRewItemsCount(); ++l_I)
        {
            if (uint32 l_ItemId = p_Quest->RewardItemId[l_I])
            {
                ItemPosCountVec l_Dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemId, p_Quest->RewardItemIdCount[l_I]) == EQUIP_ERR_OK)
                {
                    Item* l_Item = StoreNewItem(l_Dest, l_ItemId, true, Item::GenerateItemRandomPropertyId(l_ItemId));
                    SendNewItem(l_Item, p_Quest->RewardItemIdCount[l_I], true, false);
                }
            }
        }
    }

    /// - Quest have dynamic reward, skip legacy choice
    if (p_Quest->GetQuestPackageID() != 0)
    {
        /// - Check if the reward is in dynamic reward list, and if player can take it (class/spec)
        for (QuestPackageItemEntry const* l_DynamicReward : p_Quest->DynamicRewards)
        {
            if (l_DynamicReward->ItemID != p_Reward)
                continue;

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_DynamicReward->ItemID);
            if (!l_ItemTemplate)
                break;

            ItemPosCountVec l_Dest;
            if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemID, l_DynamicReward->ItemCount) == EQUIP_ERR_OK)
            {
                std::vector<uint32> l_Bonuses;
                Item::GenerateItemBonus(p_Reward, ItemContext::QuestReward, l_Bonuses, false, this);

                Item* l_Item = StoreNewItem(l_Dest, l_DynamicReward->ItemID, true, Item::GenerateItemRandomPropertyId(l_DynamicReward->ItemID), l_Bonuses);

                if (!l_Item->GetTemplate()->NeedScaleOnArtifactKnowledge && p_Quest->GetQuestMaxScalingLevel() != -1)
                    l_Item->SetModifier(ItemModifiers::ITEM_MODIFIER_SCALING_STAT_DISTRIBUTION_FIXED_LEVEL, std::min((int32)getLevel(), p_Quest->GetQuestMaxScalingLevel()));

                /// Process quality upgrade chance
                uint32 l_QualityUpgradeBonus = 0;

                /// For each new quality upgrade, we have 25% of chance to get the next upgrade
                /// Flow for a green item with a possibility to be rare or epic
                /// 1 -> roll (1, 100) < 25 ? okay, the item get the rare bonus
                /// 2 -> roll (1, 100) < 25 ? okay, the item get the epic bonus
                /// .... etc
                /// bonus quality upgrade should be in the right order in database (uncommun bonus, rare bonus, epic bonus, legendary bonus ...etc)
                static const uint32 k_RollChance = 25;

                for (auto l_ItemBonusGroupID : l_ItemTemplate->m_ItemBonusGroups)
                {
                    ItemBonusGroup const* l_ItemBonusGroup = sObjectMgr->GetItemBonusGroup(l_ItemBonusGroupID);
                    if (l_ItemBonusGroup == nullptr)
                        continue;

                    if (!(l_ItemBonusGroup->Flags & ItemBonusGroupFlags::QuestRewardQualityUpgrade))
                        continue;

                    for (uint32 l_BonusId : l_ItemBonusGroup->Bonuses)
                    {
                        uint32 l_Roll = urand(0, 100);
                        if (l_Roll > k_RollChance)
                            break;

                        l_QualityUpgradeBonus = l_BonusId;
                    }

                    break;
                }

                if (l_QualityUpgradeBonus)
                    l_Item->AddItemBonus(l_QualityUpgradeBonus);

                /// @TODO: Use the item_bonus_group tables instead ...
                /// - If quest is WoD quest & item is stuff, there is a chance player get bonus on the item
                if (l_Item->IsStuffItem())
                {
                    AreaTableEntry const* l_AreaTable = sAreaTableStore.LookupEntry(p_Quest->GetZoneOrSort());
                    if (l_AreaTable != nullptr)
                    {
                        MapEntry const* l_Map = sMapStore.LookupEntry(l_AreaTable->ContinentID);
                        if (l_Map != nullptr
                            && l_Map->Expansion() == Expansion::EXPANSION_WARLORDS_OF_DRAENOR)
                        {
                            float l_Roll = frand(0.0f, 100.0f);
                            float l_Coeff = 1.0f;
#ifndef CROSS
                            if (GetDraenorGarrison() && GetDraenorGarrison()->HasBuildingType(MS::Garrison::GDraenor::Building::Type::Armory))
                                l_Coeff *= 2.0f;
                            if (GetAuraEffectsByType(SPELL_AURA_EFFECT_INCREASE_WQ_REWARD_PROC).size())
                                l_Coeff *= 1.5f;
#endif
                            // If item is uncommon & chance match, add uncommun to rare modifier
                            if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_UNCOMMON
                                && l_Roll > (gQuestRewardBonusRareChanceRange[0] * l_Coeff) && l_Roll < (gQuestRewardBonusRareChanceRange[1] * l_Coeff))
                            {
                                l_Item->AddItemBonus((uint32)QuestRewardItemBonus::UncommunToRare);
                            }

                            if (l_Roll > (gQuestRewardBonusEpicChanceRange[0] * l_Coeff) && l_Roll < (gQuestRewardBonusEpicChanceRange[1] * l_Coeff))
                            {
                                if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_UNCOMMON)
                                {
                                    l_Item->AddItemBonus((uint32)QuestRewardItemBonus::UncommunToEpic);
                                }
                                else if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_RARE)
                                {
                                    l_Item->AddItemBonus((uint32)QuestRewardItemBonus::RareToEpic);
                                }
                            }
                        }
                    }
                }

                SendNewItem(l_Item, l_DynamicReward->ItemCount, true, false, false);
            }
            break;
        }
    }
    else
    {
        if (p_Quest->GetRewChoiceItemsCount() > 0)
        {
            if (uint32 itemId = p_Quest->RewardChoiceItemId[p_Reward])
            {
                ItemPosCountVec l_Dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, itemId, p_Quest->RewardChoiceItemCount[p_Reward]) == EQUIP_ERR_OK)
                {
                    std::vector<uint32> l_Bonuses;
                    Item::GenerateItemBonus(itemId, ItemContext::QuestReward, l_Bonuses, false, this);

                    if (Item* l_Item = StoreNewItem(l_Dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId), l_Bonuses))
                    {
                        if (!l_Item->GetTemplate()->NeedScaleOnArtifactKnowledge && p_Quest->GetQuestMaxScalingLevel() != -1)
                            l_Item->SetModifier(ItemModifiers::ITEM_MODIFIER_SCALING_STAT_DISTRIBUTION_FIXED_LEVEL, std::min((int32)getLevel(), p_Quest->GetQuestMaxScalingLevel()));

                        SendNewItem(l_Item, p_Quest->RewardChoiceItemCount[p_Reward], true, false);
                    }
                }
            }
        }
    }

    if (p_Quest->GetRewCurrencyCount() > 0)
    {
        for (uint32 i = 0; i < p_Quest->GetRewCurrencyCount(); ++i)
        {
            if (uint32 currencyId = p_Quest->RewardCurrencyId[i])
            {
                CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyId);
                if (uint32 countCurrency = p_Quest->RewardCurrencyCount[i])
                {
                    if (currency->Flags & CURRENCY_FLAG_HIGH_PRECISION)
                        countCurrency *= 100;

                    ConditionContainer const* l_Conditions = sConditionMgr->GetConditionsForItemLoot(LOOT_ITEM_TYPE_CURRENCY, currencyId);
                    if (l_Conditions)
                    {
                        ConditionSourceInfo srcInfo = ConditionSourceInfo(this);

                        if (!sConditionMgr->IsObjectMeetToConditions(srcInfo, *l_Conditions))
                            continue;
                    }

                    ModifyCurrency(currencyId, countCurrency, false);
                }
            }
        }
    }

    RewardReputation(p_Quest);
    RewardGuildReputation(p_Quest);

    uint16 log_slot = FindQuestSlot(l_QuestId);
    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlot(log_slot, 0);

    bool rewarded = (m_RewardedQuests.find(l_QuestId) != m_RewardedQuests.end());

    float QuestXpRate = 1;

    QuestXpRate = sWorld->getRate(RATE_XP_QUEST);

    // Not give XP in case already completed once repeatable quest
    uint32 XP = rewarded ? 0 : uint32(p_Quest->XPValue(this) * QuestXpRate);

    // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
    Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
    for (Unit::AuraEffectList::const_iterator l_I = ModXPPctAuras.begin(); l_I != ModXPPctAuras.end(); ++l_I)
        AddPct(XP, (*l_I)->GetAmount());

    if (GetSession()->IsPremium())
        XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);

    int64 moneyRew = 0;
    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        GiveXP(XP, NULL);
    else
        moneyRew = int64(p_Quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY));

    if (MS::Garrison::Manager* l_GarrisonMgr = GetGarrison())
    {
        MS::Garrison::GarrisonFollower* l_Follower = l_GarrisonMgr->GetCombatAllyFollower();
        if (l_Follower)
            l_Follower->EarnXP(150, this);
    }

    moneyRew += p_Quest->MoneyValue(getLevel());

    /// Negative amount are already taken in quest objectives
    if (moneyRew > 0)
    {
        ModifyMoney(moneyRew, "Player::RewardQuest moneyRew " + std::to_string(p_Quest->GetQuestId()));

        UpdateCriteria(CRITERIA_TYPE_MONEY_FROM_QUEST_REWARD, uint32(moneyRew));
    }

    // honor reward
    if (uint32 honor = p_Quest->CalculateHonorGain())
    {
        RewardHonor(NULL, 0, honor);
        SendDisplayToast(0, honor, p_Quest->GetQuestId(), DisplayToastMethod::DISPLAY_TOAST_METHOD_WORLD_QUEST_REWARD, ToastTypes::TOAST_TYPE_HONOR, false, false);
    }

    // title reward
    if (p_Quest->GetCharTitleId())
    {
        if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(p_Quest->GetCharTitleId()))
            SetTitle(titleEntry);
    }

    if (p_Quest->GetRewArtifactXP())
    {
        if (MS::Artifact::Manager* l_Artifact = GetCurrentlyEquippedArtifact())
            l_Artifact->ModifyArtifactPower(p_Quest->GetRewArtifactXP());
    }

    ///if (uint32 talents = p_Quest->GetBonusTalents())
    ///{
    ///    addQuestRewardedTalentCount(talents);
    ///    InitTalentForLevel();
    ///}

    if (uint32 l_SkillId = p_Quest->GetRewardSkillId())
    {
        uint32 l_PointsToAdd = p_Quest->GetRewardSkillPoints();
        uint32 skill_value = GetPureSkillValue(l_SkillId);
        uint32 skill_max_value = GetPureMaxSkillValue(l_SkillId);

        if (l_PointsToAdd > 0 && skill_value < skill_max_value && HasSkill(l_SkillId))
            SetSkill(l_SkillId, 0, std::min(skill_value + p_Quest->GetRewardSkillPoints(), skill_max_value), skill_max_value);
    }

#ifndef CROSS
    // Send reward mail
    if (uint32 mail_template_id = p_Quest->GetRewMailTemplateId())
    {
        //- TODO: Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft(mail_template_id).SendMailTo(trans, this, p_QuestGiver, MAIL_CHECK_MASK_HAS_BODY, p_Quest->GetRewMailDelaySecs());
        CharacterDatabase.CommitTransaction(trans);
    }
#endif

    if (p_Quest->IsDaily() || p_Quest->IsDFQuest())
    {
        SetDailyQuestStatus(l_QuestId);
        if (p_Quest->IsDaily())
        {
            UpdateCriteria(CRITERIA_TYPE_COMPLETE_DAILY_QUEST, l_QuestId);
            UpdateCriteria(CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, l_QuestId);
        }
    }
    else if (p_Quest->IsWeekly())
        SetWeeklyQuestStatus(l_QuestId);
    else if (p_Quest->IsMonthly())
        SetMonthlyQuestStatus(l_QuestId);
    else if (p_Quest->IsSeasonal())
        SetSeasonalQuestStatus(l_QuestId);

    m_RewardedQuests.insert(l_QuestId);
    m_RewardedQuestsSave[l_QuestId] = true;

    if (p_Quest->IsAccountQuest())
    {
        m_AccountRewardedQuests.insert(l_QuestId);
        m_AccountRewardedQuestsSave[l_QuestId] = true;
    }

    sScriptMgr->OnPhaseUpdate(this, p_Quest->GetQuestId(), false);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(l_QuestId);
    phaseMgr.NotifyConditionChanged(phaseUdateData);

    // Must come after the insert in m_RewardedQuests because of spell_area check
    RemoveActiveQuest(l_QuestId);

    phaseUdateData.AddQuestUpdate(l_QuestId);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    // StoreNewItem, mail reward, etc. save data directly to the database
    // to prevent exploitable data desynchronisation we save the quest status to the database too
    // (to prevent rewarding this quest another time while rewards were already given out)
    SQLTransaction trans = SQLTransaction(NULL);
    SQLTransaction l_AuthTrans = SQLTransaction(nullptr);
    _SaveQuestStatus(trans, l_AuthTrans);

    if (p_Announce)
        SendQuestReward(p_Quest, XP, p_QuestGiver);

    // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
    if (p_Quest->GetRewSpellCast() > 0)
        CastSpell(this, p_Quest->GetRewSpellCast(), true);
    else
    {
        for (uint32 l_I = 0; l_I < QUEST_REWARD_SPELL_COUNT; ++l_I)
        {
            if (uint32 l_SpellID = p_Quest->RewardSpells[l_I])
                CastSpell(this, l_SpellID, true);
        }
    }

    sScriptMgr->OnQuestReward(this, p_Quest);
    SmartScript l_QuestScript;
    l_QuestScript.OnInitialize(this, nullptr, p_Quest);
    l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_REWARDED, this);

    if (InstanceScript* l_Instance = GetInstanceScript())
        l_Instance->OnQuestRewarded(this, p_Quest);

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->OnQuestReward(p_Quest);
#endif

    if (p_Quest->GetZoneOrSort() > 0)
        UpdateCriteria(CRITERIA_TYPE_COMPLETE_QUESTS_IN_ZONE, p_Quest->GetZoneOrSort(), p_Quest->GetQuestId());
    UpdateCriteria(CRITERIA_TYPE_COMPLETE_QUEST_COUNT);
    UpdateCriteria(CRITERIA_TYPE_COMPLETE_QUEST, p_Quest->GetQuestId(), p_Quest->GetQuestId());

    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(l_QuestId))
        SetQuestBit(l_QuestBit, true);

    UpdateForQuestWorldObjects();

    //lets remove flag for delayed teleports
    SetCanDelayTeleport(false);

    if (p_Quest->InProgressPhaseID)
        SetInPhase(p_Quest->InProgressPhaseID, true, false);

    if (p_Quest->CompletedPhaseID)
        SetInPhase(p_Quest->CompletedPhaseID, true, true);

    RemoveObjectsFromLockoutListByQuest(p_Quest->GetQuestId());
}

void Player::FailQuest(uint32 questId)
{
    if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
    {
        SetQuestStatus(questId, QUEST_STATUS_FAILED);

        uint16 log_slot = FindQuestSlot(questId);

        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotTimer(log_slot, 1);
            SetQuestSlotState(log_slot, QUEST_STATE_FAIL);
        }

        if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
        {
            QuestStatusData& q_status = m_QuestStatus[questId];

            RemoveTimedQuest(questId);
            q_status.Timer = 0;

            SendQuestTimerFailed(questId);
        }
        else
            SendQuestFailed(questId);

        // Destroy quest items on quest failure.
        if (quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        {
            for (auto const& l_Objective : quest->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
                {
                    if (l_Objective.ObjectID == 138019)
                        sLog->outAshran("FailQuest delete mythic keystone");
                    DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true, true);
                }
            }
        }

        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
            if (quest->RequiredSourceItemId[i] > 0 && quest->RequiredSourceItemCount[i] > 0)
                // Destroy items received during the quest.
                DestroyItemCount(quest->RequiredSourceItemId[i], quest->RequiredSourceItemCount[i], true, true);

        if (quest->InProgressPhaseID)
            SetInPhase(quest->InProgressPhaseID, true, false);

        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(questId);
        phaseMgr.NotifyConditionChanged(phaseUdateData);

        SmartScript l_QuestScript;
        l_QuestScript.OnInitialize(this, nullptr, quest);
        l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_FAIL, this);
    }
}

bool Player::SatisfyQuestSkill(Quest const* qInfo, bool msg) const
{
    uint32 skill = qInfo->GetRequiredSkill();

    // skip 0 case RequiredSkill
    if (skill == 0)
        return true;

    uint32 skill_value = qInfo->GetRequiredSkillValue();
    if (skill_value == 0)
        skill_value = 1;

    // check skill value
    if (GetSkillValue(skill) < skill_value)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_NONE);

            if (m_IsDebugQuestLogs && GetSession())
                ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_MISSING_SKILL);
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestLevel(Quest const* qInfo, bool msg)
{
    if (getLevel() < qInfo->GetMinLevel())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_FAILED_LOW_LEVEL);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_TOO_LOW_LVL);
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestLog(bool msg)
{
    // exist free slot
    if (FindQuestSlot(0) < MAX_QUEST_LOG_SIZE)
        return true;

    if (msg)
    {
        WorldPacket data(SMSG_QUEST_LOG_FULL, 0);
        GetSession()->SendPacket(&data);

        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_QUEST_LOG);
    }

    return false;
}

bool Player::SatisfyQuestPreviousQuest(Quest const* qInfo, bool msg)
{
    // No previous quest (might be first quest in a series)
    if (qInfo->prevQuests.empty())
        return true;

    for (Quest::PrevQuests::const_iterator iter = qInfo->prevQuests.begin(); iter != qInfo->prevQuests.end(); ++iter)
    {
        uint32 prevId = abs(*iter);

        Quest const* qPrevInfo = sObjectMgr->GetQuestTemplate(prevId);

        if (qPrevInfo)
        {
            // If any of the positive previous quests completed, return true
            if (*iter > 0 && m_RewardedQuests.find(prevId) != m_RewardedQuests.end())
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group completed and rewarded
                ObjectMgr::ExclusiveQuestGroups::iterator iter2 = sObjectMgr->mExclusiveQuestGroups.lower_bound(qPrevInfo->GetExclusiveGroup());
                ObjectMgr::ExclusiveQuestGroups::iterator end  = sObjectMgr->mExclusiveQuestGroups.upper_bound(qPrevInfo->GetExclusiveGroup());

                ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0

                for (; iter2 != end; ++iter2)
                {
                    uint32 exclude_Id = iter2->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be completed and rewarded(reported)
                    if (m_RewardedQuests.find(exclude_Id) == m_RewardedQuests.end())
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(QUEST_ERR_NONE);

                            if (m_IsDebugQuestLogs)
                                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_EXCL_GRP_ALT_COMP);
                        }

                        return false;
                    }
                }
                return true;
            }

            // If any of the negative previous quests active, return true
            if (*iter < 0 && GetQuestStatus(prevId) != QUEST_STATUS_NONE)
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group active
                ObjectMgr::ExclusiveQuestGroups::iterator iter2 = sObjectMgr->mExclusiveQuestGroups.lower_bound(qPrevInfo->GetExclusiveGroup());
                ObjectMgr::ExclusiveQuestGroups::iterator end   = sObjectMgr->mExclusiveQuestGroups.upper_bound(qPrevInfo->GetExclusiveGroup());

                ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0

                for (; iter2 != end; ++iter2)
                {
                    uint32 exclude_Id = iter2->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be active
                    if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE)
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(QUEST_ERR_NONE);

                            if (m_IsDebugQuestLogs)
                                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_EXCL_GRP_ALT_ACTIVE);
                        }

                        return false;
                    }
                }
                return true;
            }
        }
    }

    // Has only positive prev. quests in non-rewarded state
    // and negative prev. quests in non-active state
    if (msg)
    {
        SendCanTakeQuestResponse(QUEST_ERR_NONE);

        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_PREV_QUEST);
    }

    return false;
}

bool Player::SatisfyQuestTeam(Quest const* qInfo)
{
    int8 reqteam = qInfo->GetRequiredTeam();

    if (reqteam < 0)
        return true;

    if (reqteam == GetTeamId())
        return true;

    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_FACTION);

    return false;
}

bool Player::SatisfyQuestClass(Quest const* qInfo, bool msg) const
{
    int32 reqClass = qInfo->GetRequiredClasses();

    if (!reqClass)
        return true;

    if (reqClass > 0)
    {
        // Positive = Only specified
        if ((reqClass & getClassMask()) == 0)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs && GetSession())
                    ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CLASS);
            }

            return false;
        }
    }
    else
    {
        // Negative = All except specified
        reqClass = -reqClass;

        if (reqClass & getClassMask())
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs && GetSession())
                    ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CLASS);
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestRace(Quest const* qInfo, bool msg)
{
    int64 reqraces = qInfo->GetRequiredRaces();
    if (!reqraces || reqraces == int64(-1))
        return true;

    if ((reqraces & getRaceMask()) == 0)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_FAILED_WRONG_RACE);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_RACE);
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestReputation(Quest const* qInfo, bool msg)
{
    uint32 fIdMin = qInfo->GetRequiredMinRepFaction();      //Min required rep
    if (fIdMin && GetReputationMgr().GetReputation(fIdMin) < qInfo->GetRequiredMinRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_NONE);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_MIN_REP);
        }

        return false;
    }

    uint32 fIdMax = qInfo->GetRequiredMaxRepFaction();      //Max required rep
    if (fIdMax && GetReputationMgr().GetReputation(fIdMax) >= qInfo->GetRequiredMaxRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_NONE);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_MAX_REP);
        }

        return false;
    }

    // ReputationObjective2 does not seem to be an objective requirement but a requirement
    // to be able to accept the quest
    if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_FACTION_MAX))
        return true;

    for (auto const& l_Objective : qInfo->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX && GetReputationMgr().GetReputation(l_Objective.ObjectID) >= l_Objective.Amount)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_OBJ_REP);
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestStatus(Quest const* p_QInfo, bool p_Msg)
{
    if (GetQuestStatus(p_QInfo->GetQuestId()) != QUEST_STATUS_NONE)
    {
        if (p_Msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_ALREADY_ON1);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_STATUS);
        }

        return false;
    }
    return true;
}

bool Player::SatisfyQuestConditions(Quest const* qInfo, bool msg)
{
    if (!sConditionMgr->IsObjectMeetingNotGroupedConditions(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, qInfo->GetQuestId(), this))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_NONE);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CONDITION);
        }

        sLog->outDebug(LOG_FILTER_CONDITIONSYS, "Player::SatisfyQuestConditions: conditions not met for quest %u", qInfo->GetQuestId());

        return false;
    }
    return true;
}

bool Player::SatisfyQuestTimed(Quest const* qInfo, bool msg)
{
    if (!m_timedquests.empty() && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_ONLY_ONE_TIMED);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_TIME);
        }

        return false;
    }
    return true;
}

bool Player::SatisfyQuestExclusiveGroup(Quest const* qInfo, bool msg)
{
    // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
    if (qInfo->GetExclusiveGroup() <= 0)
        return true;

    ObjectMgr::ExclusiveQuestGroups::iterator iter = sObjectMgr->mExclusiveQuestGroups.lower_bound(qInfo->GetExclusiveGroup());
    ObjectMgr::ExclusiveQuestGroups::iterator end  = sObjectMgr->mExclusiveQuestGroups.upper_bound(qInfo->GetExclusiveGroup());

    //ASSERT(iter != end);                                      // always must be found if qInfo->ExclusiveGroup != 0

    for (; iter != end; ++iter)
    {
        uint32 exclude_Id = iter->second;

        // skip checked quest id, only state of other quests in group is interesting
        if (exclude_Id == qInfo->GetQuestId())
            continue;

        // not allow have daily quest if daily quest from exclusive group already recently completed
        Quest const* Nquest = sObjectMgr->GetQuestTemplate(exclude_Id);
        if (!SatisfyQuestDay(Nquest) || !SatisfyQuestWeek(Nquest, false) || !SatisfyQuestSeasonal(Nquest,false))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DOUBLE_EXCL);
            }

            return false;
        }

        // alternative quest already started or completed - but don't check rewarded states if both are repeatable
        if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE || (!(qInfo->IsRepeatable() && Nquest->IsRepeatable()) && (m_RewardedQuests.find(exclude_Id) != m_RewardedQuests.end())))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_ALT_QUEST);
            }

            return false;
        }
    }
    return true;
}

bool Player::SatisfyQuestNextChain(Quest const* qInfo, bool msg)
{
    uint32 nextQuest = qInfo->GetNextQuestInChain();
    if (!nextQuest)
        return true;

    // next quest in chain already started or completed
    if (GetQuestStatus(nextQuest) != QUEST_STATUS_NONE) // GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
    {
        if (msg)
        {
            SendCanTakeQuestResponse(QUEST_ERR_NONE);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_CHAIN_NEXT);
        }

        return false;
    }

    // check for all quests further up the chain
    // only necessary if there are quest chains with more than one quest that can be skipped
    //return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
    return true;
}

bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
{
    // No previous quest in chain
    if (qInfo->prevChainQuests.empty())
        return true;

    for (Quest::PrevChainQuests::const_iterator iter = qInfo->prevChainQuests.begin(); iter != qInfo->prevChainQuests.end(); ++iter)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(*iter);

        // If any of the previous quests in chain active, return false
        if (itr != m_QuestStatus.end() && itr->second.Status != QUEST_STATUS_NONE)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(QUEST_ERR_NONE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_CHAIN_PREV);
            }

            return false;
        }
    }

    // No previous quest in chain active
    return true;
}

bool Player::SatisfyQuestDay(Quest const* qInfo)
{
    if (!qInfo->IsDaily() && !qInfo->IsDFQuest())
        return true;

    for (auto id : m_dailyQuestStorage)
    {
        if (qInfo->GetQuestId() == id)
        {
            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DAILY_DONE);

            return false;
        }
    }

    if (qInfo->IsDFQuest())
    {
        if (!m_DFQuests.empty())
        {
            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DF_DAILY);

            return false;
        }

        return true;
    }

    return true;
}

bool Player::SatisfyQuestWeek(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsWeekly() || m_weeklyquests.empty())
        return true;


    if (m_weeklyquests.find(qInfo->GetQuestId()) == m_weeklyquests.end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WEEKLY_DONE);

    return false;
}

bool Player::SatisfyQuestSeasonal(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsSeasonal() || m_seasonalquests.empty())
        return true;

    uint16 l_EventId = sGameEventMgr->GetEventIdForQuest(qInfo);
    if (m_seasonalquests.find(l_EventId) == m_seasonalquests.end() || m_seasonalquests[l_EventId].empty())
        return true;

    if (m_seasonalquests[l_EventId].find(qInfo->GetQuestId()) == m_seasonalquests[l_EventId].end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_SEASONNAL_DONE);

    return false;
}

bool Player::SatisfyQuestMonth(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsMonthly() || m_monthlyquests.empty())
        return true;

    if (m_monthlyquests.find(qInfo->GetQuestId()) == m_monthlyquests.end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_MONTHLY_DONE);

    return false;
}

bool Player::GiveQuestSourceItem(Quest const* quest)
{
    uint32 srcitem = quest->GetSrcItemId();
    
    if (auto item = sObjectMgr->GetItemTemplate(srcitem))
        if (item->StartQuest == quest->GetQuestId())
            return true;

    if (srcitem)
    {
        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);
        if (msg == EQUIP_ERR_OK)
        {
            Item* item = StoreNewItem(dest, srcitem, true);
            SendNewItem(item, QUEST_SOURCE_ITEM_COUNT, true, false);
            return true;
        }
        // player already have max amount required item, just report success
        else if (msg == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else
            SendEquipError(msg, NULL, NULL, srcitem);
        return false;
    }

    return true;
}

bool Player::TakeQuestSourceItem(uint32 questId, bool msg)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
    if (quest)
    {
        uint32 srcItemId = quest->GetSrcItemId();
        ItemTemplate const* item = sObjectMgr->GetItemTemplate(srcItemId);

        if (srcItemId > 0)
        {
            // exist two cases when destroy source quest item not possible:
            // a) non un-equippable item (equipped non-empty bag, for example)
            // b) when quest is started from an item and item also is needed in
            // the end as RequiredItemId
            InventoryResult res = CanUnequipItems(srcItemId, QUEST_SOURCE_ITEM_COUNT);
            if (res != EQUIP_ERR_OK)
            {
                if (msg)
                    SendEquipError(res, NULL, NULL, srcItemId);
                return false;
            }

            if (!quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
                return true;

            bool destroyItem = true;

            for (auto const& l_Objective : quest->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && item->StartQuest == questId && srcItemId == (uint32)l_Objective.ObjectID)
                    destroyItem = false;
            }

            if (destroyItem)
                DestroyItemCount(srcItemId, QUEST_SOURCE_ITEM_COUNT, true, true);
        }
    }

    return true;
}

bool Player::GetQuestRewardStatus(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (qInfo)
    {
        if (qInfo->IsAccountQuest())
            return m_AccountRewardedQuests.find(quest_id) != m_AccountRewardedQuests.end();

        if (qInfo->IsSeasonal() && !qInfo->IsRepeatable())
        {
            auto eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
            if (m_seasonalquests.find(eventId) != m_seasonalquests.end())
                return m_seasonalquests.find(eventId)->second.find(quest_id) != m_seasonalquests.find(eventId)->second.end();

            return false;
        }

        // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
        if (!qInfo->IsRepeatable())
            return m_RewardedQuests.find(quest_id) != m_RewardedQuests.end();

        return false;
    }
    return false;
}

QuestStatus Player::GetQuestStatus(uint32 quest_id) const
{
    if (quest_id)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
        if (itr != m_QuestStatus.end())
            return itr->second.Status;

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
        {
            if (qInfo->IsSeasonal() && !qInfo->IsRepeatable())
            {
                auto eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
                if (m_seasonalquests.find(eventId) == m_seasonalquests.end() || m_seasonalquests.find(eventId)->second.find(quest_id) == m_seasonalquests.find(eventId)->second.end())
                    return QUEST_STATUS_NONE;
            }
            if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
                return QUEST_STATUS_REWARDED;
        }
    }
    return QUEST_STATUS_NONE;
}

bool Player::CanShareQuest(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (qInfo && qInfo->HasFlag(QUEST_FLAGS_SHARABLE))
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
        if (itr != m_QuestStatus.end())
            return itr->second.Status == QUEST_STATUS_INCOMPLETE;
    }
    return false;
}

void Player::SetQuestStatus(uint32 quest_id, QuestStatus status)
{
    if (sObjectMgr->GetQuestTemplate(quest_id))
    {
        m_QuestStatus[quest_id].Status = status;
        m_QuestStatusSave[quest_id] = true;
    }

    CheckSpellAreaOnQuestStatusChange(quest_id);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    UpdateForQuestWorldObjects();
}

void Player::RemoveActiveQuest(uint32 quest_id, bool p_BonusQuest)
{
    const Quest* l_Quest = sObjectMgr->GetQuestTemplate(quest_id);
    if (!l_Quest)
        return;

    auto status = GetQuestStatus(quest_id);
    if (status == QUEST_STATUS_NONE)
        return;

    m_QuestStatus.erase(quest_id);

    if (!p_BonusQuest)
    {
        m_QuestStatusSave[quest_id] = false;

        if (l_Quest)
        {
            for (auto const& l_Objective : l_Quest->QuestObjectives)
            {
                m_questObjectiveStatus[l_Objective.ID] = 0;

                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_OPTIONAL))
                {
                    if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Objective.ObjectID))
                    {
                        if (l_ItemProto->IsQuestItem() && l_ItemProto->StartQuest != quest_id)
                            DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true);
                    }
                }

                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_OPTIONAL))
                {
                    if (auto const& l_Tree = sCriteriaMgr->GetCriteriaTree(l_Objective.ObjectID))
                    {
                        if (l_Tree->Children.empty())
                            continue;

                        auto l_Criteria = l_Tree->Children[0]->Criteria;

                        if (!l_Criteria)
                            continue;

                        if (l_Criteria->Entry->Type == CRITERIA_TYPE_COMPLETE_GARRISON_MISSION)
                            if (auto l_Garr = GetGarrison())
                                l_Garr->RemoveMission(l_Criteria->Entry->Asset.GarrMissionID);
                    }
                }
            }
        }
    }

    if (!l_Quest->HasFlag2(QUEST_FLAGS_EX_KEEP_ADDITIONAL_ITEMS))
    {
        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
        {
            if (l_Quest->RequiredSourceItemId[i])
            {
                uint32 count = l_Quest->RequiredSourceItemCount[i];

                DestroyItemCount(l_Quest->RequiredSourceItemId[i], count ? count : 9999, true);
            }
        }
    }

    CheckSpellAreaOnQuestStatusChange(quest_id);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->OnQuestAbandon(l_Quest);
#endif

    if (!IsQuestRewarded(quest_id))
    {
        if (Quest const* l_Quest = sObjectMgr->GetQuestTemplate(quest_id))
        {
            if (l_Quest->GetQuestMethod() != 3)
                RemoveObjectsFromLockoutListByQuest(quest_id);
        }

        UpdateForQuestWorldObjects();
        sScriptMgr->OnQuestAbandon(this, l_Quest);

        SmartScript l_QuestScript;
        l_QuestScript.OnInitialize(this, nullptr, l_Quest);
        l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_ABANDON, this);
    }

    if (l_Quest->InProgressPhaseID)
        SetInPhase(l_Quest->InProgressPhaseID, true, false);
}

void Player::RemoveRewardedQuest(uint32 p_QuestId)
{
    RewardedQuestSet::iterator rewItr = m_RewardedQuests.find(p_QuestId);
    if (rewItr != m_RewardedQuests.end())
    {
        uint32 l_QuestID = *rewItr;

        m_RewardedQuests.erase(l_QuestID);
        m_RewardedQuestsSave[p_QuestId] = false;

        if (Quest const* l_Quest = sObjectMgr->GetQuestTemplate(p_QuestId))
        {
            if (l_Quest->IsAccountQuest())
            {
                m_AccountRewardedQuests.erase(l_QuestID);
                m_AccountRewardedQuestsSave[p_QuestId] = false;
            }
        }

        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(p_QuestId);

        phaseMgr.NotifyConditionChanged(phaseUdateData);

        if (uint32 l_QuestBit = GetQuestUniqueBitFlag(p_QuestId))
            SetQuestBit(l_QuestBit, false);
    }
}

void Player::RemoveQuestObjectivesInternal(uint32 l_QuestID)
{
    auto l_Quest = sObjectMgr->GetQuestTemplate(l_QuestID);

    if (!l_Quest)
    {
        m_QuestStatusSave[l_QuestID] = false;

        for (auto const& l_Objective : l_Quest->QuestObjectives)
            m_questObjectiveStatus[l_Objective.ID] = 0;
    }
}

// not used in Trinity, but used in scripting code
uint16 Player::GetReqKillOrCastCurrentCount(uint32 quest_id, int32 entry)
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);

    if (!qInfo)
        return 0;

    for (auto const& l_Objective : qInfo->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC && l_Objective.ObjectID == entry)
        {
            return GetQuestObjectiveCounter(l_Objective.ID);
        }
    }

    return 0;
}

void Player::AreaExploredOrEventHappens(uint32 p_QuestId, bool p_CheckCanComplete /*= true*/)
{
    if (p_QuestId)
    {
        uint16 log_slot = FindQuestSlot(p_QuestId);
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            QuestStatusData& q_status = m_QuestStatus[p_QuestId];

            if (!q_status.Explored)
            {
                q_status.Explored = true;
                m_QuestStatusSave[p_QuestId] = true;
            }
        }

        if (p_CheckCanComplete && CanCompleteQuest(p_QuestId))
            CompleteQuest(p_QuestId);
    }
}

void Player::AdjustQuestReqItemCount(Quest const* quest)
{
    if (!quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        return;

    for (auto const& l_Objective : quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
        {
            uint32 l_Amount = std::min(GetItemCount(l_Objective.ObjectID, true), uint32(l_Objective.Amount));
            if (l_Amount)
            {
                AddDelayedEvent([this, l_Objective, l_Amount]()->void
                {
                    QuestObjectiveSatisfy(l_Objective.ObjectID, l_Amount, l_Objective.Type, 0);
                }, 1000);
            }
        }
    }
}

uint16 Player::FindQuestSlot(uint32 quest_id) const
{
    for (uint16 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
        if (GetQuestSlotQuestId(i) == quest_id)
            return i;

    return MAX_QUEST_LOG_SIZE;
}

//not used in Trinityd, function for external script library
void Player::GroupEventHappens(uint32 questId, WorldObject const* pEventObject)
{
    if (GroupPtr group = GetGroup())
    {
        group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member)
        {
            Player* player = l_Member->player;

            // for any leave or dead (with not released body) group member at appropriate distance
            if (player && player->IsAtGroupRewardDistance(pEventObject) && !player->GetCorpse())
                player->AreaExploredOrEventHappens(questId);
        });
    }
    else
        AreaExploredOrEventHappens(questId);
}

void Player::ItemAddedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData& q_status = m_QuestStatus[questid];

        if (q_status.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        for (auto const& l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && (uint32)l_Objective.ObjectID == entry)
            {
                QuestObjectiveSatisfy(l_Objective.ObjectID, count, QUEST_OBJECTIVE_TYPE_ITEM, 0);
                return;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::ItemRemovedQuestCheck(int32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);

        if (!questid)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questid];
        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);

        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
            continue;

        for (auto const& l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && l_Objective.ObjectID == entry)
            {
                uint32 currentCounter = questStatus.Status != QUEST_STATUS_COMPLETE ? GetQuestObjectiveCounter(l_Objective.ID) : GetItemCount(entry, true);
                uint32 requiredCounter = uint32(l_Objective.Amount);

                if (currentCounter < requiredCounter)
                {
                    uint16 remainingItems = currentCounter <= requiredCounter ? count : count + requiredCounter - currentCounter;

                    m_questObjectiveStatus[l_Objective.ID] = (currentCounter <= remainingItems) ? 0 : currentCounter - remainingItems;
                    m_QuestStatusSave[questid] = true;

                    IncompleteQuest(questid);
                }

                break;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::KilledMonster(CreatureTemplate const* cInfo, uint64 guid)
{
    if (cInfo->Entry)
        KilledMonsterCredit(cInfo->Entry, guid);

    for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
        if (cInfo->KillCredit[i])
            KilledMonsterCredit(cInfo->KillCredit[i], 0);
}

void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
{
    uint16 addkillcount = 1;
    uint32 real_entry = entry;
    if (guid)
    {
        Creature* killed = GetMap()->GetCreature(guid);
        if (killed && killed->GetEntry())
            real_entry = killed->GetEntry();
    }

    StartCriteriaTimer(CRITERIA_TIMED_TYPE_CREATURE, real_entry);   // MUST BE CALLED FIRST
    UpdateCriteria(CRITERIA_TYPE_KILL_CREATURE, real_entry, addkillcount, 0, guid ? GetMap()->GetCreature(guid) : NULL);

    GroupPtr l_Group = GetGroup();

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;
        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& q_status = m_QuestStatus[questid];
        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!l_Group || !l_Group->isRaidGroup() || qInfo->IsAllowedInRaid()))
        {
            for (auto const& l_Objective : qInfo->QuestObjectives)
            {
                if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL))
                {
                    if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC && l_Objective.ObjectID == (int32)real_entry)
                    {
#ifndef CROSS
                        if (auto l_GarrisonMgr = GetDraenorGarrison())
                        {
                            if (!l_GarrisonMgr->CheckGarrisonStablesQuestsConditions(questid, this))
                                continue;
                        }
#endif
                        QuestObjectiveSatisfy(l_Objective.ObjectID, addkillcount, QUEST_OBJECTIVE_TYPE_NPC, guid);

                        if (CanCompleteQuest(questid))
                            CompleteQuest(questid);
                        else
                        {
                            //Update phase or area spells by objective.
                            SetQuestStatus(questid, QUEST_STATUS_INCOMPLETE);
                        }

                        break;
                    }
                }
            }
        }
    }
}

void Player::KilledPlayerCredit()
{
    uint16 addkillcount = 1;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        GroupPtr l_Group = GetGroup();

        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& q_status = m_QuestStatus[questid];
        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!l_Group || !l_Group->isRaidGroup() || qInfo->IsAllowedInRaid()))
        {
            for (auto const& l_Objective : qInfo->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_PLAYER)
                {
                    uint32 currentCounter = GetQuestObjectiveCounter(l_Objective.ID);
                    if (currentCounter < uint32(l_Objective.Amount))
                    {
                        m_questObjectiveStatus[l_Objective.ID] = currentCounter + addkillcount;
                        m_QuestStatusSave[questid] = true;

                        SendQuestUpdateAddPlayer(qInfo, l_Objective, currentCounter, addkillcount);
                    }

                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);

                    break;
                }
            }
        }
    }
}

void Player::CastedCreatureOrGO(uint32 /*entry*/, uint64 guid, uint32 spell_id)
{
    QuestObjectiveSatisfy(spell_id, 1, QUEST_OBJECTIVE_TYPE_SPELL, guid);
}

void Player::TalkedToCreature(uint32 entry, uint64 guid)
{
    QuestObjectiveSatisfy(entry, 1, QUEST_OBJECTIVE_TYPE_NPC_INTERACT, guid);
}

void Player::MoneyChanged(uint64 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        for (QuestObjective const& obj : qInfo->QuestObjectives)
        {
            if (obj.Type != QUEST_OBJECTIVE_TYPE_MONEY)
                continue;

            QuestStatusData& q_status = m_QuestStatus[questid];

            if (q_status.Status == QUEST_STATUS_INCOMPLETE)
            {
                if (int32(count) >= obj.Amount)
                {
                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);
                }
            }
            else if (q_status.Status == QUEST_STATUS_COMPLETE)
            {
                if (int32(count) < obj.Amount)
                    IncompleteQuest(questid);
            }
        }
    }
}

void Player::ReputationChanged(FactionEntry const* factionEntry)
{
    ReputationChangedQuestCheck(factionEntry);
}

void Player::ReputationChanged2(FactionEntry const* factionEntry)
{
    ReputationChangedQuestCheck(factionEntry);
}

void Player::ReputationChangedQuestCheck(FactionEntry const* factionEntry)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_FACTION_MAX))
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];

        for (auto const& l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MAX || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_MIN)
            {
                if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) >= l_Objective.Amount)
                        if (CanCompleteQuest(questId))
                            CompleteQuest(questId);
                }
                else if (questStatus.Status == QUEST_STATUS_COMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) < l_Objective.Amount)
                        IncompleteQuest(questId);
                }
            }
        }
    }
}

void Player::QuestObjectiveSatisfy(uint32 objectId, uint32 amount, uint8 type, uint64 guid, bool p_Set /*= false*/)
{
    bool l_UpdatePhasing = false;

    for (uint8 l_I = 0; l_I < MAX_QUEST_LOG_SIZE; ++l_I)
    {
        uint32 questId = GetQuestSlotQuestId(l_I);
        if (!questId)
            continue;

        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
        if (!quest)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];
        if (questStatus.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        std::vector<uint32>* l_ScriptedQuests = sObjectMgr->GetScriptedQuests();
        if (std::find(l_ScriptedQuests->begin(), l_ScriptedQuests->end(), questId) != l_ScriptedQuests->end())
            AreaExploredOrEventHappens(questId, false);

        if (type)
        {
            if (!quest->GetQuestObjectiveCountType(type))
                continue;
        }

        for (auto const& l_Objective : quest->QuestObjectives)
        {
            if (l_Objective.Type == type && (uint32)l_Objective.ObjectID == objectId)
            {
                uint32 currentCounter   = p_Set ? 0 : GetQuestObjectiveCounter(l_Objective.ID);
                uint32 requiredCounter  = uint32(l_Objective.Amount);
                uint32 addCounter       = currentCounter + amount > requiredCounter ? requiredCounter : currentCounter +amount;

                /// The counter is already handled in the criteria system and sometime the amount set by the criteria tree is 0
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE)
                    addCounter = requiredCounter - currentCounter;

                m_questObjectiveStatus[l_Objective.ID] = addCounter;
                m_QuestStatusSave[questId] = true;

                l_UpdatePhasing = true;

                UpdateForQuestWorldObjects();

                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC)
                {
                    if (currentCounter + amount == requiredCounter)
                    {
                        SmartScript l_QuestScript;
                        l_QuestScript.OnInitialize(this, nullptr, quest);
                        l_QuestScript.ProcessEventsFor(SMART_EVENT_QUEST_OBJ_COPLETION, this, l_Objective.ID);
                        sScriptMgr->OnObjectiveValidate(this, questId, l_Objective.ID);
                    }
                }

                if (l_Objective.Index >= 0 /*&& (obj->Flags & QUEST_OBJECTIVE_FLAG_HIDEN) == 0*/ && l_Objective.Type != QUEST_OBJECTIVE_TYPE_CRITERIA_TREE && currentCounter < requiredCounter)
                {
                    SetQuestSlotCounter(l_I, l_Objective.Index, addCounter);

                    WorldPacket data(SMSG_QUEST_UPDATE_ADD_CREDIT, (4 * 4 + 8));
                    data.appendPackGUID(guid);
                    data << uint32(quest->GetQuestId());
                    data << uint32(l_Objective.ObjectID);
                    data << uint16(addCounter);
                    data << uint16(l_Objective.Amount);
                    data << uint8(l_Objective.Type);

                    GetSession()->SendPacket(&data);
                }

                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE)
                {
                    SetQuestSlotCounter(l_I, l_Objective.Index, addCounter);

                    SetByteFlag(PLAYER_FIELD_QUEST_LOG + l_I * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, 1, 1 << l_Objective.Index);

                    WorldPacket data(SMSG_QUEST_UPDATE_ADD_CREDIT_SIMPLE, (4 * 4 + 8));
                    data << uint32(quest->GetQuestId());
                    data << uint32(l_Objective.ObjectID);
                    data << uint8(l_Objective.Type);

                    GetSession()->SendPacket(&data);
                }

                if (MS::WorldQuest::Template::GetTemplate(quest->GetQuestId()))
                {
                    WorldPacket l_Data(SMSG_UPDATE_TASK_PROGRESS, 4 * 5 + 2 * quest->QuestObjectives.size());
                    l_Data << uint32(1);                        ///< Count
                    l_Data << uint32(quest->GetQuestId());      ///< QuestID
                    l_Data << uint32(0);                        ///< FailTimer
                    l_Data << uint32(0);                        ///< Flags
                    l_Data << uint32(quest->QuestObjectives.size());

                    for (auto const& l_UpdateObjective : quest->QuestObjectives)
                    {
                        l_Data << uint16(GetQuestObjectiveCounter(l_UpdateObjective.ID));
                    }

                    SendDirectMessage(&l_Data);
                }

                /// Most objectives dont have CompleteQuest handler in the call, this must be here!
                if (l_Objective.Type != QUEST_OBJECTIVE_TYPE_NPC && CanCompleteQuest(questId))
                {
                    CompleteQuest(questId);
                }
            }
        }
    }

    if (l_UpdatePhasing)
    {
        AddCriticalOperation([this]() -> void
        {
            phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
        });
    }
}

void Player::QuestObjectiveOptionalSatisfy(uint32 objectId)
{
    bool l_UpdatePhasing = false;

    for (uint8 l_I = 0; l_I < MAX_QUEST_LOG_SIZE; ++l_I)
    {
        uint32 questId = GetQuestSlotQuestId(l_I);
        if (!questId)
            continue;

        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
        if (!quest)
            continue;

        for (auto const& l_Objective : quest->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC && l_Objective.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL && (uint32)l_Objective.ObjectID == objectId)
            {
                uint32 currentCounter = GetQuestObjectiveCounter(l_Objective.ID);
                uint32 requiredCounter = uint32(l_Objective.Amount);
                uint32 addCounter = currentCounter + 1 > requiredCounter ? requiredCounter : currentCounter + 1;

                m_questObjectiveStatus[l_Objective.ID] = addCounter;
                m_QuestStatusSave[questId] = true;

                l_UpdatePhasing = true;

                if (l_Objective.Index >= 0 && l_Objective.Type != QUEST_OBJECTIVE_TYPE_CRITERIA_TREE && currentCounter < requiredCounter)
                {
                    SetQuestSlotCounter(l_I, l_Objective.Index, addCounter);

                    WorldPacket data(SMSG_QUEST_UPDATE_ADD_CREDIT, (4 * 4 + 8));
                    data.appendPackGUID(0);
                    data << uint32(quest->GetQuestId());
                    data << uint32(l_Objective.ObjectID);
                    data << uint16(addCounter);
                    data << uint16(l_Objective.Amount);
                    data << uint8(l_Objective.Type);

                    GetSession()->SendPacket(&data);
                }
            }
        }
    }

    if (l_UpdatePhasing)
        phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
}

bool Player::HasQuestForItem(uint32 itemid) const
{
    if (!itemid)
        return false;

    GroupPtr l_Group = GetGroup();

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& q_status = qs_itr->second;

        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
            if (!qinfo)
                continue;

            // hide quest if player is in raid-group and quest is no raid quest
            if (l_Group && l_Group->isRaidGroup() && !qinfo->IsAllowedInRaid())
                if (!InBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                    continue;

            for (auto const& l_QuestObjective : qinfo->QuestObjectives)
            {
                if (itemid == (uint32)l_QuestObjective.ObjectID && GetQuestObjectiveCounter(l_QuestObjective.ID) < uint32(l_QuestObjective.Amount))
                    return true;
            }

            // This part - for ReqSource
            for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
            {
                // examined item is a source item
                if (qinfo->RequiredSourceItemId[j] == itemid)
                {
                    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemid);

                    // 'unique' item
                    if (pProto->MaxCount && int32(GetItemCount(itemid, true)) < pProto->MaxCount)
                        return true;

                    // allows custom amount drop when not 0
                    if (qinfo->RequiredSourceItemCount[j])
                    {
                        if (GetItemCount(itemid, true) < qinfo->RequiredSourceItemCount[j])
                            return true;
                    }
                    else if (GetItemCount(itemid, true) < pProto->GetMaxStackSize())
                        return true;
                }
            }
        }
    }
    return false;
}

bool Player::HasQuestForCreature(CreatureTemplate const* cInfo) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& q_status = qs_itr->second;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        // There should be no mixed ReqItem/ReqSource drop
        // This part for ReqItem drop
        for (auto const& obj : qInfo->QuestObjectives)
        {
            if (obj.Type == QUEST_OBJECTIVE_TYPE_NPC)
            {
                if (cInfo->Entry == uint32(obj.ObjectID))
                    return true;
                for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
                    if (cInfo->KillCredit[i] && cInfo->KillCredit[i] == uint32(obj.ObjectID))
                        return true;
            }
            if (obj.Type == QUEST_OBJECTIVE_TYPE_ITEM)
            {
                for (uint8 i = 0; i < MAX_CREATURE_QUEST_ITEMS; ++i)
                    if (cInfo->questItems[i] && cInfo->questItems[i] == uint32(obj.ObjectID))
                        return true;
            }
        }
    }
    return false;
}

bool Player::HasQuest(uint32 p_QuestID) const
{
    for (uint8 l_I = 0; l_I < MAX_QUEST_LOG_SIZE; ++l_I)
    {
        uint32 l_QuestID = GetQuestSlotQuestId(l_I);
        if (l_QuestID == 0)
            continue;

        if (l_QuestID == p_QuestID)
            return true;
    }

    return false;
}

void Player::SendQuestComplete(Quest const* quest)
{
    if (quest)
    {
        WorldPacket data(SMSG_QUEST_UPDATE_COMPLETE, 4);
        data << uint32(quest->GetQuestId());
        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestReward(Quest const* quest, uint32 XP, Object* questGiver)
{
    uint32 questId = quest->GetQuestId();
    sGameEventMgr->HandleQuestComplete(questId);

    uint32 xp;
    int64 moneyReward;

    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        xp = XP;
        moneyReward = quest->MoneyValue(getLevel());
    }
    else // At max level, increase gold reward
    {
        xp = 0;
        moneyReward = int64(quest->MoneyValue(getLevel()) + int32(quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY)));
    }

    if (moneyReward < 0)
        moneyReward = 0;

    bool p_UseQuestReward     = false;
    bool p_LaunchGossip       = false;
    bool p_LaunchQuest        = false;
    bool p_HideChatMessage    = false;

    WorldPacket data(SMSG_QUEST_GIVER_QUEST_COMPLETE, 38);
    data << uint32(questId);                       ///< QuestId
    data << uint32(xp);                            ///< XpReward
    data << uint64(moneyReward);                   ///< MoneyReward
    data << uint32(quest->GetRewardSkillId());     ///< SkillLineIDReward
    data << uint32(quest->GetRewardSkillPoints()); ///< NumSkillUpsReward

    data.WriteBit(p_UseQuestReward);               ///< UseQuestReward
    data.WriteBit(p_LaunchGossip);                 ///< LaunchGossip
    data.FlushBits();

    data.WriteBit(p_LaunchQuest);                  ///< LaunchQuest
    data.WriteBit(p_HideChatMessage);              ///< HideChatMessage
    data.FlushBits();

    /// @TODO
    /// The response should contain the rewards too
    /// From WowPacketParser
    ///(ItemReward) ItemID: 0 (0)
    ///(ItemReward) RandomPropertiesSeed: 0
    ///(ItemReward) RandomPropertiesID: 0
    ///(ItemReward) HasItemBonus: False
    ///(ItemReward) HasModifications: False

    data << uint32(0);                             ///< ItemID
    data << uint32(0);                             ///< RandomPropertiesSeed
    data << uint32(0);                             ///< RandomPropertiesID

    data.WriteBit(0);                              ///< hasItemBonus
    data.WriteBit(0);                              ///< hasModifications
    data.FlushBits();

    GetSession()->SendPacket(&data);

    if (quest->GetQuestCompleteScript() != 0)
        GetMap()->ScriptsStart(sQuestEndScripts, quest->GetQuestCompleteScript(), questGiver, this);
}

void Player::SendQuestFailed(uint32 questId, InventoryResult reason)
{
    if (questId)
    {
        WorldPacket data(SMSG_QUEST_GIVER_QUEST_FAILED, 4 + 4);
        data << uint32(questId);
        data << uint32(reason);                             // Failed reason (valid reasons: 4, 16, 50, 17, 74, other values show default message)
        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestTimerFailed(uint32 quest_id)
{
    if (quest_id)
    {
        WorldPacket data(SMSG_QUEST_UPDATE_FAILED_TIMER, 4);
        data << uint32(quest_id);
        GetSession()->SendPacket(&data);
    }
}

void Player::SendCanTakeQuestResponse(uint32 msg) const
{
    WorldPacket data(SMSG_QUEST_GIVER_INVALID_QUEST, 4 + 2);
    data << uint32(msg);
    data << int32(0);           ///< ContributionRewardID
    data.WriteBit(true);        ///< SendErrorMessage
    data.WriteBits(0, 9);       ///< Reason text
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendQuestConfirmAccept(const Quest* quest, Player* pReceiver)
{
    if (pReceiver)
    {
        std::string strTitle = quest->GetTitle();

        int loc_idx = pReceiver->GetSession()->GetSessionDbLocaleIndex();
        if (loc_idx >= 0)
            if (const QuestLocale* pLocale = sObjectMgr->GetQuestLocale(quest->GetQuestId()))
                ObjectMgr::GetLocaleString(pLocale->Title, loc_idx, strTitle);

        WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, 200);
        data << uint32(quest->GetQuestId());
        data.appendPackGUID(GetGUID());
        data.WriteBits(strTitle.size(), 10);
        data.FlushBits();
        data.WriteString(strTitle);
        pReceiver->GetSession()->SendPacket(&data);
    }
}

void Player::SendPushToPartyResponse(Player* player, uint32 msg)
{
    if (player)
    {
        WorldPacket data(SMSG_QUEST_PUSH_RESULT, 16 + 2 + 1);

        data.appendPackGUID(player->GetGUID());
        data << uint8(msg);

        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestUpdateAddPlayer(Quest const* p_Quest, const QuestObjective & p_Objective, uint16 p_OldCount, uint16 p_AddCount)
{
    ASSERT(p_OldCount + p_AddCount < 65536 && "player count store in 16 bits");

    WorldPacket data(SMSG_QUEST_UPDATE_ADD_PVP_CREDIT, (2*4) + 1);
    data << uint32(p_Quest->GetQuestId());
    data << uint16(p_OldCount + p_AddCount);
    GetSession()->SendPacket(&data);

    uint16 log_slot = FindQuestSlot(p_Quest->GetQuestId());

    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlotCounter(log_slot, p_Objective.Index, GetQuestSlotCounter(log_slot, p_Objective.Index) + p_AddCount);
}

/*********************************************************/
/***                   LOAD SYSTEM                     ***/
/*********************************************************/
void Player::Initialize(uint32 guid)
{
    Object::_Create(guid, 0, HIGHGUID_PLAYER);
}

void Player::_LoadDeclinedNames(PreparedQueryResult result)
{
    if (!result)
        return;

    delete m_declinedname;
    m_declinedname = new DeclinedName;
    for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
        m_declinedname->name[i] = (*result)[i].GetString();
}

void Player::_LoadEquipmentSets(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
    if (!result)
        return;

    uint32 count = 0;
    do
    {
        Field* fields = result->Fetch();
        EquipmentSet equipSet;

        equipSet.Guid              = fields[0].GetUInt64();
        uint8 index                = fields[1].GetUInt8();
        equipSet.Name              = fields[2].GetString();
        equipSet.IconName          = fields[3].GetString();
        equipSet.IgnoreMask        = fields[4].GetUInt32();
        equipSet.state             = EQUIPMENT_SET_UNCHANGED;
        equipSet.AssignedSpecIndex = fields[24].GetInt32();

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
#ifndef CROSS
            equipSet.Items[i] = fields[5+i].GetUInt32();
#else /* CROSS */
        {
            uint32 originalItemGuidLow = fields[5 + i].GetUInt32();

            equipSet.OriginalItems[i] = originalItemGuidLow;
            equipSet.Items[i] = 0;

            // don't try to find item if originalGuid = 0
            if (originalItemGuidLow == 0)
                continue;

            // now find items at the cross-server
            for (uint8 j = 0; j < PLAYER_SLOTS_COUNT; ++j)
            {
                Item* item = m_items[j];
                if (!item)
                    continue;

                if (IsBagPos(item->GetPos()))
                {
                    if (Bag* pBag = item->ToBag())
                    {
                        for (uint8 k = 0; k < MAX_BAG_SIZE; ++k)
                        {
                            Item* itemInBag = pBag->GetItemByPos(k);
                            if (!itemInBag)
                                continue;

                            if (itemInBag->GetRealGUIDLow() == originalItemGuidLow)
                            {
                                equipSet.Items[i] = itemInBag->GetGUIDLow();
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (item->GetRealGUIDLow() == originalItemGuidLow)
                    {
                        equipSet.Items[i] = item->GetGUIDLow();
                        break;
                    }
                }
            }
        }
#endif /* CROSS */

        m_EquipmentSets[index] = equipSet;

        ++count;

        if (count >= MAX_EQUIPMENT_SET_INDEX)                // client limit
            break;
    }
    while (result->NextRow());
}

void Player::_LoadBracketData(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    //          0        1           2                  3                  4                     5               6         7        8         9           10            11             12         13
    // SELECT bracket, rating, bestRatingOfWeek, bestRatingOfPrevWeek, bestRatingOfSeason, matchMakerRating, dayGames, dayWins, weekGames, weekWins, prevWeekWins, prevWeekGames, seasonGames, seasonWins

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint8 l_Bracket = l_Fields[0].GetUInt8();
        m_ArenaPersonalRating[l_Bracket]   = l_Fields[1].GetUInt32();
        m_BestRatingOfWeek[l_Bracket]      = l_Fields[2].GetUInt32();
        m_BestRatingOfPrevWeek[l_Bracket]  = l_Fields[3].GetUInt32();
        m_BestRatingOfSeason[l_Bracket]    = l_Fields[4].GetUInt32();
        m_ArenaMatchMakerRating[l_Bracket] = l_Fields[5].GetUInt32();
        m_DayGames[l_Bracket]              = l_Fields[6].GetUInt32();
        m_DayWins[l_Bracket]               = l_Fields[7].GetUInt32();
        m_WeekGames[l_Bracket]             = l_Fields[8].GetUInt32();
        m_WeekWins[l_Bracket]              = l_Fields[9].GetUInt32();
        m_PrevWeekWins[l_Bracket]          = l_Fields[10].GetUInt32();
        m_PrevWeekGames[l_Bracket]         = l_Fields[11].GetUInt32();
        m_SeasonGames[l_Bracket]           = l_Fields[12].GetUInt32();
        m_SeasonWins[l_Bracket]            = l_Fields[13].GetUInt32();
    }
    while (p_Result->NextRow());
}

void Player::_LoadBGData(PreparedQueryResult result)
{
    if (!result)
        return;

    Field* fields = result->Fetch();
    // Expecting only one row
    //        0           1     2      3      4      5      6          7          8        9            10
    // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell, lastActiveSpec FROM character_battleground_data WHERE guid = ?

#ifndef CROSS
    m_bgData.bgInstanceID = fields[0].GetUInt32();
    m_bgData.bgTeam       = fields[1].GetUInt16();
#else /* CROSS */
    m_bgData.m_ReconnectBgTeam = fields[1].GetUInt16();
#endif /* CROSS */
    m_bgData.joinPos      = WorldLocation(fields[6].GetUInt16(),    // Map
                                          fields[2].GetFloat(),     // X
                                          fields[3].GetFloat(),     // Y
                                          fields[4].GetFloat(),     // Z
                                          fields[5].GetFloat());    // Orientation
    m_bgData.taxiPath[0]  = fields[7].GetUInt32();
    m_bgData.taxiPath[1]  = fields[8].GetUInt32();
    m_bgData.mountSpell   = fields[9].GetUInt32();
    m_bgData.m_LastActiveSpec = fields[10].GetUInt16();
#ifndef CROSS
    m_bgData.bgTypeID = (BattlegroundTypeId)fields[11].GetUInt32();
    m_bgData.IsRandom = fields[12].GetBool();
#endif
}

bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return false;

    Field* fields = result->Fetch();

    x = fields[0].GetFloat();
    y = fields[1].GetFloat();
    z = fields[2].GetFloat();
    o = fields[3].GetFloat();
    mapid = fields[4].GetUInt16();
    in_flight = !fields[5].GetString().empty();
#endif
    return true;
}

uint32 GetSelectionFromContext(uint32 p_Context, uint32 p_Class)
{
    switch (p_Context)
    {
        case 1:
            if (p_Class == Classes::CLASS_DEATH_KNIGHT)
                return 1;
            if (p_Class == Classes::CLASS_DEMON_HUNTER)
                return 3;
            return 0;
        case 2:
            if (p_Class == Classes::CLASS_DEATH_KNIGHT)
                return 5;
            if (p_Class == Classes::CLASS_DEMON_HUNTER)
                return 6;
            return 4;
        case 3:
            return 7;
        case 4:
            if (p_Class == Classes::CLASS_DEATH_KNIGHT)
                return 9;
            if (p_Class == Classes::CLASS_DEMON_HUNTER)
                return 10;
            return 8;
        default:
            if (p_Class == Classes::CLASS_DEATH_KNIGHT)
                return 1;
            if (p_Class == Classes::CLASS_DEMON_HUNTER)
                return 2;
            return 0;
    }

    return 0;
}

bool ComponentFlagsMatch(CharSectionsEntry const* p_Entry, uint32 p_Selection)
{
    switch (p_Selection)
    {
        case 0:
            if (!(p_Entry->Flags & 1))
                return false;
            return !(p_Entry->Flags & 0x2C);
        case 1:
            if (!(p_Entry->Flags & 1))
                return false;
            if (!(p_Entry->Flags & 0x94))
                return false;
            return !(p_Entry->Flags & 8);
        case 2:
            if (!(p_Entry->Flags & 1))
                return false;
            if (!(p_Entry->Flags & 0x70))
                return false;
            return !(p_Entry->Flags & 8);
        case 3:
            if (!(p_Entry->Flags & 1))
                return false;
            if (!(p_Entry->Flags & 0x20))
                return false;
            return !(p_Entry->Flags & 8);
        case 4:
        case 8:
            if (!(p_Entry->Flags & 3))
                return false;
            return !(p_Entry->Flags & 0x2C);
        case 5:
        case 9:
            if (!(p_Entry->Flags & 3))
                return false;
            if (!(p_Entry->Flags & 0x94))
                return false;
            return !(p_Entry->Flags & 8);
        case 6:
        case 10:
            if (!(p_Entry->Flags & 3))
                return false;
            if (!(p_Entry->Flags & 0x70))
                return false;
            return !(p_Entry->Flags & 8);
        case 7:
            return true;
        default:
            break;
    }

    return false;
}

bool IsSectionFlagValid(CharSectionsEntry const* p_Entry, uint8 p_Class, bool p_Create)
{
    if (p_Create)
        return ComponentFlagsMatch(p_Entry, GetSelectionFromContext(0, p_Class));

    return ComponentFlagsMatch(p_Entry, GetSelectionFromContext(2, p_Class));
}

bool Player::ValidateAppearance(uint8 p_Race, uint8 p_Class, uint8 p_Gender, uint8 p_HairID, uint8 p_HairColor, uint8 p_FaceID, uint8 p_FacialHair, uint8 p_SkinColor, std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> const& p_CustomDisplay, bool p_Create /*= false*/)
{
    CharSectionsEntry const* l_Skin = GetCharSectionEntry(p_Race, SECTION_TYPE_SKIN, p_Gender, 0, p_SkinColor);
    if (!l_Skin)
        return false;

    if (!IsSectionFlagValid(l_Skin, p_Class, p_Create))
        return false;

    CharSectionsEntry const* l_Face = GetCharSectionEntry(p_Race, SECTION_TYPE_FACE, p_Gender, p_FaceID, p_SkinColor);
    if (!l_Face)
        return false;

    if (!IsSectionFlagValid(l_Face, p_Class, p_Create))
        return false;

    CharSectionsEntry const* l_Hair = GetCharSectionEntry(p_Race, SECTION_TYPE_HAIR, p_Gender, p_HairID, p_HairColor);
    if (!l_Hair)
        return false;

    if (!IsSectionFlagValid(l_Hair, p_Class, p_Create))
        return false;

    CharSectionsEntry const* l_FacialHair = GetCharSectionEntry(p_Race, SECTION_TYPE_FACIAL_HAIR, p_Gender, p_FacialHair, p_HairColor);
    if (!l_FacialHair)
        return false;

    if (!IsSectionFlagValid(l_FacialHair, p_Class, p_Create))
        return false;

    for (uint8 l_I = 0; l_I < PLAYER_CUSTOM_DISPLAY_SIZE; ++l_I)
    {
        if (CharSectionsEntry const* l_CharSection = GetCharSectionEntry(p_Race, CharSectionType(SECTION_TYPE_CUSTOM_DISPLAY_1 + l_I * 2), p_Gender, p_CustomDisplay[l_I], 0))
        {
            if (!IsSectionFlagValid(l_CharSection, p_Class, p_Create))
                return false;
        }
    }

    return true;
}

void Player::SetHomebind(WorldLocation const& loc, uint32 area_id)
{
    m_homebindMapId  = loc.GetMapId();
    m_homebindAreaId = area_id;
    m_homebindX      = loc.GetPositionX();
    m_homebindY      = loc.GetPositionY();
    m_homebindZ      = loc.GetPositionZ();

    // update sql homebind
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_HOMEBIND);
    stmt->setUInt16(0, m_homebindMapId);
    stmt->setUInt16(1, m_homebindAreaId);
    stmt->setFloat (2, m_homebindX);
    stmt->setFloat (3, m_homebindY);
    stmt->setFloat (4, m_homebindZ);
    stmt->setUInt32(5, GetRealGUIDLow());
    RealmDatabase.Execute(stmt);
}

uint32 Player::GetUInt32ValueFromArray(Tokenizer const& data, uint16 index)
{
    if (index >= data.size())
        return 0;

    return (uint32)atoi(data[index]);
}

uint64 Player::GetUInt64ValueFromArray(Tokenizer const& p_Datas, uint16 p_Index)
{
    if (p_Index >= p_Datas.size())
        return 0;

    return (uint64)strtoull(p_Datas[p_Index], nullptr, 10);
}

float Player::GetFloatValueFromArray(Tokenizer const& data, uint16 index)
{
    float result;
    uint32 temp = Player::GetUInt32ValueFromArray(data, index);
    memcpy(&result, &temp, sizeof(result));

    return result;
}

bool Player::LoadFromDB(uint32 guid, SQLQueryHolder* holder, SQLQueryHolder* p_LoginDBQueryHolder)
{
    /// 0             1               2               3                  4                         5                         6                      7                               8                    9
    /// guid,         account,        name,           race,              class,                    gender,                   level,                 xp,                             money,               playerBytes,
    /// 10            11              12              13                 14                        15                        16                     17                              18                   19
    /// playerBytes2, playerFlags,    position_x,     position_y,        position_z,               map,                      orientation,           taximask,                       cinematic,           totaltime,
    /// 20            21              22              23                 24                        25                        26                     27                              28                   29
    /// leveltime,    rest_bonus,     logout_time,    is_logout_resting, resettalents_cost,        resettalents_time,        talentTree,            trans_x,                        trans_y,             trans_z,
    /// 30            31              32              33                 34                        35                        36                     37                              38                   39
    /// trans_o,      transguid,      extra_flags,    stable_slots,      at_login,                 zone,                     online,                death_expire_time,              taxi_path,           DungeonDifficulty,
    /// 40            41              42              43                 44                        45                        46                     47                              48
    /// totalKills,   todayKills,     yesterdayKills, chosenTitle,       watchedFaction,           health,                   power1,                power2,                         power3,
    /// 49            50              51              52                 53                        54                        55                     56                              57                   58                   59
    /// power4,       power5,         power6,         instance_id,       primarySpecialization,    activespec,               lootSpecID,            UNUSED_OLD_specialization2,     exploredZones,       equipmentCache,      knownTitles,
    /// 60            61              62                 63              64                        65                        66                     67                              68                   69
    /// actionBars,   currentpetslot, grantableLevels,   playerFlagsEx,  RaidDifficulty,           LegacyRaidDifficuly,      lastbattlepet,         xprate                          end_sale,            BackPackAutoSortDisabled
    ///     70
    /// playerBytes3

    uint32 l_StartTime = getMSTime();
    std::vector<uint32> l_Times;

    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADFROM);
    if (!result)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) not found in table `characters`, can't load. ", guid);
        return false;
    }

    Field* fields = result->Fetch();

    uint32 dbAccountId = fields[1].GetUInt32();

    m_EndSalesTimestamp = fields[68].GetUInt32();
    if (m_EndSalesTimestamp > time(nullptr))
        return false;

    if (m_atLoginFlags & AT_LOGIN_LOCKED_FOR_TRANSFER)
        return false;

    m_atLoginFlags = fields[34].GetUInt16();

    // check if the character's account in the db and the logged in account match.
    // player should be able to load/delete character only with correct account!
    if (dbAccountId != GetSession()->GetAccountId())
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) loading from wrong account (is: %u, should be: %u)", guid, GetSession()->GetAccountId(), dbAccountId);
        return false;
    }

    if (holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBANNED))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) is banned, can't load.", guid);
        return false;
    }

    Object::_Create(guid, 0, HIGHGUID_PLAYER);

    SetBackPackAutoSortDisabled(fields[69].GetBool());

    if (m_atLoginFlags & AT_LOGIN_CONVERT_FACTION)
    {
        uint8 l_CurrentRace = fields[3].GetUInt8();

        BattlegroundTeamId l_Team = BG_TEAM_ALLIANCE;
        switch (l_CurrentRace)
        {
            case RACE_ORC:
            case RACE_GOBLIN:
            case RACE_TAUREN:
            case RACE_UNDEAD_PLAYER:
            case RACE_TROLL:
            case RACE_BLOODELF:
            case RACE_PANDAREN_HORDE:
            case RACE_NIGHTBORNE:
            case RACE_HIGHMOUNTAIN_TAUREN:
                l_Team = BG_TEAM_HORDE;
                break;
            default:
                break;
        }


        SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
        Player::GenerateFactionConversionQuery(l_Transaction, GetGUIDLow(), l_Team, fields[59].GetCString());
        CharacterDatabase.CommitTransaction(l_Transaction);

        RemoveAtLoginFlag(AT_LOGIN_CONVERT_FACTION, true);
        return false;
    }

    if (m_atLoginFlags & AT_LOGIN_ITEM_CHANGE_FACTION)
    {
        uint8 l_CurrentRace = fields[3].GetUInt8();

        BattlegroundTeamId l_Team = BG_TEAM_ALLIANCE;
        switch (l_CurrentRace)
        {
            case RACE_ORC:
            case RACE_GOBLIN:
            case RACE_TAUREN:
            case RACE_UNDEAD_PLAYER:
            case RACE_TROLL:
            case RACE_BLOODELF:
            case RACE_PANDAREN_HORDE:
            case RACE_NIGHTBORNE:
            case RACE_HIGHMOUNTAIN_TAUREN:
                l_Team = BG_TEAM_HORDE;
                break;
            default:
                break;
        }


        SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
        Player::GenerateFactionConversionQuery(l_Transaction, GetGUIDLow(), l_Team, fields[59].GetCString(), true);
        CharacterDatabase.CommitTransaction(l_Transaction);

        RemoveAtLoginFlag(AT_LOGIN_ITEM_CHANGE_FACTION, true);
        return false;
    }

    m_name = fields[2].GetString();

    // check name limitations
    if (ObjectMgr::CheckPlayerName(m_name) != CHAR_NAME_SUCCESS ||
        (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && sObjectMgr->IsReservedName(m_name)))
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);

        stmt->setUInt16(0, uint16(AT_LOGIN_RENAME));
        stmt->setUInt32(1, guid);

        CharacterDatabase.Execute(stmt);

        return false;
    }

    // overwrite possible wrong/corrupted guid
    SetGuidValue(OBJECT_FIELD_GUID, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

    uint8 Gender = fields[5].GetUInt8();
    if (!IsValidGender(Gender))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) has wrong gender (%hhu), can't be loaded.", guid, Gender);
        return false;
    }

    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_RACE, fields[3].GetUInt8());
    SetOriginalRace(fields[3].GetUInt8());
    SetByteValue(UNIT_FIELD_SEX, UNIT_BYTES_0_OFFSET_CLASS, fields[4].GetUInt8());
    SetGender(Gender);

    SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
    SetUInt32Value(PLAYER_FIELD_XP, fields[7].GetUInt32());

    _LoadIntoDataField(fields[57].GetCString(), PLAYER_FIELD_EXPLORED_ZONES, PLAYER_EXPLORED_ZONES_SIZE, false);
    _LoadIntoDataField(fields[59].GetCString(), PLAYER_FIELD_KNOWN_TITLES, KNOWN_TITLES_SIZE, true);

    SetObjectScale(1.0f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);

    // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateCriteria)
    m_achievementMgr->LoadFromDB(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_QUERY_LOAD_ACCOUNT_ACHIEVEMENTS),   holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACHIEVEMENTS),
                                 p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_QUERY_LOAD_CRITERIA_PROGRESS),      holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CRITERIA_PROGRESS));

    uint64 money = fields[8].GetUInt64();
    if (money > MAX_MONEY_AMOUNT)
        money = MAX_MONEY_AMOUNT;
    SetMoney(money);

    SetGuidValue(PLAYER_FIELD_WOW_ACCOUNT, GetSession()->GetWoWAccountGUID());
    SetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID, fields[9].GetUInt32());
    SavePlayerBytes(fields[9].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, fields[10].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_INEBRIATION, fields[70].GetUInt32());
    SetByteValue(PLAYER_FIELD_INEBRIATION, PLAYER_BYTES_3_OFFSET_GENDER, Gender);
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS, fields[11].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX, fields[63].GetUInt32());
    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fields[44].GetUInt32());

    SetInventorySlotCount(INVENTORY_DEFAULT_SIZE);

    // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
    SetByteValue(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES, fields[60].GetUInt8());

    InitDisplayIds();

    SetFloatValue(UNIT_FIELD_MOD_TIME_RATE, 1.0f);
    m_currentPetSlot = (PetSlot)fields[61].GetUInt8();

    // cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);
        SetVisibleItemSlot(slot, NULL);

        if (Item * l_Item = m_items[slot])
            sLog->outAshran("Player::LoadFromDB: m_items[%u] : %u", slot, l_Item->GetEntry());

        //delete m_items[slot];
        m_items[slot] = NULL;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Load Basic value of player %s is: ", m_name.c_str());
    outDebugValues();

    //Need to call it to initialize m_team (m_team can be calculated from race)
    //Other way is to saves m_team into characters table.
    setFactionForRace(getRace());

    // load home bind and check in same time class/race pair, it used later for restore broken positions
    if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADHOMEBIND)))
        return false;

    InitPrimaryProfessions();                               // to max set before any spell loaded


    // init saved position, and fix it later if problematic
    uint32 transGUID = uint32(fields[31].GetUInt32());

    Relocate(fields[12].GetFloat(), fields[13].GetFloat(), fields[14].GetFloat(), fields[16].GetFloat());

    uint32 mapId = fields[15].GetUInt16();
    uint32 instanceId = fields[52].GetUInt32();

    SetDungeonDifficultyID(CheckLoadedDungeonDifficultyID(Difficulty(fields[39].GetUInt8())));
    SetRaidDifficultyID(CheckLoadedRaidDifficultyID(Difficulty(fields[64].GetUInt8())));
    SetLegacyRaidDifficultyID(CheckLoadedLegacyRaidDifficultyID(Difficulty(fields[65].GetUInt8())));

    std::string taxi_nodes = fields[38].GetString();

#define RelocateToHomebind(){ mapId = m_homebindMapId; instanceId = 0; Relocate(m_homebindX, m_homebindY, m_homebindZ); }

    _LoadHeirloomCollection(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_HEIRLOOM_COLLECTION));
    _LoadToyBox(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_TOYS));
    _LoadBossLooted(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_BOSS_LOOTED));
    _LoadPersonalInstanceLockouts(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PERSONAL_INSTANCES_LOCKOUT));
    _LoadWorldStates(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_WORLD_STATES));

    /// Init worldstates for Arena Decay system if needed
    {
        if (!HasCharacterWorldState(CharacterWorldStates::ArenaDecay2v2ConsecutiveCount))
            SetCharacterWorldState(CharacterWorldStates::ArenaDecay2v2ConsecutiveCount, 0);

        if (!HasCharacterWorldState(CharacterWorldStates::ArenaDecay3v3ConsecutiveCount))
            SetCharacterWorldState(CharacterWorldStates::ArenaDecay3v3ConsecutiveCount, 0);

        if (!HasCharacterWorldState(CharacterWorldStates::ArenaDecay2v2MatchesCount))
            SetCharacterWorldState(CharacterWorldStates::ArenaDecay2v2MatchesCount, 0);

        if (!HasCharacterWorldState(CharacterWorldStates::ArenaDecay3v3MatchesCount))
            SetCharacterWorldState(CharacterWorldStates::ArenaDecay3v3MatchesCount, 0);
    }

/// @TODO group
#ifndef CROSS
    _LoadGroup(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADGROUP));
#endif

    _LoadBracketData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBRACKETDATA));
    _LoadCurrencyCaps(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCURRENCYCAPS));
    _LoadCurrency(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCURRENCY));

    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[40].GetUInt32());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, PLAYER_FIELD_KILLS_OFFSET_TODAY_KILLS, fields[41].GetUInt16());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, PLAYER_FIELD_KILLS_OFFSET_YESTERDAY_KILLS, fields[42].GetUInt16());

    _LoadBoundInstances(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBOUNDINSTANCES));

    _LoadInstanceTimeRestrictions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADINSTANCELOCKTIMES));
    _LoadBGData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBGDATA));
    _LoadCUFProfiles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CUF_PROFILES));

    GetSession()->SetPlayer(this);

    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);

    bool mustResurrectFromUnlock = false;

    if (m_atLoginFlags & AT_LOGIN_UNLOCK)
    {
        bool BGdesert = false;
        bool DungeonDesert = false;
        bool MalDeRez = false;

        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        if (HasAura(MS::Battlegrounds::Spells::DeserterBuff))
            BGdesert = true;
        if (HasAura(71041)) // deserteur de donjon
            DungeonDesert = true;
        if (HasAura(15007))
            MalDeRez = true;

        RemoveAllAuras();
        CleanupAfterTaxiFlight();

        if (BGdesert)
            AddAura(MS::Battlegrounds::Spells::DeserterBuff, this);
        if (DungeonDesert)
            AddAura(71041, this);
        /*if (MalDeRez)
            AddAura(15007, this);*/

        mustResurrectFromUnlock = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST);
        RelocateToHomebind();
    }
    else if (!mapEntry || !IsPositionValid())
    {
        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (MapId: %u X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        RelocateToHomebind();
    }
    // currently we do not support transport in bg
    else if (transGUID)
    {
        m_movementInfo.t_guid = MAKE_NEW_GUID(transGUID, 0, HIGHGUID_MO_TRANSPORT);
        m_movementInfo.t_pos.Relocate(fields[27].GetFloat(), fields[28].GetFloat(), fields[29].GetFloat(), fields[30].GetFloat());

        if (!JadeCore::IsValidMapCoord(
            GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
            GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation()) ||
            // transport size limited
            m_movementInfo.t_pos.m_positionX > 250 || m_movementInfo.t_pos.m_positionY > 250 || m_movementInfo.t_pos.m_positionZ > 250)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid transport coordinates (X: %f Y: %f Z: %f O: %f). Teleport to bind location.",
                guid, GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
                GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation());

            RelocateToHomebind();
        }
        else
        {
            if (GameObject* go = HashMapHolder<GameObject>::Find(m_movementInfo.t_guid))
                m_transport = go->ToTransport();

            if (m_transport)
            {
                m_transport->AddPassenger(this);
                mapId = m_transport->GetMapId();
            }
            else
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have problems with transport guid (%u). Teleport to bind location.",
                    guid, transGUID);

                RelocateToHomebind();
            }
        }
    }
    // currently we do not support taxi in instance
    else if (!taxi_nodes.empty())
    {
        instanceId = 0;

        // Not finish taxi flight path
        if (m_bgData.HasTaxiPath())
        {
            for (int i = 0; i < 2; ++i)
                m_taxi.AddTaxiDestination(m_bgData.taxiPath[i]);
        }
        else if (!m_taxi.LoadTaxiDestinationsFromString(taxi_nodes, GetTeam()))
        {
            // problems with taxi path loading
            TaxiNodesEntry const* nodeEntry = NULL;
            if (uint32 node_id = m_taxi.GetTaxiSource())
                nodeEntry = sTaxiNodesStore.LookupEntry(node_id);

            if (!nodeEntry)                                      // don't know taxi start node, to homebind
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u have wrong data in taxi destination list, teleport to homebind.", GetGUIDLow());
                RelocateToHomebind();
            }
            else                                                // have start node, to it
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u have too short taxi destination list, teleport to original node.", GetGUIDLow());
                mapId = nodeEntry->MapID;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }
            m_taxi.ClearTaxiDestinations();
        }

        if (uint32 node_id = m_taxi.GetTaxiSource())
        {
            // save source node as recall coord to prevent recall and fall from sky
            TaxiNodesEntry const* nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
            if (nodeEntry && nodeEntry->MapID == GetMapId())
            {
                ASSERT(nodeEntry);                                  // checked in m_taxi.LoadTaxiDestinationsFromString
                mapId = nodeEntry->MapID;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }

            // flight will started later
        }
    }

    // Map could be changed before
    mapEntry = sMapStore.LookupEntry(mapId);
    // client without expansion support
    if (mapEntry)
    {
        if (GetSession()->Expansion() < mapEntry->Expansion())
        {
            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player %s using client without required expansion tried login at non accessible map %u", GetName(), mapId);
            RelocateToHomebind();
        }

        // fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
        if (instanceId)
            if (InstanceSavePtr save = GetInstanceSave(mapId))
                if (save->GetInstanceId() != instanceId)
                    instanceId = 0;
    }

    bool l_RemoveBGDeserter = false;

    /// Player was saved in BG or arena.
    if (mapEntry && mapEntry->IsBattlegroundOrArena())
    {
        {
            Battleground* currentBg = nullptr;
            if (m_bgData.bgInstanceID)                                                //saved in Battleground
                currentBg = sBattlegroundMgr->GetBattleground(m_bgData.bgInstanceID, MS::Battlegrounds::GetSchedulerType(m_bgData.bgTypeID));

            bool player_at_bg = currentBg && currentBg->IsPlayerInBattleground(GetGUID());

            if (player_at_bg && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
            {
                MS::Battlegrounds::BattlegroundType::Type bgQueueTypeId = MS::Battlegrounds::GetTypeFromId(currentBg->GetTypeID(), currentBg->GetArenaType(), currentBg->IsSkirmish());
                AddBattlegroundQueueId(bgQueueTypeId);

                m_bgData.bgTypeID = currentBg->GetTypeID();

                SetBGTeam(m_bgData.bgTeam);

                //join player to battleground group
                currentBg->EventPlayerLoggedIn(this);
                currentBg->AddOrSetPlayerToCorrectBgGroup(this, m_bgData.bgTeam);

                SetInviteForBattlegroundQueueType(bgQueueTypeId, currentBg->GetInstanceID());

                /// We give the deserter aura by default when we leave a battleground
                /// so if we succeed at re-entering the battleground, we remove the aura.
                l_RemoveBGDeserter = true;
            }
            // Bg was not found - go to Entry Point
            else
            {
                /// Leave bg.
                if (player_at_bg)
                    currentBg->RemovePlayerAtLeave(GetGUID(), false, true);

                sScriptMgr->OnLeaveBG(this, mapId);

                /// Do not look for instance if bg not found.
                const WorldLocation& _loc = GetBattlegroundEntryPoint();
                mapId = _loc.GetMapId(); instanceId = 0;

                /// Db field type is type int16, so it can never be MAPID_INVALID.
                /// if (mapId == MAPID_INVALID) -- code kept for reference
                if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
                {
                    sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid);
                    RelocateToHomebind();
                }
                else
                    Relocate(&_loc);

                /// We are not in BG anymore.
                m_bgData.bgInstanceID = 0;
            }
        }
    }
    else if (m_bgData.bgInstanceID != 0)
    {
        /// Map isn't battleground or arena, clean battleground id / type
#ifndef CROSS
        SetBattlegroundId(0, BattlegroundTypeId::BATTLEGROUND_TYPE_NONE);
#endif
    }

    uint32 l_ZoneId = fields[35].GetUInt16();

    // NOW player must have valid map
    // load the player's map here if it's not already loaded
    Map* map = sMapMgr->CreateMap(mapId, l_ZoneId, this);

    if (!map)
    {
        instanceId = 0;
        AreaTriggerStruct const* at = sObjectMgr->GetGoBackTrigger(mapId);
        if (at)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
            mapId = at->target_mapId;
            l_ZoneId = sMapMgr->GetZoneId(mapId, at->target_X, at->target_Y, at->target_Z);
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            RelocateToHomebind();
        }

        map = sMapMgr->CreateMap(mapId, l_ZoneId, this);
        if (!map)
        {
            PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
            mapId = info->mapId;
            Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
            l_ZoneId = sMapMgr->GetZoneId(mapId, info->positionX, info->positionY, info->positionZ);
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            map = sMapMgr->CreateMap(mapId, l_ZoneId, this);
            if (!map)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) has invalid default map coordinates (X: %f Y: %f Z: %f O: %f). or instance couldn't be created", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                return false;
            }
        }
    }

    // if the player is in an instance and it has been reset in the meantime teleport him to the entrance
    if (instanceId && !sInstanceSaveMgr->GetInstanceSave(instanceId) && !map->IsBattlegroundOrArena())
    {
        AreaTriggerStruct const* at = sObjectMgr->GetMapEntranceTrigger(mapId);
        if (at)
            Relocate(at->target_X, at->target_Y, at->target_Z, at->target_Orientation);
        else if (LFGDungeonEntry const* l_Dungeon = GetSingleDungonByMap(mapId))
        {
            if (Position const* l_Pos = sLFGMgr->GetEntrancePosition(l_Dungeon->ID))
                Relocate(l_Pos);
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s(GUID: %u) logged in to a reset instance (map: %u) and there is no area-trigger leading to this map. Thus he can't be ported back to the entrance. This _might_ be an exploit attempt.", GetName(), GetGUIDLow(), mapId);
            RelocateToHomebind();
        }
    }

    CellCoord cellCoord = JadeCore::ComputeCellCoord(GetPositionX(), GetPositionY());
    if (!cellCoord.IsCoordValid())
        return false;

    sLog->outAshran("Player::LoadFromDB add loading task for guid %u account %u to mapid %u instanceid %u instancezoneid %u", guid, GetSession()->GetAccountId(), map->GetId(), map->GetInstanceId(), map->GetInstanceZoneId());
    map->AddTask([this, map, holder, p_LoginDBQueryHolder, l_RemoveBGDeserter, mapEntry, mustResurrectFromUnlock, result, guid]() -> void
    {
        sLog->outAshran("Map->ExecuteTask:  loading guid %u account %u to mapid %u instanceid %u instancezoneid %u", guid, GetSession()->GetAccountId(), map->GetId(), map->GetInstanceId(), map->GetInstanceZoneId());

        SetCurrMap(nullptr);
        SetMap(map);

        Field* fields = result->Fetch();

        // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
        // this must help in case next save after mass player load after server startup
        m_nextSave = urand(m_nextSave / 2, m_nextSave * 3 / 2);

        SaveRecallPosition();

        time_t now = time(NULL);
        time_t logoutTime = time_t(fields[22].GetUInt32());

        // since last logout (in seconds)
        uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.

        if (logoutTime > now)
            time_diff = 0;

        // set value, including drunk invisibility detection
        // calculate sobering. after 15 minutes logged out, the player will be sober again
        uint8 newDrunkValue = 0;
        if (time_diff < uint32(GetDrunkValue()) * 9)
            newDrunkValue = GetDrunkValue() - time_diff / 9;

        SetDrunkValue(newDrunkValue);

        m_cinematic = fields[18].GetUInt8();
        m_Played_time[PLAYED_TIME_TOTAL] = fields[19].GetUInt32();
        m_Played_time[PLAYED_TIME_LEVEL] = fields[20].GetUInt32();

        SetTalentResetCost(fields[24].GetUInt32());
        SetTalentResetTime(time_t(fields[25].GetUInt32()));

        m_taxi.LoadTaxiMask(fields[17].GetCString());            // must be before InitTaxiNodesForLevel

        uint32 extraflags = fields[32].GetUInt16();

        m_stableSlots = fields[33].GetUInt8();
        if (m_stableSlots > MAX_PET_STABLES)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player can have not more %u stable slots, but have in DB %u", MAX_PET_STABLES, uint32(m_stableSlots));
            m_stableSlots = MAX_PET_STABLES;
        }

        // Honor system
        // Update Honor kills data
        m_lastHonorUpdateTime = logoutTime;
        UpdateHonorFields();

        m_deathExpireTime = time_t(fields[37].GetUInt32());
        if (m_deathExpireTime > now + MAX_DEATH_COUNT*DEATH_EXPIRE_STEP)
            m_deathExpireTime = now + MAX_DEATH_COUNT*DEATH_EXPIRE_STEP - 1;

        m_LastSummonedBattlePet = fields[66].GetUInt32();
        m_PersonnalXpRate = fields[67].GetFloat();

        // clear charm/summon related fields
        SetOwnerGUID(0);
        SetGuidValue(UNIT_FIELD_CHARMED_BY, 0);
        SetGuidValue(UNIT_FIELD_CHARM, 0);
        SetGuidValue(UNIT_FIELD_SUMMON, 0);
        SetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, 0);
        SetCreatorGUID(0);

        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FORCE_MOVEMENT);

        // reset some aura modifiers before aura apply
        SetUInt32Value(PLAYER_FIELD_TRACK_CREATURE_MASK, 0);
        SetUInt32Value(PLAYER_FIELD_TRACK_RESOURCE_MASK, 0);

        // make sure the unit is considered out of combat for proper loading
        ClearInCombat();

        // make sure the unit is considered not in duel for proper loading
        SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
        SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

        // reset stats before loading any modifiers
        InitStatsForLevel();
        InitTaxiNodesForLevel();
        InitRunes();

        // rest bonus can only be calculated after InitStatsForLevel()
        m_rest_bonus = fields[21].GetFloat();

        if (time_diff > 0)
        {
            //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
            float bubble0 = 0.031f;
            //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
            float bubble1 = 0.125f;
            float bubble = fields[23].GetUInt8() > 0
                ? bubble1*sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY)
                : bubble0*sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);

            ModRestBonus(time_diff*((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP) / 72000)*bubble);
        }

        SetPrimarySpecialization(fields[53].GetUInt32());
        SetActiveTalentGroup(fields[54].GetUInt8());

        ChrSpecializationsEntry const* l_PrimarySpec = sChrSpecializationsStore.LookupEntry(GetPrimarySpecialization());
        if (!l_PrimarySpec || l_PrimarySpec->ClassID != getClass() || GetActiveTalentGroup() >= MAX_SPECIALIZATIONS)
            ResetTalentSpecialization();

        uint32 l_LootSpecId = fields[55].GetUInt32();
        if (ChrSpecializationsEntry const* l_ChrSpec = sChrSpecializationsStore.LookupEntry(l_LootSpecId))
        {
            if (l_ChrSpec->ClassID == getClass())
            {
                SetUInt32Value(PLAYER_FIELD_LOOT_SPEC_ID, l_LootSpecId);
                SetLootSpecId(l_LootSpecId);
            }
        }

        if (ChrSpecializationsEntry const* l_Spec = GetChrSpecializationByIndex(getClass(), GetActiveTalentGroup()))
            SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, l_Spec->ID);

        /// Load skills after InitStatsForLevel because it triggering aura apply also
        /// Load after spec lood too, in case of specialization check in DoEffectCalcAmount hooks
        _LoadSkills(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSKILLS));
        UpdateSkillsForLevel(); //update skills after load, to make sure they are correctly update at player load

        m_archaeologyMgr.LoadArchaeology(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY),
            holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY_PROJECTS),
            holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY_SITES));

        // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()

    //mails are loaded only when needed ;-) - when player in game click on mailbox.
        _LoadMail(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAIL));
        _LoadMailedItems(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAIL_ITEMS));

        _LoadPvPInfo(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADPVPINFO));
        _LoadPVPTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PVP_TALENTS));
        _LoadTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADTALENTS));

        _LoadSpells(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_CHAR_LOADSPELLS));

#ifndef CROSS
        uint32 l_AllowedGroupRealmMask = sWorld->getIntConfig(CONFIG_ACCOUNT_BIND_ALLOWED_GROUP_MASK);
#else /* CROSS */
        uint32 l_AllowedGroupRealmMask = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber())->allowedGroupRealmMask;
#endif /* CROSS */

        // Load of account spell, we must load it like that because it's stored in realmd database
        // With actual implementation, we can use QueryHolder only with single database
        if (PreparedQueryResult accountResult = p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINGB_SPELL))
        {
            do
            {
                uint32 l_GroupRealmMask = (*accountResult)[4].GetUInt32();
                if ((l_GroupRealmMask & l_AllowedGroupRealmMask) == 0)
                    continue;

                uint32 l_SpellID = (*accountResult)[0].GetUInt32();
                for (uint32 l_I = 0; l_I < sBattlePetSpeciesStore.GetNumRows(); l_I++)
                {
                    BattlePetSpeciesEntry const* speciesInfo = sBattlePetSpeciesStore.LookupEntry(l_I);

                    if (speciesInfo && speciesInfo->SummonSpellID == l_SpellID)
                    {
                        m_OldPetBattleSpellToMerge.push_back(std::make_pair(l_SpellID, speciesInfo->ID));
                        break;
                    }
                }

                addSpell((*accountResult)[0].GetUInt32(), (*accountResult)[1].GetBool(), false, false, (*accountResult)[2].GetBool(), true, (*accountResult)[3].GetBool());
            } while (accountResult->NextRow());
        }

        RemoveSpecializationSpells(); /// Needed for load on crossrealm
        LearnSpecializationSpells();

        _LoadGlyphs(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GLYPHS));
        _LoadAuras(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS_EFFECTS), time_diff);
        _LoadGlyphAuras();

        if (l_RemoveBGDeserter && HasAura(MS::Battlegrounds::Spells::DeserterBuff))
            RemoveAura(MS::Battlegrounds::Spells::DeserterBuff);

        // add ghost flag (must be after aura load: PLAYER_FIELD_PLAYER_FLAGS_GHOST set in aura)
        if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
            m_deathState = DEAD;

        // after spell load, learn rewarded spell if need also
        _LoadQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUS));
        _LoadQuestObjectiveStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_OBJECTIVE_STATUS));
        _LoadQuestStatusRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUSREW));
        _LoadDailyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDAILYQUESTSTATUS));
        _LoadWeeklyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADWEEKLYQUESTSTATUS));
        _LoadSeasonalQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSEASONALQUESTSTATUS));
        _LoadMonthlyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MONTHLY_QUEST_STATUS));
        _LoadAccountQuestRewarded(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_QUERY_ACCOUNT_QUEST_REWARDED));

        // after spell and quest load
        InitTalentForLevel();
        LearnDefaultSkills();
        LearnCustomSpells();

        // must be before inventory (some items required reputation check)
        m_reputationMgr.LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADREPUTATION));
        m_reputationMgr.LoadReputationMods(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADREPUTATIONMODS));

        _LoadArtifacts(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARTIFACTS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARTIFACT_POWERS));

        m_Garrison->Load(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_FOLLOWERS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_MISSIONS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_WORKORDERS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_TALENTS),
            holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_DRAENOR), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_DRAENOR_BUILDINGS),
            holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_BROKEN_ISLES));

        if (!m_Garrison->HasGarrisonBrokenIsles())
            m_Garrison->Create(MS::Garrison::GarrisonType::GarrisonBrokenIsles);

        _LoadGarrisonDailyTavernDatas(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_DRAENOR_MISSIONS_TAVERNDATA));
        _LoadCharacterGarrisonWeeklyTavernDatas(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_DRAENOR_WEEKLY_TAVERNDATA));

        UpdateRequiredHonor();
        EquipProperArtifactIfNeeded();

        /// Temp fix - Can we move OnEnterBg here ?
        if (m_bgData.bgInstanceID != 0 && mapEntry && mapEntry->IsBattlegroundOrArena() && GetMap()->IsBattlegroundOrArena())
            SetInBattlegroundProcess(true);

        _LoadInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADINVENTORY), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ITEM_WITHOUT_INVENTORY), time_diff);

        for (uint8 l_I = InventorySlots::INVENTORY_SLOT_BAG_START; l_I < InventorySlots::INVENTORY_SLOT_BAG_END; ++l_I)
        {
            if (Bag* l_Bag = GetBagByPos(l_I))
                SetUInt32Value(EPlayerFields::PLAYER_FIELD_BAG_SLOT_FLAGS + (l_I - InventorySlots::INVENTORY_SLOT_BAG_START), l_Bag->GetBagFlags());
        }

        for (uint8 l_I = BankBagSlots::BANK_SLOT_BAG_START; l_I < BankBagSlots::BANK_SLOT_BAG_END; ++l_I)
        {
            if (Bag* l_Bag = GetBagByPos(l_I))
                SetUInt32Value(EPlayerFields::PLAYER_FIELD_BANK_BAG_SLOT_FLAGS + (l_I - BankBagSlots::BANK_SLOT_BAG_START), l_Bag->GetBagFlags());
        }

        if (IsVoidStorageUnlocked())
            _LoadVoidStorage(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADVOIDSTORAGE));

        m_VoidStorageLoaded = true;

        _LoadLegendaries(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_LEGENDARIES));

        // update items with duration and realtime
        UpdateItemDuration(time_diff, true);

        _LoadActions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACTIONS));

        // unread mails and next delivery time, actual mails not loaded
        _LoadMailInit(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILCOUNT), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILDATE));

        m_social = sSocialMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSOCIALLIST), GetGUIDLow(), GetSession()->GetAccountId());

        // check PLAYER_CHOSEN_TITLE compatibility with PLAYER_FIELD_KNOWN_TITLES
        // note: PLAYER_FIELD_KNOWN_TITLES updated at quest status loaded
        uint32 curTitle = fields[43].GetUInt32();
        if (curTitle && !HasTitle(curTitle))
            curTitle = 0;

        SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, curTitle);

        // has to be called after last Relocate() in Player::LoadFromDB
        SetFallInformation(0, GetPositionZ());

        _LoadSpellCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSPELLCOOLDOWNS));
        _LoadChargesCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CHARGES_COOLDOWNS));
        _LoadDailyLootsCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_DAILY_LOOT_COOLDOWNS));

        GetSession()->GetCollectionMgr()->LoadItemAppearances();

        // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
        // Do now before stats re-calculation cleanup for ghost state unexpected auras
        if (!isAlive())
            RemoveAllAurasOnDeath();
        else
            RemoveAllAurasRequiringDeadTarget();

        // Command Demon
        RemoveAura(119904);

    //apply all stat bonuses from items and auras
        SetCanModifyStats(true);
        UpdateAllStats();

        // restore remembered power/health values (but not more max values)
        uint64 savedHealth = fields[45].GetUInt64();
        SetHealth(savedHealth > GetMaxHealth() ? GetMaxHealth() : savedHealth);

        if (InstanceScript* l_Instance = GetInstanceScript())
        {
            if (l_Instance->IsEncounterInProgress() && l_Instance->instance->Expansion() >= Expansion::EXPANSION_WARLORDS_OF_DRAENOR && !savedHealth)
                m_deathState = DEAD;
        }

        uint32 loadedPowers = 0;

        for (int l_Power = POWER_MANA; l_Power < MAX_POWERS_PER_CLASS; ++l_Power)
            SetUInt32Value(UNIT_FIELD_POWER + l_Power, 0);

        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            uint32 l_Index = GetPowerIndex(Powers(i), getClass());
            if (l_Index != MAX_POWERS)
            {
                uint32 savedPower = fields[46 + l_Index].GetUInt32();
                uint32 maxPower = GetUInt32Value(UNIT_FIELD_MAX_POWER + l_Index);
                SetPower(Powers(l_Index), (savedPower > maxPower) ? maxPower : savedPower);
            }
        }

        Powers l_Power = GetDisplayPowerForCurrentState();
        if (getPowerType() != l_Power)
            setPowerType(l_Power);

        // GM state
        if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        {
            switch (sWorld->getIntConfig(CONFIG_GM_LOGIN_STATE))
            {
                default:
                case 0:                      break;             // disable
                case 1: SetGameMaster(true); break;             // enable
                case 2:                                         // save state
                    if (extraflags & PLAYER_EXTRA_GM_ON)
                        SetGameMaster(true);
                    break;
            }

            switch (sWorld->getIntConfig(CONFIG_GM_VISIBLE_STATE))
            {
                default:
                case 0: SetGMVisible(false); break;             // invisible
                case 1:                      break;             // visible
                case 2:                                         // save state
                    if (extraflags & PLAYER_EXTRA_GM_INVISIBLE)
                        SetGMVisible(false);
                    break;
            }

            switch (sWorld->getIntConfig(CONFIG_GM_CHAT))
            {
                default:
                case 0:                  break;                 // disable
                case 1: SetGMChat(true); break;                 // enable
                case 2:                                         // save state
                    if (extraflags & PLAYER_EXTRA_GM_CHAT)
                        SetGMChat(true);
                    break;
            }

            switch (sWorld->getIntConfig(CONFIG_GM_WHISPERING_TO))
            {
                default:
                case 0:                          break;         // disable
                case 1: SetAcceptWhispers(true); break;         // enable
                case 2:                                         // save state
                    if (extraflags & PLAYER_EXTRA_ACCEPT_WHISPERS)
                        SetAcceptWhispers(true);
                    break;
            }
        }

        // RaF stuff.
        m_grantableLevels = fields[62].GetUInt8();
        if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
            SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

        if (m_grantableLevels > 0)
            SetByteValue(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_RAF_GRANTABLE_LEVEL, 0x01);

        _LoadDeclinedNames(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDECLINEDNAMES));
        _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));

        m_WorldQuestMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_WORLD_QUEST_REWARDS));

        if (mustResurrectFromUnlock)
            ResurrectPlayer(1, true);
#ifndef CROSS /// @TODO gm ticket

        if (GmTicket* ticket = sTicketMgr->GetTicketByPlayer(GetGUID()))
            if (!ticket->IsClosed() && ticket->IsCompleted())
                ticket->SendResponse(GetSession());
#endif
#ifdef CROSS
        // Set realmID
        SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, GetSession()->GetInterRealmNumber());
#else
        SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, g_RealmID);
#endif
        ReloadPetBattles();

        /// We also need to call it on reconnect when the player already was in BG
        if (m_bgData.bgInstanceID != 0 && mapEntry && mapEntry->IsBattlegroundOrArena() && GetMap()->IsBattlegroundOrArena())
            sScriptMgr->OnEnterBG(this, mapEntry->MapID);

        _LoadCosmetics(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_QUERY_LOAD_COSMETICS));

        _LoadNomiRecipes(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_NOMI_RECIPES));

        _LoadPlayerChoiceResponseRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PLAYERCHOICE_RESPONSE_REWARDED));

        if (HasAchieved(11473)) ///< WQ Unlock hidden achievement
            SetInExcludePhase(eExcludePhases::PhaseBrokenShoreInvasions, false, true);

        _LoadPvpRewardSeason(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PVP_SEASON_REWARD_RANKING));
        _LoadChestTimedLockout(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CHEST_TIMED_LOCKOUT));
        _LoadObjectLockout(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_OBJECT_LOCKOUT));

        GetSession()->FinializePlayerLoading((LoginQueryHolder*)holder, (LoginDBQueryHolder*)p_LoginDBQueryHolder);
    });

    return true;
}

bool Player::isAllowedToLoot(const Creature* creature)
{
    if (!creature->isDead())
        return false;

    if (HasPendingBind())
        return false;

    uint64 l_LootContainerGuid = GetLootContainerGuidForCreature(const_cast<Creature*>(creature));
    if (!l_LootContainerGuid)
        return false;

    const Loot* loot = &const_cast<Creature*>(creature)->m_LootContainers[l_LootContainerGuid];
    if (loot->isLooted())
        return false;

    GroupPtr l_Group = GetGroup();

    if (IS_GROUP(l_LootContainerGuid))
    {
        switch (l_Group->GetLootMethod())
        {
            case FREE_FOR_ALL:
                return true;
            case MASTER_LOOT:
            {
                /// Master looter can loot
                if (l_Group)
                {
                    if (l_Group->GetLooterGuid() == GetGUID())
                        return true;
                }
                /// Player can loot if there is anything specific for him
                else if (loot->AllowedPlayers.HasPlayerGuid(GetGUID()))
                    return true;

                return loot->hasItemFor(this);
            }
            case GROUP_LOOT:
            {
                // may only loot if the player is the loot roundrobin player
                // or item over threshold (so roll(s) can be launched)
                // or if there are free/quest/conditional item for the player
                if (loot->Items.empty() && loot->Gold > 0)
                    return true;

                if (loot->hasOverThresholdItem())
                    return true;

                return loot->hasItemFor(this);
            }
            default:
                break;
        }
    }

    return true;
}

void Player::_LoadActions(PreparedQueryResult result)
{
    m_actionButtons.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint8 button = fields[0].GetUInt8();
            uint32 action = fields[1].GetUInt32();
            uint8 type = fields[2].GetUInt8();

            if (ActionButton* ab = addActionButton(button, action, type))
                ab->uState = ACTIONBUTTON_UNCHANGED;
            else
            {
                // Will deleted in DB at next save (it can create data until save but marked as deleted)
                m_actionButtons[button].uState = ACTIONBUTTON_DELETED;
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadAuras(PreparedQueryResult result, PreparedQueryResult resultEffect, uint32 timediff)
{
    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Loading auras for player %u", GetGUIDLow());

    std::list<auraEffectData> auraEffectList;
    if (resultEffect)
    {
        do
        {
            Field* fields = resultEffect->Fetch();
            uint8 slot = fields[0].GetUInt8();
            uint8 effect = fields[1].GetUInt8();
            uint32 baseamount = fields[2].GetUInt32();
            uint32 amount = fields[3].GetUInt32();

            auraEffectList.push_back(auraEffectData(slot, effect, amount, baseamount));
        }
        while (resultEffect->NextRow());
    }

    /*                                                           0       1        2         3                 4         5      6       7         8              9            10
    QueryResult* result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2,
                                                        11          12          13
                                                    maxduration, remaintime, remaincharges FROM character_aura WHERE guid = '%u'", GetGUIDLow());
    */

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            int32 damage[32];
            int32 baseDamage[32];
            uint64 caster_guid = fields[0].GetUInt64();
            uint8 slot = fields[1].GetUInt8();
            uint32 spellid = fields[2].GetUInt32();
            uint32 effmask = fields[3].GetUInt32();
            uint32 recalculatemask = fields[4].GetUInt32();
            uint8 stackcount = fields[5].GetUInt8();
            int32 maxduration = fields[6].GetInt32();
            int32 remaintime = fields[7].GetInt32();
            uint8 remaincharges = fields[8].GetUInt8();
            int32 castItemLevel = fields[9].GetInt32();

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Unknown aura (spellid %u), ignore.", spellid);
                continue;
            }

            // negative effects should continue counting down after logout
            if (remaintime != -1 && !spellInfo->IsPositive())
            {
                if (remaintime/IN_MILLISECONDS <= int32(timediff))
                    continue;

                remaintime -= timediff*IN_MILLISECONDS;
            }

            // prevent wrong values of remaincharges
            if (spellInfo->ProcCharges)
            {
                // we have no control over the order of applying auras and modifiers allow auras
                // to have more charges than value in SpellInfo
                if (remaincharges <= 0)
                    remaincharges = spellInfo->ProcCharges;
            }
            else
                remaincharges = 0;

            for(std::list<auraEffectData>::iterator itr = auraEffectList.begin(); itr != auraEffectList.end(); ++itr)
            {
                if (itr->_slot == slot)
                {
                    damage[itr->_effect] = itr->_amount;
                    baseDamage[itr->_effect] = itr->_baseamount;
                }
            }

            Aura* aura = Aura::TryCreate(spellInfo, effmask, this, NULL, &baseDamage[0], NULL, caster_guid, castItemLevel);
            if (aura != nullptr)
            {
                if (!aura->CanBeSaved())
                {
                    aura->Remove();
                    continue;
                }

                aura->SetLoadedState(maxduration, remaintime, remaincharges, stackcount, recalculatemask, &damage[0]);
                aura->ApplyForTargets();
                sLog->outInfo(LOG_FILTER_PLAYER, "Added aura spellid %u, effectmask %u", spellInfo->Id, effmask);
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadGlyphAuras()
{
    for (uint32 l_GlyphID : GetGlyphs(GetActiveTalentGroup()))
    {
        if (GlyphPropertiesEntry const* l_PropEntry = sGlyphPropertiesStore.LookupEntry(l_GlyphID))
            CastSpell(this, l_PropEntry->SpellID, true);
    }
}

void Player::SendGlyphs()
{
    WorldPacket l_Data(Opcodes::SMSG_ACTIVE_GLYPHS, 1024);
    ByteBuffer  l_GlyphsData;

    uint32 l_GlyphsCount = 0;
    for (uint32 l_GlyphID : GetGlyphs(GetActiveTalentGroup()))
    {
        if (std::vector<uint32> const* l_BindableSpells = GetGlyphBindableSpells(l_GlyphID))
        {
            for (uint32 l_BindableSpell : *l_BindableSpells)
            {
                if (HasSpell(l_BindableSpell) && m_overrideSpells.find(l_BindableSpell) == m_overrideSpells.end())
                {
                    l_GlyphsData << uint32(l_BindableSpell);
                    l_GlyphsData << uint16(l_GlyphID);

                    ++l_GlyphsCount;
                }
            }
        }
    }

    l_Data << l_GlyphsCount;

    if (l_GlyphsCount)
        l_Data.append(l_GlyphsData);

    l_Data.WriteBit(true);  ///< IsFullUpdate
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::SendGlyph(uint32 p_SpellID, uint16 p_GlyphID)
{
    WorldPacket l_Data(Opcodes::SMSG_ACTIVE_GLYPHS, 1024);

    l_Data << uint32(1);
    l_Data << uint32(p_SpellID);
    l_Data << uint16(p_GlyphID);

    l_Data.WriteBit(false);  ///< IsFullUpdate
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::_LoadGlyphs(PreparedQueryResult p_Result)
{
    /// SELECT talentGroup, glyphId from character_glyphs WHERE guid = ?
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint8 l_Spec = l_Fields[0].GetUInt8();
        if (l_Spec >= MAX_SPECIALIZATIONS || !GetChrSpecializationByIndex(getClass(), l_Spec))
            continue;

        uint16 l_GlyphID = l_Fields[1].GetUInt16();
        if (!sGlyphPropertiesStore.LookupEntry(l_GlyphID))
            continue;

        GetGlyphs(l_Spec).push_back(l_GlyphID);

    }
    while (p_Result->NextRow());
}

void Player::_SaveGlyphs(SQLTransaction& trans) const
{
    PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
    l_Statement->setUInt32(0, GetGUIDLow());
    trans->Append(l_Statement);

    for (uint8 l_Spec = 0; l_Spec < MAX_SPECIALIZATIONS; ++l_Spec)
    {
        for (uint32 l_GlyphID : GetGlyphs(l_Spec))
        {
            uint8 l_Index = 0;

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
            l_Statement->setUInt32(l_Index++, GetGUIDLow());
            l_Statement->setUInt8(l_Index++, l_Spec);
            l_Statement->setUInt16(l_Index++, uint16(l_GlyphID));

            trans->Append(l_Statement);
        }
    }
}

void Player::LoadCorpse(PreparedQueryResult result)
{
    if (isAlive())
        SpawnCorpseBones(false);
    else
    {
        if (result)
        {
            Field* fields = result->Fetch();
            m_CorpseLocation.WorldRelocate(fields[0].GetUInt16(), fields[1].GetFloat(), fields[2].GetFloat(), fields[3].GetFloat(), fields[4].GetFloat());
            ApplyModFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_RELEASE_TIMER,  !sMapStore.LookupEntry(m_CorpseLocation.GetMapId())->Instanceable());
        }
        else
        {
            if (InstanceScript* l_Instance = GetInstanceScript())
            {
                if (l_Instance->IsEncounterInProgress() && l_Instance->instance->Expansion() >= Expansion::EXPANSION_WARLORDS_OF_DRAENOR)
                    return;
            }

            /// Prevent Dead Player login without corpse
            ResurrectPlayer(0.5f);
        }
    }
}

void Player::_LoadInventory(PreparedQueryResult p_Result, PreparedQueryResult p_DelinkItemsResult, uint32 p_TimeDiff)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT data, text, bag, slot, item, item_template FROM character_inventory JOIN item_instance ON character_inventory.item = item_instance.guid WHERE character_inventory.guid = '%u' ORDER BY bag, slot", GetGUIDLow());
    //NOTE: the "order by `bag`" is important because it makes sure
    //the bagMap is filled before items in the bags are loaded
    //NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
    //expected to be equipped before offhand items (TODO: fixme)

    auto l_Database = &CharacterDatabase;

    if (p_Result)
    {
        uint32 zoneId = GetZoneId(true);

        std::map<uint32, Bag*> bagMap;                                  // fast guid lookup for bags
        std::map<uint32, Item*> invalidBagMap;                          // fast guid lookup for bags
        std::list<Item*> problematicItems;
        SQLTransaction trans = l_Database->BeginTransaction();

        std::set<uint64> l_ParentGUID;
        // Prevent items from being added to the queue while loading
        m_itemUpdateQueueBlocked = true;
        do
        {
            Field* fields = p_Result->Fetch();
            if (Item* item = _LoadItem(trans, zoneId, p_TimeDiff, fields))
            {
                uint32 bagGuid  = fields[ItemInstanceField::End + 1].GetUInt32();
                uint8  slot     = fields[ItemInstanceField::End + 2].GetUInt8();

                GetSession()->GetCollectionMgr()->AddItemAppearance(item);

                uint8 err = EQUIP_ERR_OK;

                if (item->HasFlag(EItemFields::ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
                {
                    if (Item* parent = GetItemByGuid(item->GetGuidValue(ITEM_FIELD_CREATOR)))
                    {
                        /// Check if parent doesn't already own a child
                        /// Prevent crash and weird behavior if db data are corrupted
                        if (parent->GetChildItem() != 0)
                        {
                            sLog->outAshran("Player::_LoadInventory: Try to load child item %u in bag %u at slot %u but his parent already own a child. Destroy the item to prevent crashs ... (player %u)", item->GetEntry(), bagGuid, slot, GetGUIDLow());
                            item->DeleteFromInventoryDB(trans);
                            delete item;
                            continue;
                        }

                        parent->SetChildItem(item->GetGUID());
                        item->CopyArtifactDataFromParent(parent);
                    }
                    else
                        err = EQUIP_ERR_WRONG_BAG_TYPE_3; // send by mail
                }
                else if (g_ItemChildIds.count(item->GetEntry()))
                {
                    sLog->outAshran("Player::_LoadInventory: Item doesn't have ITEM_FIELD_FLAG_CHILD flag but is a item child, delete id (%u %u)", item->GetEntry(), GetGUIDLow());
                    item->DeleteFromInventoryDB(trans);
                    delete item;
                    continue;
                }

                if (ItemChildEquipmentEntry const* childItemEntry = GetItemChildEquipment(item->GetEntry()))
                    l_ParentGUID.insert(item->GetGUID());

                // Item is not in bag
                if (!bagGuid)
                {
                    item->SetContainer(NULL);
                    item->SetSlot(slot);

                    if (IsInventoryPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        uint16 dest;
                        err = CanEquipItem(slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            QuickEquipItem(dest, item);
                    }
                    else if (IsBankPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            item = BankItem(dest, item, true);
                    }
                    else if (IsReagentBankPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanReagentBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                        if (err == EQUIP_ERR_OK)
                            item = BankItem(dest, item, true);
                    }

                    // Remember bags that may contain items in them
                    if (err == EQUIP_ERR_OK)
                    {
                        if (IsBagPos(item->GetPos()))
                            if (Bag* pBag = item->ToBag())
                                bagMap[item->GetRealGUIDLow()] = pBag;
                    }
                    else
                        if (IsBagPos(item->GetPos()))
                            if (item->IsBag())
                                invalidBagMap[item->GetRealGUIDLow()] = item;
                }
                else
                {
                    item->SetSlot(NULL_SLOT);
                    // Item is in the bag, find the bag
                    std::map<uint32, Bag*>::iterator itr = bagMap.find(bagGuid);
                    if (itr != bagMap.end())
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (invalidBagMap.find(bagGuid) != invalidBagMap.end())
                    {
                        std::map<uint32, Item*>::iterator itr = invalidBagMap.find(bagGuid);
                        if (std::find(problematicItems.begin(), problematicItems.end(),itr->second) != problematicItems.end())
                            err = EQUIP_ERR_INTERNAL_BAG_ERROR;
                    }
                    else
                    {
                        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which doesnt have a valid bag (Bag GUID: %u, slot: %u). Possible cheat?",
                            GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot);
                        err = EQUIP_ERR_INTERNAL_BAG_ERROR;
                    }
                }

                // Item's state may have changed after storing
                if (err == EQUIP_ERR_OK)
                    item->SetState(ITEM_UNCHANGED, this);
                else
                {
                    sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which can't be loaded into inventory (Bag GUID: %u, slot: %u) by reason %u. Item will be sent by mail.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot, err);

                    PreparedStatement* stmt = l_Database->GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
                    stmt->setUInt32(0, item->GetGUIDLow());
                    trans->Append(stmt);

                    problematicItems.push_back(item);
                }

                if (item->GetTemplate()->Quality == ITEM_QUALITY_HEIRLOOM)
                    if (HeirloomEntry const* l_HeirloomEntry = GetHeirloomEntryByItemID(item->GetTemplate()->ItemId))
                        AddHeirloom(l_HeirloomEntry, item->HasCustomFlags(ItemCustomFlags::FromStore));
            }
        }
        while (p_Result->NextRow());

        m_itemUpdateQueueBlocked = false;

        for (uint8 l_Slot = CHILD_EQUIPMENT_SLOT_START; l_Slot < CHILD_EQUIPMENT_SLOT_END; ++l_Slot)
        {
            if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_Slot))
            {
                if (!l_Item->IsArtifactOrArtifactChild(this) || l_Item->GetArtifactManager())
                {
                    std::list<uint32> l_ItemBonuses;
                    for (uint32 l_Bonus : l_Item->GetAllItemBonuses())
                        l_ItemBonuses.push_back(l_Bonus);

                    AddItem(l_Item->GetEntry(), 1, l_ItemBonuses, false, 0, false, true);
                    DestroyItem(INVENTORY_SLOT_BAG_0, l_Slot, true);
                }
            }
        }

        for (uint64 l_Parent : l_ParentGUID)
        {
            if (Item* l_Item = GetItemByGuid(l_Parent))
            {
                if (ItemChildEquipmentEntry const* childItemEntry = GetItemChildEquipment(l_Item->GetEntry()))
                {
                    uint64 l_ChildGUID = l_Item->GetChildItem();
                    if (!l_ChildGUID || (l_ChildGUID && !GetItemByGuid(l_ChildGUID)))
                    {
                        if (ItemTemplate const* childTemplate = sObjectMgr->GetItemTemplate(childItemEntry->ChildItemID))
                        {
                            ItemPosCountVec childDest;
                            uint32 count = 1;
                            CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, childDest, childTemplate, count, false, nullptr, NULL_BAG, NULL_SLOT);
                            if (Item* childItem = StoreNewItem(childDest, childTemplate->ItemId, true, 0))
                            {
                                childItem->SetGuidValue(ITEM_FIELD_CREATOR, l_Item->GetGUID());
                                childItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD);
                                l_Item->SetChildItem(childItem->GetGUID());
                                l_ChildGUID = l_Item->GetChildItem();
                            }
                        }
                    }
                }
            }
        }

        /// @TODO: New review it sometime send back items that are on AH on sent to others ppl by mail
        /// Send by mails lost items
        if (p_DelinkItemsResult)
        {
            do
            {
                Field* l_Fields = p_DelinkItemsResult->Fetch();

                if (Item* l_Item = _LoadItem(trans, zoneId, p_TimeDiff, l_Fields))
                    problematicItems.push_back(l_Item);

            } while (p_DelinkItemsResult->NextRow());
        }

        // Send problematic items by mail
        while (!problematicItems.empty())
        {
            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

            MailDraft draft(subject, "There were problems with equipping item(s).");
            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
            {
                draft.AddItem(problematicItems.front());
                problematicItems.pop_front();
            }
            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
        }

        l_Database->CommitTransaction(trans);
    }

    if (MS::Artifact::Manager* l_Artifact = GetCurrentlyEquippedArtifact())
        l_Artifact->UpdateAppearance();

    //if (isAlive())
    _ApplyAllItemMods();
}

void Player::_LoadVoidStorage(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
        Field* fields = result->Fetch();

        uint64 itemId = fields[0].GetUInt64();
        uint32 itemEntry = fields[1].GetUInt32();
        uint8 slot = fields[2].GetUInt8();
        uint32 creatorGuid = fields[3].GetUInt32();
        uint32 randomProperty = fields[4].GetUInt32();
        uint32 suffixFactor = fields[5].GetUInt32();
        Tokenizer l_BonusToken(fields[6].GetString(), ' ');
        uint32 customFlags = fields[7].GetUInt32();

        if (!itemId)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName(), itemId, itemEntry);
            continue;
        }

        if (!sObjectMgr->GetItemTemplate(itemEntry))
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid entry (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName(), itemId, itemEntry);
            continue;
        }

        if (slot >= VOID_STORAGE_MAX_SLOT)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName(), itemId, itemEntry, slot);
            continue;
        }

        std::vector<uint32> l_Bonuses;
        uint32 l_AppearanceModID = 0;

        for (uint8 l_I = 0; l_I < l_BonusToken.size(); ++l_I)
        {
            l_Bonuses.push_back(atoi(l_BonusToken[l_I]));

            if (ItemBonusEntry const* l_BonusEntry = sItemBonusStore.LookupEntry(l_Bonuses.back()))
            {
                if (l_BonusEntry->Type == ItemBonusType::ITEM_BONUS_APPEARANCE && l_AppearanceModID < l_BonusEntry->Value[0])
                    l_AppearanceModID = l_BonusEntry->Value[0];
            }
        }

        if (!sObjectMgr->GetPlayerByLowGUID(creatorGuid))
            creatorGuid = 0;

        _voidStorageItems[slot] = new VoidStorageItem(itemId, itemEntry, creatorGuid, randomProperty, suffixFactor, l_Bonuses, customFlags, false);
        GetSession()->GetCollectionMgr()->AddItemAppearance(itemEntry, l_AppearanceModID);
    }
    while (result->NextRow());
}

Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
{
    Item* item = NULL;

    auto l_Database  = &CharacterDatabase;
    uint32 l_RealmID = g_RealmID;

    uint32 itemGuid  = fields[ItemInstanceField::Guid].GetUInt32();
    uint32 itemEntry = fields[ItemInstanceField::ItemEntry].GetUInt32();

    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry))
    {
        bool remove = false;
        item = NewItemOrBag(proto);
        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry))
        {
            PreparedStatement* stmt = NULL;

            // Do not allow to have item limited to another map/zone in alive state
            if (isAlive() && item->IsLimitedToAnotherMapOrZone(GetMapId(), zoneId))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', map: %u) has item (GUID: %u, entry: %u) limited to another map (%u). Deleting item.",
                    GetGUIDLow(), GetName(), GetMapId(), item->GetGUIDLow(), item->GetEntry(), zoneId);
                remove = true;
            }
            // "Conjured items disappear if you are logged out for more than 15 minutes"
            else if (timeDiff > 15 * MINUTE && proto->Flags & int32(ItemFlags::CONJURED))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', diff: %u) has conjured item (GUID: %u, entry: %u) with expired lifetime (15 minutes). Deleting item.",
                    GetGUIDLow(), GetName(), timeDiff, item->GetGUIDLow(), item->GetEntry());
                remove = true;
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
            {
                if (item->GetPlayedTime() > (2 * HOUR))
                {
                    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), item->GetPlayedTime());

                    stmt = l_Database->GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
                    stmt->setUInt32(0, item->GetRealGUIDLow());
                    trans->Append(stmt);

                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
                }
                else
                {
                    uint64 l_PlayerGUID = GetGUID();

                    PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_ITEM_REFUNDS);
                    l_Statement->setUInt32(0, item->GetRealGUIDLow());
                    l_Statement->setUInt32(1, GetRealGUIDLow());

                    l_Database->AsyncQuery(l_Statement, m_QueryCallbackMgr, [itemGuid, l_PlayerGUID](PreparedQueryResult p_Result) -> void
                    {
                        Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
                        if (l_Player == nullptr)
                            return;

                        Item* l_ItemRetreive = l_Player->GetItemByGuid(MAKE_NEW_GUID(itemGuid, 0, HIGHGUID_ITEM));
                        if (l_ItemRetreive == nullptr)
                            return;

                        if (p_Result)
                        {
                            l_ItemRetreive->SetRefundRecipient((*p_Result)[0].GetUInt32());
                            l_ItemRetreive->SetPaidMoney((*p_Result)[1].GetUInt64());
                            l_ItemRetreive->SetPaidExtendedCost((*p_Result)[2].GetUInt16());
                            l_Player->AddRefundReference(l_ItemRetreive->GetGUIDLow());
                        }
                        else
                        {
                            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with refundable flags, but without data in item_refund_instance. Removing flag.",
                                l_Player->GetGUIDLow(), l_Player->GetName(), l_ItemRetreive->GetGUIDLow(), l_ItemRetreive->GetEntry());
                            l_ItemRetreive->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
                        }
                    });
                }
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
            {
                uint64 l_PlayerGUID = GetGUID();

                PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_ITEM_BOP_TRADE);
                l_Statement->setUInt32(0, item->GetRealGUIDLow());

                l_Database->AsyncQuery(l_Statement, m_QueryCallbackMgr, [itemGuid, l_PlayerGUID](PreparedQueryResult p_Result) -> void
                {
                    Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
                    if (l_Player == nullptr)
                        return;

                    Item* l_ItemRetreive = l_Player->GetItemByGuid(MAKE_NEW_GUID(itemGuid, 0, HIGHGUID_ITEM));
                    if (l_ItemRetreive == nullptr)
                        return;

                    if (p_Result)
                    {
                        std::string strGUID = (*p_Result)[0].GetString();
                        Tokenizer GUIDlist(strGUID, ' ');
                        AllowedLooterSet looters;
                        for (Tokenizer::const_iterator itr = GUIDlist.begin(); itr != GUIDlist.end(); ++itr)
                            looters.insert(atol(*itr));
                        l_ItemRetreive->SetSoulboundTradeable(looters);
                        l_Player->AddTradeableItem(l_ItemRetreive);
                    }
                    else
                    {
                        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with ITEM_FIELD_FLAG_BOP_TRADEABLE flag, but without data in item_soulbound_trade_data. Removing flag.",
                            l_Player->GetGUIDLow(), l_Player->GetName(), l_ItemRetreive->GetGUIDLow(), l_ItemRetreive->GetEntry());
                        l_ItemRetreive->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE);
                    }
                });
            }
            else if (proto->HolidayId)
            {
                remove = true;
                GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
                GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
                for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
                {
                    if (uint32(events[*itr].holiday_id) == proto->HolidayId)
                    {
                        remove = false;
                        break;
                    }
                }
            }

            if (proto->NeedScaleOnArtifactKnowledge)
            {
                if (uint32 l_ArtifactKnowledge = fields[ItemInstanceField::AcquiredLevel].GetUInt32())
                {
                    uint32 l_PlayerArtifactKnowledge = getLevel() >= 110 ? sWorld->GetCurrentArtifactKnowledge() : 0;

                    if (l_ArtifactKnowledge < l_PlayerArtifactKnowledge)
                        item->SetArtifactKnowledgeOnAcquire(l_ArtifactKnowledge);
                    else
                        item->SetArtifactKnowledgeOnAcquire(l_PlayerArtifactKnowledge);
                }
            }
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has broken item (GUID: %u, entry: %u) in inventory. Deleting item.",
                GetGUIDLow(), GetName(), itemGuid, itemEntry);
            remove = true;
        }
        // Remove item from inventory if necessary
        if (remove)
        {
            sLog->outArena("_LoadItem: remove = true for entry %u", itemEntry);
            Item::DeleteFromInventoryDB(trans, itemGuid, l_RealmID);
            item->FSetState(ITEM_REMOVED);
            item->SaveToDB(trans);                           // it also deletes item object!
            item = NULL;
        }
    }
    else
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has unknown item (entry: %u) in inventory. Deleting item.",
            GetGUIDLow(), GetName(), itemEntry);
    }
    return item;
}

// load mailed item which should receive current player
void Player::_LoadMailedItems(PreparedQueryResult p_MailedItems)
{
    // data needs to be at first place for Item::LoadFromDB
    if (!p_MailedItems)
        return;

    do
    {
        Field* l_Fields = p_MailedItems->Fetch();

        uint32 l_ItemGuid     = l_Fields[ItemInstanceField::Guid].GetUInt32();
        uint32 l_ItemTemplate = l_Fields[ItemInstanceField::ItemEntry].GetUInt32();
        uint32 l_MailId       = l_Fields[ItemInstanceField::End + 2].GetUInt32();

        Mail* l_Mail = GetMail(l_MailId);
        if (l_Mail == nullptr)
            continue;

        l_Mail->AddItem(l_ItemGuid, l_ItemTemplate);

        ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_ItemTemplate);

        if (!l_Proto)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %u has unknown item_template (ProtoType) in mailed items(GUID: %u template: %u) in mail (%u), deleted.", GetGUIDLow(), l_ItemGuid, l_ItemTemplate, l_Mail->messageID);

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_MAIL_ITEM);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);
            sLog->outAshran("Player::_LoadMailedItems delete item %u", l_ItemGuid);
            continue;
        }

        Item* l_Item = NewItemOrBag(l_Proto);
        if (!l_Item->LoadFromDB(l_ItemGuid, MAKE_NEW_GUID(l_Fields[ItemInstanceField::End + 1].GetUInt32(), 0, HIGHGUID_PLAYER), l_Fields, l_ItemTemplate))
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", l_Mail->messageID, l_ItemGuid);

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);

            if (l_Item->GetEntry() == 138019)
                sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (5)");
            l_Item->FSetState(ITEM_REMOVED);

            SQLTransaction l_Tmp = SQLTransaction(NULL);
            l_Item->SaveToDB(l_Tmp);                               // it also deletes item object !
            continue;
        }

        AddMItem(l_Item);
    }
    while (p_MailedItems->NextRow());
}

void Player::_LoadMailInit(PreparedQueryResult resultUnread, PreparedQueryResult resultDelivery)
{
    //set a count of unread mails
    //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
    if (resultUnread)
        unReadMails = uint8((*resultUnread)[0].GetUInt64());

    // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
    //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
    if (resultDelivery)
        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
}

void Player::_LoadMail(PreparedQueryResult p_MailResult)
{
    m_mail.clear();

    if (p_MailResult)
    {
        do
        {
            Field* fields = p_MailResult->Fetch();
            Mail* m = new Mail;

            m->messageID      = fields[0].GetUInt32();
            m->messageType    = fields[1].GetUInt8();
            m->sender         = fields[2].GetUInt32();
            m->receiver       = fields[3].GetUInt32();

            std::string subject = fields[4].GetString();
            std::string body = fields[5].GetString();
            MailDraft::NormalizeMessage(body, subject);
            m->subject = subject;
            m->body = body;

            bool has_items    = fields[6].GetBool(); ///< hasitem is never read 01/18/16
            m->expire_time    = time_t(fields[7].GetUInt32());
            m->deliver_time   = time_t(fields[8].GetUInt32());
            m->money          = fields[9].GetUInt64();
            m->COD            = fields[10].GetUInt64();
            m->checked        = fields[11].GetUInt8();
            m->stationery     = fields[12].GetUInt8();
            m->mailTemplateId = fields[13].GetInt16();

            if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMail - Mail (%u) have not existed MailTemplateId (%u), remove at load", m->messageID, m->mailTemplateId);
                m->mailTemplateId = 0;
            }

            m->state = MAIL_STATE_UNCHANGED;

            m_mail.push_back(m);
        }
        while (p_MailResult->NextRow());
    }
}

void Player::LoadPet(PreparedQueryResult result)
{
    //fixme: the pet should still be loaded if the player is not in world
    // just not added to the map
    if (IsInWorld())
    {
        if (result)
        {
            Field* fields = result->Fetch();

            uint32 l_RealmID = g_RealmID;

            PetQueryHolder* queryHolder = new PetQueryHolder(fields[0].GetUInt32(), l_RealmID, result);
            if (!queryHolder->Initialize())
            {
                delete queryHolder;
                return;
            }

            _petLoginCallback = RealmDatabase.DelayQueryHolder((SQLQueryHolder*)queryHolder);
        }

        auto res = RealmDatabase.PQuery("select modelId, entry from character_pet where owner = %u and slot >= 5", GetGUIDLow());
        if (res)
        {
            do
            {
                auto field = res->Fetch();
                m_stablePetModels[field[0].GetUInt32()] = field[1].GetUInt32();
            } while (res->NextRow());
        }
    }
}

void Player::_LoadQuestStatus(PreparedQueryResult result)
{
    uint16 slot = 0;

    ////                                                       0      1       2        3
    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, explored, timer, FROM character_queststatus WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                // find or create
                QuestStatusData& questStatusData = m_QuestStatus[quest_id];

                uint8 qstatus = fields[1].GetUInt8();
                if (qstatus < MAX_QUEST_STATUS)
                    questStatusData.Status = QuestStatus(qstatus);
                else
                {
                    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
                    sLog->outError(LOG_FILTER_PLAYER, "Player %s (GUID: %u) has invalid quest %d status (%u), replaced by QUEST_STATUS_INCOMPLETE(3).",
                        GetName(), GetGUIDLow(), quest_id, qstatus);
                }

                questStatusData.Explored = (fields[2].GetUInt8() > 0);

                time_t quest_time = time_t(fields[3].GetUInt32());

                if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && !GetQuestRewardStatus(quest_id))
                {
                    AddTimedQuest(quest_id);

                    if (quest_time <= sWorld->GetGameTime())
                        questStatusData.Timer = 1;
                    else
                        questStatusData.Timer = uint32((quest_time - sWorld->GetGameTime()) * IN_MILLISECONDS);
                }
                else
                    quest_time = 0;


                // add to quest log
                if (slot < MAX_QUEST_LOG_SIZE && questStatusData.Status != QUEST_STATUS_NONE)
                {
                    SetQuestSlot(slot, quest_id, uint32(quest_time)); // cast can't be helped

                    if (questStatusData.Status == QUEST_STATUS_COMPLETE)
                        SetQuestSlotState(slot, QUEST_STATE_COMPLETE);
                    else if (questStatusData.Status == QUEST_STATUS_FAILED)
                        SetQuestSlotState(slot, QUEST_STATE_FAIL);

                    ++slot;
                }

                if (quest->InProgressPhaseID)
                    SetInPhase(quest->InProgressPhaseID, true, true);

                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Quest status is {%u} for quest {%u} for player (GUID: %u)", questStatusData.Status, quest_id, GetGUIDLow());
            }
        }
        while (result->NextRow());
    }

    // clear quest log tail
    for (uint16 i = slot; i < MAX_QUEST_LOG_SIZE; ++i)
        SetQuestSlot(i, 0);
}

void Player::_LoadQuestObjectiveStatus(PreparedQueryResult result)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 objectiveId  = fields[0].GetUInt32();
            uint32 amount       = fields[1].GetUInt32();

            if (!sObjectMgr->QuestObjectiveExists(objectiveId))
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player %s (%u) has invalid Quest Objective Id %u in Quest Objective status data! Skipping.", GetName(), GetGUIDLow(), objectiveId);
                continue;
            }

            uint32 l_ObjectiveQuestId = sObjectMgr->GetQuestObjectiveQuestId(objectiveId);

            for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
            {
                uint32 questId = GetQuestSlotQuestId(i);
                if (!questId)
                    continue;

                if (questId != l_ObjectiveQuestId)
                    continue;

                // Quest existence is checked on Quest Objective load, no issue should arise
                QuestObjective const* objective = sObjectMgr->GetQuestTemplate(l_ObjectiveQuestId)->GetQuestObjective(objectiveId);

                SetQuestSlotCounter(i, objective->Index, amount);
                m_questObjectiveStatus.insert(std::make_pair(objectiveId, amount));

                break;
            }

            /// Load world quest progress
            if (amount)
            {
                for (auto l_WorldQuest : MS::WorldQuest::Template::GetAreaGroupMap())
                {
                    if (l_WorldQuest.first == l_ObjectiveQuestId)
                    {
                        m_questObjectiveStatus.insert(std::make_pair(objectiveId, amount));
                        break;
                    }
                }
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadQuestStatusRewarded(PreparedQueryResult result)
{
    // SELECT quest FROM character_queststatus_rewarded WHERE guid = ?

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                if (quest->IsAccountQuest())
                    m_AccountRewardedQuests.insert(quest_id);

                // learn rewarded spell if unknown
                learnQuestRewardedSpells(quest);

                // set rewarded title if any
                if (quest->GetCharTitleId())
                {
                    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
                        SetTitle(titleEntry);
                }

                /// Skip loading special quests - they are also added to rewarded quests but only once and remain there forever
                /// instead add them separately from load daily/weekly/monthly/seasonal
                if (!quest->IsDailyOrWeekly() && !quest->IsMonthly() && !quest->IsSeasonal())
                {
                    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(quest_id))
                        SetQuestBit(l_QuestBit, true);
                }

                for (uint32 l_I = 0; l_I < quest->GetRewChoiceItemsCount(); ++l_I)
                    GetSession()->GetCollectionMgr()->AddItemAppearance(quest->RewardChoiceItemId[l_I]);

                for (uint32 l_I = 0; l_I < quest->GetRewItemsCount(); ++l_I)
                    GetSession()->GetCollectionMgr()->AddItemAppearance(quest->RewardItemId[l_I]);

                if (std::vector<QuestPackageItemEntry const*> const* l_QuestPackageItems = GetQuestPackageItems(quest->GetQuestPackageID()))
                {
                    for (QuestPackageItemEntry const* questPackageItem : *l_QuestPackageItems)
                    {
                        if (ItemTemplate const* rewardProto = sObjectMgr->GetItemTemplate(questPackageItem->ItemID))
                        {
                            if (rewardProto->ItemSpecClassMask & getClassMask())
                                GetSession()->GetCollectionMgr()->AddItemAppearance(questPackageItem->ItemID);
                        }
                    }
                }

                if (quest->CompletedPhaseID)
                    SetInPhase(quest->CompletedPhaseID, true, true);
            }

            m_RewardedQuests.insert(quest_id);
        }
        while (result->NextRow());
    }
}

void Player::_LoadDailyQuestStatus(PreparedQueryResult result)
{
    m_dailyQuestStorage.clear();

    m_DFQuests.clear();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        uint32 quest_daily_idx = 0;
        do
        {
            Field* fields = result->Fetch();
            if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(fields[0].GetUInt32()))
            {
                if (qQuest->IsDFQuest())
                {
                    m_DFQuests.insert(qQuest->GetQuestId());
                    m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
                    continue;
                }
            }

            uint32 quest_id = fields[0].GetUInt32();

            // save _any_ from daily quest times (it must be after last reset anyway)
            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());

            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_dailyQuestStorage.insert(quest_id);
            if (++quest_daily_idx < DynamicFields::Count)
                SetDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED, quest_daily_idx++, quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit , true);

            if (quest->CompletedPhaseID)
                SetInPhase(quest->CompletedPhaseID, true, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Daily quest (%u) cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_DailyQuestChanged = false;
}

void Player::_LoadWeeklyQuestStatus(PreparedQueryResult result)
{
    m_weeklyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_weeklyquests.insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            if (quest->CompletedPhaseID)
                SetInPhase(quest->CompletedPhaseID, true, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_WeeklyQuestChanged = false;
}

void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
{
    m_seasonalquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            uint32 event_id = fields[1].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_seasonalquests[event_id].insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            if (quest->CompletedPhaseID)
                SetInPhase(quest->CompletedPhaseID, true, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Seasonal quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_SeasonalQuestChanged = false;
}

void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
{
    m_monthlyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_monthlyquests.insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            if (quest->CompletedPhaseID)
                SetInPhase(quest->CompletedPhaseID, true, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Monthly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_MonthlyQuestChanged = false;
}

void Player::_LoadAccountQuestRewarded(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    /// SELECT quest FROM account_queststatus_rewarded

    do
    {
        Field* l_Fields     = p_Result->Fetch();

        uint32 l_QuestID    = l_Fields[0].GetUInt32();

        Quest const* l_Quest = sObjectMgr->GetQuestTemplate(l_QuestID);
        if (!l_Quest || !l_Quest->IsAccountQuest())
            continue;

        if (!l_Quest->IsDailyOrWeekly() && !l_Quest->IsMonthly() && !l_Quest->IsSeasonal())
        {
            if (uint32 l_QuestBit = GetQuestUniqueBitFlag(l_QuestID))
                SetQuestBit(l_QuestBit, true);
        }

        m_AccountRewardedQuests.insert(l_QuestID);
    }
    while (p_Result->NextRow());
}

void Player::_LoadSpells(PreparedQueryResult result)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            addSpell(fields[0].GetUInt32(), fields[1].GetBool(), false, false, fields[2].GetBool(), true, fields[3].GetBool());
        }
        while (result->NextRow());
    }
}

void Player::_LoadGarrisonDailyTavernDatas(PreparedQueryResult p_Result)
{
    auto l_GarrisonMgr = GetDraenorGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    if (p_Result)
    {
        do
        {
            Field* fields = p_Result->Fetch();

            uint32 l_NpcEntry = fields[1].GetUInt32();
            l_GarrisonMgr->SetGarrisonDailyTavernData(l_NpcEntry);
        }
        while (p_Result->NextRow());
    }
    else
    {

        if (l_GarrisonMgr->HasActiveBuilding(MS::Garrison::GDraenor::Building::ID::LunarfallInn_FrostwallTavern_Level1))
        {
            if (roll_chance_i(50))
            {
                uint32 l_Entry = MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries.size() - 1)];

                l_GarrisonMgr->CleanGarrisonDailyTavernData();
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_Entry);
            }
            else
            {
                uint32 l_FirstEntry  = MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries.size() - 1)];
                uint32 l_SecondEntry = 0;

                do
                    l_SecondEntry = MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::GDraenor::TavernDatas::g_QuestGiverEntries.size() - 1)];
                while (l_SecondEntry == l_FirstEntry);

                l_GarrisonMgr->CleanGarrisonDailyTavernData();
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_FirstEntry);
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_SecondEntry);
            }
        }
    }
}

void Player::_LoadCharacterGarrisonWeeklyTavernDatas(PreparedQueryResult p_Result)
{
    auto l_GarrisonMgr = GetDraenorGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    if (p_Result)
    {
        do
        {
            Field* l_Fields = p_Result->Fetch();
            std::vector<uint32> l_AbilitiesVector;
            uint32 l_FollowerID = l_Fields[1].GetUInt32();
            std::string l_Abilities = l_Fields[2].GetString();

            Tokenizer l_Tokens(l_Abilities, ' ');

            for (Tokenizer::const_iterator l_Iter = l_Tokens.begin(); l_Iter != l_Tokens.end(); ++l_Iter)
                l_AbilitiesVector.push_back(uint32(atol(*l_Iter)));

            MS::Garrison::WeeklyTavernData l_TavernData = { l_FollowerID, l_AbilitiesVector };

            l_GarrisonMgr->SetGarrisonWeeklyTavernData(l_TavernData);
        }
        while (p_Result->NextRow());
    }
}

void Player::_LoadGroup(PreparedQueryResult result)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", GetGUIDLow());
    if (result)
    {
        if (GroupPtr group = sGroupMgr->GetGroupByDbStoreId((*result)[0].GetUInt32()))
        {
            uint8 subgroup = group->GetMemberGroup(GetGUID());
            SetGroup(group, subgroup);
            if (getLevel() >= LEVELREQUIREMENT_HEROIC)
            {
                // the group leader may change the instance difficulty while the player is offline
                SetDungeonDifficultyID(group->GetDungeonDifficultyID());
                SetRaidDifficultyID(group->GetRaidDifficultyID());
                SetLegacyRaidDifficultyID(group->GetLegacyRaidDifficultyID());
            }
        }
    }
}

void Player::_LoadBoundInstances(PreparedQueryResult p_Result)
{
    for (uint8 l_I = 0; l_I < Difficulty::MaxDifficulties; ++l_I)
        m_boundInstances[l_I].clear();

    GroupPtr l_Group = GetGroup();

    if (p_Result)
    {
        do
        {
            uint8 l_Index = 0;
            Field* l_Fields = p_Result->Fetch();

            uint32 l_InstanceID = l_Fields[l_Index++].GetUInt32();
            bool l_Perm = l_Fields[l_Index++].GetBool();
            uint32 l_MapID = l_Fields[l_Index++].GetUInt16();
            uint8 l_Difficulty = l_Fields[l_Index++].GetUInt8();
            BindExtensionState l_ExtendState = BindExtensionState(l_Fields[l_Index++].GetUInt8());

            time_t l_ResetTime = time_t(l_Fields[l_Index++].GetUInt32());

            /// The resettime for normal instances is only saved when the InstanceSave is unloaded
            /// so the value read from the DB may be wrong here but only if the InstanceSave is loaded
            /// and in that case it is not used

            bool l_DeleteInstance = false;

            MapEntry const* l_MapEntry = sMapStore.LookupEntry(l_MapID);
            if (!l_MapEntry || !l_MapEntry->IsDungeon())
            {
                sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed or not dungeon map %d", GetName(), GetGUIDLow(), l_MapID);
                l_DeleteInstance = true;
            }
            else if (l_Difficulty >= Difficulty::MaxDifficulties)
            {
                sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), l_Difficulty, l_MapID);
                l_DeleteInstance = true;
            }
            else
            {
                MapDifficultyEntry const* l_MapDiff = GetMapDifficultyData(l_MapID, Difficulty(l_Difficulty));
                if (!l_MapDiff)
                {
                    sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), l_Difficulty, l_MapID);
                    l_DeleteInstance = true;
                }
                else if (!l_Perm && l_Group)
                {
                    sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) is in group %d but has a non-permanent character bind to map %d, %d, %d", GetName(), GetGUIDLow(), GUID_LOPART(l_Group->GetGUID()), l_MapID, l_InstanceID, l_Difficulty);
                    l_DeleteInstance = true;
                }
            }

            if (l_DeleteInstance)
            {
                PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CharacterDatabaseStatements::CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

                l_Statement->setUInt32(0, GetGUIDLow());
                l_Statement->setUInt32(1, l_InstanceID);

                RealmDatabase.Execute(l_Statement);

                continue;
            }

            /// Since non permanent binds are always solo bind, they can always be reset
            if (InstanceSavePtr l_Save = sInstanceSaveMgr->AddInstanceSave(l_MapID, l_InstanceID, Difficulty(l_Difficulty), l_ResetTime, !l_Perm, true))
               BindToInstance(l_Save, l_Perm, l_ExtendState, true);
        }
        while (p_Result->NextRow());
    }
}

InstancePlayerBindPtr Player::GetBoundInstance(uint32 p_MapID, Difficulty p_Difficulty, bool p_WithExpired)
{
    /// Some instances only have one difficulty
    MapDifficultyEntry const* l_MapDiff = GetDownscaledMapDifficultyData(p_MapID, p_Difficulty);
    if (!l_MapDiff)
        return nullptr;

    BoundInstancesMap::iterator l_Iter = m_boundInstances[p_Difficulty].find(p_MapID);
    if (l_Iter != m_boundInstances[p_Difficulty].end())
    {
        if (l_Iter->second->extendState || p_WithExpired)
            return l_Iter->second;
    }
    else
        return nullptr;

    return nullptr;
}

InstanceSavePtr Player::GetInstanceSave(uint32 p_MapID)
{
    MapEntry const* l_MapEntry      = sMapStore.LookupEntry(p_MapID);
    InstancePlayerBindPtr l_Bind    = GetBoundInstance(p_MapID, GetDifficultyID(l_MapEntry));
    InstanceSavePtr l_Save          = l_Bind ? l_Bind->save : NULL;

    if (!l_Bind || !l_Bind->perm)
    {
        if (GroupPtr l_Group = GetGroup())
        {
            if (InstanceGroupBindPtr l_GroupBind = l_Group->GetBoundInstance(this))
                l_Save = l_GroupBind->save;
        }
    }

    if (!l_Bind || !l_Bind->perm)
    {
        if (GroupPtr l_Group = GetGroup())
        {
            if (InstanceGroupBindPtr l_GroupBind = l_Group->GetBoundInstance(this))
                l_Save = l_GroupBind->save;
        }
    }

    return l_Save;
}

void Player::UnbindInstance(uint32 mapid, Difficulty difficulty, bool unload)
{
    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
    UnbindInstance(itr, difficulty, unload);
}

void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficulty, bool unload)
{
    if (itr != m_boundInstances[difficulty].end())
    {
        if (!unload)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, itr->second->save->GetInstanceId());
            RealmDatabase.Execute(stmt);
        }

        /// @TODO: Cross
        //if (itr->second.perm)
        //    GetSession()->SendCalendarRaidLockout(itr->second.save, false);

        itr->second->save->RemovePlayer(this);               // save can become invalid
        m_boundInstances[difficulty].erase(itr++);
    }
}

InstancePlayerBindPtr Player::BindToInstance(InstanceSavePtr p_InstanceSave, bool p_Permanent, BindExtensionState p_ExtendState, bool p_Load)
{
    if (p_InstanceSave && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyRaidLFR
        && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyRaidTool
        && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyMythic
        && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyNScenario)
    {
        InstancePlayerBindPtr l_InstanceBind = nullptr;

        auto& l_BoundInstanceDifficulty = m_boundInstances[p_InstanceSave->GetDifficultyID()];
        auto l_Itr = l_BoundInstanceDifficulty.find(p_InstanceSave->GetMapId());
        if (l_Itr == l_BoundInstanceDifficulty.end())
        {
            l_InstanceBind = std::make_shared<InstancePlayerBind>();
            l_BoundInstanceDifficulty[p_InstanceSave->GetMapId()] = l_InstanceBind;
        }
        else
            l_InstanceBind = l_Itr->second;

        /// Special flag, keep the player's current extend state when updating for new boss down
        if (p_ExtendState == BindExtensionState::EXTEND_STATE_KEEP)
        {
            if (p_InstanceSave == l_InstanceBind->save)
                p_ExtendState = l_InstanceBind->extendState;
            else
                p_ExtendState = BindExtensionState::EXTEND_STATE_NORMAL;
        }

        if (l_InstanceBind->save)
        {
            /// Update the save when the group kills a boss
            if (p_Permanent != l_InstanceBind->perm || p_InstanceSave != l_InstanceBind->save || p_ExtendState != l_InstanceBind->extendState)
            {
                if (!p_Load)
                {
                    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CharacterDatabaseStatements::CHAR_UPD_CHAR_INSTANCE);
                    l_Statement->setUInt32(0, p_InstanceSave->GetInstanceId());
                    l_Statement->setBool(1, p_Permanent);
                    l_Statement->setUInt8(2, p_ExtendState);
                    l_Statement->setUInt32(3, GetRealGUIDLow());
                    l_Statement->setUInt32(4, l_InstanceBind->save->GetInstanceId());
                    RealmDatabase.Execute(l_Statement);
                }
            }
        }
        else
        {
            if (!p_Load)
            {
                PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CharacterDatabaseStatements::CHAR_INS_CHAR_INSTANCE);
                l_Statement->setUInt32(0, GetRealGUIDLow());
                l_Statement->setUInt32(1, p_InstanceSave->GetInstanceId());
                l_Statement->setBool(2, p_Permanent);
                l_Statement->setUInt8(3, p_ExtendState);
                RealmDatabase.Execute(l_Statement);
            }
        }

        if (l_InstanceBind->save != p_InstanceSave)
        {
            if (l_InstanceBind->save)
                l_InstanceBind->save->RemovePlayer(this);

            p_InstanceSave->AddPlayer(this);
        }

        if (p_Permanent)
            p_InstanceSave->SetCanReset(false);

        l_InstanceBind->save = p_InstanceSave;
        l_InstanceBind->perm = p_Permanent;
        l_InstanceBind->extendState = p_ExtendState;

        if (!p_Load)
            sLog->outDebug(LogFilterType::LOG_FILTER_MAPS, "Player::BindToInstance: %s(%d) is now bound to map %d, instance %d, difficulty %d", GetName(), GetGUIDLow(), p_InstanceSave->GetMapId(), p_InstanceSave->GetInstanceId(), p_InstanceSave->GetDifficultyID());

        sScriptMgr->OnPlayerBindToInstance(this, p_InstanceSave->GetDifficultyID(), p_InstanceSave->GetMapId(), p_Permanent, uint8(p_ExtendState));
        return l_InstanceBind;
    }
    else
        return nullptr;
}

void Player::BindToInstance()
{
    InstanceSavePtr l_MapSave = sInstanceSaveMgr->GetInstanceSave(_pendingBindId);
    if (!l_MapSave) ///< It seems sometimes mapSave is NULL, but I did not check why
        return;

    WorldPacket l_Data(SMSG_INSTANCE_SAVE_CREATED, 4);
    l_Data.WriteBit(false);
    GetSession()->SendPacket(&l_Data);

    BindToInstance(l_MapSave, true, BindExtensionState::EXTEND_STATE_KEEP);

    /// @TODO: cross
    ///GetSession()->SendCalendarRaidLockout(mapSave, true);
}

void Player::SendPendingRaidLock(uint32 p_Timer, uint32 p_CompletedMask /*= 0*/, bool p_Extends /*= false*/, bool p_WarningOnly /*= false*/)
{
    WorldPacket l_Data(Opcodes::SMSG_PENDING_RAID_LOCK);

    l_Data << p_Timer;
    l_Data << p_CompletedMask;

    l_Data.WriteBit(p_Extends);
    l_Data.WriteBit(p_WarningOnly);
    l_Data.FlushBits();

    GetSession()->SendPacket(&l_Data);
}

void Player::SendRaidInfo()
{
    uint32 l_Counter = 0;
    WorldPacket l_Data(SMSG_RAID_INSTANCE_INFO, 1024);
    ByteBuffer l_Buffer;
    time_t l_Now = time(NULL);

    /// shared instances locks
    for (uint8 l_Iter = 0; l_Iter < Difficulty::MaxDifficulties; ++l_Iter)
    {
        m_boundInstances[l_Iter].safe_foreach(true, [&l_Buffer, &l_Counter, l_Now](BoundInstancesMap::const_iterator* p_Itr) -> void
        {
            InstancePlayerBindPtr l_InstanceBind = (*p_Itr)->second;
            if (l_InstanceBind->perm)
            {
                InstanceSavePtr l_Save = l_InstanceBind->save;
                l_Counter++;

                l_Buffer << uint32(l_Save->GetMapId());             ///< MapId
                l_Buffer << uint32(l_Save->GetDifficultyID());      ///< DifficultyId
                l_Buffer << uint64(l_Save->GetInstanceId());        ///< InstanceId

                /// Time Remaining
                if (l_InstanceBind->extendState != BindExtensionState::EXTEND_STATE_EXTENDED)
                    l_Buffer << uint32(l_Save->GetResetTime() - l_Now);
                else
                    l_Buffer << uint32(sInstanceSaveMgr->GetSubsequentResetTime(l_Save->GetMapId(), l_Save->GetDifficultyID(), l_Save->GetResetTime()) - l_Now);

                l_Buffer << uint32(l_Save->GetEncounterMask());                                                 ///< CompletedMask
                l_Buffer.WriteBit(l_InstanceBind->extendState != BindExtensionState::EXTEND_STATE_EXPIRED);      ///< Locked
                l_Buffer.WriteBit(l_InstanceBind->extendState == BindExtensionState::EXTEND_STATE_EXTENDED);     ///< Extended

                l_Buffer.FlushBits();
            }
        });
    }

    /// personal instances lock
    PersonalInstanceLockout const& l_PersonInstancesLockout = GetPersonalInstanceLockout();
    for (auto l_Itr : l_PersonInstancesLockout)
    {
        l_Buffer << uint32(l_Itr.first.first);
        l_Buffer << uint32(l_Itr.first.second);
        l_Buffer << uint64(uint64(l_Itr.first.first) | uint64(l_Itr.first.second << 16) | uint64(GetGUIDLow()) << 32);
        l_Buffer << uint32(sWorld->GetNextBossLootResetTime() - l_Now);
        l_Buffer << uint32(l_Itr.second);
        l_Buffer.WriteBit(true);    ///< Locked
        l_Buffer.WriteBit(false);   ///< Extended
        l_Buffer.FlushBits();

        l_Counter++;
    }

    l_Data << uint32(l_Counter);
    if (l_Counter)
        l_Data.append(l_Buffer);

    GetSession()->SendPacket(&l_Data);
}

/*
- called on every successful teleportation to a map
*/
void Player::SendSavedInstances()
{
    bool hasBeenSaved = false;
    WorldPacket data;

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        m_boundInstances[i].safe_foreach(true, [&hasBeenSaved](BoundInstancesMap::const_iterator* p_Itr) -> void
        {
            if ((*p_Itr)->second->perm) ///< Only permanent binds are sent
                hasBeenSaved = true;
        });
    }

    //Send opcode SMSG_UPDATE_INSTANCE_OWNERSHIP. true or false means, whether you have current raid/heroic instances
    data.Initialize(SMSG_UPDATE_INSTANCE_OWNERSHIP, 4);
    data << uint32(hasBeenSaved);
    GetSession()->SendPacket(&data);

    if (!hasBeenSaved)
        return;

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        m_boundInstances[i].safe_foreach(true, [this, &data](BoundInstancesMap::const_iterator* p_Itr) -> void
        {
            if ((*p_Itr)->second->perm)
            {
                data.Initialize(SMSG_UPDATE_LAST_INSTANCE, 4);
                data << uint32((*p_Itr)->second->save->GetMapId());
                GetSession()->SendPacket(&data);
            }
        });
    }
}

/// convert the player's binds to the group
void Player::ConvertInstancesToGroup(Player* player, GroupPtr group, bool switchLeader)
{
    // copy all binds to the group, when changing leader it's assumed the character
    // will not have any solo binds

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        player->m_boundInstances[i].safe_foreach(false, [&](BoundInstancesMap::iterator* p_Itr) -> void
        {
            if (!switchLeader || !group->GetBoundInstance((*p_Itr)->second->save->GetDifficultyID(), (*p_Itr)->first))
            {
                if ((*p_Itr)->second->extendState) ///< Not expired
                    group->BindToInstance((*p_Itr)->second->save, (*p_Itr)->second->perm, false);
            }

            // permanent binds are not removed
            if (switchLeader && !(*p_Itr)->second->perm)
            {
                // increments itr in call
                player->UnbindInstance((*p_Itr), Difficulty(i), false);
            }
            else
                ++(*p_Itr);
        });
    }
}

bool Player::Satisfy(AccessRequirement const* p_AccessReq, uint32 p_TargetMapID, bool p_ReportError)
{
    if (!isGameMaster() && p_AccessReq)
    {
        uint8 l_LevelMin = 0;
        uint8 l_LevelMax = 0;

        MapEntry const* l_MapEntry = sMapStore.LookupEntry(p_TargetMapID);
        if (!l_MapEntry)
            return false;

        if (!sWorld->getBoolConfig(CONFIG_INSTANCE_IGNORE_LEVEL))
        {
            if (p_AccessReq->levelMin && getLevel() < p_AccessReq->levelMin)
                l_LevelMin = p_AccessReq->levelMin;
            if (p_AccessReq->levelMax && getLevel() > p_AccessReq->levelMax)
                l_LevelMax = p_AccessReq->levelMax;
        }

        uint32 l_MissingItem = 0;
        if (p_AccessReq->item)
        {
            if (!HasItemCount(p_AccessReq->item) &&
                (!p_AccessReq->item2 || !HasItemCount(p_AccessReq->item2)))
                l_MissingItem = p_AccessReq->item;
        }
        else if (p_AccessReq->item2 && !HasItemCount(p_AccessReq->item2))
            l_MissingItem = p_AccessReq->item2;

        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, p_TargetMapID, this))
        {
            GetSession()->SendNotification("%s", GetSession()->GetTrinityString(LANG_INSTANCE_CLOSED));
            return false;
        }

        uint32 l_MissingQuest = 0;
        if (GetTeam() == ALLIANCE && p_AccessReq->quest_A && !GetQuestRewardStatus(p_AccessReq->quest_A))
            l_MissingQuest = p_AccessReq->quest_A;
        else if (GetTeam() == HORDE && p_AccessReq->quest_H && !GetQuestRewardStatus(p_AccessReq->quest_H))
            l_MissingQuest = p_AccessReq->quest_H;

        uint32 l_MissingAchievement = 0;
        Player* l_Leader = this;
        GroupPtr l_Group = GetGroup();
        uint64 l_LeaderGuid = l_Group ? l_Group->GetLeaderGUID() : GetGUID();
        if (l_LeaderGuid != GetGUID())
            l_Leader = ObjectAccessor::FindPlayer(l_LeaderGuid);

        if (p_AccessReq->achievement)
            if (!l_Leader || !l_Leader->HasAchieved(p_AccessReq->achievement))
                l_MissingAchievement = p_AccessReq->achievement;

        Difficulty l_TargetDifficulty = GetDifficultyID(l_MapEntry);
        MapDifficultyEntry const* l_MapDifficulty = GetDownscaledMapDifficultyData(p_TargetMapID, l_TargetDifficulty);
        if (!l_MapDifficulty)
            return false;

        if (l_LevelMin || l_LevelMax || l_MissingItem || l_MissingQuest || l_MissingAchievement)
        {
            if (p_ReportError)
            {
                if (l_MissingQuest && !p_AccessReq->questFailedText.empty())
                    ChatHandler(GetSession()).PSendSysMessage("%s", p_AccessReq->questFailedText.c_str());
                else if (l_MapDifficulty->Message_lang->Str[sWorld->GetDefaultDb2Locale()][0] != '\0') // if (missingAchievement) covered by this case
                    SendTransferAborted(p_TargetMapID, TRANSFER_ABORT_DIFFICULTY, l_TargetDifficulty);
                else if (l_MissingItem)
                    GetSession()->SendNotification(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED_AND_ITEM), l_LevelMin, sObjectMgr->GetItemTemplate(l_MissingItem) != nullptr ? (sObjectMgr->GetItemTemplate(l_MissingItem)->Name1->Get(GetSession()->GetSessionDb2Locale())) : "");
                else if (l_LevelMin)
                    GetSession()->SendNotification(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED), l_LevelMin);
            }
            return false;
        }
    }
    return true;
}

bool Player::CheckInstanceLoginValid()
{
    if (!GetMap())
        return false;

    /// Is Allowed to login into legacy raids before Legion
    if (!GetMap()->IsDungeon() || isGameMaster() || (GetMap()->IsDungeon() && GetMap()->Expansion() < 6))
        return true;

    if (GetMap()->IsRaid())
    {
        // cannot be in raid instance without a group
        if (!GetGroup())
            return false;
    }
    else
    {
        // cannot be in normal instance without a group and more players than 1 in instance
        if (!GetGroup() && GetMap()->GetPlayersCountExceptGMs() > 1)
            return false;
    }

    // do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
    return sMapMgr->CanPlayerEnter(GetMap()->GetId(), this, true);
}

bool Player::_LoadHomeBind(PreparedQueryResult result)
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (Name %s) has incorrect race/class (%u/%u) pair. Can't be loaded.", GetName(), uint32(getRace()), uint32(getClass()));
        return false;
    }

    bool ok = false;
    // SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
    if (result)
    {
        Field* fields = result->Fetch();

        m_homebindMapId = fields[0].GetUInt16();
        m_homebindAreaId = fields[1].GetUInt16();
        m_homebindX = fields[2].GetFloat();
        m_homebindY = fields[3].GetFloat();
        m_homebindZ = fields[4].GetFloat();

        MapEntry const* bindMapEntry = sMapStore.LookupEntry(m_homebindMapId);

        // accept saved data only for valid position (and non instanceable), and accessable
        if (MapManager::IsValidMapCoord(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ) &&
            !bindMapEntry->Instanceable() && GetSession()->Expansion() >= bindMapEntry->Expansion())
            ok = true;
        else
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, GetRealGUIDLow());
            RealmDatabase.Execute(stmt);
        }
    }

    if (!ok)
    {
        m_homebindMapId = info->mapId;
        m_homebindAreaId = info->areaId;
        m_homebindX = info->positionX;
        m_homebindY = info->positionY;
        m_homebindZ = info->positionZ;

        PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt16(1, m_homebindMapId);
        stmt->setUInt16(2, m_homebindAreaId);
        stmt->setFloat (3, m_homebindX);
        stmt->setFloat (4, m_homebindY);
        stmt->setFloat (5, m_homebindZ);
        RealmDatabase.Execute(stmt);
    }

    sLog->outDebug(LOG_FILTER_PLAYER, "Setting player home position - mapid: %u, areaid: %u, X: %f, Y: %f, Z: %f",
        m_homebindMapId, m_homebindAreaId, m_homebindX, m_homebindY, m_homebindZ);

    return true;
}

/*********************************************************/
/***                   SAVE SYSTEM                     ***/
/*********************************************************/
void Player::SaveToDB(bool create /*=false*/, bool logout /*=false*/, MS::Utilities::CallBackPtr p_Callback)
{
#ifdef CROSS
    if (!PlayOnCross())
        return;
#endif

#ifndef CROSS
    if (GetSession()->GetInterRealmBG())
        return;
#endif

    //lets allow only players in world to be saved
    if (IsBeingTeleportedFar() || GetSession()->PlayerLoading())
    {
        ScheduleDelayedOperation(DELAYED_SAVE_PLAYER);
        return;
    }

    // delay auto save at any saves (manual, in code, or autosave)
    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    // first save/honor gain after midnight will also update the player's honor fields
    UpdateHonorFields();

    sLog->outDebug(LOG_FILTER_UNITS, "The value of player %s at save: ", m_name.c_str());
    outDebugValues();

    PreparedStatement* stmt = NULL;
    uint8 index = 0;

    if (create)
    {
        //! Insert query
        //! TO DO: Filter out more redundant fields that can take their default value at player create
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER);
        stmt->setUInt32(index++, GetRealGUIDLow());
        stmt->setUInt32(index++, GetSession()->GetAccountId());
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetOriginalPlayerData());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_INEBRIATION));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));
        stmt->setUInt16(index++, (uint16)GetMapId());
        stmt->setUInt32(index++, (uint32)GetInstanceId());
        stmt->setUInt8(index++, GetDungeonDifficultyID());
        stmt->setUInt8(index++, GetRaidDifficultyID());
        stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
        stmt->setFloat(index++, finiteAlways(GetPositionX()));
        stmt->setFloat(index++, finiteAlways(GetPositionY()));
        stmt->setFloat(index++, finiteAlways(GetPositionZ()));
        stmt->setFloat(index++, finiteAlways(GetOrientation()));

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());
        stmt->setUInt32(index++, GetPrimarySpecialization());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId(true));
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt64(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(Powers(i), getClass()) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());
        stmt->setUInt8(index++, GetActiveTalentGroup());
        stmt->setUInt32(index++, GetLootSpecId());

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");

        /// Cache equipment...
        for (uint32 l_I = 0; l_I < EquipmentSlots::EQUIPMENT_SLOT_END; ++l_I)
        {
            if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            {
                ss << l_Item->GetVisibleEntry(this) << ' ';
                ss << GetItemDisplayID(l_Item->GetVisibleEntry(this), l_Item->GetVisibleAppearanceModID(this)) << ' ';
                ss << l_Item->GetVisibleItemVisual(this) << ' ';
            }
            else
                ss << "0 0 0 ";
        }

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';

            ss << " 0";
            ss << " 0 ";
        }
        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';
        stmt->setString(index++, ss.str());

        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES));
        stmt->setUInt8(index++, m_currentPetSlot);
        stmt->setUInt32(index++, m_grantableLevels);
        stmt->setUInt32(index++, m_LastSummonedBattlePet);
        stmt->setFloat(index++, m_PersonnalXpRate);
        stmt->setUInt32(index++, GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::EquippedAvgItemLevel));
        stmt->setBool(index++, IsBackPackAutoSortDisabled());
    }
    else
    {
        // Update query
        stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetOriginalPlayerData());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_INEBRIATION));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));

#ifndef CROSS
        uint16 l_MapID = IsInDraenorGarrison() ? MS::Garrison::GDraenor::Globals::BaseMap : (IsBeingTeleported() ? GetTeleportDest().GetMapId() : GetMapId());
#else
        uint16 l_MapID = (IsBeingTeleported() ? GetTeleportDest().GetMapId() : GetMapId());
#endif

        if (!IsBeingTeleported())
        {
            stmt->setUInt16(index++, (uint16)l_MapID);
            stmt->setUInt32(index++, (uint32)GetInstanceId());
            stmt->setUInt8(index++, GetDungeonDifficultyID());
            stmt->setUInt8(index++, GetRaidDifficultyID());
            stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
            stmt->setFloat(index++, finiteAlways(GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetOrientation()));
        }
        else
        {
            stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
            stmt->setUInt32(index++, (uint32)0);
            stmt->setUInt8(index++, GetDungeonDifficultyID());
            stmt->setUInt8(index++, GetRaidDifficultyID());
            stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
        }

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());
        stmt->setUInt32(index++, GetPrimarySpecialization());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId());
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt64(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(Powers(i), getClass()) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());
        stmt->setUInt8(index++, GetActiveTalentGroup());
        stmt->setUInt32(index++, GetLootSpecId());

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");

        /// Cache equipment...
        for (uint32 l_I = 0; l_I < EquipmentSlots::EQUIPMENT_SLOT_END; ++l_I)
        {
            if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            {
                ss << l_Item->GetVisibleEntry(this) << ' ';
                ss << GetItemDisplayID(l_Item->GetVisibleEntry(this), l_Item->GetVisibleAppearanceModID(this)) << ' ';
                ss << l_Item->GetVisibleItemVisual(this) << ' ';
            }
            else
                ss << "0 0 0 ";
        }

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';
            ss << " 0";
            ss << " 0 ";
        }

        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';

        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_NUM_RESPECS, PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES));
        stmt->setUInt8(index++, m_currentPetSlot);
        stmt->setUInt32(index++, m_grantableLevels);

        stmt->setUInt8(index++, IsInWorld() ? 1 : 0);

        stmt->setUInt32(index++, m_LastSummonedBattlePet);

        stmt->setFloat(index++, m_PersonnalXpRate);
        stmt->setUInt32(index++, GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::EquippedAvgItemLevel));
        stmt->setBool(index++, IsBackPackAutoSortDisabled());

        // Index
        stmt->setUInt32(index++, GetRealGUIDLow());
    }

    SQLTransaction trans = RealmDatabase.BeginTransaction();
    SQLTransaction accountTrans = LoginDatabase.BeginTransaction();

    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_OR_UPD_CHARACTER_SELL_DATA);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt32(1, GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::EquippedAvgItemLevel));
    stmt->setUInt32(2, ComputeSellPrice());
    stmt->setUInt32(3, getClass());
    stmt->setUInt32(4, GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::EquippedAvgItemLevel));
    stmt->setUInt32(5, ComputeSellPrice());
    trans->Append(stmt);

    if (m_Garrison)
        m_Garrison->Save();

    if (m_mailsUpdated)                                     //save mails only when needed
        _SaveMail(trans);

    _SaveArenaData(trans);
    _SaveBGData(trans);
    _SaveInventory(trans);
    _SaveVoidStorage(trans);
    _SaveQuestStatus(trans, accountTrans);
    _SaveQuestObjectiveStatus(trans);
    _SaveDailyQuestStatus(trans);
    _SaveWeeklyQuestStatus(trans);
    _SaveSeasonalQuestStatus(trans);
    _SaveMonthlyQuestStatus(trans);
    _SaveGlyphs(trans);
    _SaveTalents(trans);
    _SavePvPTalents(trans);
    _SaveSpells(trans, accountTrans);
    _SaveSpellCooldowns(trans);
    _SaveChargesCooldowns(trans);
    _SaveActions(trans);
    _SaveAuras(trans);
    _SaveSkills(trans);
    m_achievementMgr->SaveToDB(accountTrans, trans);
    m_reputationMgr.SaveToDB(trans);
    m_reputationMgr.SaveReputationMods(trans);
    _SaveEquipmentSets(trans);
    GetSession()->SaveTutorialsData(trans);                 // changed only while character in game
    _SaveInstanceTimeRestrictions(trans);
    _SaveCurrency(trans);
    _SaveCurrencyCaps(trans);
    m_archaeologyMgr.SaveArchaeology(trans);
    _SaveCharacterWorldStates(trans);
    _SavePvpInfo(trans);
    _SavePersonalInstanceLockouts(trans);
    _SaveLegendaries(trans);
    _SaveNomiRecipes(trans);

    GetSession()->GetCollectionMgr()->SaveAccountItemAppearances(accountTrans);

    _SaveCharacterGarrisonDailyTavernDatas(trans);
    _SaveCharacterGarrisonWeeklyTavernDatas(trans);

    for (auto l_Artifact : m_ArtifactMgrHolder)
        l_Artifact.second->SaveToDB(trans);

    // check if stats should only be saved on logout
    // save stats can be out of transaction
    if (m_session->isLogingOut() || !sWorld->getBoolConfig(CONFIG_STATS_SAVE_ONLY_ON_LOGOUT))
        _SaveStats(trans);

    for (std::vector<BattlePet::Ptr>::iterator l_It = m_BattlePets->begin(); l_It != m_BattlePets->end(); ++l_It)
    {
        BattlePet::Ptr l_Pet = (*l_It);
        l_Pet->Save(accountTrans);
    }

    m_WorldQuestMgr->SaveToDB(trans);

    /// Disable to force the realm selection at login since the button "change realm" isn't working yet
    /*stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_LAST_PLAYED_CHARACTER);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt32(1, g_RealmID);
    accountTrans->Append(stmt);

    stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_LAST_PLAYED_CHARACTER);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt8(1, 0);
    stmt->setUInt8(2, 0);
    stmt->setUInt32(3, g_RealmID);
    stmt->setString(4, GetName());
    stmt->setUInt64(5, GetGUIDLow());
    stmt->setUInt32(6, time(nullptr));
    accountTrans->Append(stmt);*/

    RealmDatabase.CommitTransaction(trans, sWorld->GetQueryCallbackMgr(), p_Callback);
    LoginDatabase.CommitTransaction(accountTrans);

    // we save the data here to prevent spamming
    sAnticheatMgr->SavePlayerData(this);

    // save pet (hunter pet level and experience and all type pets health/mana).
    if (Pet* pet = GetPet())
        pet->SavePetToDB(PET_SLOT_ACTUAL_PET_SLOT, pet->m_Stampeded, logout);
}

// fast save function for item/money cheating preventing - save only inventory and money state
void Player::SaveInventoryAndGoldToDB(SQLTransaction& trans)
{
    _SaveInventory(trans);
    _SaveCurrency(trans);
    _SaveVoidStorage(trans);
    SaveGoldToDB(trans);
}

void Player::SaveGoldToDB(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
    stmt->setUInt64(0, GetMoney());
    stmt->setUInt32(1, GetRealGUIDLow());
    trans->Append(stmt);
}

void Player::SaveSpells()
{
    SQLTransaction l_Trans = CharacterDatabase.BeginTransaction();
    SQLTransaction l_AccountTrans = LoginDatabase.BeginTransaction();

    _SaveSpells(l_Trans, l_AccountTrans);

    CharacterDatabase.CommitTransaction(l_Trans);
    LoginDatabase.CommitTransaction(l_AccountTrans);
};

void Player::_SaveActions(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
    {
        switch (itr->second.uState)
        {
            case ACTIONBUTTON_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt8(1, GetActiveTalentGroup());
                stmt->setUInt8(2, itr->first);
                stmt->setUInt32(3, itr->second.GetAction());
                stmt->setUInt8(4, uint8(itr->second.GetType()));
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
                stmt->setUInt32(0, itr->second.GetAction());
                stmt->setUInt8(1, uint8(itr->second.GetType()));
                stmt->setUInt32(2,  GetRealGUIDLow());
                stmt->setUInt8(3, itr->first);
                stmt->setUInt8(4, GetActiveTalentGroup());
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_DELETED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt8(1, itr->first);
                stmt->setUInt8(2, GetActiveTalentGroup());
                trans->Append(stmt);

                m_actionButtons.erase(itr++);
                break;
            default:
                ++itr;
                break;
        }
    }
}

void Player::_SaveAuras(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);
    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
    {
        if (!itr->second->CanBeSaved())
            continue;

        Aura* aura = itr->second;
        AuraApplication * foundAura = GetAuraApplication(aura->GetId(), aura->GetCasterGUID(), aura->GetCastItemGUID());

        if (!foundAura)
            continue;


        uint8 index = 0;
        int32 damage[SpellEffIndex::MAX_EFFECTS];
        int32 baseDamage[SpellEffIndex::MAX_EFFECTS];
        uint32 effMask = 0;
        uint32 recalculateMask = 0;
        for (uint8 i = 0; i < aura->GetEffectCount(); ++i)
        {
            if (AuraEffect const* effect = aura->GetEffect(i))
            {
                index = 0;
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_AURA_EFFECT);
                stmt->setUInt32(index++, GetRealGUIDLow());
                stmt->setUInt8(index++, foundAura->GetSlot());
                stmt->setUInt8(index++, i);
                stmt->setInt32(index++, effect->GetBaseAmount());
                stmt->setInt32(index++, effect->GetAmount());

                trans->Append(stmt);

                baseDamage[i] = effect->GetBaseAmount();
                damage[i] = effect->GetAmount();
                effMask |= 1 << i;
                if (effect->CanBeRecalculated())
                    recalculateMask |= 1 << i;
            }
            else
            {
                baseDamage[i] = 0;
                damage[i] = 0;
            }
        }

        index = 0;
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_AURA);
        stmt->setUInt32(index++, GetRealGUIDLow());
        stmt->setUInt8(index++, foundAura->GetSlot());
        stmt->setUInt64(index++, itr->second->GetCasterGUID());
        stmt->setUInt64(index++, itr->second->GetCastItemGUID());
        stmt->setUInt32(index++, itr->second->GetId());
        stmt->setUInt32(index++, effMask);
        stmt->setUInt32(index++, recalculateMask);
        stmt->setUInt8(index++, itr->second->GetStackAmount());
        stmt->setInt32(index++, itr->second->GetMaxDuration());
        stmt->setInt32(index++, itr->second->GetDuration());
        stmt->setUInt8(index++, itr->second->GetCharges());
        stmt->setInt32(index++, aura->GetCastItemLevel());
        trans->Append(stmt);
    }
}

void Player::_SaveInventory(SQLTransaction& trans)
{
    // force items in buyback slots to new state
    // and remove those that aren't already
    for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
    {
        Item* item = m_items[i];
        if (!item || item->GetState() == ITEM_NEW)
            continue;

        sLog->outAshran("_SaveInventory: delete item entry %u guidlow %u owner %u", item->GetEntry(), item->GetRealGUIDLow(), GetGUIDLow());

        trans->PAppend("DELETE FROM character_inventory WHERE item = %u", item->GetRealGUIDLow());
        trans->PAppend("DELETE FROM item_instance WHERE guid = %u", item->GetRealGUIDLow());

        m_items[i]->FSetState(ITEM_NEW);
    }

    // Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
    // the client auto counts down in real time after having received the initial played time on the first
    // SMSG_SET_ITEM_PURCHASE_DATA packet.
    // Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
    std::set<uint32>::iterator i_next;
    for (std::set<uint32>::iterator itr = m_refundableItems.begin(); itr!= m_refundableItems.end(); itr = i_next)
    {
        // use copy iterator because itr may be invalid after operations in this loop
        i_next = itr;
        ++i_next;

        Item* iPtr = GetItemByGuid(MAKE_NEW_GUID(*itr, 0, HIGHGUID_ITEM));
        if (iPtr)
        {
            iPtr->UpdatePlayedTime(this);
            continue;
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Can't find item guid %u but is in refundable storage for player %u ! Removing.", *itr, GetGUIDLow());
            m_refundableItems.erase(itr);
        }
    }

    // update enchantment durations
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);

    // if no changes
    if (m_itemUpdateQueue.empty())
        return;

    uint32 lowGuid = GetRealGUIDLow();
    for (size_t i = 0; i < m_itemUpdateQueue.size(); ++i)
    {
        Item* item = m_itemUpdateQueue[i];
        if (!item)
            continue;

        Bag* container = item->GetContainer();
        uint32 bag_guid = container ? container->GetRealGUIDLow() : 0;

        if (item->GetState() != ITEM_REMOVED)
        {
            Item* test = GetItemByPos(item->GetBagSlot(), item->GetSlot());
            if (test == NULL)
            {
                uint32 bagTestGUID = 0;
                if (Item* test2 = GetItemByPos(INVENTORY_SLOT_BAG_0, item->GetBagSlot()))
                    bagTestGUID = test2->GetRealGUIDLow();
                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
                // according to the test that was just performed nothing should be in this slot, delete

                trans->PAppend("DELETE FROM character_inventory WHERE bag=%u AND slot=%u AND guid=%u", bagTestGUID, item->GetSlot(), lowGuid);

                // also THIS item should be somewhere else, cheat attempt
                item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue

                if (item->GetEntry() == 138019)
                    sLog->outAshran("Item: SetState ITEM_REMOVED for 138019 (6)");
                DeleteRefundReference(item->GetGUIDLow());
                // don't skip, let the switch delete it
                //continue;
            }
            else if (test != item)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u are incorrect, the item with guid %u is there instead!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), test->GetGUIDLow());
                // save all changes to the item...
                if (item->GetState() != ITEM_NEW) // only for existing items, no dupes
                    item->SaveToDB(trans);
                // ...but do not save position in inventory
                continue;
            }
        }

        switch (item->GetState())
        {
            case ITEM_NEW:
            case ITEM_CHANGED:
                trans->PAppend("REPLACE INTO character_inventory (guid, bag, slot, item) VALUES ('%u', '%u', '%u', '%u')", lowGuid, bag_guid, item->GetSlot(), item->GetRealGUIDLow());
                break;
            case ITEM_REMOVED:
                trans->PAppend("DELETE FROM character_inventory WHERE item = '%u'", item->GetRealGUIDLow());
                break;
            case ITEM_UNCHANGED:
                break;
        }

        item->SaveToDB(trans);                                   // item have unchanged inventory record and can be save standalone
    }
    m_itemUpdateQueue.clear();
}

void Player::_SaveVoidStorage(SQLTransaction& trans)
{
    if (!m_VoidStorageLoaded)
        return;

    PreparedStatement* stmt = NULL;
    uint32 lowGuid = GetRealGUIDLow();

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i]) // unused item
        {
            if (_voidStorageItems[i]->deleted)
            {
                // DELETE FROM void_storage WHERE ItemId = ?
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM);
                stmt->setUInt32(0, _voidStorageItems[i]->ItemId);
                trans->Append(stmt);

                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM_BY_SLOT);
                stmt->setUInt8(0, i);
                stmt->setUInt32(1, lowGuid);

                delete _voidStorageItems[i];
                _voidStorageItems[i] = NULL;
                continue;
            }

            if (!_voidStorageItems[i]->change)
                continue;

            // REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
            stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_VOID_STORAGE_ITEM);
            stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
            stmt->setUInt32(1, lowGuid);
            stmt->setUInt32(2, _voidStorageItems[i]->ItemEntry);
            stmt->setUInt8(3, i);
            stmt->setUInt32(4, _voidStorageItems[i]->CreatorGuid);
            stmt->setUInt32(5, _voidStorageItems[i]->ItemRandomPropertyId);
            stmt->setUInt32(6, _voidStorageItems[i]->ItemSuffixFactor);

            std::ostringstream l_Bonuses;

            for (uint32 l_I = 0; l_I < _voidStorageItems[i]->Bonuses.size(); l_I++)
            {
                if (_voidStorageItems[i])
                    l_Bonuses << _voidStorageItems[i]->Bonuses[l_I] << ' ';
            }

            stmt->setString(7, l_Bonuses.str());
            stmt->setUInt32(8, _voidStorageItems[i]->CustomFlags);
            trans->Append(stmt);
        }
    }
}

void Player::_SaveMail(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        Mail* m = (*itr);
        if (m->state == MAIL_STATE_CHANGED)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
            stmt->setUInt32(1, uint32(m->expire_time));
            stmt->setUInt32(2, uint32(m->deliver_time));
            stmt->setUInt64(3, m->money);
            stmt->setUInt64(4, m->COD);
            stmt->setUInt8(5, uint8(m->checked));
            stmt->setUInt32(6, m->messageID);

            trans->Append(stmt);

            if (!m->removedItems.empty())
            {
                for (std::vector<uint32>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
                    stmt->setUInt32(0, *itr2);
                    trans->Append(stmt);
                }
                m->removedItems.clear();
            }
            m->state = MAIL_STATE_UNCHANGED;
        }
        else if (m->state == MAIL_STATE_DELETED)
        {
            if (m->HasItems())
            {
                PreparedStatement* stmt = NULL;
                for (MailItemInfoVec::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                    stmt->setUInt32(0, itr2->item_guid);
                    trans->Append(stmt);
                    sLog->outAshran("Player::_SaveMail delete item %u", itr2->item_guid);
                }
            }
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);
        }
    }

    //deallocate deleted mails...
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end();)
    {
        if ((*itr)->state == MAIL_STATE_DELETED)
        {
            Mail* m = *itr;
            m_mail.erase(itr);
            delete m;
            itr = m_mail.begin();
        }
        else
            ++itr;
    }

    m_mailsUpdated = false;
}

void Player::_SaveQuestStatus(SQLTransaction& trans, SQLTransaction& p_AuthTrans)
{
    bool isTransaction = trans.get() != nullptr;
    if (!isTransaction)
        trans = RealmDatabase.BeginTransaction();

    bool l_IsAuthTransaction = p_AuthTrans.get() != nullptr;
    if (!l_IsAuthTransaction)
        p_AuthTrans = LoginDatabase.BeginTransaction();

    QuestStatusSaveMap::iterator saveItr;
    QuestStatusMap::iterator statusItr;
    PreparedStatement* stmt = NULL;

#ifndef CROSS
    bool keepAbandoned = !(sWorld->GetCleaningFlags() & CharacterDatabaseCleaner::CLEANING_FLAG_QUESTSTATUS);
#else
    bool keepAbandoned = true;
#endif

    for (saveItr = m_QuestStatusSave.begin(); saveItr != m_QuestStatusSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            statusItr = m_QuestStatus.find(saveItr->first);
            if (statusItr == m_QuestStatus.end())
                continue;

            if (sObjectMgr->IsAreaTaskQuest(statusItr->first))
                continue;

            MS::WorldQuest::Template const* l_Template = MS::WorldQuest::Template::GetTemplate(statusItr->first);
            if (l_Template != nullptr && l_Template->GetWorldQuestType() != MS::WorldQuest::WorldQuestType::Bounty)
            {
                if (MS::WorldQuest::Template::GetAreaGroupMap().find(statusItr->first) != MS::WorldQuest::Template::GetAreaGroupMap().end())
                    continue;
            }

            if (statusItr != m_QuestStatus.end() && (keepAbandoned || statusItr->second.Status != QUEST_STATUS_NONE))
            {
                uint8 index = 0;
                stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);
                stmt->setUInt32(index++, GetRealGUIDLow());
                stmt->setUInt32(index++, statusItr->first);
                stmt->setUInt8(index++, uint8(statusItr->second.Status));
                stmt->setBool(index++, statusItr->second.Explored);
                stmt->setUInt32(index++, uint32(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()));

                trans->Append(stmt);
            }
        }
        else
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);

        }
        else if (!keepAbandoned)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    for (saveItr = m_AccountRewardedQuestsSave.begin(); saveItr != m_AccountRewardedQuestsSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_QUEST_REWARDED);
            stmt->setUInt32(0, GetSession()->GetAccountId());
            stmt->setUInt32(1, saveItr->first);
            p_AuthTrans->Append(stmt);

        }
        else if (!keepAbandoned)
        {
            stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_ACCOUNT_QUEST_REWARDED);
            stmt->setUInt32(0, GetSession()->GetAccountId());
            stmt->setUInt32(1, saveItr->first);
            p_AuthTrans->Append(stmt);
        }
    }

    m_RewardedQuestsSave.clear();
    m_AccountRewardedQuestsSave.clear();

    if (!isTransaction)
        CharacterDatabase.CommitTransaction(trans);

    if (!l_IsAuthTransaction)
        LoginDatabase.CommitTransaction(p_AuthTrans);
}

void Player::_SaveQuestObjectiveStatus(SQLTransaction& trans)
{
    for (QuestObjectiveStatusMap::const_iterator citr = m_questObjectiveStatus.begin(); citr != m_questObjectiveStatus.end(); citr++)
    {
        uint32 questId = sObjectMgr->GetQuestObjectiveQuestId(citr->first);
        if (!questId)
            continue;

        QuestStatusSaveMap::const_iterator citrSave = m_QuestStatusSave.find(questId);
        if (citrSave == m_QuestStatusSave.end())
            continue;

        if (citrSave->second)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, citr->first);
            stmt->setUInt32(2, citr->second);
            trans->Append(stmt);
        }
        else
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, citr->first);
            trans->Append(stmt);
        }
    }

    m_QuestStatusSave.clear();
}

void Player::_SaveDailyQuestStatus(SQLTransaction& trans)
{
    if (!m_DailyQuestChanged)
        return;

    m_DailyQuestChanged = false;

    // save last daily quest time for all quests: we need only mostly reset time for reset check anyway

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (auto id : m_dailyQuestStorage)
    {
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, id);
        stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
        trans->Append(stmt);
    }

    if (!m_DFQuests.empty())
    {
        for (DFQuestsDoneList::iterator itr = m_DFQuests.begin(); itr != m_DFQuests.end(); ++itr)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, (*itr));
            stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
            trans->Append(stmt);
        }
    }
}

void Player::_SaveWeeklyQuestStatus(SQLTransaction& trans)
{
    if (!m_WeeklyQuestChanged || m_weeklyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_weeklyquests.begin(); iter != m_weeklyquests.end(); ++iter)
    {
        uint32 quest_id  = *iter;

        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WEEKLYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_WeeklyQuestChanged = false;
}

void Player::_SaveSeasonalQuestStatus(SQLTransaction& trans)
{
    if (!m_SeasonalQuestChanged || m_seasonalquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (SeasonalEventQuestMap::const_iterator iter = m_seasonalquests.begin(); iter != m_seasonalquests.end(); ++iter)
    {
        uint16 event_id = iter->first;
        for (SeasonalQuestSet::const_iterator itr = iter->second.begin(); itr != iter->second.end(); ++itr)
        {
            uint32 quest_id = (*itr);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, quest_id);
            stmt->setUInt32(2, event_id);
            trans->Append(stmt);
        }
    }

    m_SeasonalQuestChanged = false;
}

void Player::_SaveMonthlyQuestStatus(SQLTransaction& trans)
{
    if (!m_MonthlyQuestChanged || m_monthlyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_MONTHLY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_monthlyquests.begin(); iter != m_monthlyquests.end(); ++iter)
    {
        uint32 quest_id = *iter;
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_MONTHLYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_MonthlyQuestChanged = false;
}

void Player::_SaveSkills(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // we don't need transactions here.
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
    {
        if (itr->second.uState == SKILL_UNCHANGED)
        {
            ++itr;
            continue;
        }

        if (itr->second.uState == SKILL_DELETED)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, itr->first);
            trans->Append(stmt);

            mSkillStatus.erase(itr++);
            continue;
        }

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1;

        uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

        switch (itr->second.uState)
        {
            case SKILL_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, uint16(itr->first));
                stmt->setUInt16(2, value);
                stmt->setUInt16(3, max);
                trans->Append(stmt);
                break;
            case SKILL_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
                stmt->setUInt16(0, value);
                stmt->setUInt16(1, max);
                stmt->setUInt32(2, GetRealGUIDLow());
                stmt->setUInt16(3, uint16(itr->first));
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.uState = SKILL_UNCHANGED;
        ++itr;
    }
}

#define SKILL_MOUNT     777
#define SKILL_MINIPET   778

void Player::_SaveSpells(SQLTransaction& charTrans, SQLTransaction& accountTrans)
{
#ifndef CROSS
    uint32 l_GroupRealmMask     = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_GROUP_MASK);
#else
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());
    uint32 l_GroupRealmMask     = l_Config->groupRealmMask;
#endif

    uint32 l_ShopGroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_SHOP_GROUP_MASK);
    PreparedStatement* stmt = NULL;

    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end();)
    {
        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
        {
            if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if (GetSession() && ((spell->IsAbilityOfSkillType(SKILL_MOUNT) && !(spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE))
                    || spell->IsAbilityOfSkillType(SKILL_MINIPET))
                    && sWorld->CanBeSaveInLoginDatabase())
                {
                    /*stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_CHAR_SPELL_BY_SPELL);
                    stmt->setUInt32(0, itr->first);
                    stmt->setUInt32(1, GetSession()->GetAccountId());
                    accountTrans->Append(stmt);*/
                }
                else
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
                    stmt->setUInt32(0, itr->first);
                    stmt->setUInt32(1, GetRealGUIDLow());
                    charTrans->Append(stmt);
                }
            }
        }

        /// add only changed/new not dependent spells
        if (!itr->second->dependent && (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED))
        {
            if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if (GetSession() && ((spell->IsAbilityOfSkillType(SKILL_MOUNT) && ((spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE) == 0))
                    || spell->IsAbilityOfSkillType(SKILL_MINIPET)
                    || spell->Id == 191645 || spell->Id == 171840) ///< flying draenor & Coldflame Infernal
                    && sWorld->CanBeSaveInLoginDatabase())
                {
                    stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_CHAR_SPELL);
                    stmt->setUInt32(0, GetSession()->GetAccountId());
                    stmt->setUInt32(1, itr->first);
                    stmt->setBool(2, itr->second->active);
                    stmt->setBool(3, itr->second->disabled);
                    stmt->setBool(4, itr->second->IsMountFavorite);
                    stmt->setUInt32(5, itr->second->FromShopItem ? l_ShopGroupRealmMask : l_GroupRealmMask);
                    stmt->setUInt32(6, itr->second->FromShopItem ? l_ShopGroupRealmMask : l_GroupRealmMask);
                    stmt->setBool(7, itr->second->IsMountFavorite);

                    accountTrans->Append(stmt);
                }
                else
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
                    stmt->setUInt32(0, GetRealGUIDLow());
                    stmt->setUInt32(1, itr->first);
                    stmt->setBool(2, itr->second->active);
                    stmt->setBool(3, itr->second->disabled);
                    stmt->setBool(4, itr->second->IsMountFavorite);
                    charTrans->Append(stmt);
                }
            }
        }

        if (itr->second->state == PLAYERSPELL_REMOVED)
        {
            delete itr->second;
            m_spells.erase(itr++);
        }
        else if (itr->second->state == PLAYERSPELL_TEMPORARY)
            ++itr;
        else
        {
            itr->second->state = PLAYERSPELL_UNCHANGED;
            ++itr;
        }
    }
}

// save player stats -- only for external usage
// real stats will be recalculated on player login
void Player::_SaveStats(SQLTransaction& trans)
{
    // check if stat saving is enabled and if char level is high enough
    if (!sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE))
        return;

    PreparedStatement* stmt = NULL;

    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_STATS);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    uint8 index = 0;

    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_STATS);
    stmt->setUInt32(index++, GetRealGUIDLow());
    stmt->setUInt32(index++, GetMaxHealth());

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        stmt->setUInt32(index++, GetMaxPower(Powers(i)));

    for (uint8 i = 0; i < MAX_STATS; ++i)
        stmt->setUInt32(index++, GetStat(Stats(i)));

    for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
        stmt->setUInt32(index++, GetResistance(SpellSchools(i)));

    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_ATTACK_POWER));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER));
    stmt->setUInt32(index++, GetBaseSpellPowerBonus());
    stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + CR_RESILIENCE_PLAYER_DAMAGE_TAKEN));

    trans->Append(stmt);
}

void Player::_SaveCharacterGarrisonDailyTavernDatas(SQLTransaction& p_Transaction)
{
    auto l_GarrisonMgr = GetDraenorGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GARRISON_DRAENOR_DAILY_TAVERN_DATA_CHAR);
    l_Stmt->setUInt32(0, GetGUIDLow());
    p_Transaction->Append(l_Stmt);

    for (uint32 l_TavernData : l_GarrisonMgr->GetGarrisonDailyTavernDatas())
    {
        l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_ADD_GARRISON_DRAENOR_DAILY_TAVERN_DATA_CHAR);
        l_Stmt->setUInt32(0, GetGUIDLow());
        l_Stmt->setUInt32(1, l_TavernData);
        p_Transaction->Append(l_Stmt);
    }
}

void Player::_SaveCharacterGarrisonWeeklyTavernDatas(SQLTransaction& p_Transaction)
{
    auto l_GarrisonMgr = GetDraenorGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GARRISON_DRAENOR_WEEKLY_TAVERN_DATA_CHAR);
    l_Stmt->setUInt32(0, GetGUIDLow());
    p_Transaction->Append(l_Stmt);

    for (MS::Garrison::WeeklyTavernData l_TavernData : l_GarrisonMgr->GetGarrisonWeeklyTavernDatas())
    {
        l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_ADD_GARRISON_DRAENOR_WEEKLY_TAVERN_DATA_CHAR);
        l_Stmt->setUInt32(0, GetGUIDLow());
        l_Stmt->setUInt32(1, l_TavernData.FollowerID);

        std::ostringstream l_Abilities;

        for (uint32 l_Ability : l_TavernData.Abilities)
        {
            if (l_Ability != l_TavernData.Abilities.back())
                l_Abilities << l_Ability << ' ';
            else
                l_Abilities << l_Ability;
        }

        l_Stmt->setString(2, l_Abilities.str());
        p_Transaction->Append(l_Stmt);
    }
}

void Player::_SaveObjectLockoutDatas(SQLTransaction& p_Transaction)
{
    for (std::unordered_map<uint32, ObjectLockout>::iterator l_Itr = m_ObjectLockout.begin(); l_Itr != m_ObjectLockout.end(); l_Itr++)
    {
        PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_OBJECT_LOCKOUT);
        l_Stmt->setUInt32(0, GetRealGUIDLow());
        l_Stmt->setUInt32(1, l_Itr->first);
        l_Stmt->setUInt32(2, l_Itr->second.QuestId);
        l_Stmt->setBool(3, l_Itr->second.Invisible);
        p_Transaction->Append(l_Stmt);
    }
}

void Player::outDebugValues() const
{
    if (!sLog->ShouldLog(LOG_FILTER_UNITS, LOG_LEVEL_DEBUG))
        return;

    sLog->outDebug(LOG_FILTER_UNITS, "HP is: \t\t\t%lu\t\tMP is: \t\t\t%u", GetMaxHealth(), GetMaxPower(POWER_MANA));
    sLog->outDebug(LOG_FILTER_UNITS, "AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
    sLog->outDebug(LOG_FILTER_UNITS, "STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
    sLog->outDebug(LOG_FILTER_UNITS, "Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
    sLog->outDebug(LOG_FILTER_UNITS, "NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
    sLog->outDebug(LOG_FILTER_UNITS, "ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MIN_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "ATTACK_TIME is: \t%u\t\tRANGE_ATTACK_TIME is: \t%u", GetAttackTime(WeaponAttackType::BaseAttack), GetAttackTime(WeaponAttackType::RangedAttack));
}

/*********************************************************/
/***               FLOOD FILTER SYSTEM                 ***/
/*********************************************************/
void Player::UpdateSpeakTime()
{
    // ignore chat spam protection for GMs in any mode
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        return;

    time_t current = time (NULL);
    if (m_speakTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_COUNT);
        if (!max_count)
            return;

        ++m_speakCount;
        if (m_speakCount >= max_count)
        {
            // prevent overwrite mute time, if message send just before mutes set, for example.
            time_t new_mute = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MUTE_TIME);
            if (GetSession()->m_muteTime < new_mute)
                GetSession()->m_muteTime = new_mute;

            m_speakCount = 0;
        }
    }
    else
        m_speakCount = 0;

    m_speakTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_DELAY);
}

bool Player::UpdatePmChatTime()
{
    // ignore chat spam protection for GMs in any mode
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        return true;

    time_t current = time (NULL);
    if (m_pmChatTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_PRIVATE_MESSAGE_COUNT);
        if (!max_count)
            return true;

        ++m_pmChatCount;
        if (m_pmChatCount >= max_count)
            return false;
    }
    else
        m_pmChatCount = 0;

    m_pmChatTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_PRIVATE_MESSAGE_DELAY);
    return true;
}

bool Player::CanSpeak() const
{
    return  GetSession()->m_muteTime <= time (NULL);
}

/*********************************************************/
/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
/*********************************************************/
void Player::SavePositionInDB(uint32 mapid, float x, float y, float z, float o, uint32 zone, uint64 guid)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);

    stmt->setFloat(0, x);
    stmt->setFloat(1, y);
    stmt->setFloat(2, z);
    stmt->setFloat(3, o);
    stmt->setUInt16(4, uint16(mapid));
    stmt->setUInt16(5, uint16(zone));
    stmt->setUInt32(6, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
#endif
}

void Player::SetUInt32ValueInArray(Tokenizer& tokens, uint16 index, uint32 /*value*/)
{
    char buf[11];

    if (index >= tokens.size())
        return;

    tokens[index] = buf;
}

void Player::Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair, std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> const& p_CustomDisplay)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);

    stmt->setUInt8(0, gender);
    stmt->setUInt32(1, skin | (face << 8) | (hairStyle << 16) | (hairColor << 24));
    stmt->setUInt32(2, p_CustomDisplay[0] | (p_CustomDisplay[1] << 8) | (p_CustomDisplay[2] << 16) | (facialHair << 24));
    stmt->setUInt32(3, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
#endif
}

void Player::SendAttackSwingError(AttackSwingError p_Error)
{
    WorldPacket l_Data(SMSG_ATTACK_SWING_ERROR, 1);
    l_Data.WriteBits(p_Error, 2);
    l_Data.FlushBits();

    GetSession()->SendPacket(&l_Data);
}

void Player::SendAttackSwingCancelAttack()
{
    WorldPacket data(SMSG_CANCEL_COMBAT, 0);
    GetSession()->SendPacket(&data);
}

void Player::SendAutoRepeatCancel(Unit* p_Target)
{
    WorldPacket l_Data(SMSG_CANCEL_AUTO_REPEAT);
    l_Data.appendPackGUID(p_Target->GetGUID());
    GetSession()->SendPacket(&l_Data);
}

void Player::SendExplorationExperience(uint32 Area, uint32 Experience)
{
    WorldPacket data(SMSG_EXPLORATION_EXPERIENCE, 8);
    data << uint32(Area);
    data << uint32(Experience);
    GetSession()->SendPacket(&data);
}

void Player::SendDungeonDifficulty(int32 p_ForcedDifficulty /*= -1*/)
{
    WorldPacket data(SMSG_SET_DUNGEON_DIFFICULTY, 4);
    data << uint32(p_ForcedDifficulty == -1 ? GetDungeonDifficultyID() : p_ForcedDifficulty);
    GetSession()->SendPacket(&data);
}

void Player::SendRaidDifficulty(bool p_Legacy, int32 forcedDifficulty)
{
    WorldPacket data(SMSG_SET_RAID_DIFFICULTY, 4 + 1);
    data << uint32(forcedDifficulty == -1 ? (p_Legacy ? GetLegacyRaidDifficultyID () : GetRaidDifficultyID()) : forcedDifficulty);
    data << uint8(p_Legacy);
    GetSession()->SendPacket(&data);
}

void Player::SendResetFailedNotify()
{
    WorldPacket data(SMSG_RESET_FAILED_NOTIFY);
    GetSession()->SendPacket(&data);
}

/// Reset all solo instances and optionally send a message on success for each
void Player::ResetInstances(uint8 method, bool isRaid, bool isLegacy)
{
    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN

    // we assume that when the difficulty changes, all instances that can be reset will be
    Difficulty diff = GetDungeonDifficultyID();
    if (isRaid)
    {
        if (!isLegacy)
            diff = GetRaidDifficultyID();
        else
            diff = GetLegacyRaidDifficultyID();
    }

    MapChallengeModeEntry const* l_MapChallenge = nullptr;
    MapChallengeModeEntryContainer const & l_ChallengeDungeons = *GetLegionChallengeModeEntries();

    m_boundInstances[diff].safe_foreach(false, [&](BoundInstancesMap::iterator* p_Itr) -> void
    {
        InstanceSavePtr p = (*p_Itr)->second->save;
        const MapEntry* entry = sMapStore.LookupEntry((*p_Itr)->first);
        if (!entry || entry->IsRaid() != isRaid || !p->CanReset())
        {
            ++(*p_Itr);
            return;
        }

        if (method == INSTANCE_RESET_ALL)
        {
            // the "reset all instances" method can only reset normal maps
            if (entry->instanceType == MAP_RAID || diff == DifficultyRaidHeroic)
            {
                ++(*p_Itr);
                return;
            }
        }

        // if the map is loaded, reset it
        Map* map = sMapMgr->FindMap(p->GetMapId(), p->GetInstanceId());
        if (map && map->IsDungeon())
        {
            if (!((InstanceMap*)map)->Reset(method))
            {
                ++(*p_Itr);
                return;
            }
        }

        // since this is a solo instance there should not be any players inside
        if (method == INSTANCE_RESET_ALL || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
            SendResetInstanceSuccess(p->GetMapId());

        p->DeleteFromDB();
        m_boundInstances[diff].erase((*p_Itr)++);

        // the following should remove the instance save from the manager and delete it as well
        p->RemovePlayer(this);
    });
}

void Player::SendResetInstanceSuccess(uint32 p_MapID)
{
    WorldPacket data(SMSG_INSTANCE_RESET, 4);
    data << uint32(p_MapID);
    GetSession()->SendPacket(&data);
}

void Player::SendResetInstanceFailed(ResetFailedReason p_Reason, uint32 p_MapID)
{
    /*reasons for instance reset failure:
    // 0: There are players inside the instance.
    // 1: There are players offline in your party.
    // 2>: There are players in your party attempting to zone into an instance.
    */
    WorldPacket data(SMSG_INSTANCE_RESET_FAILED);
    data << uint32(p_MapID);
    data.WriteBits(p_Reason, 2);
    GetSession()->SendPacket(&data);
}

/*********************************************************/
/***              Update timers                        ***/
/*********************************************************/
///checks the 15 afk reports per 5 minutes limit
void Player::UpdateAfkReport(time_t currTime)
{
    if (m_bgData.bgAfkReportedTimer <= currTime)
    {
        m_bgData.bgAfkReportedCount = 0;
        m_bgData.bgAfkReportedTimer = currTime+5*MINUTE;
    }
}

void Player::UpdateContestedPvP(uint32 diff)
{
    if (!m_contestedPvPTimer||isInCombat())
        return;
    if (m_contestedPvPTimer <= diff)
    {
        ResetContestedPvP();
    }
    else
        m_contestedPvPTimer -= diff;
}

void Player::UpdatePvPFlag(time_t currTime)
{
    if (!IsPvP() || InBattleground() || InArena())
        return;
    if (pvpInfo.endTimer == 0 || currTime < (pvpInfo.endTimer + 300) || pvpInfo.inHostileArea)
        return;

    UpdatePvP(false);
}

void Player::UpdateDuelFlag(time_t currTime)
{
    if (!m_Duel || m_Duel->startTimer == 0 ||currTime < m_Duel->startTimer + 3)
        return;

    sScriptMgr->OnPlayerDuelStart(this, m_Duel->opponent);

    if (sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
        RemoveAllSpellCooldown();
        if (m_Duel->opponent != nullptr)
            m_Duel->opponent->RemoveAllSpellCooldown();
    }

    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 1);
    m_Duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 2);

    // cleanup combo points
    ClearComboPoints();
    m_Duel->opponent->ClearComboPoints();

    m_Duel->startTimer = 0;
    m_Duel->startTime  = currTime;
    m_Duel->started    = true;
    m_Duel->opponent->m_Duel->startTimer = 0;
    m_Duel->opponent->m_Duel->startTime  = currTime;
    m_Duel->opponent->m_Duel->started    = true;
}

Pet* Player::GetPet() const
{
    if (uint64 pet_guid = GetPetGUID())
    {
        if (!IS_PET_GUID(pet_guid))
            return NULL;

        Pet* pet = ObjectAccessor::GetPet(*this, pet_guid);

        if (!pet)
            return NULL;

        if (IsInWorld() && pet)
            return pet;
    }

    return NULL;
}

void Player::RemovePet(Pet* pet, PetSlot mode, bool returnreagent, bool stampeded)
{
    if (!pet)
        pet = GetPet();

    if (pet)
    {
        sLog->outDebug(LOG_FILTER_PETS, "RemovePet %u, %u, %u", pet->GetEntry(), mode, returnreagent);

        if (pet->m_removed)
            return;
    }

    if (!pet || pet->GetOwnerGUID() != GetGUID())
        return;

    if (mode == PET_SLOT_ACTUAL_PET_SLOT)
        mode = PetSlot(pet->GetSlot());

    pet->CombatStop();
    // only if current pet in slot
    pet->SavePetToDB(mode, stampeded);

    if (pet->getPetType() != HUNTER_PET)
        SetMinion(pet, false, PET_SLOT_UNK_SLOT, stampeded);
    else
        SetMinion(pet, false, PET_SLOT_ACTUAL_PET_SLOT, stampeded);

    pet->AddObjectToRemoveList();
    pet->m_removed = true;

    if (pet->isControlled() && !stampeded)
    {
        SendRemoveControlBar();
        if (GetGroup())
            SetGroupUpdateFlag(GROUP_UPDATE_PET);
    }

    // Kindred Spirits
    if (HasAura(56315))
        pet->RemoveAura(56315);

    if (Unit* l_Owner = pet->GetOwner())
    {
        if (Player* l_Player = l_Owner->ToPlayer())
        {
            // Soul Link
            if (l_Player->HasSpell(108415))
            {
                l_Player->RemoveAura(108446);
                pet->RemoveAura(108446);
            }

            /// Override Command Demon
            if (l_Player->HasAura(119904))
                l_Player->RemoveAura(119904);
        }
    }
}

void Player::StopCastingCharm()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    if (charm->GetTypeId() == TYPEID_UNIT)
    {
        if (charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET))
            ((Puppet*)charm)->UnSummon();
#ifndef CROSS
        else if (charm->IsVehicle())
            ExitVehicle();
#endif
    }

#ifdef CROSS
    if (charm->IsVehicle())
    {
        /// Prevent exit vehicle at map switch
        if (GetMapSwitchDestination() != -1 && charm->GetTypeId() == TYPEID_UNIT)
        {
            uint32 l_ZoneId = sMapMgr->GetZoneId(GetMapSwitchDestination(), GetPositionX(), GetPositionY(), GetPositionZ());
            Map* l_NewMap   = sMapMgr->CreateMap(GetMapSwitchDestination(), l_ZoneId, this);

            if (l_NewMap && l_NewMap->CanEnter(this))
            {
                charm->SetMapSwitchDestination(GetMapSwitchDestination());
                charm->ToCreature()->SetLockAI(true);
                charm->ToCreature()->FarTeleportTo(l_NewMap, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                charm->ToCreature()->SetLockAI(false);
                charm->SetMapSwitchDestination(-1);

                return;
            }
        }

        ExitVehicle();
    }
#endif

    if (GetCharmGUID())
        charm->RemoveCharmAuras();

    if (GetCharmGUID())
    {
        sLog->outFatal(LOG_FILTER_PLAYER, "Player %s (GUID: " UI64FMTD " is not able to uncharm unit (GUID: " UI64FMTD " Entry: %u, Type: %u)", GetName(), GetGUID(), GetCharmGUID(), charm->GetEntry(), charm->GetTypeId());
        if (charm->GetCharmerGUID())
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Charmed unit has charmer guid " UI64FMTD, charm->GetCharmerGUID());
            ASSERT(false);
        }
        else
            SetCharm(charm, false);
    }
}

void Player::BuildPlayerChat(WorldPacket* p_Data, uint64 p_TargetGuid, uint8 p_SlashCmd, std::string const& p_ChatText, uint32 p_Language, char const* p_Prefix /*= nullptr*/, std::string const& p_Channel /*= ""*/) const
{
    uint32 l_TargetVirtualAddress = g_RealmID;
    uint32 l_SenderVirtualAddress = g_RealmID;

    uint32 l_SenderName = strlen(GetName());
    uint32 l_TargetName = 0; ///< NYI

    bool l_HideChatLog = false;
    bool l_FakeSenderName = false;

    GroupPtr l_Group = GetGroup();

    uint64 l_GuildGuid = const_cast<Player*>(this)->GetGuild() ? const_cast<Player*>(this)->GetGuild()->GetGUID() : 0;

    p_Data->Initialize(SMSG_CHAT, 800);
    *p_Data << uint8(p_SlashCmd);
    *p_Data << uint8(p_Language);
    p_Data->appendPackGUID(GetGUID());                              ///< SenderGUID
    p_Data->appendPackGUID(l_GuildGuid);                            ///< SenderGuildGUID
    p_Data->appendPackGUID(0);                                      ///< WowAccountGUID
    p_Data->appendPackGUID(p_TargetGuid);                           ///< TargetGUID
    *p_Data << uint32(l_TargetVirtualAddress);                      ///< TargetVirtualAddress
    *p_Data << uint32(l_SenderVirtualAddress);                      ///< SenderVirtualAddress
    p_Data->appendPackGUID(l_Group ? l_Group->GetGUID() : 0); ///< PartyGUID
    *p_Data << uint32(0);                                           ///< AchievementID
    *p_Data << float(0);                                            ///< DisplayTime

    p_Data->WriteBits(l_SenderName, 11);                            ///< SenderName
    p_Data->WriteBits(l_TargetName, 11);                            ///< TargetName
    p_Data->WriteBits(p_Prefix ? strlen(p_Prefix) : 0, 5);          ///< Prefix
    p_Data->WriteBits(p_Channel.length(), 7);                       ///< Channel
    p_Data->WriteBits(p_ChatText.length(), 12);                     ///< ChatText
    p_Data->WriteBits(GetChatTag(), 11);                            ///< ChatFlags
    p_Data->WriteBit(l_HideChatLog);                                ///< HideChatLog
    p_Data->WriteBit(l_FakeSenderName);                             ///< FakeSenderName
    p_Data->FlushBits();

    p_Data->WriteString(GetName());                                 ///< SenderName
    /// @todo715 p_Data->WriteString();                             ///< TargetName
    p_Data->WriteString(p_Prefix ? p_Prefix : "");                  ///< Prefix
    p_Data->WriteString(p_Channel);                                 ///< Channel
    p_Data->WriteString(p_ChatText);                                ///< ChatText
}

void Player::Say(std::string const& p_Text, uint32 const p_LangID)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, p_LangID, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (PlayerSocial* l_Social = l_Target->GetSocial())
        {
            if (l_Social->HasIgnore(GUID_LOPART(GetGUID())))
                continue;
        }

        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_SAY, l_Text, p_LangID);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::Yell(std::string const& p_Text, uint32 const p_LangID)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_YELL, p_LangID, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (PlayerSocial* l_Social = l_Target->GetSocial())
        {
            if (l_Social->HasIgnore(GUID_LOPART(GetGUID())))
                continue;
        }

        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_YELL, l_Text, p_LangID);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::TextEmote(std::string const& p_Text)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_EMOTE, LANG_UNIVERSAL, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT) && l_Target->GetTeamId() != GetTeamId() && !l_Target->isGameMaster())
            continue;

        if (PlayerSocial* l_Social = l_Target->GetSocial())
        {
            if (l_Social->HasIgnore(GUID_LOPART(GetGUID())))
                continue;
        }

        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            /// No specific target needed
            BuildPlayerChat(&l_Data, 0, CHAT_MSG_EMOTE, l_Text, LANG_UNIVERSAL);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::WhisperAddon(std::string const& p_Text, std::string const& p_Prefix, Player* p_Receiver)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, uint32(LANG_ADDON), l_Text, p_Receiver);

    if (!p_Receiver->GetSession()->IsAddonRegistered(p_Prefix))
        return;

    WorldPacket l_Data;
    BuildPlayerChat(&l_Data, 0, CHAT_MSG_WHISPER, l_Text, LANG_ADDON, p_Prefix.c_str());
    p_Receiver->GetSession()->SendPacket(&l_Data);
}

void Player::Whisper(std::string const& p_Text, uint32 p_LangID, uint64 p_Receiver)
{
#ifndef CROSS
    Player* l_Target = ObjectAccessor::FindPlayerInOrOutOfWorld(p_Receiver);
#else /* CROSS */
    Player* l_Target = ObjectAccessor::FindPlayer(p_Receiver);
#endif /* CROSS */
    if (l_Target == nullptr)
        return;

    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, p_LangID, l_Text, l_Target);

#ifndef CROSS
    if (l_Target->GetSocial()->HasIgnore(GetGUIDLow()))
#else /* CROSS */
    if (l_Target->GetSocial() && l_Target->GetSocial()->HasIgnore(GetGUIDLow()))
#endif /* CROSS */
    {
        WorldPacket l_Data;
        ChatHandler::FillMessageData(&l_Data, GetSession(), CHAT_MSG_IGNORED, LANG_UNIVERSAL, NULL, GetGUID(), GetName(), NULL);
        GetSession()->SendPacket(&l_Data);
        return;
    }

    /// When player you are whispering to is dnd, he cannot receive your message, unless you are in gm mode
    if (!l_Target->isDND() || isGameMaster())
    {
        bool l_IsUsingForbiddenRegex = false;
        /// Forbidden Regex for Whispers are the link of websites we don't want to be shared.
        std::string badWord = sWordFilterMgr->FindBadWord(l_Text);
        if (!badWord.empty())
            l_IsUsingForbiddenRegex = true;
        else
        {
            std::vector<std::regex> const& l_ForbiddenRegex = sObjectMgr->GetForbiddenRegex(eChannelType::ChannelWhisper);
            for (std::regex l_Regex : l_ForbiddenRegex)
            {
                if (std::regex_search(l_Text, l_Regex))
                {
                    l_IsUsingForbiddenRegex = true;
                    break;
                }
            }
        }

        WorldPacket l_Data;
        BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_WHISPER, l_Text, p_LangID);

        if (l_Text.size() > 20 && GetSession()->GetSecurity() == AccountTypes::SEC_PLAYER)
        {
            m_WhispersSentData[l_Text].insert(l_Target->GetGUID());
            if (m_WhispersSentData[l_Text].size() > 5)
                l_IsUsingForbiddenRegex = true;
        }

        if (l_IsUsingForbiddenRegex)
        {
            sLog->outExtChat("#sylvanas-whisp-flood", "", false, "*_Whisper flood detected_*\n*Sender*: %s\n*GUID*: %u\n*Receiver*: %s\n*GUID*: %u\n*Message*: %s", GetName(), GetGUIDLow(), l_Target->GetName(), l_Target->GetGUIDLow(), l_Text.c_str());
            //ChatHandler(GetSession()).SendGlobalFormatedGMSysMessage("System: Player %s (GUID %u) is trying to whisper forbidden expression to player %s (GUID %u). Message was (\"%s\")", GetName(), GetGUIDLow(), l_Target->GetName(), l_Target->GetGUIDLow(), l_Text.c_str());
        }
        else
            l_Target->GetSession()->SendPacket(&l_Data);

        /// Always notice the sender if if the packet contain forbidden regex, so latest they notice, the better.
        l_Target->BuildPlayerChat(&l_Data, GetGUID(), CHAT_MSG_WHISPER_INFORM, l_Text, p_LangID);
        GetSession()->SendPacket(&l_Data);
    }
    else ///< Announce to player that player he is whispering to is dnd and cannot receive his message
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_DND, l_Target->GetName(), l_Target->dndMsg.c_str());

    if (!IsAcceptWhispers() && !isGameMaster() && !l_Target->isGameMaster())
    {
        SetAcceptWhispers(true);
        ChatHandler(this).SendSysMessage(LANG_COMMAND_WHISPERON);
    }

    /// Announce to player that player he is whispering to is afk
    if (l_Target->isAFK())
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_AFK, l_Target->GetName(), l_Target->afkMsg.c_str());

    /// If player whisper someone, auto turn of dnd to be able to receive an answer
    if (isDND() && !l_Target->isGameMaster())
        ToggleDND();
}

void Player::PetSpellInitialize()
{
    Pet* l_Pet = GetPet();
    if (!l_Pet)
        return;

    CharmInfo* l_CharmInfo = l_Pet->GetCharmInfo();

    uint32 l_ActionCount = 0;
    if (l_Pet->IsPermanentPetFor(this))
    {
        for (PetSpellMap::iterator l_Itr = l_Pet->m_spells.begin(); l_Itr != l_Pet->m_spells.end(); ++l_Itr)
        {
            if (l_Itr->second.state != PETSPELL_REMOVED)
                ++l_ActionCount;
        }
    }

    uint32 l_CooldownCount        = l_Pet->m_CreatureSpellCooldowns.size();
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = l_Pet->GetDuration();
    uint32 l_PetModeAndOrders     = l_Pet->GetReactState() | l_CharmInfo->GetCommandState() << 8 | 0 << 16;     // PetModeAndOrders have : React state, Command State & flags
    uint16 l_CreatureFamily       = l_Pet->GetCreatureTemplate()->family;
    uint16 l_Specialization       = l_Pet->GetSpecialization();
    uint8  l_Flags                = 0;
    float  l_ModRate              = 1.0f;

    ObjectGuid l_PetGUID          = l_Pet->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint16(l_CharmInfo->GetCommandState() | (l_Flags << 8));
    l_Data << uint8(l_Pet->GetReactState());

    // action bar loop
    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    if (l_Pet->IsPermanentPetFor(this))
    {
        for (PetSpellMap::iterator itr = l_Pet->m_spells.begin(); itr != l_Pet->m_spells.end(); ++itr)
        {
            if (itr->second.state == PETSPELL_REMOVED)
                continue;

            l_Data << uint32(MAKE_UNIT_ACTION_BUTTON(itr->first, itr->second.active));  ///< Actions
        }
    }

    time_t l_Now = sWorld->GetGameTime();
    for (CreatureSpellCooldowns::const_iterator l_Itr = l_Pet->m_CreatureSpellCooldowns.begin(); l_Itr != l_Pet->m_CreatureSpellCooldowns.end(); ++l_Itr)
    {
        uint32 l_SpellID          = 0;
        uint32 l_Duration         = 0;
        uint32 l_CategoryDuration = 0;
        uint16 l_Category         = 0;
        float l_ModRate           = 1.0f;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        if (l_SpellInfo != nullptr)
        {
            l_Duration = (l_Itr->second > l_Now) ? (l_Itr->second - l_Now) * IN_MILLISECONDS : 0;
            l_SpellID = l_Itr->second;

            CreatureSpellCooldowns::const_iterator l_CategoryItr = l_Pet->m_CreatureCategoryCooldowns.find(l_SpellInfo->GetCategory());
            if (l_CategoryItr != l_Pet->m_CreatureCategoryCooldowns.end())
            {
                l_Category         = l_SpellInfo->GetCategory();
                l_CategoryDuration = (l_CategoryItr->second > l_Now) ? (l_CategoryItr->second - l_Now) * IN_MILLISECONDS : 0;
            }
        }

        l_Data << uint32(l_SpellID);
        l_Data << uint32(l_Duration);
        l_Data << uint32(l_CategoryDuration);
        l_Data << uint16(l_Category);
        l_Data << float(l_ModRate);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::PossessSpellInitialize()
{
    Unit* l_Charm = GetCharm();
    if (!l_Charm)
        return;

    CharmInfo* l_CharmInfo = l_Charm->GetCharmInfo();
    if (!l_CharmInfo)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::PossessSpellInitialize(): charm (" UI64FMTD ") has no charminfo!", l_Charm->GetGUID());
        return;
    }

    uint32 l_CooldownCount        = 0;
    uint32 l_ActionCount          = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = 0;
    uint32 l_PetModeAndOrders     = 0;
    uint16 l_CreatureFamily       = 0;
    uint16 l_Specialization       = 0;
    uint8  l_Flags                = 0;
    ObjectGuid l_PetGUID          = l_Charm->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint16(COMMAND_STAY | (l_Flags << 8)); ///< @todo715 should be two int8 one with the ReactState and another whit the CommandState see PetModeAndOrders in WPP
    l_Data << uint8(0); ///< Flags

    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::VehicleSpellInitialize()
{
    Creature* l_Vehicle = GetVehicleCreatureBase();
    if (!l_Vehicle)
        return;

    uint32 l_CooldownCount          = l_Vehicle->m_CreatureSpellCooldowns.size();
    uint32 l_ActionCount            = 0;
    uint32 l_PetSpellHistoryCount   = 0;
    uint32 l_TimeLimit              = l_Vehicle->isSummon() ? l_Vehicle->ToTempSummon()->GetTimer() : 0;
    uint32 l_PetModeAndOrders       = l_Vehicle->GetReactState() | 0 << 8 | 0x800 << 16;                  // PetModeAndOrders have : React state, Command State & DisableActions
    uint16 l_CreatureFamily         = l_Vehicle->GetCreatureTemplate()->family;
    uint16 l_Specialization         = 0;                                                                  // I think it's useless in case of vehicle action bar
    uint8  l_Flags                  = 0x8;
    ObjectGuid l_PetGUID            = l_Vehicle->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint16(COMMAND_FOLLOW | (l_Flags << 8));
    l_Data << uint8(l_Vehicle->GetReactState());

    /// Spell 1-8
    for (uint32 l_I = 0; l_I < MAX_CREATURE_SPELLS; ++l_I)
    {
        uint32 l_SpellId = l_Vehicle->m_spells[l_I];
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellId);
        if (!l_SpellInfo)
        {
            l_Data << uint16(0) << uint8(0) << uint8(l_I + 8);
            continue;
        }

        if (!sConditionMgr->IsObjectMeetingVehicleSpellConditions(l_Vehicle->GetEntry(), l_SpellId, this, l_Vehicle))
        {
            sLog->outDebug(LOG_FILTER_CONDITIONSYS, "VehicleSpellInitialize: conditions not met for Vehicle entry %u spell %u", l_Vehicle->ToCreature()->GetEntry(), l_SpellId);
            l_Data << uint16(0) << uint8(0) << uint8(l_I + 8);
            continue;
        }

        if (l_SpellInfo->IsPassive())
            l_Vehicle->CastSpell(l_Vehicle, l_SpellId, true);

        l_Data << uint32(MAKE_UNIT_ACTION_BUTTON(l_SpellId, l_I + 8));
    }

    for (uint32 l_I = MAX_CREATURE_SPELLS; l_I < MAX_SPELL_CONTROL_BAR; ++l_I)
        l_Data << uint32(0);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    //for (uint32 l_I = 0; l_I < l_ActionCount; ++l_ActionCount)
    //    l_Data << (l_Action[l_I]);

    time_t l_Now = sWorld->GetGameTime();
    for (CreatureSpellCooldowns::const_iterator l_Itr = l_Vehicle->m_CreatureSpellCooldowns.begin(); l_Itr != l_Vehicle->m_CreatureSpellCooldowns.end(); ++l_Itr)
    {
        uint32 l_SpellID          = 0;
        uint32 l_Duration         = 0;
        uint32 l_CategoryDuration = 0;
        uint16 l_Category         = 0;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        if (l_SpellInfo != nullptr)
        {
            l_Duration = (l_Itr->second > l_Now) ? (l_Itr->second - l_Now) * IN_MILLISECONDS : 0;
            l_SpellID = l_Itr->second;

            CreatureSpellCooldowns::const_iterator l_CategoryItr = l_Vehicle->m_CreatureCategoryCooldowns.find(l_SpellInfo->GetCategory());
            if (l_CategoryItr != l_Vehicle->m_CreatureCategoryCooldowns.end())
            {
                l_Category         = l_SpellInfo->GetCategory();
                l_CategoryDuration = (l_CategoryItr->second > l_Now) ? (l_CategoryItr->second - l_Now) * IN_MILLISECONDS : 0;
            }
        }

        l_Data << uint32(l_SpellID);
        l_Data << uint32(l_Duration);
        l_Data << uint32(l_CategoryDuration);
        l_Data << uint16(l_Category);
    }


    //for (uint32 l_I = 0; l_I < l_PetSpellHistoryCount; ++l_I)
    //{
    //    l_Data << int32(l_PetSpellHistory[l_I].CategoryID);
    //    l_Data << int32(l_PetSpellHistory[l_I].RecoveryTime);
    //    l_Data << int32(l_PetSpellHistory[l_I].ConsumedCharges);
    //}

    GetSession()->SendPacket(&l_Data);
}

void Player::CharmSpellInitialize()
{
    Unit* l_Charm = GetFirstControlled();
    if (!l_Charm)
        return;

    CharmInfo* l_CharmInfo = l_Charm->GetCharmInfo();
    if (!l_CharmInfo)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::CharmSpellInitialize(): the player's charm (" UI64FMTD ") has no charminfo!", l_Charm->GetGUID());
        return;
    }

    WorldPacket l_ActionBuffer;
    for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
    {
        CharmSpellInfo* l_CSpell = l_CharmInfo->GetCharmSpell(i);
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_CSpell->packedData & 0x00FFFFFF);
        if (l_SpellInfo && !l_SpellInfo->CannotBeAddedToCharm())
            continue;

        if (l_CSpell->GetAction())
            l_ActionBuffer << uint32(l_CSpell->packedData);
    }

    uint32 l_PetModeAndOrders = 0;
    if (l_Charm->GetTypeId() != TYPEID_PLAYER)
        l_PetModeAndOrders = uint8(l_Charm->ToCreature()->GetReactState()) | uint8(l_CharmInfo->GetCommandState()) << 8 | 0 << 16;  // PetModeAndOrders have : React state, Command State & flags

    uint32 l_CooldownCount        = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = 0;
    uint16 l_CreatureFamily       = 0;
    uint16 l_Specialization       = 0;
    uint8  l_Flags                = 0;
    ObjectGuid l_PetGUID          = l_Charm->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit

    if (l_Charm->GetTypeId() == TYPEID_UNIT)
    {
        l_Data << uint16(l_CharmInfo->GetCommandState() | (l_Flags << 8));
        l_Data << uint8(l_Charm->ToCreature()->GetReactState());
    }
    else
    {
        l_Data << uint16(COMMAND_STAY | (l_Flags << 8));
        l_Data << uint8(0);
    }

    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionBuffer.size() / 4);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    l_Data.append(l_ActionBuffer);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendRemoveControlBar()
{
    uint32 l_CooldownCount = 0;
    uint32 l_ActionCount = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit = 0;
    uint32 l_PetModeAndOrders = 0;
    uint16 l_CreatureFamily = CREATURE_FAMILY_NONE;
    uint16 l_Specialization = 0;
    uint8  l_Flags = 0;
    ObjectGuid l_PetGUID = 0;

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint16(COMMAND_STAY | (l_Flags << 8));
    l_Data << uint8(0);

    for (int l_I = 0; l_I < 10; l_I++)
        l_Data << uint32(0);                    ///< ActionButtons[l_I]

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    GetSession()->SendPacket(&l_Data);
}

bool Player::IsAffectedBySpellmod(SpellInfo const* spellInfo, SpellModifier* mod, Spell* p_SpellModTakingSpell /*= nullptr*/, Spell* p_OriginalSpell /*= nullptr*/)
{
    if (!mod || !spellInfo)
        return false;

    // Mod out of charges
    if (p_SpellModTakingSpell && mod->charges == -1 && p_SpellModTakingSpell->m_appliedMods.find((Aura*)mod->ownerAura) == p_SpellModTakingSpell->m_appliedMods.end())
        return false;

    // +duration to infinite duration spells making them limited
    if (mod->op == SPELLMOD_DURATION && spellInfo->GetDuration() == -1)
        return false;

    switch (spellInfo->Id)
    {
        case 32175: /// Storm Strike (mh)
        case 32176: /// Storm Strike (offh)
            /// Stormbringer cannot be used if the spell is triggered by Stormflurry
            if (mod->spellId == 201846 && p_OriginalSpell != nullptr && p_OriginalSpell->GetSpellValue(SpellValueMod::SPELLVALUE_BASE_POINT5) != 0)
                return false;
            break;
        default:
            break;
    }

    return spellInfo->IsAffectedBySpellMod(mod);
}

void Player::AddSpellMod(SpellModifier* p_Modifier, bool p_Apply)
{
    Opcodes l_Opcode = Opcodes((p_Modifier->type == SPELLMOD_FLAT) ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);

    flag128 l_Mask = 0;
    uint32 l_ModifierTypeCount = 0; // count of mods per one mod->op
    uint32 l_MaskIndex = 0;

    WorldPacket l_Packet(l_Opcode);
    ByteBuffer l_Buffer;

    for (int l_EffectIndex = 0; l_EffectIndex < 128; ++l_EffectIndex)
    {
        if (l_EffectIndex != 0 && (l_EffectIndex % 32) == 0)
            l_Mask[l_MaskIndex++] = 0;

        l_Mask[l_MaskIndex] = uint32(1) << (l_EffectIndex - (32 * l_MaskIndex));

        if (p_Modifier->mask & l_Mask)
        {
            float l_Value = p_Modifier->type == SPELLMOD_FLAT ? 0.0f : 1.0f;

            if (p_Modifier->type == SPELLMOD_FLAT)
            {
                for (SpellModList::iterator l_It = m_spellMods[p_Modifier->op].begin(); l_It != m_spellMods[p_Modifier->op].end(); ++l_It)
                    if ((*l_It)->type == p_Modifier->type && (*l_It)->mask & l_Mask)
                        l_Value += float((*l_It)->value);

                l_Value += p_Apply ? float(p_Modifier->value) : float(-p_Modifier->value);
            }
            else
            {
                for (SpellModList::iterator l_It = m_spellMods[p_Modifier->op].begin(); l_It != m_spellMods[p_Modifier->op].end(); ++l_It)
                    if ((*l_It)->type == p_Modifier->type && (*l_It)->mask & l_Mask && (p_Apply || (!p_Apply && p_Modifier != *l_It)))
                        AddPct(l_Value, (*l_It)->value);

                if (p_Apply)
                    AddPct(l_Value, p_Modifier->value);
            }

            l_Buffer << float(l_Value);
            l_Buffer << uint8(l_EffectIndex);

            ++l_ModifierTypeCount;
        }
    }

    l_Packet << uint32(1);
    l_Packet << uint8(p_Modifier->op);
    l_Packet << uint32(l_ModifierTypeCount);
    l_Packet.append(l_Buffer);

    SendDirectMessage(&l_Packet);

    if (p_Apply)
        m_spellMods[p_Modifier->op].push_back(p_Modifier);
    else
    {
        m_spellMods[p_Modifier->op].remove(p_Modifier);
        // mods bound to aura will be removed in AuraEffect::~AuraEffect
        if (!p_Modifier->ownerAura)
            delete p_Modifier;
    }
}

// Restore spellmods in case of failed cast
void Player::RestoreSpellMods(Spell* spell, uint32 ownerAuraId, Aura* aura)
{
    if (!spell || spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end(); ++itr)
        {
            SpellModifier* mod = *itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges())
                continue;

            // Restore only specific owner aura mods
            if (ownerAuraId && (ownerAuraId != mod->ownerAura->GetSpellInfo()->Id))
                continue;

            if (aura && mod->ownerAura != aura)
                continue;

            // check if mod affected this spell
            // first, check if the mod aura applied at least one spellmod to this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find((Aura*)mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;
            // secondly, check if the current mod is one of the spellmods applied by the mod aura
            if (!(mod->mask & spell->m_spellInfo->SpellFamilyFlags))
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            // add mod charges back to mod
            if (mod->charges == -1)
                mod->charges = 1;
            else
                mod->charges++;

            // Do not set more spellmods than avalible
            if (mod->ownerAura->GetCharges() < mod->charges)
                mod->charges = mod->ownerAura->GetCharges();

            // Skip this check for now - aura charges may change due to various reason
            // TODO: trac these changes correctly
            //ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
        }
    }
}

void Player::RestoreAllSpellMods(uint32 ownerAuraId, Aura* aura)
{
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (m_currentSpells[i])
            RestoreSpellMods(m_currentSpells[i], ownerAuraId, aura);
}

void Player::RemoveSpellMods(Spell* spell)
{
    if (!spell)
        return;

    if (spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::const_iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end();)
        {
            SpellModifier* mod = *itr;
            ++itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges())
                continue;

            // check if mod affected this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find((Aura*)mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            bool l_DelayedRemove = mod->ownerAura->GetSpellInfo()->HasAura(AuraType::SPELL_AURA_ADD_VIRTUAL_CHARGE);
            if (l_DelayedRemove)
            {
                uint32 l_SpellID = mod->ownerAura->GetId();

                if (l_SpellID == 194594) ///< Lock and Load
                    continue;

                AddDelayedEvent([this, l_SpellID]() -> void
                {
                    if (Aura* l_Aura = GetAura(l_SpellID, GetGUID()))
                        l_Aura->DropCharge(AuraRemoveMode::AURA_REMOVE_BY_EXPIRE);
                }, 1);
            }
            else
            {
                /// Camouflage and Camouflage (Subterfuge) have spellModifier with value 0, add specific case
                if (!(mod->ownerAura->GetId() == 117828 && spell->GetSpellInfo()->Id == 116858) && mod->ownerAura->GetId() != 1784 && mod->ownerAura->GetId() != 115191
                    && mod->ownerAura->GetId() != 242705 ///< Feeding Frenzy
                    && mod->ownerAura->GetId() != 227272) ///< Trick Shot
                    if (((Aura*)mod->ownerAura)->DropCharge(AURA_REMOVE_BY_EXPIRE))
                        itr = m_spellMods[i].begin();
            }
        }
    }
}

void Player::DropModCharge(SpellModifier* mod, Spell* spell)
{
    // don't handle spells with proc_event entry defined
    // this is a temporary workaround, because all spellmods should be handled like that
    if (sSpellMgr->GetSpellProcEvent(mod->spellId))
        return;

    if (spell && mod->ownerAura && mod->charges > 0)
    {
        if (--mod->charges == 0)
            mod->charges = -1;

        spell->m_appliedMods.insert((Aura*)mod->ownerAura);
    }
}

void Player::SetSpellModTakingSpell(Spell* spell, bool apply)
{
    if (!spell || (m_spellModTakingSpell && m_spellModTakingSpell != spell))
        return;

    if (apply && spell->getState() == SPELL_STATE_FINISHED)
        return;

    m_spellModTakingSpell = apply ? spell : NULL;
}

bool Player::NeedToConsumeSpellMod(SpellInfo const* p_SpellInfo, SpellModifier* p_Mod) const
{
    switch (p_Mod->spellId)
    {
        case 202425: ///< Warrior of Elune
            /// Should not be consumed if there is a Owlkin Frenzy, Owlkin Frenzy should be consumed first
            if (AuraEffect const* l_AuraEffect = GetAuraEffect(157228, EFFECT_0)) ///< Owlkin Frenzy
            {
                if (l_AuraEffect->IsAffectingSpell(p_SpellInfo))
                    return false;
            }
            break;
    }
    return true;
}

// send Proficiency
void Player::SendProficiency(ItemClass itemClass, uint32 itemSubclassMask)
{
    WorldPacket data(SMSG_SET_PROFICIENCY, 1 + 4);
    data << uint32(itemSubclassMask) << uint8(itemClass);
    GetSession()->SendPacket(&data);
}

void Player::RemovePetitionsAndSigns(uint64 guid, uint32 type)
{
#ifndef CROSS
    PreparedStatement* stmt;

    if (type == 10)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE);
        stmt->setUInt8(1, uint8(type));
    }

    stmt->setUInt32(0, GUID_LOPART(guid));

    CharacterDatabase.AsyncQuery(stmt, sWorld->GetQueryCallbackMgr(), [type, guid](PreparedQueryResult const& p_Result)
    {
        if (p_Result)
        {
            do                                                  // this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
            {                                                   // and SendPetitionQueryOpcode reads data from the DB
                Field* fields = p_Result->Fetch();
                uint64 ownerguid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
                uint64 petitionguid = MAKE_NEW_GUID(fields[1].GetUInt32(), 0, HIGHGUID_ITEM);

                // send update if charter owner in game
                Player* owner = ObjectAccessor::FindPlayer(ownerguid);
                if (owner)
                    owner->GetSession()->SendPetitionQueryOpcode(petitionguid);
            } while (p_Result->NextRow());

            if (type == 10)
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_PETITION_SIGNATURES);

                stmt->setUInt32(0, GUID_LOPART(guid));

                CharacterDatabase.Execute(stmt);
            }
            else
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE);

                stmt->setUInt32(0, GUID_LOPART(guid));
                stmt->setUInt8(1, uint8(type));

                CharacterDatabase.Execute(stmt);
            }
        }
    });

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    if (type == 10)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);
    }
    CharacterDatabase.CommitTransaction(trans);
#endif
}

void Player::ModRestBonus(float mod)
{
    float rest_bonus_max = (float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)*1.5f / 2;

    if (mod > 0)
    {
        // Inner Peace
        // Player has not aura when loading, check player class
        if (HasAura(107074) || getClass() == CLASS_MONK)
            mod *= 2;
    }

    float rest_bonus_new = m_rest_bonus + mod;

    if (rest_bonus_new < 0)
    {
        rest_bonus_new = 0;
    }
    else if (rest_bonus_new > rest_bonus_max)
    {
        m_rest_bonus = rest_bonus_max;
    }

    SetRestBonus(rest_bonus_new);
}

void Player::SetRestBonus(float rest_bonus_new)
{
    // Prevent resting on max level
    if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        rest_bonus_new = 0;

    if (rest_bonus_new < 0)
        rest_bonus_new = 0;

    float rest_bonus_max = (float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)*1.5f/2;

    if (rest_bonus_new > rest_bonus_max)
        m_rest_bonus = rest_bonus_max;
    else
        m_rest_bonus = rest_bonus_new;

    if (m_rest_bonus > 10)
        SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, REST_STATE_RESTED);
    else if (m_rest_bonus <= 1)
        SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, REST_STATE_NOT_RAF_LINKED);

    //RestTickUpdate
    SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_RESTED_XP, uint32(m_rest_bonus));
}

bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc /*= NULL*/, uint32 spellid /*= 0*/, uint32 p_PreferredMountDisplay /*=0*/)
{
    if (nodes.size() < 2)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
        return false;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL))
        return false;

    //Remove mount
    RemoveAurasByType(SPELL_AURA_MOUNTED);

    // taximaster case
    if (npc)
    {
        // not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
        if (IsNonMeleeSpellCasted(false))
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
            return false;
        }
    }
    // cast case or scripted call case
    else
    {
        if (IsInDisallowedMountForm())
            RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);

        if (Spell* spell = GetCurrentSpell(CURRENT_GENERIC_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_GENERIC_SPELL, false);

        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);

        if (Spell* spell = GetCurrentSpell(CURRENT_CHANNELED_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_CHANNELED_SPELL, true);
    }

    uint32 sourcenode = nodes[0];

    // starting node too far away (cheat?)
    TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(sourcenode);
    if (!node)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    uint32 l_MapID = GetMapId();

    /// Desination map can be different in case of phased map (like garrisons) and we have to override the map id
    std::map<uint32, uint32> l_PhasedToGlobalMap =
    {
        { 1158, MS::Garrison::GDraenor::Globals::BaseMap },
        { 1159, MS::Garrison::GDraenor::Globals::BaseMap },
        { 1152, MS::Garrison::GDraenor::Globals::BaseMap },
        { 1153, MS::Garrison::GDraenor::Globals::BaseMap },
        { 1331, MS::Garrison::GDraenor::Globals::BaseMap },
        { 1330, MS::Garrison::GDraenor::Globals::BaseMap },
    };

    auto l_Itr = l_PhasedToGlobalMap.find(l_MapID);
    if (l_Itr != l_PhasedToGlobalMap.end())
        l_MapID = l_Itr->second;

    // check node starting pos data set case if provided
    if (node->x != 0.0f || node->y != 0.0f || node->z != 0.0f)
    {
        if (node->MapID != l_MapID)
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXITOOFARAWAY);
            return false;
        }
    }
    // node must have pos if taxi master case (npc != NULL)
    else if (npc)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        return false;
    }
    // Prepare to flight start now

    // stop combat at start taxi flight if any
    CombatStop();

    StopCastingCharm();
    StopCastingBindSight();
    ExitVehicle();

    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
    TradeCancel(true);

    // clean not finished taxi path if any
    m_taxi.ClearTaxiDestinations();

    // 0 element current node
    m_taxi.AddTaxiDestination(sourcenode);

    // fill destinations path tail
    uint32 sourcepath = 0;
    uint32 totalcost = 0;
    uint32 firstcost = 0;

    uint32 prevnode = sourcenode;
    uint32 lastnode;

    if (!(node->Flags & TaxiNodeFlags::TAXI_NODE_FLAG_ARGUS))
    {
        for (uint32 i = 1; i < nodes.size(); ++i)
        {
            uint32 path, cost;

            lastnode = nodes[i];
            sObjectMgr->GetTaxiPath(prevnode, lastnode, path, cost);

            if (!path)
            {
                m_taxi.ClearTaxiDestinations();
                return false;
            }

            totalcost += cost;
            if (i == 1)
                firstcost = cost;

            if (prevnode == sourcenode)
                sourcepath = path;

            m_taxi.AddTaxiDestination(lastnode);

            prevnode = lastnode;
        }
    }

    // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
    //
    // Hack-Fix for Alliance not being able to use Acherus taxi. There is
    // only one mount ID for both sides. Probably not good to use 315 in case DB2 nodes
    // change but I couldn't find a suitable alternative. OK to use class because only DK
    // can use this taxi.
    uint32 mount_display_id = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetTeam(), npc == nullptr || (sourcenode == 315 && getClass() == CLASS_DEATH_KNIGHT), p_PreferredMountDisplay);

    // in spell case allow 0 model
    if (((mount_display_id == 0 && spellid == 0) || sourcepath == 0) && !(node->Flags & TAXI_NODE_FLAG_ARGUS))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    uint64 money = GetMoney();

    if (npc)
        totalcost = (uint32)ceil(totalcost*GetReputationPriceDiscount(npc));

    if (money < totalcost)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOTENOUGHMONEY);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    //Checks and preparations done, DO FLIGHT
    UpdateCriteria(CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);

    // prevent stealth flight
    //RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);

    if (sWorld->getBoolConfig(CONFIG_INSTANT_TAXI) || node->Flags & TAXI_NODE_FLAG_ARGUS || GetSession()->IsPremium())
    {
        TaxiNodesEntry const* lastPathNode = sTaxiNodesStore.LookupEntry(nodes[nodes.size()-1]);
        ASSERT(lastPathNode);
        m_taxi.ClearTaxiDestinations();
        ModifyMoney(-int64(totalcost), "Player::ActivateTaxiPathTo");
        UpdateCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, totalcost);

        if (node->Flags & TAXI_NODE_FLAG_ARGUS)
            sScriptMgr->OnActivateArgusTaxi(this, lastPathNode->ID);

        if (lastPathNode->ID == 1977) ///< Vindicaar
            TeleportTo(1669, 4600.83f, 9831.84f, 68.06f, 0.213662f);
        else
            TeleportTo(lastPathNode->MapID, lastPathNode->x, lastPathNode->y, lastPathNode->z, GetOrientation());
        return false;
    }
    else
    {
        if (GetDisplayId() != GetNativeDisplayId())
        {
            SetDisplayId(GetNativeDisplayId());
        }

        ModifyMoney(-int64(firstcost), "Player::ActivateTaxiPathTo");
        UpdateCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, firstcost);
        GetSession()->SendActivateTaxiReply(ERR_TAXIOK);
        GetSession()->SendDoFlight(mount_display_id, sourcepath);
    }
    SetTeleportFlagForAnticheat(true);
    return true;
}

bool Player::ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid /*= 0*/)
{
    TaxiPathEntry const* entry = sTaxiPathStore.LookupEntry(taxi_path_id);
    if (!entry)
        return false;

    std::vector<uint32> nodes;

    nodes.resize(2);
    nodes[0] = entry->From;
    nodes[1] = entry->To;

    return ActivateTaxiPathTo(nodes, nullptr, spellid);
}

void Player::CleanupAfterTaxiFlight()
{
    m_taxi.ClearTaxiDestinations();        // not destinations, clear source node
    StopMoving();
    Dismount();
    ClearUnitState(UNIT_STATE_IN_FLIGHT);
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL | UNIT_FLAG_TAXI_FLIGHT);
    getHostileRefManager().setOnlineOfflineState(true);
}

void Player::ContinueTaxiFlight() const
{
    uint32 sourceNode = m_taxi.GetTaxiSource();
    if (!sourceNode)
        return;

    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Restart character %u taxi flight", GetGUIDLow());

    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourceNode, GetTeam(), true);
    if (!mountDisplayId)
        return;

    uint32 path = m_taxi.GetCurrentTaxiPath();

    // search appropriate start path node
    uint32 startNode = 0;

    TaxiPathNodeList const& nodeList = sTaxiPathNodesByPath[path];

    float distPrev;
    float distNext =
        (nodeList[0]->x - GetPositionX())*(nodeList[0]->x - GetPositionX()) +
        (nodeList[0]->y - GetPositionY())*(nodeList[0]->y - GetPositionY()) +
        (nodeList[0]->z - GetPositionZ())*(nodeList[0]->z - GetPositionZ());

    for (uint32 i = 1; i < nodeList.size(); ++i)
    {
        TaxiPathNodeEntry const* node = nodeList[i];
        TaxiPathNodeEntry const* prevNode = nodeList[i - 1];

        // skip nodes at another map
        if (node->MapID != GetMapId())
            continue;

        distPrev = distNext;

        distNext =
            (node->x - GetPositionX()) * (node->x - GetPositionX()) +
            (node->y - GetPositionY()) * (node->y - GetPositionY()) +
            (node->z - GetPositionZ()) * (node->z - GetPositionZ());

        float distNodes =
            (node->x - prevNode->x) * (node->x - prevNode->x) +
            (node->y - prevNode->y) * (node->y - prevNode->y) +
            (node->z - prevNode->z) * (node->z - prevNode->z);

        if (distNext + distPrev < distNodes)
        {
            startNode = i;
            break;
        }
    }

    GetSession()->SendDoFlight(mountDisplayId, path, startNode);
}

void Player::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs, uint32 p_SpellID /*= 0*/)
{
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
        if (idSchoolMask & (1 << i))
            prohibited[i] = prohibited_struct(unTimeMs);

    WorldPacket data(SMSG_SPELL_COOLDOWN, 1 * 1024);
    ByteBuffer dataBuffer(1 * 1024);
    ObjectGuid playerGuid = GetGUID();

    uint32 counter = 0;
    uint32 curMsTime = getMSTime();

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
    {
        if (itr->second->state == PLAYERSPELL_REMOVED)
            continue;

        uint32 unSpellId = itr->first;
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(unSpellId);
        if (!spellInfo)
        {
            ASSERT(spellInfo);
            continue;
        }
        // Not send cooldown for this spells
        if (spellInfo->IsCooldownStartedOnEvent())
            continue;

        if ((spellInfo->PreventionType & (SpellPreventionMask::Silence)) == 0)
            continue;

        for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
        {
            if (idSchoolMask & (1 << i))
            {
                if (((1 << i) & spellInfo->GetSchoolMask()) && GetSpellCooldownDelay(unSpellId) < unTimeMs)
                {
                    SpellSchools school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
                    if ((1 << school) != spellInfo->GetSchoolMask())
                    {
                        SpellSchoolMask d_mask = SpellSchoolMask((1 << i) ^ spellInfo->GetSchoolMask());
                        bool do_break = false;
                        for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
                        {
                            if (d_mask & (1 << i))
                            {
                                if (prohibited[i].m_time_prohibited_until < curMsTime)
                                {
                                    do_break = true;
                                    break;
                                }
                                else
                                {
                                    unTimeMs = std::max(unTimeMs, prohibited[i].m_time_prohibited_until - curMsTime);
                                }
                            }
                        }

                        if (do_break)
                            continue;
                    }

                    Unit::AuraEffectList swaps = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS);
                    Unit::AuraEffectList const& swaps2 = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2);
                    if (!swaps2.empty())
                        swaps.insert(swaps.end(), swaps2.begin(), swaps2.end());

                    if (!swaps.empty())
                    {
                        for (Unit::AuraEffectList::const_iterator itr = swaps.begin(); itr != swaps.end(); ++itr)
                        {
                            if ((*itr)->IsAffectingSpell(spellInfo))
                            {
                                if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo((*itr)->GetAmount()))
                                {
                                    ++counter;
                                    dataBuffer << uint32(newInfo->Id);
                                    dataBuffer << uint32(unTimeMs); ///< in m.secs
                                    dataBuffer << float(1.0f);      ///< Mod Rate

                                    AddSpellCooldown(newInfo->Id, 0, unTimeMs);
                                }

                                break;
                            }
                        }
                    }

                    ++counter;
                    dataBuffer << uint32(unSpellId);
                    dataBuffer << uint32(unTimeMs); ///< in m.secs
                    dataBuffer << float(1.0f);      ///< Mod Rate

                    AddSpellCooldown(unSpellId, 0, unTimeMs);
                }
            }
        }
    }

    data.appendPackGUID(playerGuid);
    data << uint8(0);
    data << uint32(counter);
    data.append(dataBuffer);

    GetSession()->SendPacket(&data);
}

void Player::InitDataForForm(bool reapplyMods)
{
    ShapeshiftForm form = GetShapeshiftForm();

    SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
    if (ssEntry && ssEntry->CombatRoundTime)
    {
        SetAttackTime(WeaponAttackType::BaseAttack, ssEntry->CombatRoundTime);
        SetAttackTime(WeaponAttackType::OffAttack, ssEntry->CombatRoundTime);
        SetAttackTime(WeaponAttackType::RangedAttack, BASE_ATTACK_TIME);
    }
    else
        SetRegularAttackTime();

    Powers l_Power = GetDisplayPowerForCurrentState();
    if (getPowerType() != l_Power)
        setPowerType(l_Power);

    // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
    if (!reapplyMods)
        UpdateEquipSpellsAtFormChange();

    /// Update weapons damage (needed for pvp templates)
    if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
    {
        UpdateWeaponDamage(l_Item->GetTemplate(), EQUIPMENT_SLOT_MAINHAND, false, l_Item);
        UpdateWeaponDamage(l_Item->GetTemplate(), EQUIPMENT_SLOT_MAINHAND, true, l_Item);
    }

    if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
    {
        UpdateWeaponDamage(l_Item->GetTemplate(), EQUIPMENT_SLOT_OFFHAND, false, l_Item);
        UpdateWeaponDamage(l_Item->GetTemplate(), EQUIPMENT_SLOT_OFFHAND, true, l_Item);
    }

    UpdateAttackPowerAndDamage();
    UpdateAttackPowerAndDamage(true);
}

void Player::InitDisplayIds(uint8 p_MercenaryRace)
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(p_MercenaryRace == 0 ? getRace() : p_MercenaryRace, getClass());
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player %u has incorrect race/class pair. Can't init display ids.", GetGUIDLow());
        return;
    }

    uint8 gender = getGender();
    switch (gender)
    {
        case GENDER_FEMALE:
            SetDisplayId(info->displayId_f);
            SetNativeDisplayId(info->displayId_f);
            break;
        case GENDER_MALE:
            SetDisplayId(info->displayId_m);
            SetNativeDisplayId(info->displayId_m);
            break;
        default:
            sLog->outError(LOG_FILTER_PLAYER, "Invalid gender %u for player", gender);
            return;
    }
}

inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int64 price, ItemTemplate const* pProto, Creature* pVendor, VendorItem const* crItem, bool bStore)
{
    ItemPosCountVec vDest;
    uint16 uiDest = 0;
    InventoryResult msg = bStore ?
        CanStoreNewItem(bag, slot, vDest, item, count) :
        CanEquipNewItem(slot, uiDest, item, false);
    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, NULL, NULL, item);
        return false;
    }

    if (crItem->ExtendedCost) // case for new honor system
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredItem[i])
            {
                int32 l_ItemCount = 0;

                if (count > pProto->BuyCount && pProto->BuyCount && !(count % pProto->BuyCount))
                    l_ItemCount = count / pProto->BuyCount;
                else
                    l_ItemCount = (count != pProto->BuyCount) ? (iece->RequiredItemCount[i] * count) : iece->RequiredItemCount[i];

                // Fix for Sargerite vendor on Vindicaar
                if (pVendor->GetEntry() == 129674 && count > pProto->BuyCount)
                    l_ItemCount = iece->RequiredItemCount[i] * (count / pProto->BuyCount);

                if (iece->RequiredItem[i] == 138019)
                    sLog->outAshran("_StoreOrEquipNewItem delete mythic keystone");

                DestroyItemCount(iece->RequiredItem[i], l_ItemCount, true);
            }

            if (iece->RequiredCurrency[i])
            {
                if (i != 1 || iece->ID == 2999) ///< 1 are season count request, we must not substract it
                {
                    int32 l_Cost = 0;

                    if (count > pProto->BuyCount && pProto->BuyCount && !(count % pProto->BuyCount))
                        l_Cost = count / pProto->BuyCount * iece->RequiredCurrencyCount[i];
                    else
                        l_Cost = (count != pProto->BuyCount) ? (iece->RequiredCurrencyCount[i] * count) : iece->RequiredCurrencyCount[i];

                    ModifyCurrency(iece->RequiredCurrency[i], -int32(l_Cost), true, true);
                }
            }
        }

        ItemExtendedCostAddon const* l_ExtendedCostAddon = sObjectMgr->GetItemExtendedCostAddon(crItem->ExtendedCost);
        if (l_ExtendedCostAddon && l_ExtendedCostAddon->OverrideBuyPrice)
        {
            if (count != pProto->BuyCount)
                price = l_ExtendedCostAddon->OverrideBuyPrice * count * GetReputationPriceDiscount(pVendor);
            else
                price = l_ExtendedCostAddon->OverrideBuyPrice * GetReputationPriceDiscount(pVendor);

            if (int64 priceMod = int64(GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES)))
                price -= CalculatePct(price, priceMod);
        }
    }

    ModifyMoney(-price, "Player::_StoreOrEquipNewItem " + std::to_string(item) + " x" + std::to_string(count));

    std::vector<uint32> l_Bonuses = crItem->BonusList;
    if (!l_Bonuses.empty())
        Item::GenerateItemBonus(item, ItemContext::None, l_Bonuses);

    Item* it = bStore ?
        StoreNewItem(vDest, item, true, 0, l_Bonuses) :
        EquipNewItem(uiDest, item, true);
    if (it)
    {
        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, count);

        WorldPacket data(SMSG_BUY_ITEM, 16 + 2 + 4 + 4 + 4);

        ObjectGuid vendorGuid = pVendor->GetGUID();

        data.appendPackGUID(vendorGuid);
        data << uint32(vendorslot + 1);                   // numbered from 1 at client
        data << int32(crItem->maxcount > 0 ? new_count : 0xFFFFFFFF);
        data << uint32(count);

        GetSession()->SendPacket(&data);
        SendNewItem(it, count, true, false, false);

        if (!bStore)
            AutoUnequipOffhandIfNeed();

        if (pProto->Flags & int32(ItemFlags::ITEMPURCHASE_RECORD) && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1)
        {
            it->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
            it->SetUInt32Value(ITEM_FIELD_CONTEXT, 14);
            it->SetRefundRecipient(GetGUIDLow());
            it->SetPaidMoney(price);
            it->SetPaidExtendedCost(crItem->ExtendedCost);
            it->SaveRefundDataToDB();
            AddRefundReference(it->GetGUIDLow());
        }

        GetSession()->GetCollectionMgr()->OnItemAdded(it);
    }
    return true;
}

bool Player::BuyCurrencyFromVendorSlot(uint64 vendorGuid, uint32 vendorSlot, uint32 currency, uint32 count)
{
    //vendorSlot += 1; Already handled in HandleBuyItemOpcode ?

    // cheating attempt
    if (count < 1) count = 1;

    if (!isAlive())
        return false;

    CurrencyTypesEntry const* proto = sCurrencyTypesStore.LookupEntry(currency);
    if (!proto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyCurrencyFromVendorSlot - Unit (GUID: %u) not found or you can't interact with him.", GUID_LOPART(vendorGuid));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, currency, 0);
        return false;
    }

    VendorItemData const* vItems = creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (vendorSlot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorSlot);
    // store diff item (cheating)
    if (!crItem || crItem->item != currency || crItem->Type != ITEM_VENDOR_TYPE_CURRENCY)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (crItem->PlayerConditionID != 0 && EvalPlayerCondition(crItem->PlayerConditionID).first == false)
    {
        /// @TODO find the right error
        return false;
    }

    int32 precision = (proto->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    if (crItem->ExtendedCost)
    {
        // Can only buy full stacks for extended cost
        if ((crItem->maxcount * precision) != count)
        {
            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
            return false;
        }

        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Currency %u have wrong ExtendedCost field value %u", currency, crItem->ExtendedCost);
            return false;
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0); // Find correct error
                return false;
            }

            if (!HasCurrency(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i] * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }
    }
    else // currencies have no price defined, can only be bought with ExtendedCost
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    ModifyCurrency(currency, crItem->maxcount * precision, true, true);

    if (crItem->ExtendedCost)
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredItem[i])
            {
                if (iece->RequiredItem[i] == 138019)
                    sLog->outAshran("BuyCurrencyFromVendorSlot delete mythic keystone");
                DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count, true);
            }
        }

        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredCurrency[i])
                if (i != 1 || iece->ID == 2999) // 1 are season count request, we must not substract it
                    ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i] * count), true, true);
        }
    }

    return true;
}

// Return true is the bought item has a max count to force refresh of window by caller
bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot)
{
    // cheating attempt
    if (count < 1)
        count = 1;

    // cheating attempt
    if (slot > MAX_BAG_SIZE && slot != NULL_SLOT)
        return false;

    if (!isAlive())
        return false;

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (!pProto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
        return false;
    }

    VendorItemData const* vItems = creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    if (vendorslot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorslot);
    // store diff item (cheating)
    if (!crItem || crItem->item != item)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    if (pProto->Flags & int32(ItemFlags::ITEMPURCHASE_RECORD) && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1 && count != 1)
    {
        sLog->outAshran("Account %u characters %u tried a gold exploit.", GetSession()->GetAccountId(), GetGUIDLow());
        SendBuyError(BUY_ERR_SELLER_DONT_LIKE_YOU, creature, item, 0);
        return false;
    }

    // check current item amount if it limited
    if (crItem->maxcount != 0)
    {
        if (creature->GetVendorItemCurrentCount(crItem) < pProto->BuyCount * count)
        {
            SendBuyError(BUY_ERR_ITEM_ALREADY_SOLD, creature, item, 0);
            return false;
        }
    }

    if (pProto->RequiredReputationFaction && (uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank))
    {
        SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, item, 0);
        return false;
    }

    if (crItem->PlayerConditionID != 0 && crItem->PlayerConditionID < 0xFFFFFF && EvalPlayerCondition(crItem->PlayerConditionID).first == false)
    {
        /// @TODO find the right error
        return false;
    }

    uint64 price = 0;

    if (crItem->ExtendedCost)
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Item %u have wrong ExtendedCost field value %u", pProto->ItemId, crItem->ExtendedCost);
            return false;
        }

        ItemExtendedCostAddon const* l_ExtendedCostAddon = sObjectMgr->GetItemExtendedCostAddon(crItem->ExtendedCost);
        if (l_ExtendedCostAddon && l_ExtendedCostAddon->OverrideBuyPrice)
            price = l_ExtendedCostAddon->OverrideBuyPrice;

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            int32 l_ItemCount = 0;

            if (count > pProto->BuyCount && pProto->BuyCount && !(count % pProto->BuyCount))
                l_ItemCount = count / pProto->BuyCount;
            else
                l_ItemCount = (count != pProto->BuyCount) ? (iece->RequiredItemCount[i] * count) : iece->RequiredItemCount[i];

            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], l_ItemCount, true, true))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }

            uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

            int32 l_RealCount = 0;

            if (count > pProto->BuyCount && pProto->BuyCount && !(count % pProto->BuyCount))
                l_RealCount = count / pProto->BuyCount * iece->RequiredCurrencyCount[i];
            else
                l_RealCount = (count != pProto->BuyCount) ? (iece->RequiredCurrencyCount[i] * count) : iece->RequiredCurrencyCount[i];

            // Second field in db2 is season count except two strange rows
            if (i == 1 && iece->ID != 2999)
            {
                if ((l_RealCount / precision) > GetCurrencyOnSeason(iece->RequiredCurrency[i], false))
                {
                    SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                    return false;
                }
            }
            else if (!HasCurrency(iece->RequiredCurrency[i], l_RealCount))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }
    }

#ifndef CROSS
    if (GuildReward const* l_Reward = sGuildMgr->GetGuildReward(item))
    {
        Guild* l_Guild = sGuildMgr->GetGuildById(GetGuildId());
        if (!l_Guild)
        {
            SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
            return false;
        }

        if (l_Reward->Standing)
        {
            if (GetReputationRank(REP_GUILD) < l_Reward->Standing)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }
        }

        if (l_Reward->AchievementId)
        {
            if (!l_Guild->HasAchieved(l_Reward->AchievementId))
            {
                if (!(l_Reward->AchievementId == 5492 && l_Guild->HasAchieved(4912)) && !(l_Reward->AchievementId == 4912 && l_Guild->HasAchieved(5492)))
                {
                    SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                    return false;
                }
            }
        }

        if (l_Reward->Racemask)
        {
            if (!(getRaceMask() & l_Reward->Racemask))
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }
        }
    }
#endif

    if (!price && crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
    {
        uint32 maxCount = MAX_MONEY_AMOUNT / pProto->BuyPrice;
        if ((uint32)count > maxCount)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to buy %u item id %u, causing overflow", GetName(), (uint32)count, pProto->ItemId);
            count = (uint8)maxCount;
        }

        price = uint64(pProto->BuyPrice);
    }

    if (price)
    {
        if (count != pProto->BuyCount)
            price *= count; ///< it should not exceed MAX_MONEY_AMOUNT

        /// Reputation discount
        price = uint64(floor(price * GetReputationPriceDiscount(creature)));

        if (int64 priceMod = int64(GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES)))
            price -= CalculatePct(price, priceMod);

        if (!HasEnoughMoney(price))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, item, 0);
            return false;
        }
    }

    if ((bag == NULL_BAG && slot == NULL_SLOT) || IsInventoryPos(bag, slot))
    {
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, true))
            return false;
    }
    else if (IsEquipmentPos(bag, slot))
    {
        if (count != 1)
        {
            SendEquipError(EQUIP_ERR_NOT_EQUIPPABLE, NULL, NULL);
            return false;
        }
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, false))
            return false;
    }
    else
    {
        SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return false;
    }

    if (crItem->maxcount != 0) ///< Bought
        return true;

    return false;
}

uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
{
    // returns the maximal personal arena rating that can be used to purchase items requiring this condition
    // the personal rating of the arena team must match the required limit as well
    // so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
    uint32 max_personal_rating = 0;
    for (uint8 i = minarenaslot; i < (uint8)BattlegroundBracketType::Max; ++i)
    {
        if (max_personal_rating < GetArenaPersonalRating(i))
            max_personal_rating = GetArenaPersonalRating(i);
    }
    return max_personal_rating;
}

void Player::UpdateHomebindTime(uint32 time)
{
    // GMs never get homebind timer online
#ifndef CROSS
    if (m_InstanceValid || isGameMaster() || IsInDraenorGarrison())
#else /* CROSS */
    if (m_InstanceValid || isGameMaster())
#endif /* CROSS */
    {
        if (m_HomebindTimer)                                 // instance valid, but timer not reset
        {
            // hide reminder
            WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
            data << uint32(0);
            data << uint32(0);
            GetSession()->SendPacket(&data);
        }
        // instance is valid, reset homebind timer
        m_HomebindTimer = 0;
    }
    else if (m_HomebindTimer > 0)
    {
        if (time >= m_HomebindTimer)
        {
            // teleport to nearest graveyard
            RepopAtGraveyard(true);
        }
        else
            m_HomebindTimer -= time;
    }
    else
    {
        // instance is invalid, start homebind timer
        m_HomebindTimer = 60000;
        // send message to player
        WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
        data << uint32(m_HomebindTimer);
        data << uint32(1);
        GetSession()->SendPacket(&data);
        sLog->outDebug(LOG_FILTER_MAPS, "PLAYER: Player '%s' (GUID: %u) will be teleported to homebind in 60 seconds", GetName(), GetGUIDLow());
    }
}

void Player::UpdatePvPState(bool onlyFFA)
{
    // TODO: should we always synchronize UNIT_FIELD_SHAPESHIFT_FORM, 1 of controller and controlled?
    // no, we shouldn't, those are checked for affecting player by client
    if (!pvpInfo.inNoPvPArea && !isGameMaster()
        && (pvpInfo.inFFAPvPArea || sWorld->IsFFAPvPRealm()))
    {
        if (!HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP))
        {
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
            for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
                (*itr)->SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        }
    }
    else if (HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP))
    {
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
            (*itr)->RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
    }

    if (onlyFFA)
        return;

    if (pvpInfo.inHostileArea)                               // in hostile area
    {
        if (!IsPvP() || pvpInfo.endTimer != 0)
            UpdatePvP(true, true);
    }
    else                                                    // in friendly area
    {
        if (IsPvP() && !HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) && pvpInfo.endTimer == 0)
            pvpInfo.endTimer = time(0);                     // start toggle-off
    }
}

void Player::UpdatePvP(bool state, bool override)
{
    if (!state || override)
    {
        SetPvP(state);
        pvpInfo.endTimer = 0;
    }
    else
    {
        pvpInfo.endTimer = time(NULL);
        SetPvP(state);
    }
}

bool Player::HasSpellCooldown(uint32 p_SpellID) const
{
    return GetSpellCooldownDelay(p_SpellID) != 0;
}

uint32 Player::GetSpellCooldownDelay(uint32 p_SpellID) const
{
    SpellCooldowns::const_iterator l_Iter = m_spellCooldowns.find(p_SpellID);

    ACE_UINT64 l_CurrTime = 0;
    ACE_OS::gettimeofday().msec(l_CurrTime);

    return uint32(l_Iter != m_spellCooldowns.end() && l_Iter->second.end > l_CurrTime ? l_Iter->second.end - l_CurrTime : 0);
}

void Player::AddSpellAndCategoryCooldowns(SpellInfo const* p_SpellInfo, uint32 p_ItemId, Spell* p_Spell, bool p_InfinityCooldown)
{
    /// No need to set cooldown for Battle resurrection spells during a raid encounter
    /// Now we have a system using Battle resurrection charges
    if (p_SpellInfo->IsBattleResurrection())
    {
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->IsEncounterInProgress() && (l_InstanceScript->instance->IsRaid() || l_InstanceScript->instance->IsChallengeMode()))
                return;
        }
    }

    // init cooldown values
    uint32 l_CategoryId       = 0; // cat
    int64  l_Cooldown         = -1; //rec
    int64  l_CategoryCooldown = -1; //catrec

    // some special item spells without correct cooldown in SpellInfo
    // cooldown information stored in item prototype
    // This used in same way in WorldSession::HandleItemQuerySingleOpcode data sending to client.
    if (p_ItemId)
    {
        if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(p_ItemId))
        {
            for (uint8 l_Idx = 0; l_Idx < MAX_ITEM_SPELLS; ++l_Idx)
            {
                if (uint32(l_Proto->Spells[l_Idx].SpellId) == p_SpellInfo->Id)
                {
                    l_CategoryId       = l_Proto->Spells[l_Idx].SpellCategory;
                    l_Cooldown         = l_Proto->Spells[l_Idx].SpellCooldown;
                    l_CategoryCooldown = l_Proto->Spells[l_Idx].SpellCategoryCooldown;
                    break;
                }
            }
        }
    }

    // if no cooldown found above then base at DB2 data
    if (l_Cooldown < 0 && l_CategoryCooldown < 0)
    {
        l_CategoryId       = p_SpellInfo->GetCategory();
        l_Cooldown         = p_SpellInfo->RecoveryTime;
        l_CategoryCooldown = p_SpellInfo->CategoryRecoveryTime;
    }

    ACE_UINT64 l_CurTime = 0;
    ACE_OS::gettimeofday().msec(l_CurTime);

    uint64 l_CooldownTime;
    uint64 l_CategoryCooldownTime;

    bool l_NeedsCooldownPacket = false;

    ///< Demonic Trample
    if (p_SpellInfo->Id == 205629)
    {
        l_Cooldown = 45 * IN_MILLISECONDS;
        l_NeedsCooldownPacket = true;
    }

    l_Cooldown *= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);
    l_CategoryCooldown *= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);

    // overwrite time for selected category
    if (p_InfinityCooldown)
    {
        // use +MONTH as infinity mark for spell cooldown (will checked as MONTH/2 at save ans skipped)
        // but not allow ignore until reset or re-login
        l_CategoryCooldownTime = l_CategoryCooldown > 0 ? infinityCooldownDelay : 0;
        l_CooldownTime         = l_Cooldown         > 0 ? infinityCooldownDelay : l_CategoryCooldownTime;
    }
    else
    {
        // shoot spells used equipped item cooldown values already assigned in GetAttackTime(RANGED_ATTACK)
        // prevent 0 cooldowns set by another way
        if (l_Cooldown <= 0 && l_CategoryCooldown <= 0 && (l_CategoryId == 7611 || (p_SpellInfo->IsAutoRepeatRangedSpell() && p_SpellInfo->Id != 75 && p_SpellInfo->Id != 5019 && p_SpellInfo->Id != 121733)))
            l_Cooldown = GetAttackTime(WeaponAttackType::RangedAttack);

        // Now we have cooldown data (if found any), time to apply mods
        if (l_Cooldown > 0 || p_SpellInfo->Id == 85288) ///< HACK: Raging Blow has no default cooldown but it has cooldown if Warrior has Inner Rage
            ApplySpellMod(p_SpellInfo->Id, SPELLMOD_COOLDOWN, l_Cooldown, p_Spell);

        if (l_CategoryCooldown > 0 && !(p_SpellInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
            ApplySpellMod(p_SpellInfo->Id, SPELLMOD_COOLDOWN, l_CategoryCooldown, p_Spell);

        if (int32 l_CooldownMod = GetTotalAuraModifier(SPELL_AURA_MOD_COOLDOWN))
        {
            // Apply SPELL_AURA_MOD_COOLDOWN only to own spells
            if (HasSpell(p_SpellInfo->Id) || HasOverridedSpell(p_SpellInfo->Id))
            {
                l_NeedsCooldownPacket = true;
                l_Cooldown += l_CooldownMod * IN_MILLISECONDS;   // SPELL_AURA_MOD_COOLDOWN does not affect category cooldows, verified with shaman shocks
            }
        }

        AuraEffectList const& l_ListAuraCooldownByHaste = GetAuraEffectsByType(SPELL_AURA_MOD_COOLDOWN_BY_HASTE);
        if (!l_ListAuraCooldownByHaste.empty())
        {
            for (AuraEffect* l_AuraEffect : l_ListAuraCooldownByHaste)
            {
                if (l_AuraEffect->IsAffectingSpell(p_SpellInfo))
                {
                    if (l_Cooldown > 0)
                        l_Cooldown *= std::min(1.0f, GetFloatValue(UNIT_FIELD_MOD_HASTE));

                    if (l_CategoryCooldown > 0)
                        l_CategoryCooldown *= std::min(1.0f, GetFloatValue(UNIT_FIELD_MOD_HASTE));

                    l_NeedsCooldownPacket = true;
                    break;
                }
            }
        }

        l_Cooldown *= GetTotalCooldownRecoveryRateForSpell(p_SpellInfo->Id);
        l_CategoryCooldown *= GetTotalCooldownRecoveryRateForSpell(p_SpellInfo->Id);

        if (l_CategoryId)
        {
            if (int32 l_CategoryModifier = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN, l_CategoryId))
            {
                if (l_Cooldown > 0)
                    l_Cooldown += l_CategoryModifier;

                if (l_CategoryCooldown > 0)
                    l_CategoryCooldown += l_CategoryModifier;
            }

            SpellCategoryEntry const* l_CategoryEntry = sSpellCategoryStore.LookupEntry(l_CategoryId);
            if (l_CategoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET)
                l_CategoryCooldown = (sWorld->GetNextDailyQuestsResetTime() * IN_MILLISECONDS) - l_CurTime;
        }

        // replace negative cooldowns by 0
        if (l_Cooldown < 0)
            l_Cooldown = 0;

        if (l_CategoryCooldown < 0)
            l_CategoryCooldown = 0;

        // no cooldown after applying spell mods
        if (l_Cooldown == 0 && l_CategoryCooldown == 0)
            return;

        l_CategoryCooldownTime = l_CategoryCooldown ? l_CategoryCooldown : 0;
        l_CooldownTime = l_Cooldown ? l_Cooldown : l_CategoryCooldownTime;
    }

    // self spell cooldown
    if (l_CooldownTime > 0)
        AddSpellCooldown(p_SpellInfo->Id, p_ItemId, l_CooldownTime, l_NeedsCooldownPacket);
}

void Player::AddSpellCooldown(uint32 spellid, uint32 itemid, uint64 end_time, bool p_send /*= false*/)
{
    ACE_UINT64 curTime = 0;
    ACE_OS::gettimeofday().msec(curTime);

    SpellCooldown sc;
    sc.end = curTime + end_time;
    sc.itemid = itemid;
    m_spellCooldowns[spellid] = sc;

    if (p_send)
        SendSpellCooldown(spellid, 0, end_time);
}

void Player::SendCategoryCooldown(uint32 p_CategoryID, int32 p_CoolDown)
{
    WorldPacket l_Packet(SMSG_CATEGORY_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
    l_Packet << uint32(1);
    l_Packet << uint32(p_CategoryID);
    l_Packet << uint32(p_CoolDown);
    SendDirectMessage(&l_Packet);
}

void Player::SendCooldownEvent(SpellInfo const* p_SpellInfo, uint32 p_ItemID /*= 0*/, Spell* p_Spell /*= nullptr*/, bool p_SetCooldown /*= true*/, uint64 p_ItemGUID /*= 0*/)
{
    /// start cooldowns at server side, if any
    if (p_SetCooldown)
        AddSpellAndCategoryCooldowns(p_SpellInfo, p_ItemID, p_Spell);

    /// Always sent instantly after drinking a potion
    if (p_Spell && p_ItemGUID)
    {
        uint64 l_Guid = p_ItemGUID;

        AddDelayedEvent([this, l_Guid]() -> void
        {
            SendItemExpirePurchaseRefund(l_Guid);
        }, 1);
    }

    /// Sent only if drinking a potion out of combat, or when leaving combat
    if (!p_Spell || !isInCombat())
    {
        uint32 l_SpellId = p_SpellInfo->Id;

        AddDelayedEvent([this, l_SpellId]() -> void
        {
            SendCooldownEvent(l_SpellId);
        }, 1);
    }
}

void Player::SendCooldownEvent(uint32 p_SpellID)
{
    /// Send activate cooldown timer (possible 0) at client side
    WorldPacket l_Data(SMSG_COOLDOWN_EVENT, 4 + 8);

    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(false);             ///< IsPet

    SendDirectMessage(&l_Data);
}

void Player::SendItemExpirePurchaseRefund(uint64 p_Guid)
{
    WorldPacket l_Data(Opcodes::SMSG_ITEM_EXPIRE_PURCHASE_REFUND, 8);

    l_Data.appendPackGUID(p_Guid);

    SendDirectMessage(&l_Data);
}

void Player::UpdatePotionCooldown(Spell* p_Spell)
{
    /// Player just drank a potion
    if (p_Spell)
    {
        uint32 l_CategoryID = p_Spell->m_spellInfo->CategoryEntry ? p_Spell->m_spellInfo->CategoryEntry->Id : 0;

        /// Potion not linked to any category
        if (!l_CategoryID)
            return;

        auto const& l_Iter = m_LastPotions.find(l_CategoryID);

        /// No potion of this category used in combat, or still in combat
        if (l_Iter == m_LastPotions.end() || isInCombat())
        {
            /// Send SMSG_ITEM_EXPIRE_PURCHASE_REFUND when driking a potion while in combat, then SMSG_COOLDOWN_EVENT at leaving combat
            if (l_Iter != m_LastPotions.end() && l_Iter->second.m_LastPotionItemID && l_Iter->second.m_LastPotionGUID)
                SendCooldownEvent(p_Spell->m_spellInfo, 0, p_Spell, false, l_Iter->second.m_LastPotionGUID);

            return;
        }

        SendCooldownEvent(p_Spell->m_spellInfo, l_Iter->second.m_LastPotionItemID, p_Spell, true, l_Iter->second.m_LastPotionGUID);

        m_LastPotions.erase(l_CategoryID);
    }
    /// Called at combat leaving
    else
    {
        for (auto const& l_Iter : m_LastPotions)
        {
            bool l_Success = false;

            /// Spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
            if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_Iter.second.m_LastPotionItemID))
            {
                for (uint8 l_IDx = 0; l_IDx < MAX_ITEM_PROTO_SPELLS; ++l_IDx)
                {
                    if (l_Proto->Spells[l_IDx].SpellTrigger == ItemSpelltriggerType::ITEM_SPELLTRIGGER_ON_USE)
                    {
                        if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Proto->Spells[l_IDx].SpellId))
                        {
                            l_Success = true;
                            SendCooldownEvent(l_SpellInfo, l_Iter.second.m_LastPotionItemID, nullptr, true, l_Iter.second.m_LastPotionGUID);
                        }
                    }
                }
            }

            if (!l_Success && l_Iter.second.m_LastPotionSpellID)
            {
                SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Iter.second.m_LastPotionSpellID);
                SendCooldownEvent(l_SpellInfo, l_Iter.second.m_LastPotionItemID, nullptr, true, l_Iter.second.m_LastPotionGUID);
            }
        }

        m_LastPotions.clear();
    }
}
                                                           //slot to be excluded while counting
bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
{
    if (!enchantmentcondition)
        return true;

    SpellItemEnchantmentConditionEntry const* Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);
    if (!Condition)
        return true;

    uint8 curcount[4] = { 0, 0, 0, 0 };

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == slot)
            continue;

        Item* item2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (item2 && !item2->IsBroken())
        {
            for (ItemDynamicFieldGems const& gemData : item2->GetGems())
            {
                ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemData.ItemId);
                if (!gemProto)
                    continue;

                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GemProperties);
                if (!gemProperty)
                    continue;

                for (uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
                    if (tmpcolormask & gemProperty->Type)
                        ++curcount[b];
            }
        }
    }

    bool activate = true;

    for (uint8 i = 0; i < 5; i++)
    {
        if (!Condition->LTOperandType[i])
            continue;

        uint32 _cur_gem = curcount[Condition->LTOperandType[i] - 1];
        uint32 _cmp_gem = Condition->RTOperandType[i] ? curcount[Condition->RTOperandType[i] - 1] : Condition->RTOperand[i];

        switch (Condition->Operator[i])
        {
        case 2:
            activate &= (_cur_gem < _cmp_gem) ? true : false;
            break;
        case 3:
            activate &= (_cur_gem > _cmp_gem) ? true : false;
            break;
        case 5:
            activate &= (_cur_gem >= _cmp_gem) ? true : false;
            break;
        }
    }

    return activate;
}

void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
{
                                                            //cycle all equipped items
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        //enchants for the slot being socketed are handled by Player::ApplyItemMods
        if (slot == exceptslot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)
            continue;

        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            if (uint32 condition = enchantEntry->ConditionID)
            {
                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
                if (wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
                    ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), !wasactive, true, true);
            }
        }
    }
}

void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
{
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        if (slot == exceptslot)
            continue;

        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
        if (!item || !item->GetSocketColor(0))
            continue;

        for (uint32 enchantSlot = SOCK_ENCHANTMENT_SLOT; enchantSlot < SOCK_ENCHANTMENT_SLOT + 3; ++enchantSlot)
        {
            uint32 enchantID = item->GetEnchantmentId(EnchantmentSlot(enchantSlot));
            if (!enchantID)
                continue;

            if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantID))
                if (enchantEntry->ConditionID)
                    ApplyEnchantment(item, EnchantmentSlot(enchantSlot), apply);
        }
    }
}

void Player::HandleDeserterAfterLeaveQueue(int32 p_RatingChange /*= 0*/, int32 p_MMRChange /*= 0*/, uint8 p_Slot /*= 0*/, bool p_Deserter /*= true*/)
{
    uint64 l_Value = GetLeaveQueueCounter();

    if (p_Deserter)
        SetLeaveQueueCounter(++l_Value);

    if (p_RatingChange < 0 || p_MMRChange < 0)
    {
        SetArenaPersonalRating(p_Slot, std::max(0, (int)GetArenaPersonalRating(p_Slot) + p_RatingChange));
        SetArenaMatchMakerRating(p_Slot, std::max(0, (int)GetArenaMatchMakerRating(p_Slot) + p_MMRChange));

        IncrementWeekGames(p_Slot);
        IncrementSeasonGames(p_Slot);
    }

    if (p_Deserter)
    {
        SpellInfo const* l_Deserter = sSpellMgr->GetSpellInfo(MS::Battlegrounds::Spells::DeserterBuff);
        if (l_Deserter == nullptr)
            return;

        int32 l_Duration = l_Deserter->DurationEntry->MaxDuration;
        switch (l_Value)
        {
            /// First decline: 1min deserter
            case 1:
            {
                l_Duration = 1 * TimeConstants::MINUTE * TimeConstants::IN_MILLISECONDS;
                break;
            }
            /// Second decline: 5min deserter
            case 2:
            {
                l_Duration = 5 * TimeConstants::MINUTE * TimeConstants::IN_MILLISECONDS;
                break;
            }
            /// Third and + decline: full deserter duration
            case 3:
            default:
                break;
        }

        RemoveAura(MS::Battlegrounds::Spells::DeserterBuff);
        CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);

        AddDelayedEvent([this, l_Duration, l_Deserter]() -> void
        {
            RemoveAura(MS::Battlegrounds::Spells::DeserterBuff);
            CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);

            if (l_Duration != l_Deserter->DurationEntry->MaxDuration)
            {
                if (Aura* l_Debuff = GetAura(MS::Battlegrounds::Spells::DeserterBuff))
                {
                    l_Debuff->SetDuration(l_Duration);
                    l_Debuff->SetMaxDuration(l_Duration);
                }
            }
        });
    }
}

void Player::SetBattlegroundEntryPoint()
{
    // Taxi path store
    if (!m_taxi.IsPathEmpty())
    {
        m_bgData.mountSpell  = 0;
        m_bgData.taxiPath[0] = m_taxi.GetTaxiSource();
        m_bgData.taxiPath[1] = m_taxi.GetTaxiDestination();

        // On taxi we don't need check for dungeon
        m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }
    else
    {
        m_bgData.ClearTaxiPath();

        // Mount spell id storing
        if (IsMounted())
        {
            AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOUNTED);
            if (!auras.empty())
                m_bgData.mountSpell = (*auras.begin())->GetId();
        }
        else
            m_bgData.mountSpell = 0;

        if (Aura* aur = GetAura(33943))
            m_bgData.mountSpell = 33943;

        // If map is dungeon find linked graveyard
#ifndef CROSS
        if (GetMap()->IsDungeon() && !IsInDraenorGarrison())
#else /* CROSS */
        if (GetMap()->IsDungeon())
#endif /* CROSS */
        {
            if (const WorldSafeLocsEntry* entry = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam()))
                m_bgData.joinPos = WorldLocation(entry->MapID, entry->x, entry->y, entry->z, 0.0f);
            else
                sLog->outError(LOG_FILTER_PLAYER, "SetBattlegroundEntryPoint: Dungeon map %u has no linked graveyard, setting home location as entry point.", GetMapId());
        }
        // If new entry point is not BG or arena set it
        else if (!GetMap()->IsBattlegroundOrArena())
            m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }

    if (m_bgData.joinPos.m_mapId == MAPID_INVALID) // In error cases use homebind position
        m_bgData.joinPos = WorldLocation(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0.0f);
}

#ifndef CROSS
void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    if (Battleground* bg = GetBattleground())
    {
        bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);
        SetInRandomBG(false);

        sScriptMgr->OnLeaveBG(this, bg->GetMapId());

        // call after remove to be sure that player resurrected for correct cast
        if (bg->isBattleground() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                //lets check if player was teleported from BG and schedule delayed Deserter spell cast
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);
            }
        }
    }
}

#endif /* not CROSS */
bool Player::CanJoinToBattleground() const
{
    /// Check Deserter debuff.
    if (HasAura(MS::Battlegrounds::Spells::DeserterBuff))
        return false;

    return true;
}

bool Player::CanReportAfkDueToLimit()
{
    // a player can complain about 15 people per 5 minutes
    if (m_bgData.bgAfkReportedCount++ >= 15)
        return false;

    return true;
}

///This player has been blamed to be inactive in a battleground
void Player::ReportedAfkBy(Player* reporter)
{
    Battleground* bg = GetBattleground();
    // Battleground also must be in progress!
    if (!bg || bg != reporter->GetBattleground() || GetTeam() != reporter->GetTeam() || bg->GetStatus() != STATUS_IN_PROGRESS)
        return;

    // check if player has 'Idle' or 'Inactive' debuff
    if (m_bgData.bgAfkReporter.find(reporter->GetGUIDLow()) == m_bgData.bgAfkReporter.end() && !HasAura(43680) && !HasAura(43681) && reporter->CanReportAfkDueToLimit())
    {
        m_bgData.bgAfkReporter.insert(reporter->GetGUIDLow());
        // 5 players have to complain to apply debuff
        if (m_bgData.bgAfkReporter.size() >= 5)
        {
            // cast 'Idle' spell
            //CastSpell(this, 43680, true);
            CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);
            m_bgData.bgAfkReporter.clear();
#ifndef CROSS
            LeaveBattleground();
#else /* CROSS */

            // afk player not allowed in battleground
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
            bg->RemoveFromInterRealm(GetGUID());
#endif /* CROSS */
        }
    }
}

WorldLocation Player::GetStartPosition() const
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    uint32 mapId = info->mapId;
    if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
        mapId = 0;
    return WorldLocation(mapId, info->positionX, info->positionY, info->positionZ, 0);
}

WorldLocation* Player::GetPreviousLocation()
{
    return &m_PreviousLocation;
}

bool Player::IsNeverVisible() const
{
    if (Unit::IsNeverVisible())
        return true;

    if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
        return true;

    return false;
}

bool Player::CanAlwaysSee(WorldObject const* obj) const
{
    // Always can see self
    if (m_mover == obj)
        return true;

    if (uint64 guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT))
        if (obj->GetGUID() == guid)
            return true;

    return false;
}

bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
{
    if (Unit::IsAlwaysDetectableFor(seer))
        return true;

    if (const Player* seerPlayer = seer->ToPlayer())
        if (IsGroupVisibleFor(seerPlayer))
            return !(seerPlayer->m_Duel && seerPlayer->m_Duel->startTime != 0 && seerPlayer->m_Duel->opponent == this);

     return false;
 }

bool Player::IsVisibleGloballyFor(Player* u) const
{
    if (!u)
        return false;

    // Always can see self
    if (u == this)
        return true;

    // Visible units, always are visible for all players
    if (IsVisible())
        return true;

    // GMs are visible for higher gms (or players are visible for gms)
    if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
        return GetSession()->GetSecurity() <= u->GetSession()->GetSecurity();

    // non faction visibility non-breakable for non-GMs
    if (!IsVisible())
        return false;

    // non-gm stealth/invisibility not hide from global player lists
    return true;
}

template<class T>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, T* target, std::set<Unit*>& /*v*/)
{
    s64.insert(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, GameObject* target, std::set<Unit*>& /*v*/)
{
    // But exclude stoppable elevators from this hack - they would be teleporting from one end to another
    // if affected transports move so far horizontally that it causes them to run out of visibility range then you are out of luck
    // fix visibility instead of adding hacks here
    if (!target->IsTransport())
        s64.insert(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, Creature* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, Player* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<class T>
inline void BeforeVisibilityDestroy(T* /*t*/, Player* /*p*/)
{
}

template<>
inline void BeforeVisibilityDestroy<Creature>(Creature* t, Player* p)
{
    if (p->GetPetGUID() == t->GetGUID() && t->ToCreature()->isPet())
        t->ToPet()->Remove(PET_SLOT_OTHER_PET, true, t->ToPet()->m_Stampeded);
}

void Player::UpdateVisibilityOf(WorldObject* target)
{
    if (HaveAtClient(target))
    {
        if (!canSeeOrDetect(target, false, true))
        {
            if (PreventClientDestroyFor(target->GetGUID()))
                return;

            if (target->GetTypeId() == TYPEID_UNIT)
                BeforeVisibilityDestroy<Creature>(target->ToCreature(), this);

            target->DestroyForPlayer(this);

            m_clientGUIDs_lock.acquire_write();
            m_clientGUIDs.erase(target->GetGUID());
            m_clientGUIDs_lock.release();

            m_VignetteMgr.OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else
    {
        if (canSeeOrDetect(target, false, true))
        {
            target->SendUpdateToPlayer(this);

            m_clientGUIDs_lock.acquire_write();
            m_clientGUIDs.insert(target->GetGUID());
            m_clientGUIDs_lock.release();

            m_VignetteMgr.OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif

            // target aura duration for caster show only if target exist at caster client
            // send data at target visibility change (adding to client)
            if (target->isType(TYPEMASK_UNIT))
                SendInitialVisiblePackets((Unit*)target);
        }
    }
}

void Player::UpdateTriggerVisibility()
{
    m_clientGUIDs_lock.acquire_read();

    if (m_clientGUIDs.empty())
    {
        m_clientGUIDs_lock.release();
        return;
    }

    if (!IsInWorld())
    {
        m_clientGUIDs_lock.release();
        return;
    }

    UpdateData udata(GetMapId());
    WorldPacket packet;

    for (auto itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_CREATURE_GUID(*itr))
        {
            Creature* obj = GetMap()->GetCreature(*itr);
            if (!obj || (!obj->isTrigger() && !obj->HasAuraType(SPELL_AURA_TRANSFORM) && !obj->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE)))
                continue;

            obj->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            obj->BuildValuesUpdateBlockForPlayer(&udata, this);
            obj->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
        else if (IS_GAMEOBJECT_GUID((*itr)))
        {
            GameObject* go = GetMap()->GetGameObject(*itr);
            if (!go)
                continue;

            go->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            go->BuildValuesUpdateBlockForPlayer(&udata, this);
            go->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
    }

    m_clientGUIDs_lock.release();

    if (!udata.HasData())
        return;

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::SendInitialVisiblePackets(Unit* p_Target)
{
    SendAurasForTarget(p_Target);

    if (p_Target->isAlive())
    {
        if (p_Target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && p_Target->getVictim())
            p_Target->SendMeleeAttackStart(p_Target->getVictim());
    }
}

template<class T>
void Player::UpdateVisibilityOf(T* p_Target, UpdateData& p_UpdData, std::set<Unit*>& p_VisibleNow)
{
    if (HaveAtClient(p_Target))
    {
        if (!canSeeOrDetect(p_Target, false, true))
        {
            BeforeVisibilityDestroy<T>(p_Target, this);

            p_Target->BuildOutOfRangeUpdateBlock(&p_UpdData);

            m_clientGUIDs_lock.acquire_write();
            m_clientGUIDs.erase(p_Target->GetGUID());
            m_clientGUIDs_lock.release();

            m_VignetteMgr.OnWorldObjectDisappear(p_Target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is out of range for player %u. Distance = %f", p_Target->GetGUIDLow(), p_Target->GetTypeId(), p_Target->GetEntry(), GetGUIDLow(), GetDistance(p_Target));
            #endif
        }
    }
    else
    {
        if (canSeeOrDetect(p_Target, false, true))
        {
            p_Target->BuildCreateUpdateBlockForPlayer(&p_UpdData, this);

            m_clientGUIDs_lock.acquire_write();
            UpdateVisibilityOf_helper(m_clientGUIDs, p_Target, p_VisibleNow);
            m_clientGUIDs_lock.release();

            m_VignetteMgr.OnWorldObjectAppear(p_Target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is visible now for player %u. Distance = %f", p_Target->GetGUIDLow(), p_Target->GetTypeId(), p_Target->GetEntry(), GetGUIDLow(), GetDistance(p_Target));
            #endif
        }
    }
}

template void Player::UpdateVisibilityOf(Player*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Creature*      target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Corpse*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(GameObject*    target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(DynamicObject* target, UpdateData& data, std::set<Unit*>& visibleNow);

thread_local UpdateData tl_UpdateData_UpdateVisibilityForPlayer;

void Player::UpdateVisibilityForPlayer(bool p_CreateGrids)
{
    tl_UpdateData_UpdateVisibilityForPlayer.Clear();
    tl_UpdateData_UpdateVisibilityForPlayer.SetMap(GetMapId());

    Map* l_Map = m_seer->GetMap();

    if (l_Map)
        l_Map->m_GridsNotFullyLoadedInVisit = false;

    // updates visibility of all objects around point of view for current player
    m_clientGUIDs_lock.acquire_read();
    JadeCore::VisibleNotifier notifier(*this, tl_UpdateData_UpdateVisibilityForPlayer);
    m_clientGUIDs_lock.release();
    m_seer->VisitNearbyObject(GetSightRange(), notifier, p_CreateGrids);
    notifier.SendToSelf();   // send gathered data

    if (l_Map && l_Map->m_GridsNotFullyLoadedInVisit)
    {
        l_Map->m_GridsNotFullyLoadedInVisit = false;
        m_NeedForcedVisibilityUpdate = true;
    }
}

void Player::InitPrimaryProfessions()
{
    SetFreePrimaryProfessions(sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL));
}

void Player::ModifyMoney(int64 d, std::string p_Source)
{
    sScriptMgr->OnPlayerMoneyChanged(this, d);

    if (d < 0)
        SetMoney (GetMoney() > uint64(-d) ? GetMoney() + d : 0);
    else
    {
        uint64 newAmount = 0;
        if (GetMoney() < uint64(MAX_MONEY_AMOUNT - d))
            newAmount = GetMoney() + d;
        else
        {
            // "At Gold Limit"
            newAmount = MAX_MONEY_AMOUNT;
            if (d)
                SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD, NULL, NULL);
        }
        SetMoney(newAmount);
    }
}

void Player::SetMoney(uint64 value)
{
    SetUInt64Value(PLAYER_FIELD_COINAGE, value);
    MoneyChanged(value);
    UpdateCriteria(CRITERIA_TYPE_HIGHEST_GOLD_VALUE_OWNED);
}

void Player::SendWorldQuestUpdate()
{
    auto const& l_ActiveWorldQuests = sWorldQuestGenerator->GetActiveWorldQuests();
    int l_Count = 0;

    WorldPacket l_Data(SMSG_WORLD_QUEST_UPDATE, 200);
    l_Data << uint32(0);

    l_ActiveWorldQuests.safe_foreach(true, [this, &l_Data, &l_Count](MS::WorldQuest::ActiveWorldQuestsList::const_iterator& p_Itr) -> void
    {
        if (GetWorldQuestManager()->CanBeNotifiedToClient(p_Itr->second->m_ID) && GetWorldQuestManager())
        {
            l_Data << uint32(p_Itr->second->m_CreationTime);
            l_Data << uint32(p_Itr->second->m_ID);
            l_Data << uint32(p_Itr->second->m_Duration);
            l_Data << uint32(p_Itr->second->m_Template->GetWorldStateID());
            l_Data << uint32(p_Itr->second->m_Template->GetWorldStateValue()); /// Value
            ++l_Count;
        }
    });

    l_Data.put<uint32>(0, l_Count);
    SendDirectMessage(&l_Data);
}

void Player::SendAllTaskProgress()
{
    uint32 l_Count = 0;

    WorldPacket l_Data(SMSG_SET_ALL_TASK_PROGRESS, 200);
    l_Data << uint32(0);

    for (auto l_Current : MS::WorldQuest::Template::GetAreaGroupMap())
    {
        uint32 l_QuestID = l_Current.first;

        if (GetWorldQuestManager()->CanBeNotifiedToClient(l_QuestID))
        {
            bool l_AllNull = true;

            auto l_QuestInfo = sObjectMgr->GetQuestTemplate(l_QuestID);

            for (auto const& l_Objective : l_QuestInfo->QuestObjectives)
            {
                if (GetQuestObjectiveCounter(l_Objective.ID))
                {
                    l_AllNull = false;
                    break;
                }
            }

           // if (!l_AllNull)
            {
                l_Data << uint32(l_QuestID);    ///< QuestID
                l_Data << uint32(0);            ///< FailTimer
                l_Data << uint32(0);            ///< Flags
                l_Data << uint32(l_QuestInfo->QuestObjectives.size());

                for (auto const& l_Objective : l_QuestInfo->QuestObjectives)
                {
                    l_Data << uint16(GetQuestObjectiveCounter(l_Objective.ID));
                }

                ++l_Count;
            }
        }
    }

    l_Data.put<uint32>(0, l_Count);
    SendDirectMessage(&l_Data);
}

Unit* Player::GetSelectedUnit() const
{
    if (m_curSelection)
        return ObjectAccessor::GetUnit(*this, m_curSelection);
    return NULL;
}

Player* Player::GetSelectedPlayer() const
{
    if (m_curSelection)
        return ObjectAccessor::GetPlayer(*this, m_curSelection);
    return NULL;
}

void Player::SetGroup(GroupPtr p_Group, int8 p_Subgroup)
{
    if (p_Group == nullptr && m_Group)
        m_Group->UnlinkPlayer(this);
    else if (m_Group)
    {
        ACE_Stack_Trace trace;
        sLog->outExtChat("#jarvis", "danger", true, "Try to override group");
        sLog->outExtChat("#jarvis", "danger", true, trace.c_str());
        m_Group->UnlinkPlayer(this);
    }

    if (p_Group)
        p_Group->LinkPlayer(this);

    m_Group = p_Group;
    m_SubGroup = p_Subgroup;

    sLFGMgr->SetPlayerGroup(GetGUIDLow(), p_Group ? GUID_LOPART(p_Group->GetGUID()) : 0);

    AddCriticalOperation([this]()->void
    {
        UpdateObjectVisibility(false);
    });
}

void Player::SendInitialPacketsBeforeAddToMap()
{
    //if (!(m_teleport_options & TELE_TO_SEAMLESS)) NYI!
    {
        m_movementCounter = 0;
        ResetTimeSync();
    }

     SendTimeSync();

#ifndef CROSS
    /// Pass 'this' as argument because we're not stored in ObjectAccessor yet
    GetSocial()->SendSocialList(this);
#endif

    // Guild bank list wtf?

    // Homebind
    WorldPacket l_Data(SMSG_BIND_POINT_UPDATE, 5 * 4);
    l_Data << m_homebindX << m_homebindY << m_homebindZ;
    l_Data << uint32(m_homebindMapId);
    l_Data << uint32(m_homebindAreaId);
    GetSession()->SendPacket(&l_Data);

    // SMSG_SET_PROFICIENCY
    // SMSG_SET_PCT_SPELL_MODIFIER
    // SMSG_SET_FLAT_SPELL_MODIFIER
    // SMSG_UPDATE_AURA_DURATION

    SendTalentsInfoData();

    SendKnownSpells();

    //4374 - summon pet spell in packet - 111896, 111895, 111859, 111897, 111898
    //5376

    SendGlyphs();

    SendInitialActionButtons();
    m_reputationMgr.SendInitialReputations();
    m_reputationMgr.SendFactionBonusInfo();

    uint32 l_PlayerArtifactKnowledge = getLevel() >= 110 ? sWorld->GetCurrentArtifactKnowledge() : 0;

    l_Data.Initialize(SMSG_ARTIFACT_KNOWLEDGE);
    l_Data << uint32(1);
    l_Data << uint8(sWorld->GetCurrentArtifactKnowledge());
    GetSession()->SendPacket(&l_Data);

    l_Data.Initialize(SMSG_ARTIFACT_KNOWLEDGE);
    l_Data << uint32(2);
    l_Data << uint8(0);
    GetSession()->SendPacket(&l_Data);

    SendEquipmentSetList();

    m_achievementMgr->SendAllData(this);

    l_Data.Initialize(SMSG_LOGIN_SET_TIME_SPEED, 4 * 5);
    l_Data << uint32(MS::Utilities::WowTime::Encode(sWorld->GetGameTime())); ///< ServerTime
    l_Data << uint32(MS::Utilities::WowTime::Encode(sWorld->GetGameTime())); ///< GameTime
    l_Data << float(0.01666667f);                                            ///< NewSpeed
    l_Data << uint32(0);                                                     ///< ServerTimeHolidayOffset
    l_Data << uint32(0);                                                     ///< GameTimeHolidayOffset
    GetSession()->SendPacket(&l_Data);

    Map* l_Map          = GetMap();
    bool l_IsInInstance = false;
    uint32 l_Size       = l_Map->GetPlayers().getSize();

    if (MapDifficultyEntry const* l_Diff = l_Map->GetMapDifficulty())
    {
        l_IsInInstance = l_Diff->MaxPlayers != 0;

        if (l_Map->Expansion() < Expansion::EXPANSION_WARLORDS_OF_DRAENOR ||
            (l_Diff->DifficultyID != Difficulty::DifficultyRaidNormal && l_Diff->DifficultyID != Difficulty::DifficultyRaidHeroic))
            l_Size = l_Diff->MaxPlayers;
    }

    l_Data.Initialize(SMSG_WORLD_SERVER_INFO, 4 * 5);
    l_Data << uint32(GetMap()->GetDifficultyID());                            ///< DifficultyID
    l_Data << uint8(0);                                                       ///< Is Tournament Realm
    l_Data.WriteBit(false);                                                   ///< XRealmPvpAlert
    l_Data.WriteBit(false);                                                   ///< Has Restricted Account Max Level
    l_Data.WriteBit(false);                                                   ///< Has Restricted Account Max Money
    l_Data.WriteBit(l_IsInInstance);                                          ///< Has Instance Group Size

    l_Data.FlushBits();

    if (l_IsInInstance)
        l_Data << uint32(l_Size);

    GetSession()->SendPacket(&l_Data);

    l_Data.Initialize(SMSG_INITIAL_SETUP, 2062);
    l_Data << uint8(sWorld->getIntConfig(CONFIG_EXPANSION));      ///< Server Expansion Level
    l_Data << uint8(0);                                           ///< Server Expansion Tier
    GetSession()->SendPacket(&l_Data);

    if (Pet* l_Pet = GetPet())
    {
        l_Data.Initialize(SMSG_PET_GUIDS);
        l_Data << uint32(1);
        l_Data.appendPackGUID(l_Pet->GetGUID());
        GetSession()->SendPacket(&l_Data);
    }

    // SMSG_UPDATE_WORLD_STATE
    // SMSG_POWER_UPDATE

    SendCurrencies();
    SetMover(this);

    /// Unlock WoD heroic dungeons
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37213))   ///< FLAG - Proving Grounds - Damage Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33090))   ///< FLAG - Proving Grounds - Damage Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33096))   ///< FLAG - Proving Grounds - Healer Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37219))   ///< FLAG - Proving Grounds - Healer Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37216))   ///< FLAG - Proving Grounds - Tank Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33093))   ///< FLAG - Proving Grounds - Tank Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(41694))   ///< FLAG - Unlock WQuests
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(43341))   ///< FLAG - Unlock WQuests 2
        SetQuestBit(l_QuestBit, true);

    GetSession()->GetCollectionMgr()->SendFavoriteAppearances();

    if (GetGarrison())
        GetGarrison()->SendRemoteInformations();
}

void Player::SendSpellHistory()
{
    ACE_UINT64 l_CurTime = 0;
    ACE_OS::gettimeofday().msec(l_CurTime);

    WorldPacket l_HistoryData(SMSG_SEND_SPELL_HISTORY, 2 * 1024);
    l_HistoryData << uint32(GetSpellCooldownMap().size());

    for (SpellCooldowns::const_iterator l_Itr = GetSpellCooldownMap().begin(); l_Itr != GetSpellCooldownMap().end(); ++l_Itr)
    {
        l_HistoryData << uint32(l_Itr->first);
        l_HistoryData << uint32(l_Itr->second.itemid);

        bool l_HasCooldown = l_Itr->second.end > l_CurTime;

        uint32 l_Category             = 0;
        uint32 l_CategoryRecoveryTime = 0;
        uint32 l_RecoveryTime         = l_Itr->second.end - l_CurTime;
        float  l_ModRate              = 1.0f;

        if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Itr->second.itemid))
        {
            for (uint8 l_I = 0; l_I < MAX_ITEM_SPELLS; ++l_I)
            {
                if (uint32(l_ItemProto->Spells[l_I].SpellId) == l_Itr->first)
                {
                    l_Category             = l_ItemProto->Spells[l_I].SpellCategory;
                    l_CategoryRecoveryTime = l_ItemProto->Spells[l_I].SpellCategoryCooldown;
                    break;
                }
            }
        }

        l_HistoryData << uint32(l_Category);
        l_HistoryData << uint32(l_HasCooldown ? l_RecoveryTime : 0);
        l_HistoryData << uint32(l_CategoryRecoveryTime);
        l_HistoryData << float(l_ModRate);

        l_HistoryData.WriteBit(false);  ///< OnHold
        l_HistoryData.WriteBit(false);
        l_HistoryData.WriteBit(false);

        l_HistoryData.FlushBits();
    }

    GetSession()->SendPacket(&l_HistoryData);
}

void Player::SendInitialPacketsAfterAddToMap()
{
    UpdateVisibilityForPlayer(true);

    // update zone
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea, true);
    UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();

    CastSpell(this, 836, true);                             // LOGINEFFECT

    // set some aura effects that send packet to player client after add player to map
    // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
    // same auras state lost at far teleport, send it one more time in this case also
    static const AuraType auratypes[] =
    {
        SPELL_AURA_MOD_FEAR,     SPELL_AURA_TRANSFORM,                 SPELL_AURA_WATER_WALK,
        SPELL_AURA_FEATHER_FALL, SPELL_AURA_HOVER,                     SPELL_AURA_SAFE_FALL,
        SPELL_AURA_FLY,          SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED, SPELL_AURA_NONE
    };
    for (AuraType const* itr = &auratypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        Unit::AuraEffectList const& auraList = GetAuraEffectsByType(*itr);
        if (!auraList.empty())
            auraList.front()->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
    }

    SendRefreshSpellMods();

    RemoveAllMovementForces();

    if (HasAuraType(SPELL_AURA_MOD_STUN))
        SetRooted(true);

    // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
    if (HasAuraType(SPELL_AURA_MOD_ROOT) || HasAuraType(SPELL_AURA_MOD_ROOT_2))
        SendMoveRoot(0);

    SendSpellHistory();
    SendSpellCharges();
    SendAurasForTarget(this);
    SendEnchantmentDurations();                             // must be after add to map
    SendItemDurations();                                    // must be after add to map

    CutOffItemLevel(false);
    RescaleAllItemsIfNeeded();

    ApplyWargameItemModifications();

    AuraEffectList const& l_ModSpeedAuras = GetAuraEffectsByType(SPELL_AURA_MOD_SPEED_ALWAYS);
    for (AuraEffectList::const_iterator iter = l_ModSpeedAuras.begin(); iter != l_ModSpeedAuras.end(); iter++)
        (*iter)->RecalculateAmount((*iter)->GetCaster(), true);

    if (GetMap()->IsRaid())
    {
        m_PrevMapDifficulty = GetMap()->GetDifficultyID();
        if (DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(m_PrevMapDifficulty))
            SendRaidDifficulty((l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0, m_PrevMapDifficulty);
    }
    else if (GetMap()->IsNonRaidDungeon())
    {
        m_PrevMapDifficulty = GetMap()->GetDifficultyID();
        SendDungeonDifficulty(m_PrevMapDifficulty);
    }
    else if (!GetMap()->Instanceable())
    {
        if (DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(m_PrevMapDifficulty))
            SendRaidDifficulty((l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0);
    }

    GetSession()->SendBattlePetJournal();

    if (GetSkillValue(SKILL_ARCHAEOLOGY))
    {
        m_archaeologyMgr.PropagateResearchSites();
        m_archaeologyMgr.PropagateResearchProjects();
    }

    if (getClass() == CLASS_HUNTER)
        GetSession()->SendStablePet(0);

    // Hack fix for remove flags auras after crash
    if (!GetMap()->IsBattlegroundOrArena())
        RemoveFlagsAuras();

    // Hack fix for AURA_STATE_PVP_PREPARATION.
    if (GetBattleground() && GetBattleground()->GetStatus() == BattlegroundStatus::STATUS_WAIT_JOIN)
        ModifyAuraState(AURA_STATE_PVP_RAID_PREPARE, true);

    GroupPtr l_Group = GetGroup();

    /// Fix ghost group leader flag
    if (!l_Group || !l_Group->IsLeader(GetGUID()))
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);

    WorldPacket l_NullPacket;
    GetSession()->HandleLfgGetStatus(l_NullPacket);

#ifndef CROSS
    /// Force map shift update
    if ((GetMapId() == MS::Garrison::GDraenor::Globals::BaseMap && m_Garrison) || IsInDraenorGarrison())
    {
        phaseMgr.Update();
        phaseMgr.ForceMapShiftUpdate();
    }

    if (IsInDraenorGarrison())
        m_Garrison->OnPlayerEnter();
#endif

    std::map<uint32, bool> l_MountSpells;
    for (PlayerSpellMap::iterator l_It = m_spells.begin(); l_It != m_spells.end(); l_It++)
    {
        if (!l_It->second)
            continue;

        if (const SpellInfo * spell = sSpellMgr->GetSpellInfo(l_It->first))
        {
            if (spell->IsAbilityOfSkillType(SKILL_MOUNT) || spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE)
            {
                l_MountSpells[l_It->first] = l_It->second->IsMountFavorite;
            }
        }
    }

    WorldPacket l_Data(SMSG_ACCOUNT_MOUNT_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);                      ///< Is full update
    l_Data.FlushBits();
    l_Data << uint32(l_MountSpells.size());

    for (auto l_Pair : l_MountSpells)
    {
        l_Data << uint32(l_Pair.first);
        l_Data.WriteBits(l_Pair.second ? 2 : 0, 2);
        l_Data.FlushBits();
    }

    SendDirectMessage(&l_Data);
    GetSession()->SendTwitterStatus(true);

    if (GroupPtr l_Group = GetGroup())
        l_Group->SendUpdate();

    if (HasAura(196055))   ///< Cannot be done any other way
        SendMovementSetCanDoubleJump(true);

    /// Prevent crash caused by data race
    Player* l_Player = this;
    AddDelayedEvent([l_Player]() -> void
    {
        l_Player->GetWorldQuestManager()->OnLogin();

        if (InstanceScript* l_Instance = l_Player->GetInstanceScript())
        {
            if (l_Instance->IsEncounterInProgress() && l_Player->isDead() && l_Instance->GetCurrentEncounter())
            {
                l_Instance->SendEncounterUnit(EncounterFrameType::ENCOUNTER_FRAME_START);
                l_Instance->SendEncounterStart(l_Instance->GetCurrentEncounter(), l_Player);
            }
        }
    }, 1);

    UpdateWorldQuests(0, GetBaseMap()->GetAreaId(GetPositionX(), GetPositionY(), GetPositionZ()));

    // send step data when entering scenarios
    if (Scenario* progress = sScenarioMgr->GetScenario(GetMap()->GetScenarioGuid()))
        progress->SendStepUpdate(this, true);

    if (m_CelestialBodyID)
        SendUpdateCelestialBody(m_CelestialBodyID);

    sLFGListMgr->OnPlayerLogin(this);
}

void Player::SendUpdateToOutOfRangeGroupMembers()
{
    if (m_groupUpdateMask == GROUP_UPDATE_FLAG_NONE)
        return;

    if (GroupPtr group = GetGroup())
        group->UpdatePlayerOutOfRange(this);

    m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;
    m_auraRaidUpdateMask.reset();

    if (Pet* pet = GetPet())
        pet->ResetAuraUpdateMaskForRaid();
}

void Player::SendTransferAborted(uint32 mapid, TransferAbortReason reason, uint8 arg)
{
    WorldPacket data(SMSG_TRANSFER_ABORTED, 4 + 2 + 4 + 1);
    data << uint32(mapid);
    data << uint8(arg);
    data << uint32(0);          ///< MapDifficultyXConditionID
    data.WriteBits(reason, 5);
    data.FlushBits();

    GetSession()->SendPacket(&data);
}

void Player::SendRaidInstanceMessage(uint32 p_MapID, Difficulty p_Difficulty, uint32 p_Time, bool p_Welcome)
{
    if (p_Difficulty == Difficulty::DifficultyMythic)
        return;

    // type of warning, based on the time remaining until reset
    uint32 l_Type;
    if (p_Welcome)
        l_Type = RAID_INSTANCE_WELCOME;
    else if (p_Time > 21600)
        l_Type = RAID_INSTANCE_WELCOME;
    else if (p_Time > 3600)
        l_Type = RAID_INSTANCE_WARNING_HOURS;
    else if (p_Time > 300)
        l_Type = RAID_INSTANCE_WARNING_MIN;
    else
        l_Type = RAID_INSTANCE_WARNING_MIN_SOON;

    bool l_Locked;
    if (InstancePlayerBindPtr bind = GetBoundInstance(p_MapID, p_Difficulty))
        l_Locked = bind->perm;
    else
        l_Locked = false;

    WorldPacket l_Data(SMSG_RAID_INSTANCE_MESSAGE, 1 + 4 * 3 + 1);
    l_Data << uint8(l_Type);
    l_Data << uint32(p_MapID);
    l_Data << uint32(p_Difficulty);
    l_Data.WriteBit(l_Locked);                            ///< is locked
    l_Data.WriteBit(0);                                   ///< is extended, ignored if prev field is 0
    l_Data.FlushBits();

    GetSession()->SendPacket(&l_Data);
}

void Player::SendInstanceGroupSizeChanged(uint32 p_Size)
{
    WorldPacket l_Data(Opcodes::SMSG_INSTANCE_GROUP_SIZE_CHANGED, 4);
    l_Data << uint32(p_Size);
    GetSession()->SendPacket(&l_Data);
}

void Player::HandleItemSetBonuses(bool p_Apply)
{
    for (uint8 l_I = 0; l_I < InventorySlots::INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (m_items[l_I])
        {
            ItemTemplate const* l_Proto = m_items[l_I]->GetTemplate();
            if (!l_Proto)
                continue;

            if (l_Proto->ItemSet)
            {
                if (p_Apply)
                    AddItemsSetItem(this, m_items[l_I]);
                else
                    RemoveItemsSetItem(this, l_Proto);
            }
        }
    }
}

void Player::HandleGemBonuses(bool p_Apply)
{
    for (uint8 l_I = 0; l_I < InventorySlots::INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            if (!l_Item->IsEquipped())
                continue;

            for (uint32 l_EnchantSlot = EnchantmentSlot::SOCK_ENCHANTMENT_SLOT; l_EnchantSlot < EnchantmentSlot::SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++l_EnchantSlot)
                ApplyEnchantment(l_Item, EnchantmentSlot(l_EnchantSlot), p_Apply);
        }
    }
}

void Player::ApplyEquipCooldown(Item* p_Item)
{
    if (p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, int32(ItemFlags::NO_EQUIP_COOLDOWN)))
        return;

    for (uint8 l_I = 0; l_I < MAX_ITEM_PROTO_SPELLS; ++l_I)
    {
        _Spell const& l_SpellData = p_Item->GetTemplate()->Spells[l_I];

        // no spell
        if (!l_SpellData.SpellId)
            continue;

        // wrong triggering type (note: ITEM_SPELLTRIGGER_ON_NO_DELAY_USE not have cooldown)
        if (l_SpellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        //! Don't replace longer cooldowns by equi cooldown if we have any.
        SpellCooldowns::iterator l_It = m_spellCooldowns.find(l_SpellData.SpellId);

        if (l_It != m_spellCooldowns.end() && l_It->second.itemid == p_Item->GetEntry() && l_It->second.end > uint64((time(NULL) + 30) * IN_MILLISECONDS))
            continue;

        AddSpellCooldown(l_SpellData.SpellId, p_Item->GetEntry(), 30 * IN_MILLISECONDS, true);

        WorldPacket l_Data(SMSG_ITEM_COOLDOWN, 12);
        l_Data.appendPackGUID(p_Item->GetGUID());
        l_Data << uint32(l_SpellData.SpellId);
        l_Data << uint32(30 * IN_MILLISECONDS);
        GetSession()->SendPacket(&l_Data);
    }
}

void Player::resetSpells(bool myClassOnly)
{
    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_SPELLS, true);

    // make full copy of map (spells removed and marked as deleted at another spell remove
    // and we can't use original map for safe iterative with visit each spell at loop end
    PlayerSpellMap smap = GetSpellMap();

    uint32 family;

    if (myClassOnly)
    {
        ChrClassesEntry const* clsEntry = sChrClassesStore.LookupEntry(getClass());
        if (!clsEntry)
            return;
        family = clsEntry->SpellClassSet;

        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(iter->first);
            if (!spellInfo)
                continue;

            // skip server-side/triggered spells
            if (spellInfo->SpellLevel == 0)
                continue;

            // skip wrong class/race skills
            if (!IsSpellFitByClassAndRace(spellInfo->Id))
                continue;

            // skip other spell families
            if (spellInfo->SpellFamilyName != family)
                continue;

            // skip broken spells
            if (!SpellMgr::IsSpellValid(spellInfo, this, false))
                continue;
        }
    }
    else
        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
            removeSpell(iter->first, false, false);           // only iter->first can be accessed, object by iter->second can be deleted already

    LearnDefaultSkills();
    LearnCustomSpells();
    learnQuestRewardedSpells();
}

void Player::LearnCustomSpells()
{
    if (!sWorld->getBoolConfig(CONFIG_START_ALL_SPELLS))
        return;

    // learn default race/class spells
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    for (PlayerCreateInfoSpells::const_iterator itr = info->customSpells.begin(); itr != info->customSpells.end(); ++itr)
    {
        uint32 tspell = *itr;
        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "PLAYER (Class: %u Race: %u): Adding initial spell, id = %u", uint32(getClass()), uint32(getRace()), tspell);
        if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
            addSpell(tspell, true, true, true, false);
        else                                                // but send in normal spell in game learn case
            learnSpell(tspell, true);
    }
}

void Player::LearnDefaultSkills()
{
    // learn default race/class skills
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(true), getClass());
    for (PlayerCreateInfoSkills::const_iterator itr = info->skills.begin(); itr != info->skills.end(); ++itr)
    {
        SkillRaceClassInfoEntry const* rcInfo = *itr;
        if (HasSkill(rcInfo->SkillID))
            continue;

        if (rcInfo->SkillID == 777)
            continue;

        if (rcInfo->MinLevel > getLevel())
            continue;

        LearnDefaultSkill(rcInfo);
    }

    /// Worgen players are automatically granted Apprentice Riding at level 20, as well, due to their racial ability Running Wild.
    if (getLevel() >= 20 && getRace() == RACE_WORGEN)
    {
        learnSpell(87840, false); ///< Running Wild
        learnSpell(33388, false); ///< Apprentice Riding

                                  /// Aberration, Two Forms, Darkflight, Flayer, Viciousness
        learnSpell(68976, false);
        learnSpell(68996, false);
        learnSpell(97709, false);
        learnSpell(68992, false);
        learnSpell(68978, false);
        learnSpell(68975, false);
    }
}

void Player::LearnDefaultSkill(SkillRaceClassInfoEntry const* rcInfo)
{
    uint16 skillId = rcInfo->SkillID;

    if (rcInfo->SkillID == 777)
        return;

    switch (GetSkillRangeType(rcInfo))
    {
        case SKILL_RANGE_LANGUAGE:
            SetSkill(skillId, 0, 300, 300);
            break;
        case SKILL_RANGE_LEVEL:
        {
            uint16 skillValue = 1;
            uint16 maxValue = GetMaxSkillValueForLevel();
            if (rcInfo->Flags & SKILL_FLAG_ALWAYS_MAX_VALUE)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT)
                skillValue = std::min(std::max<uint16>({ 1, uint16((getLevel() - 1) * 5) }), maxValue);
            else if (skillId == SKILL_FIST_WEAPONS)
                skillValue = std::max<uint16>(1, GetSkillValue(SKILL_UNARMED));

            SetSkill(skillId, 0, skillValue, maxValue);
            break;
        }
        case SKILL_RANGE_MONO:
            SetSkill(skillId, 0, 1, 1);
            break;
        case SKILL_RANGE_RANK:
        {
            uint16 rank = 1;
            if (getClass() == CLASS_DEATH_KNIGHT && skillId == SKILL_FIRST_AID)
                rank = 4;

            SkillTiersEntry const* tier = sObjectMgr->GetSkillTier(rcInfo->SkillTierID);
            uint16 maxValue = tier->Value[std::max<int32>(rank - 1, 0)];
            uint16 skillValue = 1;
            if (rcInfo->Flags & SKILL_FLAG_ALWAYS_MAX_VALUE)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT)
                skillValue = std::min(std::max(uint16(1), uint16((getLevel() - 1) * 5)), maxValue);

            SetSkill(skillId, rank, skillValue, maxValue);
            break;
        }
        default:
            break;
    }
}

void Player::LearnSpecializationSpells()
{
    if (std::vector<SpecializationSpellEntry const*> const* specSpells = GetSpecializationSpells(GetActiveSpecializationID()))
    {
        for (size_t j = 0; j < specSpells->size(); ++j)
        {
            SpecializationSpellEntry const* specSpell = specSpells->at(j);
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(specSpell->SpellID);
            if (!spellInfo || spellInfo->SpellLevel > getLevel())
                continue;

            learnSpell(specSpell->SpellID, false, false, false);
            if (specSpell->OverridesSpellID)
                AddOverrideSpell(specSpell->OverridesSpellID, specSpell->SpellID);
        }
    }
}

void Player::EquipProperArtifactIfNeeded()
{
    Item* l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);

    if (!l_CurrentItem || !l_CurrentItem->GetTemplate()->ArtifactID)
        l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

    if (!l_CurrentItem)
        return;

    uint32 l_ArtifactID = l_CurrentItem->GetTemplate()->ArtifactID;
    if (!l_ArtifactID)
        return;

    ArtifactEntry const* l_Entry = sArtifactStore.LookupEntry(l_ArtifactID);
    if (!l_Entry->SpecializationID)
        return;

    uint32 l_ItemID = GetArtifactItemIDEntryBySpec(GetActiveSpecializationID());
    if (!l_ItemID)
        return;

    Item* l_TargetArtifact = GetItemByEntry(l_ItemID);
    if (!l_TargetArtifact)
        return;

    uint16 l_Dest = 0;
    InventoryResult l_Res = CanEquipItem(NULL_SLOT, l_Dest, l_TargetArtifact, true);

    if (l_Res != EQUIP_ERR_OK)
        return;

    SwapItem(l_TargetArtifact->GetPos(), l_Dest);
}

void Player::RemoveSpecializationSpells()
{
    for (uint32 i = 0; i < MAX_SPECIALIZATIONS; ++i)
    {
        if (ChrSpecializationsEntry const* specialization = GetChrSpecializationByIndex(getClass(), i))
        {
            if (std::vector<SpecializationSpellEntry const*> const* specSpells = GetSpecializationSpells(specialization->ID))
            {
                for (size_t j = 0; j < specSpells->size(); ++j)
                {
                    SpecializationSpellEntry const* specSpell = specSpells->at(j);

                    /// Prevent remove Disengage on loading player
                    if (specSpell->SpellID == 781 && GetActiveSpecializationID() == SPEC_HUNTER_SURVIVAL && HasSpell(specSpell->SpellID))
                        continue;

                    removeSpell(specSpell->SpellID, true);

                    if (specSpell->OverridesSpellID)
                        RemoveOverrideSpell(specSpell->OverridesSpellID, specSpell->SpellID);
                }
            }

            if (uint32 mastery = specialization->MasterySpellID)
                RemoveAurasDueToSpell(mastery);

            if (uint32 mastery = specialization->MasterySpellID2)
                RemoveAurasDueToSpell(mastery);
        }
    }
}

void Player::learnQuestRewardedSpells(Quest const* quest)
{
    int32 spell_id = quest->GetRewSpellCast();
    uint32 src_spell_id = quest->GetSrcSpell();

    // skip quests without rewarded spell
    if (!spell_id)
        return;

    // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
    if (spell_id == -1 && src_spell_id)
    {
        RemoveAurasDueToSpell(src_spell_id);
        return;
    }

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return;

    // check learned spells state
    bool found = false;
    for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
    {
        if (spellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL && !HasSpell(spellInfo->Effects[i].TriggerSpell))
        {
            found = true;
            break;
        }
    }

    // skip quests with not teaching spell or already known spell
    if (!found)
        return;

    uint32 learned_0 = spellInfo->Effects[0].TriggerSpell;
    if (!HasSpell(learned_0))
    {
        SpellInfo const* learnedInfo = sSpellMgr->GetSpellInfo(learned_0);
        if (!learnedInfo)
            return;

        // profession specialization can be re-learned from npc
        if (learnedInfo->Effects[0].Effect == SPELL_EFFECT_TRADE_SKILL && learnedInfo->Effects[1].Effect == 0 && !learnedInfo->SpellLevel)
            return;

        /// Prevent learning of professions we don't have anymore by quest reward
        auto l_SkillLine = sSpellMgr->GetSkillLineAbilityMapBounds(learned_0);
        for (SkillLineAbilityMap::const_iterator l_SpellIdx = l_SkillLine.first; l_SpellIdx != l_SkillLine.second; ++l_SpellIdx)
        {
            if (l_SpellIdx->second && IsProfessionSkill(l_SpellIdx->second->SkillLine) && GetSkillValue(l_SpellIdx->second->SkillLine) == 0)
                return;
        }
    }

    CastSpell(this, spell_id, true);
}

void Player::learnQuestRewardedSpells()
{
    // learn spells received from quest completing
    for (RewardedQuestSet::const_iterator itr = m_RewardedQuests.begin(); itr != m_RewardedQuests.end(); ++itr)
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(*itr);
        if (!quest)
            continue;

        learnQuestRewardedSpells(quest);
    }
}

void Player::learnSkillRewardedSpells(uint32 skill_id, uint32 skill_value)
{
    // bad hack to work around data being suited only for the client - AcquireMethod == SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN for riding
    // client uses it to show riding in spellbook as trainable
    if (skill_id == SKILL_RIDING)
        return;

    uint64 raceMask = getRaceMask();
    uint32 classMask = getClassMask();

    for (SkillLineAbilityEntry const* ability : g_SkillLineAbilityPerSkill[skill_id])
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(ability->spellId);
        if (!spellInfo)
            continue;

        if (ability->Flags != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_VALUE && ability->Flags != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN)
            continue;

        // Check race if set
        if (ability->RaceMask && !(ability->RaceMask & raceMask))
            continue;

        // Check class if set
        if (ability->ClassMask && !(ability->ClassMask & classMask))
            continue;

        // check level, skip class spells if not high enough
        if (getLevel() < spellInfo->SpellLevel)
            continue;

        // need unlearn spell
        if (skill_value < ability->MinSkillLineRank && ability->Flags == SKILL_LINE_ABILITY_LEARNED_ON_SKILL_VALUE)
            removeSpell(ability->spellId);
        // need learn
        else
        {
            if (!IsInWorld())
                addSpell(ability->spellId, true, true, true, false, false, false, false, false, ability->SkillLine);
            else
                learnSpell(ability->spellId, true, false, false, ability->SkillLine);
        }
    }
}

void Player::SendAurasForTarget(Unit* p_Target)
{
    if (!p_Target || p_Target->GetVisibleAuras()->empty())                  // speedup things
        return;

    /// Blizz sends certain movement packets sometimes even before CreateObject
    if (p_Target->HasAuraType(SPELL_AURA_FEATHER_FALL))
        p_Target->SetFeatherFall(true, true);

    if (p_Target->HasAuraType(SPELL_AURA_WATER_WALK))
        p_Target->SetWaterWalking(true, true);

    if (p_Target->HasAuraType(SPELL_AURA_HOVER))
        p_Target->SetHover(true, true);

    Unit::VisibleAuraMap const* l_VisibleAuras = p_Target->GetVisibleAuras();

    uint32 l_AuraCount = 0;
    for (Unit::VisibleAuraMap::const_iterator itr = l_VisibleAuras->begin(); itr != l_VisibleAuras->end(); ++itr)
    {
        AuraApplication * l_AuraApplication = itr->second;

        if (!l_AuraApplication || !l_AuraApplication->GetBase() || (l_AuraApplication->GetBase()->GetSpellInfo()->Id == 197912 && sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE) && !GetBattleground()))
            continue;

        ++l_AuraCount;
    }

    WorldPacket l_Data(SMSG_AURA_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);                          ///< Update All
    l_Data.WriteBits(l_AuraCount, 9);               ///< Aura count
    l_Data.FlushBits();

    if (l_AuraCount)
    {
        for (Unit::VisibleAuraMap::const_iterator l_It = l_VisibleAuras->begin(); l_It != l_VisibleAuras->end(); ++l_It)
        {
            AuraApplication * l_AuraApplication = l_It->second;

            if (!l_AuraApplication || !l_AuraApplication->GetBase() || (l_AuraApplication->GetBase()->GetSpellInfo()->Id == 197912 && sWorld->getBoolConfig(CONFIG_TOURNAMENT_ENABLE) && !GetBattleground()))
                continue;

            l_AuraApplication->BuildUpdatePacket(l_Data, false);
        }
    }

    l_Data.appendPackGUID(p_Target->GetGUID());     ///< Unit GUID
    GetSession()->SendPacket(&l_Data);
}

void Player::SetDailyQuestStatus(uint32 quest_id)
{
    if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(quest_id))
    {
        if (!qQuest->IsDFQuest())
        {
            m_dailyQuestStorage.insert(quest_id);
            m_lastDailyQuestTime = time(NULL);              // last daily quest time
            m_DailyQuestChanged = true;

            if (m_dailyQuestStorage.size() - 1 < DynamicFields::Count)
                SetDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED, m_dailyQuestStorage.size() - 1, quest_id);
        }
        else
        {
            m_DFQuests.insert(quest_id);
            m_lastDailyQuestTime = time(NULL);
            m_DailyQuestChanged = true;
        }
    }
}

void Player::SetWeeklyQuestStatus(uint32 quest_id)
{
    m_weeklyquests.insert(quest_id);
    m_WeeklyQuestChanged = true;
}

void Player::SetSeasonalQuestStatus(uint32 quest_id)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
    if (!quest)
        return;

    m_seasonalquests[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
    m_SeasonalQuestChanged = true;
}

void Player::SetMonthlyQuestStatus(uint32 quest_id)
{
    m_monthlyquests.insert(quest_id);
    m_MonthlyQuestChanged = true;
}

void Player::ResetDailyQuestStatus()
{
    m_dailyQuestStorage.clear();

    std::vector<uint32> l_Dailies = GetDynamicValues(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED);
    if (!l_Dailies.empty())
    {
        std::vector<uint32> l_QuestBits;
        for (uint32 questId : l_Dailies)
        {
            if (uint32 questBit = GetQuestUniqueBitFlag(questId))
                l_QuestBits.push_back(questBit);
        }

        if (!l_QuestBits.empty())
            ClearQuestBits(l_QuestBits);
    }

    ClearDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED);
    m_DFQuests.clear(); // Dungeon Finder Quests.

    // DB data deleted in caller
    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    WorldPacket data(SMSG_DAILY_QUESTS_RESET);
    data << uint32(l_Dailies.size());
    GetSession()->SendPacket(&data);
}

bool Player::CanCompleteAdventurePOI(uint32 p_ID) const
{
    /// Disable  or enable specific ones
    switch (p_ID)
    {
        case 3: ///< Azsuna zone - initial quest
            break;
        case 4: ///< Val’sharah
            break;
        case 6: ///< Stormheim Alliance
            break;
        case 7: ///< Stormheim Horde
            break;
        case 8: ///< Highmountain
            break;
        default:
            return false;
    }

    AdventureMapPOIEntry const* l_Entry = sAdventureMapPOIStore.LookupEntry(p_ID);

    if (!l_Entry)
        return false;

    Quest const* l_QuestEntry = sObjectMgr->GetQuestTemplate(l_Entry->m_QuestID);
    if (!l_QuestEntry)
        return false;

    return const_cast<Player*>(this)->CanSeeStartQuest(l_QuestEntry);
}

#ifndef CROSS
void Player::ResetDailyGarrisonDatas()
{
    using namespace MS::Garrison;

    if (auto l_Garrison = GetDraenorGarrison())
    {
        if (l_Garrison->HasBuildingType(GDraenor::Building::Type::Inn))
        {
            /// Weekly Tavern Reset is done in World::ResetWeeklyGarrisonDatas

            l_Garrison->ResetGarrisonDailyTavernData();
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(GDraenor::Building::Type::Inn);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(GDraenor::CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(GDraenor::Building::Type::Stable))
        {
            if (uint64 l_Value = GetCharacterWorldStateValue(CharacterWorldStates::GarrisonStablesFirstQuest))
                SetCharacterWorldState(CharacterWorldStates::GarrisonStablesFirstQuest, l_Value &= ~GDraenor::StablesData::g_PendingQuestFlag);

            if (uint64 l_Value = GetCharacterWorldStateValue(CharacterWorldStates::GarrisonStablesSecondQuest))
                SetCharacterWorldState(CharacterWorldStates::GarrisonStablesSecondQuest, l_Value &= ~GDraenor::StablesData::g_PendingQuestFlag);
        }

        if (l_Garrison->HasBuildingType(GDraenor::Building::Type::Workshop))
        {
            l_Garrison->ResetGarrisonWorkshopData(this);
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(GDraenor::Building::Type::Workshop);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(GDraenor::CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(GDraenor::Building::Type::TradingPost))
        {
            l_Garrison->ResetGarrisonTradingPostData(this);
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(GDraenor::Building::Type::TradingPost);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(GDraenor::CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        l_Garrison->UpdatePlot(GetPlotInstanceID());
    }

    if (auto l_Garrison = GetGarrison())
        l_Garrison->ResetMissionStartedTodayCount();

    SaveToDB();
}

void Player::ResetWeeklyGarrisonDatas()
{
    using namespace MS::Garrison;

    if (auto l_Garrison = GetDraenorGarrison())
    {
        /// Armory token handling
        if (l_Garrison->GetBuildingWithType(GDraenor::Building::Type::Armory).DatabaseID)
        {
            if (GetCharacterWorldStateValue(CharacterWorldStates::GarrisonArmoryWeeklyCurrencyGain) == 1)
                SetCharacterWorldState(CharacterWorldStates::GarrisonArmoryWeeklyCurrencyGain, 0);
        }

        l_Garrison->ResetGarrisonWeeklyTavernData();
    }
}

#endif /* not CROSS */
void Player::ResetWeeklyQuestStatus()
{
    if (m_weeklyquests.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : m_weeklyquests)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_weeklyquests.clear();
    // DB data deleted in caller
    m_WeeklyQuestChanged = false;
}

void Player::ResetSeasonalQuestStatus(uint16 event_id)
{
    auto eventItr = m_seasonalquests.find(event_id);
    if (eventItr == m_seasonalquests.end())
        return;

    if (eventItr->second.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : eventItr->second)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_seasonalquests.erase(eventItr);
    // DB data deleted in caller
    m_SeasonalQuestChanged = false;
}

void Player::ResetMonthlyQuestStatus()
{
    if (m_monthlyquests.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : m_monthlyquests)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_monthlyquests.clear();
    // DB data deleted in caller
    m_MonthlyQuestChanged = false;
}

Battleground* Player::GetBattleground() const
{
    if (GetBattlegroundId() == 0)
        return NULL;

    return sBattlegroundMgr->GetBattleground(GetBattlegroundId(), MS::Battlegrounds::GetSchedulerType(m_bgData.bgTypeID));
}

bool Player::InArena() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->isArena())
        return false;

    return true;
}

bool Player::InRatedBattleGround() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->IsRatedBG())
        return false;

    return true;
}

bool Player::GetBGAccessByLevel(BattlegroundTypeId bgTypeId) const
{
    // get a template bg instead of running one
    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(MS::Battlegrounds::GetSchedulerType(bgTypeId));
    if (!bg)
        return false;

    // limit check leel to db2 compatible level range
    uint32 level = getLevel();
    if (level > MAX_LEVEL)
        level = MAX_LEVEL;

    if (level < bg->GetMinLevel() || level > bg->GetMaxLevel())
        return false;

    return true;
}

float Player::GetReputationPriceDiscount(Creature const* creature) const
{
    FactionTemplateEntry const* vendor_faction = creature->getFactionTemplateEntry();
    if (!vendor_faction || !vendor_faction->Faction)
        return 1.0f;

    ReputationRank rank = GetReputationRank(vendor_faction->Faction);
    if (rank <= REP_NEUTRAL)
        return 1.0f;

    return 1.0f - 0.05f* (rank - REP_NEUTRAL);
}

bool Player::IsSpellFitByClassAndRace(uint32 p_SpellId) const
{
    uint64 l_RaceMask  = getRaceMask();
    uint32 l_ClassMask = getClassMask();
    auto l_Spellinfo   = sSpellMgr->GetSpellInfo(p_SpellId);

    if (l_Spellinfo == nullptr)
        return false;

    SkillLineAbilityMapBounds l_Bounds = sSpellMgr->GetSkillLineAbilityMapBounds(p_SpellId);
    if (l_Bounds.first == l_Bounds.second)
        return true;

    for (SkillLineAbilityMap::const_iterator l_SpellIdx = l_Bounds.first; l_SpellIdx != l_Bounds.second; ++l_SpellIdx)
    {
        // Hackfix, Gift of the Naaru for Monks (121093) doesn't have a racemask for only Draenei
        if (p_SpellId == 121093 && l_RaceMask != 1024)
            continue;

        /// Skip horde or alliance only spells
        if ((l_Spellinfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && (l_RaceMask & RACEMASK_HORDE) == 0)
            || (l_Spellinfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && (l_RaceMask & RACEMASK_ALLIANCE) == 0))
            continue;

        // skip wrong race skills
        if (l_SpellIdx->second->RaceMask && (l_SpellIdx->second->RaceMask & l_RaceMask) == 0)
            continue;

        // skip wrong class skills
        if (l_SpellIdx->second->ClassMask && (l_SpellIdx->second->ClassMask & l_ClassMask) == 0)
            continue;

        return true;
    }

    return false;
}

bool Player::HasQuestForGO(uint32 GOId) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& qs = qs_itr->second;

        if (qs.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
            if (!qinfo)
                continue;

            GroupPtr l_Group = GetGroup();

            if (l_Group && l_Group->isRaidGroup() && !qinfo->IsAllowedInRaid())
                continue;

            for (auto const& l_Objective : qinfo->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_GO)
                {
                    if (GOId == (uint32)l_Objective.ObjectID && GetQuestObjectiveCounter(l_Objective.ID) < uint32(l_Objective.Amount))
                        return true;
                }
            }
        }
    }
    return false;
}
uint32 Player::GetQuestObjectiveCounter(uint32 objectiveId) const
{
    QuestObjectiveStatusMap::const_iterator citr = m_questObjectiveStatus.find(objectiveId);
        if (citr != m_questObjectiveStatus.end())
            return citr->second;

    return 0;
}

void Player::SetQuestObjectiveCounter(uint32 p_ObjectId, uint32 p_Amount)
{
    QuestObjectiveStatusMap::iterator l_Iter = m_questObjectiveStatus.find(p_ObjectId);

    if (l_Iter != m_questObjectiveStatus.end())
        l_Iter->second = p_Amount;
}

void Player::UpdateForQuestWorldObjects()
{
    m_clientGUIDs_lock.acquire_read();

    if (m_clientGUIDs.empty())
    {
        m_clientGUIDs_lock.release();
        return;
    }

    UpdateData udata(GetMapId());
    WorldPacket packet;

    for (auto itr=m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_GAMEOBJECT_GUID(*itr))
        {
            if (GameObject* obj = HashMapHolder<GameObject>::Find(*itr))
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
        else if (IS_CRE_OR_VEH_GUID(*itr))
        {
            Creature* obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *itr);
            if (!obj)
                continue;

            // check if this unit requires quest specific flags
            if (!obj->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
                continue;

            SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(obj->GetEntry());
            for (SpellClickInfoContainer::const_iterator _itr = clickPair.first; _itr != clickPair.second; ++_itr)
            {
                //! This code doesn't look right, but it was logically converted to condition system to do the exact
                //! same thing it did before. It definitely needs to be overlooked for intended functionality.
                if (ConditionContainer const* conds = sConditionMgr->GetConditionsForSpellClickEvent(obj->GetEntry(), _itr->second.spellId))
                {
                    bool buildUpdateBlock = false;
                    for (ConditionContainer::const_iterator jtr = conds->begin(); jtr != conds->end() && !buildUpdateBlock; ++jtr)
                    {
                        switch ((*jtr)->ConditionType)
                        {
                            case CONDITION_QUESTREWARDED:
                            case CONDITION_QUESTTAKEN:
                            case CONDITION_QUESTSTATE:
                            case CONDITION_QUEST_OBJECTIVE_COMPLETE:
                            case CONDITION_AURA:
                            case CONDITION_QUEST_COMPLETE:
                                buildUpdateBlock = true;
                            default:
                                break;
                        }
                    }

                    if (buildUpdateBlock)
                    {
                        obj->BuildValuesUpdateBlockForPlayer(&udata, this);
                        break;
                    }
                }
            }
        }
    }

    m_clientGUIDs_lock.release();

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::ForceUpdateForObjectWithEntry(uint32 p_Entry, bool p_Creature)
{
    m_clientGUIDs_lock.acquire_read();

    if (m_clientGUIDs.empty())
    {
        m_clientGUIDs_lock.release();
        return;
    }

    UpdateData l_Udata(GetMapId());
    WorldPacket l_Packet;

    for (auto l_Itr = m_clientGUIDs.begin(); l_Itr != m_clientGUIDs.end(); ++l_Itr)
    {
        if (IS_CRE_OR_VEH_GUID(*l_Itr) && p_Creature)
        {
            Creature* l_Creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *l_Itr);
            if (!l_Creature || l_Creature->GetEntry() != p_Entry)
                continue;

            l_Creature->BuildValuesUpdateBlockForPlayer(&l_Udata, this);
        }
        else if (IS_GAMEOBJECT_GUID(*l_Itr) && !p_Creature)
        {
            GameObject* l_Gob = HashMapHolder<GameObject>::Find(*l_Itr);
            if (!l_Gob || l_Gob->GetEntry() != p_Entry)
                continue;

            l_Gob->BuildValuesUpdateBlockForPlayer(&l_Udata, this);
        }
    }

    m_clientGUIDs_lock.release();

    if (l_Udata.BuildPacket(&l_Packet))
        GetSession()->SendPacket(&l_Packet);
}

void Player::SummonIfPossible(bool agree)
{
    if (!agree)
    {
        m_summon_expire = 0;
        return;
    }

    // expire and auto declined
    if (m_summon_expire < time(NULL))
        return;

    // stop taxi flight at summon
    if (isInFlight())
    {
        GetMotionMaster()->MovementExpired();
        CleanupAfterTaxiFlight();
    }

    // drop flag at summon
    // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
    if (Battleground* bg = GetBattleground())
        bg->EventPlayerDroppedFlag(this);

    m_summon_expire = 0;

    UpdateCriteria(CRITERIA_TYPE_ACCEPTED_SUMMONINGS, 1);

    TeleportTo(m_summon_mapid, m_summon_x, m_summon_y, m_summon_z, GetOrientation());
}

void Player::RemoveItemDurations(Item* item)
{
    for (ItemDurationList::iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
    {
        if (*itr == item)
        {
            m_itemDuration.erase(itr);
            break;
        }
    }
}

void Player::AddItemDurations(Item* item)
{
    if (item->GetUInt32Value(ITEM_FIELD_EXPIRATION))
    {
        m_itemDuration.push_back(item);
        item->SendTimeUpdate(this);
    }
}

void Player::AutoUnequipOffhandIfNeed(bool force /*= false*/)
{
    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!offItem)
        return;

     // unequip offhand weapon if player doesn't have dual wield anymore
    if (!CanDualWield() && !offItem->GetTemplate()->ArtifactID && !offItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD)
        && ((offItem->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND && !(offItem->GetTemplate()->Flags3 & int32(ItemFlagsEX2::ALWAYS_ALLOW_DUAL_WIELD)))
            || offItem->GetTemplate()->InventoryType == INVTYPE_WEAPON))
        force = true;

    // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
    if ((!force && (CanTitanGrip() || (offItem->GetTemplate()->InventoryType != INVTYPE_2HWEAPON && !IsTwoHandUsed()))) || offItem->GetTemplate()->ArtifactID || offItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_CHILD))
        return;

    ItemPosCountVec off_dest;
    uint8 off_msg = CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false);
    if (off_msg == EQUIP_ERR_OK)
    {
        RemoveItem(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        StoreItem(off_dest, offItem, true);
    }
    else
    {
        MoveItemFromInventory(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        SQLTransaction trans = RealmDatabase.BeginTransaction();
        offItem->DeleteFromInventoryDB(trans);                   // deletes item from character's inventory
        offItem->SaveToDB(trans);                                // recursive and not have transaction guard into self, item not in inventory and can be save standalone

        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
        MailDraft(subject, "There were problems with equipping one or several items").AddItem(offItem).SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);

        RealmDatabase.CommitTransaction(trans);
    }
}

OutdoorPvP* Player::GetOutdoorPvP() const
{
    return sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId());
}

bool Player::HasItemFitToSpellRequirements(SpellInfo const* spellInfo, Item const* ignoreItem) const
{
    if (spellInfo->EquippedItemClass < 0)
        return true;

    // scan other equipped items for same requirements (mostly 2 daggers/etc)
    // for optimize check 2 used cases only
    switch (spellInfo->EquippedItemClass)
    {
        case ITEM_CLASS_WEAPON:
        {
            for (uint8 i= EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;
            break;
        }
        case ITEM_CLASS_ARMOR:
        {
            // tabard not have dependent spells
            for (uint8 i= EQUIPMENT_SLOT_START; i< EQUIPMENT_SLOT_MAINHAND; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;

            // shields can be equipped to offhand slot
            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;

            // ranged slot can have some armor subclasses
            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;

            break;
        }
        default:
            sLog->outError(LOG_FILTER_PLAYER, "HasItemFitToSpellRequirements: Not handled spell requirement for item class %u", spellInfo->EquippedItemClass);
            break;
    }

    return false;
}

bool Player::CanNoReagentCast(SpellInfo const* spellInfo) const
{
    // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
    if (spellInfo->AttributesEx5 & SPELL_ATTR5_NO_REAGENT_WHILE_PREP &&
        HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION))
        return true;

    // Check no reagent use mask
    flag128 noReagentMask;
    noReagentMask[0] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK);
    noReagentMask[1] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+1);
    noReagentMask[2] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+2);
    noReagentMask[3] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+3);
    if (spellInfo->SpellFamilyFlags & noReagentMask)
        return true;

    return false;
}

void Player::RemoveItemDependentAurasAndCasts(Item* pItem)
{
    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* aura = itr->second;

        // skip passive (passive item dependent spells work in another way) and not self applied auras
        SpellInfo const* spellInfo = aura->GetSpellInfo();
        if (aura->IsPassive() ||  aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        // skip if not item dependent or have alternative item
        if (HasItemFitToSpellRequirements(spellInfo, pItem))
        {
            ++itr;
            continue;
        }

        // no alt item, remove aura, restart check
        RemoveOwnedAura(itr);
    }

    // currently casted spells can be dependent from item
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
            if (spell->getState() != SPELL_STATE_DELAYED && !HasItemFitToSpellRequirements(spell->m_spellInfo, pItem))
                InterruptSpell(CurrentSpellTypes(i));
}

void Player::RemoveAuraDependentItem(Item* p_Item)
{
    if (p_Item == nullptr)
        return;

    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* l_Aura = itr->second;

        SpellInfo const* spellInfo = l_Aura->GetSpellInfo();
        if (l_Aura->IsPassive() || l_Aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        if (l_Aura->GetCastItemGUID() == p_Item->GetGUID())
            RemoveOwnedAura(itr);
        else
            ++itr;
    }
}

uint32 Player::GetResurrectionSpellId()
{
    // search priceless resurrection possibilities
    uint32 l_Priority = 0;
    uint32 l_ResurrectSpellID = 0;

    AuraEffectList const& l_DummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
    for (AuraEffectList::const_iterator l_AuraItr = l_DummyAuras.begin(); l_AuraItr != l_DummyAuras.end(); ++l_AuraItr)
    {
        // Soulstone Resurrection                           // prio: 3 (max, non death persistent)
        if (l_Priority < 2 && (*l_AuraItr)->GetId() == 20707)
        {
            l_Priority = 3;
            l_ResurrectSpellID = 3026;
        }
        // Twisting Nether                                  // prio: 2 (max)
        else if ((*l_AuraItr)->GetId() == 23701 && roll_chance_i(10))
        {
            l_Priority = 2;
            l_ResurrectSpellID = 23700;
        }
    }

    // Reincarnation (passive spell)  // prio: 1
    if (l_Priority < 1 && HasSpell(20608) && !HasSpellCooldown(21169))
        l_ResurrectSpellID = 21169;

    return l_ResurrectSpellID;
}

uint32 Player::GetFirstDescriptorRessurectSpell() const
{
    return GetDynamicValue(PLAYER_DYNAMIC_FIELD_SELF_RES_SPELLS, 0);
}

void Player::SetResurectSpell(uint32 p_SpellID)
{
    SetDynamicValue(PLAYER_DYNAMIC_FIELD_SELF_RES_SPELLS, 0, p_SpellID);
}

// Used in triggers for check "Only to targets that grant experience or honor" req
bool Player::isHonorOrXPTarget(Unit* victim)
{
    uint8 v_level = victim->getLevelForTarget(this);
    uint8 k_grey  = JadeCore::XP::GetGrayLevel(getLevelForTarget(victim));

    // Victim level less gray level
    if (v_level < k_grey)
        return false;

    if (victim->GetTypeId() == TYPEID_UNIT)
    {
        if (victim->ToCreature()->isTotem() ||
            victim->ToCreature()->isStatue() ||
            victim->ToCreature()->GetFlagsExtra() & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL)
                return false;
    }
    return true;
}

void Player::RewardPersonnalCurrencies(Unit* p_Victim)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (!p_Victim->ToCreature())
        return;

    if (!p_Victim->ToCreature()->GetEntry())
        return;

    if (uint32 l_TrackingQuestId = Vignette::GetTrackingQuestIdFromWorldObject(p_Victim))
    {
        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuestId);
        if (IsQuestBitFlaged(l_QuestBit) && !p_Victim->ToCreature()->IsAllowedTrackingQuestLooter(GetGUID()))
            return;
    }

    CurrencyOnKillEntry const* l_Curr = sObjectMgr->GetPersonnalCurrencyOnKillEntry(p_Victim->ToCreature()->GetEntry());
    if (!l_Curr)
        return;

    bool l_Result = true;
    if (p_Victim->ToCreature()->AI())
        p_Victim->ToCreature()->AI()->CurrenciesRewarder(l_Result);

    if (!l_Result)
        return;

    for (CurrencyOnKillEntry::const_iterator l_Iter = l_Curr->begin(); l_Iter != l_Curr->end(); ++l_Iter)
    {
        int32 l_Pct = 100;
        Unit::AuraEffectList const& l_Auras = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_PCT);
        for (Unit::AuraEffectList::const_iterator l_I = l_Auras.begin(); l_I != l_Auras.end(); ++l_I)
        {
            if (l_Iter->first == (*l_I)->GetMiscValue()) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                l_Pct += (*l_I)->GetAmount();
        }

        ModifyCurrency(l_Iter->first, CalculatePct(l_Iter->second, l_Pct), false);
    }
}

void Player::RewardPlayerAndGroupAtKill(Unit* p_Victim, bool p_IsBattleGround, std::set<uint64>& p_RewardedPlayers)
{
    if (!IsInMap(p_Victim))
        return;

    if (std::find(p_RewardedPlayers.begin(), p_RewardedPlayers.end(), GetGUID()) == p_RewardedPlayers.end())
    {
        if (GroupPtr l_Group = GetGroup())
        {
            l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Itr)
            {
                Player* l_GroupGuy = l_Itr->player;

                /// If you aren't in a dungeon/raid/scenario, you have to be in the threat list to receive the currency.
                if (l_GroupGuy && IsInMap(l_GroupGuy) && GetMap()->IsDungeon())
                    l_GroupGuy->RewardCurrencyAtKill(p_Victim);
            });
        }
        else
            RewardCurrencyAtKill(p_Victim);
    }

    KillRewarder(this, p_Victim, p_IsBattleGround, p_RewardedPlayers).Reward();
}

void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
{
    if (!pRewardSource)
        return;

    uint64 creature_guid = (pRewardSource->GetTypeId() == TYPEID_UNIT) ? pRewardSource->GetGUID() : uint64(0);

    // prepare data for near group iteration
    if (GroupPtr group = GetGroup())
    {
        group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member)
        {
            Player* player = l_Member->player;
            if (!player)
                return;

            if (!player->IsAtGroupRewardDistance(pRewardSource))
                return;                               // member (alive or dead) or his corpse at req. distance

            // quest objectives updated only for alive group member or dead but with not released body
            if (player->isAlive()|| !player->GetCorpse())
                player->KilledMonsterCredit(creature_id, creature_guid);
        });
    }
    else                                                    // if (!group)
        KilledMonsterCredit(creature_id, creature_guid);
}

bool Player::IsAtGroupRewardDistance(WorldObject const* pRewardSource) const
{
    if (!pRewardSource)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || isAlive())
        player = this;

    if (player->GetMapId() != pRewardSource->GetMapId() || player->GetInstanceId() != pRewardSource->GetInstanceId() || player->GetMap() != pRewardSource->GetMap())
        return false;

    if (Map* l_Map = pRewardSource->GetMap())
    {
        if (l_Map->IsDungeon() || l_Map->IsRaid())
        {
            float l_XPDistance = sWorld->getFloatConfig(CONFIG_INSTANCE_GROUP_XP_DISTANCE);

            if (Creature* l_Creature = const_cast<WorldObject*>(pRewardSource)->ToCreature())
            {
                if (l_Creature->IsAIEnabled && l_Creature->AI()->BypassXPDistanceIfNeeded(const_cast<WorldObject*>(player)))
                    return true;
            }

            return pRewardSource->GetDistance(player) <= l_XPDistance;
        }
    }

    return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE);
}

void Player::ResurectUsingRequestData()
{
    if (_resurrectionData->ResSpell != nullptr && _resurrectionData->ResSpell->IsBattleResurrection())
    {
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->CanUseCombatResurrection())
                l_InstanceScript->ConsumeCombatResurrectionCharge();
            else
            {
                /// Resurrecting - 60s aura preventing client from new res spells
                RemoveAura(160029);
                ClearResurrectRequestData();
                SendGameError(GameError::ERR_SPELL_FAILED_S, 236);
                SendForcedDeathUpdate();
                return;
            }
        }
    }

    /// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
    float x, y, z, o;
    _resurrectionData->Location.GetPosition(x, y, z, o);
    TeleportTo(_resurrectionData->Location.GetMapId(), x, y, z, o);

    if (IsBeingTeleported())
    {
        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
        return;
    }

    ResurrectPlayer(0.0f, false);

    if (GetMaxHealth() > _resurrectionData->Health)
        SetHealth(_resurrectionData->Health);
    else
        SetFullHealth();

    for (int l_Power = POWER_MANA; l_Power < MAX_POWERS; ++l_Power)
        SetPower((Powers)l_Power, GetDefaultValuePower((Powers)l_Power));

    if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
        SetPower(POWER_MANA, _resurrectionData->Mana);
    else
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

    if (uint32 aura = _resurrectionData->Aura)
        CastSpell(this, aura, true, NULL, nullptr, _resurrectionData->GUID);

    SpawnCorpseBones();

    /// Resurrecting - 60s aura preventing client from new res spells
    RemoveAura(160029);
    ClearResurrectRequestData();
}

void Player::SendForcedDeathUpdate()
{
    WorldPacket l_Data(Opcodes::SMSG_FORCED_DEATH_UPDATE, 0);
    GetSession()->SendPacket(&l_Data);
}

void Player::SendGameError(GameError::Type p_Error, uint32 p_Data1 /*= 0xF0F0F0F0*/, uint32 p_Data2 /*= 0xF0F0F0F0*/)
{
    GetSession()->SendGameError(p_Error, p_Data1, p_Data2);
}

void Player::SetClientControl(Unit* p_Target, uint8 p_AllowMove)
{
    WorldPacket l_Data(SMSG_CLIENT_CONTROL_UPDATE);
    l_Data.appendPackGUID(p_Target->GetGUID());
    l_Data.WriteBit(p_AllowMove);
    GetSession()->SendPacket(&l_Data);

    if (p_Target == this && p_AllowMove)
        SetMover(this);
}

void Player::UpdateZoneDependentAuras(uint32 newZone)
{
    // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newZone);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);
}

void Player::UpdateAreaDependentAuras(uint32 newArea)
{
    // remove auras from spells with area limitations
    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
    {
        // use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
        if (iter->second->GetSpellInfo()->CheckLocation(GetMapId(), m_zoneUpdateId, newArea, this) != SPELL_CAST_OK)
        {
            /// don't remove dampening after teleporting spells in arena
            if ((iter->second->GetSpellInfo()->Id != 110310) || !GetBattleground())
            {
                RemoveOwnedAura(iter);
                continue;
            }
        }

        ++iter;
    }

    // some auras applied at subzone enter
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newArea);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, m_zoneUpdateId, newArea))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);

    if (newArea == 4273 && GetVehicle() && GetPositionX() > 400) // Ulduar
    {
        switch (GetVehicleBase()->GetEntry())
        {
            case 33062:
            case 33109:
            case 33060:
                GetVehicle()->Dismiss();
                break;
        }
    }
}

bool Player::IsInAreaGroup(uint32 p_AreaGroupID)
{
    auto& l_Groups = s_AreaGroupsByAreaID[GetAreaId()];
    return l_Groups.find(p_AreaGroupID) != l_Groups.end();
}

uint32 Player::GetCorpseReclaimDelay(bool pvp) const
{
    if (pvp)
    {
        if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP))
            return gCopseReclaimDelay[0];
    }
    else if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE))
        return 0;

    time_t now = time(NULL);
    // 0..2 full period
    // should be ceil(x)-1 but not floor(x)
    uint64 count = (now < m_deathExpireTime - 1) ? (m_deathExpireTime - 1 - now)/DEATH_EXPIRE_STEP : 0;
    return gCopseReclaimDelay[count];
}

void Player::UpdateCorpseReclaimDelay()
{
    bool pvp = m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH;

    if ((pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
        (!pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        return;

    time_t now = time(NULL);
    if (now < m_deathExpireTime)
    {
        // full and partly periods 1..3
        uint64 count = (m_deathExpireTime - now)/DEATH_EXPIRE_STEP +1;
        if (count < MAX_DEATH_COUNT)
            m_deathExpireTime = now+(count+1)*DEATH_EXPIRE_STEP;
        else
            m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP;
    }
    else
        m_deathExpireTime = now+DEATH_EXPIRE_STEP;
}

void Player::SendCorpseReclaimDelay(bool p_Load)
{
    /// Unlock "release spirit" button while the player IsFalling
    if (isDead())
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);

    Corpse * l_Corpse = GetCorpse();

    if (p_Load && !l_Corpse)
        return;

    bool l_IsPVP;

    if (l_Corpse)
        l_IsPVP = (l_Corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
    else
        l_IsPVP = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH);

    time_t l_Delay;

    if (p_Load)
    {
        if (l_Corpse->GetGhostTime() > m_deathExpireTime)
            return;

        uint64 l_Count;

        if ((l_IsPVP && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
           (!l_IsPVP && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        {
            l_Count = (m_deathExpireTime-l_Corpse->GetGhostTime())/DEATH_EXPIRE_STEP;

            if (l_Count >= MAX_DEATH_COUNT)
                l_Count = MAX_DEATH_COUNT-1;
        }
        else
            l_Count=0;

        time_t l_ExpectedTime = l_Corpse->GetGhostTime() + gCopseReclaimDelay[l_Count];
        time_t l_Now          = time(NULL);

        if (l_Now >= l_ExpectedTime)
            return;

        l_Delay = l_ExpectedTime-l_Now;
    }
    else
        l_Delay = GetCorpseReclaimDelay(l_IsPVP);

    if (!l_Delay)
        return;

    /// Corpse reclaim delay 30 * 1000ms or longer at often deaths
    WorldPacket l_Data(SMSG_CORPSE_RECLAIM_DELAY, 4);
    l_Data << uint32(l_Delay * IN_MILLISECONDS);

    GetSession()->SendPacket(&l_Data);
}

Player* Player::GetNextRandomRaidMember(float radius)
{
    GroupPtr group = GetGroup();
    if (!group)
        return NULL;

    std::vector<Player*> nearMembers;
    nearMembers.reserve(group->GetMembersCount());

    group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_Member)
    {
        Player* Target = l_Member->player;

        // IsHostileTo check duel and controlled by enemy
        if (Target && Target != this && IsWithinDistInMap(Target, radius) &&
            !Target->HasInvisibilityAura() && !IsHostileTo(Target))
            nearMembers.push_back(Target);
    });

    if (nearMembers.empty())
        return NULL;

    uint32 randTarget = urand(0, nearMembers.size()-1);
    return nearMembers[randTarget];
}

PartyResult Player::CanUninviteFromGroup() const
{
    GroupPtr const grp = GetGroup();
    if (!grp)
        return ERR_NOT_IN_GROUP;

    if (grp->isLFGGroup())
    {
        uint64 gguid = grp->GetGUID();
        if (!sLFGMgr->GetKicksLeft(gguid))
            return ERR_PARTY_LFG_BOOT_LIMIT;

        LfgState state = sLFGMgr->GetState(gguid);
        if (state == LFG_STATE_BOOT)
            return ERR_PARTY_LFG_BOOT_IN_PROGRESS;

        if (grp->GetMembersCount() <= sLFGMgr->GetVotesNeeded(gguid))
            return ERR_PARTY_LFG_BOOT_TOO_FEW_PLAYERS;

        if (state == LFG_STATE_FINISHED_DUNGEON)
            return ERR_PARTY_LFG_BOOT_DUNGEON_COMPLETE;

        if (grp->isRollLootActive())
            return ERR_PARTY_LFG_BOOT_LOOT_ROLLS;

        // TODO: Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
        bool l_LfgBootInCombat = grp->GetMemberSlots().exist([&](Group::MemberSlotPtr l_Itr) -> bool
        {
            if (l_Itr->player && l_Itr->player->isInCombat())
                return true;

            return false;
        });

        if (l_LfgBootInCombat)
            return ERR_PARTY_LFG_BOOT_IN_COMBAT;

        /* Missing support for these types
            return ERR_PARTY_LFG_BOOT_COOLDOWN_S;
            return ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S;
        */
    }
    else
    {
        if (!grp->IsLeader(GetGUID()) && !grp->IsAssistant(GetGUID()) && !(grp->GetPartyFlags() & PARTY_FLAG_EVERYONE_IS_ASSISTANT))
            return ERR_NOT_LEADER;

        if (InBattleground())
            return ERR_LFG_PENDING;
    }

    return ERR_PARTY_RESULT_OK;
}

bool Player::isUsingLfg()
{
    uint64 guid = GetGUID();
    return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
}

void Player::SetBattlegroundOrBattlefieldRaid(GroupPtr p_Group, int8 p_Subgroup)
{
    if (m_OriginalGroup)
    {
        sLog->outExtChat("#jarvis", "danger", true, "SetBattlegroundOrBattlefieldRaid override m_OriginalGroup!");
        m_OriginalGroup->UnlinkPlayer(this);
    }

    m_OriginalGroup    = m_Group;
    m_OriginalSubGroup = m_SubGroup;

    if (m_Group)
        m_Group->UnlinkPlayer(this);

    m_Group    = p_Group;
    m_Group->LinkPlayer(this);

    m_SubGroup = p_Subgroup;
}

void Player::RemoveFromBattlegroundOrBattlefieldRaid()
{
    if (m_Group)
    {
        m_Group->UnlinkPlayer(this);
        m_Group = nullptr;
    }

    if (GroupPtr group = GetOriginalGroup())
    {
        m_Group = group;
        m_SubGroup = m_OriginalSubGroup;

        m_Group->LinkPlayer(this);
    }

    m_OriginalGroup = nullptr;
    m_OriginalSubGroup = 0;
}

void Player::SetOriginalGroup(GroupPtr p_Group, int8 p_Subgroup)
{
    if (p_Group == nullptr && m_OriginalGroup)
        m_OriginalGroup->UnlinkPlayer(this);
    else if (m_OriginalGroup)
    {
        ACE_Stack_Trace trace;
        sLog->outExtChat("#jarvis", "danger", true, "Try to override original group");
        sLog->outExtChat("#jarvis", "danger", true, trace.c_str());
        m_OriginalGroup->UnlinkPlayer(this);
    }

    if (p_Group)
        p_Group->LinkPlayer(this);

    m_OriginalGroup = p_Group;
    m_OriginalSubGroup = p_Subgroup;
}

void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
{
    // temporary hack
    // player can't be on the ship and in the water at the same time
    // If this is not submarine
    if (GetTransport())
        return;

    LiquidData liquid_status;
    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
    if (!res)
    {
        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWARER_INDARKWATER);

        if (HasAuraType(AuraType::SPELL_AURA_DROWNING))
            m_MirrorTimerFlags |= UNDERWATER_INWATER;

        if (_lastLiquid && _lastLiquid->SpellID)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        _lastLiquid = NULL;
        return;
    }

    if (uint32 liqEntry = liquid_status.entry)
    {
        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
        if (_lastLiquid && _lastLiquid->SpellID && _lastLiquid->Id != liqEntry)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        if (liquid && liquid->SpellID)
        {
            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
            {
                if (!HasAura(liquid->SpellID))
                    CastSpell(this, liquid->SpellID, true);
            }
            else
                RemoveAurasDueToSpell(liquid->SpellID);
        }

        _lastLiquid = liquid;
    }
    else if (_lastLiquid && _lastLiquid->SpellID)
    {
        RemoveAurasDueToSpell(_lastLiquid->SpellID);
        _lastLiquid = NULL;
    }


    // All liquids type - check under water position
    if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
    {
        if (res & LIQUID_MAP_UNDER_WATER)
            m_MirrorTimerFlags |= UNDERWATER_INWATER;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
    }

    // Allow travel in dark water on taxi or transport
    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !isInFlight() && !GetTransport())
        m_MirrorTimerFlags |= UNDERWARER_INDARKWATER;
    else
        m_MirrorTimerFlags &= ~UNDERWARER_INDARKWATER;

    // in lava check, anywhere in lava level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
    }
    // in slime check, anywhere in slime level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
    }
}

void Player::SetCanParry(bool value)
{
    if (m_canParry == value)
        return;

    m_canParry = value;
    UpdateParryPercentage();
}

void Player::SetCanBlock(bool value)
{
    if (m_canBlock == value)
        return;

    m_canBlock = value;
    UpdateBlockPercentage();
}

bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
{
    for (ItemPosCountVec::const_iterator itr = vec.begin(); itr != vec.end(); ++itr)
        if (itr->pos == pos)
            return true;
    return false;
}

void Player::StopCastingBindSight()
{
    if (WorldObject* target = GetViewpoint())
    {
        if (target->isType(TYPEMASK_UNIT))
        {
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_BIND_SIGHT, GetGUID());
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS, GetGUID());
        }
    }
}

void Player::SetViewpoint(WorldObject* target, bool apply)
{
    if (apply)
    {
        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName(), target->GetEntry(), target->GetTypeId());

        if (!AddGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName());
            return;
        }

        // farsight dynobj or puppet may be very far away
        UpdateVisibilityOf(target);

        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
            ((Unit*)target)->AddPlayerToVision(this);
    }
    else
    {
        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s remove seer", GetName());

        if (!RemoveGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot remove current viewpoint!", GetName());
            return;
        }

        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
            ((Unit*)target)->RemovePlayerFromVision(this);

        // Must immediately set seer back otherwise may crash
        m_seer = this;
    }
}

WorldObject* Player::GetViewpoint() const
{
    if (uint64 guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT))
        return (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_SEER);
    return NULL;
}

bool Player::CanUseBattlegroundObject()
{
    // TODO : some spells gives player ForceReaction to one faction (ReputationMgr::ApplyForceReaction)
    // maybe gameobject code should handle that ForceReaction usage
    // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
    bool l_HasMechanicImmunity = false;
    if (getClass() == Classes::CLASS_DRUID && GetShapeshiftForm() != ShapeshiftForm::FORM_NONE)
    {
        AuraEffectList l_MechanicImunityList = GetAuraEffectsByType(SPELL_AURA_MECHANIC_IMMUNITY);
        for (AuraEffect const* l_AuraEffect : l_MechanicImunityList)
        {
            if (l_AuraEffect->GetMiscValue() != MECHANIC_POLYMORPH)
            {
                l_HasMechanicImmunity = true;
                break;
            }
        }
    }
    else
    {
        AuraEffectList const& l_MechanicImunityList = GetAuraEffectsByType(SPELL_AURA_MECHANIC_IMMUNITY);
        for (auto l_AuraEffect : l_MechanicImunityList)
        {
            /// Don't know if it's correct to skip by GetMiscValue and mask
            /// So use spell id only
            switch (l_AuraEffect->GetId())
            {
                case 1044: ///< Blessing of Freedom
                case 25771: ///< Forbearance
                    continue;
                default:
                    break;
            }
            l_HasMechanicImmunity = true;
            break;
        }
    }

    return (//InBattleground() &&                          // in battleground - not need, check in other cases
             //!IsMounted() && - not correct, player is dismounted when he clicks on flag
             //player cannot use object when he is invulnerable (immune)
             !isTotalImmune() &&                            // not totally immune
             !HasAuraType(SPELL_AURA_SCHOOL_IMMUNITY) &&    // not immune to school immunity
             !l_HasMechanicImmunity &&                      // not immune to mechanic immunity
             //i'm not sure if these two are correct, because invisible players should get visible when they click on flag
             !HasStealthAura() &&                           // not stealthed
             !HasInvisibilityAura() &&                      // not invisible
             !HasAura(SPELL_RECENTLY_DROPPED_FLAG) &&    // can't pickup
             !HasAura(186265) &&                         ///< Aspect of the Turtle
             !HasAura(213602) &&                         ///< Greater Fade
             isAlive()                                      // live player
);
}

bool Player::CanCaptureTowerPoint()
{
    return (!HasStealthAura() &&                           // not stealthed
             !HasInvisibilityAura() &&                      // not invisible
             isAlive() &&                                   // live player
            !HasAura(213602)                                ///< Greater Fade
);
}

uint32 Player::GetBarberShopCost(uint8 newhairstyle, uint8 newhaircolor, uint8 newfacialhair, BarberShopStyleEntry const* newSkin, BarberShopStyleEntry const* p_NewFace, std::array<BarberShopStyleEntry const*, PLAYER_CUSTOM_DISPLAY_SIZE> const& p_NewCustomDisplay)
{
    uint8 level = getLevel();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;                               // max level in this gametable

    uint8 skincolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_SKIN_ID);
    uint8 l_Face        = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_FACE_ID);
    uint8 hairstyle     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_STYLE_ID);
    uint8 haircolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_FIELD_HAIR_COLOR_ID_OFFSET_HAIR_COLOR_ID);
    uint8 facialhair    = GetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_CUSTOM_OPTOTIONS_FACIAL_STYLE);

    std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> l_CustomDisplay;
    for (uint32 l_I = 0; l_I < PLAYER_CUSTOM_DISPLAY_SIZE; ++l_I)
        l_CustomDisplay[l_I] = GetByteValue(PLAYER_FIELD_CUSTOM_DISPLAY_OPTION, PLAYER_BYTES_2_OFFSET_CUSTOM_DISPLAY_OPTION + l_I);

    if ((hairstyle == newhairstyle) &&
        (haircolor == newhaircolor) &&
        (facialhair == newfacialhair) &&
        (!newSkin || (newSkin->Data == skincolor)) &&
        (!p_NewFace || (p_NewFace->Data == l_Face)) &&
        (!p_NewCustomDisplay[0] || (p_NewCustomDisplay[0]->Data == l_CustomDisplay[0])) &&
        (!p_NewCustomDisplay[1] || (p_NewCustomDisplay[1]->Data == l_CustomDisplay[1])) &&
        (!p_NewCustomDisplay[2] || (p_NewCustomDisplay[2]->Data == l_CustomDisplay[2])))
        return 0;

    BarberShopCostBaseEntry const* bsc = g_BarberShopCostBaseEntry.LookupEntry(level);

    if (!bsc)                                                // shouldn't happen
        return 0xFFFFFFFF;

    float cost = 0;

    if (hairstyle != newhairstyle)
        cost += bsc->cost;                                  // full price

    if ((haircolor != newhaircolor) && (hairstyle == newhairstyle))
        cost += bsc->cost * 0.5f;                           // +1/2 of price

    if (facialhair != newfacialhair)
        cost += bsc->cost * 0.75f;                          // +3/4 of price

    if (newSkin && skincolor != newSkin->Data)
        cost += bsc->cost * newSkin->m_CostMultiplier;

    if (p_NewFace && l_Face != p_NewFace->Data)
        cost += bsc->cost * p_NewFace->m_CostMultiplier;

    for (uint32 l_I = 0; l_I < PLAYER_CUSTOM_DISPLAY_SIZE; ++l_I)
    {
        if (p_NewCustomDisplay[l_I] && l_CustomDisplay[l_I] != p_NewCustomDisplay[l_I]->Data)
            cost += uint32(bsc->cost * p_NewCustomDisplay[l_I]->m_CostMultiplier);
    }

    return uint32(cost);
}

bool Player::isTotalImmune()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    uint32 immuneMask = 0;
    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        immuneMask |= (*itr)->GetMiscValue();
        if (immuneMask & SPELL_SCHOOL_MASK_ALL)            // total immunity
            return true;
    }
    return false;
}

bool Player::HasTitle(uint32 bitIndex) const
{
    if (bitIndex > MAX_TITLE_INDEX)
        return false;

    uint32 fieldIndexOffset = bitIndex / 32;
    uint32 flag = 1 << (bitIndex % 32);
    return HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
}

void Player::SetTitle(CharTitlesEntry const* title, bool lost)
{
    uint32 fieldIndexOffset = title->MaskID / 32;
    uint32 flag = 1 << (title->MaskID % 32);

    if (lost)
    {
        if (!HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        RemoveFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        SetFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
    }

    if (lost)
    {
        WorldPacket data(SMSG_TITLE_LOST, 4);
        data << uint32(title->MaskID);
        GetSession()->SendPacket(&data);
    }
    else
    {
        WorldPacket data(SMSG_TITLE_EARNED, 4);
        data << uint32(title->MaskID);
        GetSession()->SendPacket(&data);
    }
}

bool Player::isTotalImmunity()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_ALL) !=0)   // total immunity
        {
            return true;
        }
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) !=0)   // physical damage immunity
        {
            for (AuraEffectList::const_iterator i = immune.begin(); i != immune.end(); ++i)
            {
                if (((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_MAGIC) !=0)   // magic immunity
                {
                    return true;
                }
            }
        }
    }
    return false;
}
/// @todo DO SOMETHING WITH THIS SHIT
                                   // Heurtoir,            Frappe héro,        Coup traumatisant
#define SPELL_WAR_ATTACK_LIST   47475,                  47450,              12809


                                // Consecration,       Repentir
#define SPELL_PAL_ATTACK_LIST   26573,              20066
                                // Eclair Lumineux,     Lumiere sacree
#define SPELL_PAL_FRIEND_LIST   48785,                  48782,              48785


                                // Tir des arcanes,     Morsure de serpent, Morsure de la mangouste
#define SPELL_HUNT_ATTACK_LIST  49045,                  49001,              53339


                                // pied,                Hemoragie           suriner         Eventail de couteaux
#define SPELL_ROG_ATTACK_LIST   1766,                   48660,              1776,           51723


                                // Douleur,             Chatiment,          Flammes sacrees
#define SPELL_PRI_ATTACK_LIST   48125,                  48123,              48135
                                // Soins rapides,       Rénovation,         Priere de guérison
#define SPELL_PRI_FRIEND_LIST   48071,                  48068,              48113


                                // frappe au coeur,     Toucher de glace,   Mort et decompo
#define SPELL_DK_ATTACK_LIST    55262,                  49909,              49938


                                // Chaine d'éclairs,    Horion de flammes,  Orage
#define SPELL_CHA_ATTACK_LIST   49271,                  49233,              59159
                                // Salve de guerison    Vague de soin       Bouclier de terre
#define SPELL_CHA_FRIEND_LIST   55459,                  49273,              49284


                                // Boule de feu,        Nova de givre,      Rafale
#define SPELL_MAG_ATTACK_LIST   42833,                  42917,              44614


                                // Immolation,          Drain de vie,       Hurlement de terreur
#define SPELL_DEM_ATTACK_LIST   47811,                  47857,              17928


                                // Colère,              Eclat Lunaire,      Lucioles
#define SPELL_DRU_ATTACK_LIST   48461,                  48463,              770
                                // Recuperation,        Toucher guerriseur, Tranquillité
#define SPELL_DRU_FRIEND_LIST   48441,                  48378,              48447
                                // Breath of fire       //Blackout kick     //Chi burst
#define SPELL_MONK_ATTACK_LIST  123725,                 128531,             130651

uint32 rand_number(uint32 value1, uint32 value2, uint32 value3 = 0, uint32 value4 = 0)
{
    switch (rand() % 4)
    {
        case 0:     return value1;
        case 1:     return value2;
        case 2:     return value3;
        case 3:     return value4;
        default:    return 0;
    }
}

void Player::UpdateCharmedAI()
{
    //This should only called in Player::Update
    Creature* charmer = GetCharmer()->ToCreature();

    //kill self if charm aura has infinite duration
    if (charmer->IsInEvadeMode())
    {
        AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOD_CHARM);
        for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
            if ((*iter)->GetCasterGUID() == charmer->GetGUID() && (*iter)->GetBase()->IsPermanent())
            {
                charmer->DealDamage(this, GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                return;
            }
    }

    if (!charmer->isInCombat())
        GetMotionMaster()->MoveFollow(charmer, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);

    Unit* target = getVictim();
    if (!target || !charmer->IsValidAttackTarget(target))
    {
        target = charmer->SelectNearestPlayerNotGM();
        if (!target)
            return;

        GetMotionMaster()->MoveChase(target);
        Attack(target, true);
    }
    else
    {
        if (HasUnitState(UNIT_STATE_CASTING))
            return;
        else if (target && GetMotionMaster()->GetCurrentMovementGeneratorType() != CHASE_MOTION_TYPE)
            GetMotionMaster()->MoveChase(target);

        // On laisse quelques attaques en melée deux fois sur trois
        if (urand(0, 2))
            return;

        // On s'arrete pour cast le spell
        GetMotionMaster()->MoveIdle();

        // 0 : Friendly, 1-2-3 : attack
        bool attack = urand(0 , 3);

        switch (getClass())
        {
            case CLASS_WARRIOR:
            {
                CastSpell(target, rand_number(SPELL_WAR_ATTACK_LIST));
                break;
            }
            case CLASS_PALADIN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PAL_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PAL_FRIEND_LIST));
                break;
            }
            case CLASS_HUNTER:
            {
                CastSpell(target, rand_number(SPELL_HUNT_ATTACK_LIST));
                break;
            }
            case CLASS_ROGUE:
            {
                CastSpell(target, rand_number(SPELL_ROG_ATTACK_LIST));
                break;
            }
            case CLASS_PRIEST:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PRI_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PRI_FRIEND_LIST));
                break;
            }
            case CLASS_DEATH_KNIGHT:
            {
                CastSpell(target, rand_number(SPELL_DK_ATTACK_LIST));
                break;
            }
            case CLASS_SHAMAN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_CHA_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_CHA_FRIEND_LIST));
                break;
            }
            case CLASS_MAGE:
            {
                CastSpell(target, rand_number(SPELL_MAG_ATTACK_LIST));
                break;
            }
            case CLASS_WARLOCK:
            {
                CastSpell(target, rand_number(SPELL_DEM_ATTACK_LIST));
                break;
            }
            case CLASS_DRUID:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_DRU_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_DRU_FRIEND_LIST));
                break;
            }
            case CLASS_MONK:
            {
                CastSpell(target, rand_number(SPELL_MONK_ATTACK_LIST));
                break;
            }
            default:
                break;
        }
    }
}

uint32 Player::GetRuneBaseCooldown() const
{
    return RUNE_BASE_COOLDOWN * std::min(1.0f, GetFloatValue(UNIT_FIELD_MOD_HASTE));
}

void Player::SetRuneCooldown(uint8 index, uint32 cooldown, bool casted /*= false*/)
{
    uint32 gracePeriod = GetRuneTimer(index);

    if (casted && isInCombat())
    {
        if (gracePeriod < 0xFFFFFFFF && cooldown > 0)
        {
            uint32 lessCd = std::min(uint32(2500), gracePeriod);
            cooldown = (cooldown > lessCd) ? (cooldown - lessCd) : 0;
            SetLastRuneGraceTimer(index, lessCd);
        }

        SetRuneTimer(index, 0);
    }

    m_runes->Cooldown[index] = cooldown;
    m_runes->SetRuneState(index, (cooldown == 0) ? true : false);
}

void Player::InitRunes()
{
    if (getClass() != CLASS_DEATH_KNIGHT)
        return;

    uint32 runeIndex = GetPowerIndex(POWER_RUNES, CLASS_DEATH_KNIGHT);
    if (runeIndex == MAX_POWERS)
        return;

    m_runes = new Runes();
    m_runes->RuneState = 0;

    for (uint8 i = 0; i < MAX_RUNES; ++i)
    {
        SetRuneCooldown(i, 0);                                          // reset cooldowns
        SetRuneTimer(i, 0xFFFFFFFF);                                    // Reset rune flags
        SetLastRuneGraceTimer(i, 0);
    }

    // set a base regen timer equal to 10 sec
    SetStatFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + runeIndex, 0.01f);
    SetStatFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + runeIndex, 0.01f);
}

void Runes::SetRuneState(uint8 index, bool set /*= true*/)
{
    auto itr = std::find(CooldownOrder.begin(), CooldownOrder.end(), index);
    if (set)
    {
        RuneState |= (1 << index);                      // usable
        if (itr != CooldownOrder.end())
            CooldownOrder.erase(itr);
    }
    else
    {
        RuneState &= ~(1 << index);                     // on cooldown
        if (itr == CooldownOrder.end())
            CooldownOrder.push_back(index);
    }
}

void Player::RestoreRune()
{
    if (!m_runes->CooldownOrder.size())
        return;

    ModifyPower(POWER_RUNES, 1);
    uint8 l_BeforeState = GetRunesState();
    uint8 l_RuneIndex = m_runes->CooldownOrder.back();
    SetRuneCooldown(l_RuneIndex, 0);                                          // reset cooldowns
    SetRuneTimer(l_RuneIndex, 0xFFFFFFFF);                                    // Reset rune flags
    ResyncRunes(m_runes->CooldownOrder.size(), 0);
}

void Player::ResyncRunes(uint8 p_Count, uint8 p_OldState)
{
    WorldPacket l_Data(SMSG_RESYNC_RUNES);

    l_Data << uint8(p_OldState);             ///< Start
    l_Data << uint8(GetRunesState());        ///< Count

    l_Data << uint32(p_Count);               ///< Cooldowns lenght

    for (uint32 l_I = 0; l_I < p_Count; ++l_I)
    {
        float l_BaseCooldown = GetRuneBaseCooldown();
        uint32 l_CooldownDelta = l_BaseCooldown - GetRuneCooldown(l_I);
        uint8 l_CooldownPkt = (float(l_CooldownDelta) / l_BaseCooldown) * 255;

        l_Data << uint8(l_CooldownPkt);
    }

    GetSession()->SendPacket(&l_Data);
}

#pragma region Achievement
void Player::SendRespondInspectAchievements(Player* player) const
{
    m_achievementMgr->SendAchievementInfo(player);
}

uint32 Player::GetAchievementPoints() const
{
    return m_achievementMgr->GetAchievementPoints();
}

bool Player::HasAchieved(uint32 achievementId) const
{
    return m_achievementMgr->HasAchieved(achievementId);
}

uint32 Player::GetAchievementProgress(uint32 p_AchievementID) const
{
    return m_achievementMgr->GetAchievementProgress(p_AchievementID);
}

bool Player::HasModifierTreeSatisfied(uint32 p_ModifierTreeID) const
{
    return m_achievementMgr->ModifierTreeSatisfied(p_ModifierTreeID);
}

void Player::ResetAchievements()
{
    m_achievementMgr->Reset();
}

void Player::ResetCriteria(CriteriaTypes type, uint64 miscValue1, uint64 miscValue2, bool evenIfCriteriaComplete)
{
    m_achievementMgr->ResetCriteria(type, miscValue1, miscValue2, evenIfCriteriaComplete);
}

void Player::UpdateCriteria(CriteriaTypes type, uint64 miscValue1, uint64 miscValue2, uint64 miscValue3, Unit* unit)
{
    if (sWorld->getBoolConfig(CONFIG_ACHIEVEMENT_DISABLE) || GetSession()->PlayerLoading() || !IsInWorld())
        return;

    m_achievementMgr->UpdateCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);

    // Update only individual achievement criteria here, otherwise we may get multiple updates
    // from a single boss kill
    if (CriteriaMgr::IsGroupCriteriaType(type))
        return;

    // Update scenario/challenge criterias
    if (Scenario* progress = sScenarioMgr->GetScenario(GetMap()->GetScenarioGuid()))
        progress->GetAchievementMgr().UpdateCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);

    /// @TODO cross guild
#ifndef CROSS
    Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
    if (guild)
        guild->UpdateCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
#endif
}

void Player::StartCriteriaTimer(CriteriaTimedTypes type, uint32 entry, uint32 timeLost)
{
    m_achievementMgr->StartCriteriaTimer(type, entry, timeLost);
}

void Player::RemoveCriteriaTimer(CriteriaTimedTypes type, uint32 entry)
{
    m_achievementMgr->RemoveCriteriaTimer(type, entry);
}

void Player::CompletedAchievement(AchievementEntry const* entry)
{
    m_achievementMgr->CompletedAchievement(entry, this);
}

bool Player::ModifierTreeSatisfied(uint32 modifierTreeId) const
{
    return m_achievementMgr->ModifierTreeSatisfied(modifierTreeId);
}

void Player::ResetCriteriaTree(CriteriaTree const* p_Tree)
{
    if (p_Tree->Criteria)
        m_achievementMgr->RemoveCriteriaProgress(p_Tree->Criteria);

    for (auto const& l_SubTree : p_Tree->Children)
        ResetCriteriaTree(l_SubTree);
}

#pragma endregion

void Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, bool broadcast)
{
    Loot loot;
    loot.FillLoot (loot_id, store, this, true, true);

    uint32 max_slot = loot.GetMaxSlotInLootFor(this);
    for (uint32 i = 0; i < max_slot; ++i)
    {
        LootItem* lootItem = loot.LootItemInSlot(i, this);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(bag, slot, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && slot != NULL_SLOT)
            msg = CanStoreNewItem(bag, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && bag != NULL_BAG)
            msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, NULL, NULL, lootItem->itemid);
            continue;
        }

        Item* pItem = StoreNewItem(dest, lootItem->itemid, true, lootItem->randomPropertyId);
        SendNewItem(pItem, lootItem->count, false, false, broadcast);
    }
}

void Player::StoreLootItem(uint8 lootSlot, Loot* loot, uint8 linkedLootSlot)
{
    QuestItem* qitem = NULL;
    QuestItem* ffaitem = NULL;
    QuestItem* conditem = NULL;
    QuestItem* currency = NULL;

    LootItem* item = loot->LootItemInSlot(lootSlot, this, &qitem, &ffaitem, &conditem, &currency);

    if (!item)
    {
        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
        return;
    }

    if (item->alreadyAskedForRoll)
    {
        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
        return;
    }

    // questitems use the blocked field for other purposes
    if (!qitem && item->is_blocked)
    {
        SendLootRelease(GetLootGUID());
        return;
    }

    if (currency)
    {
        if (CurrencyTypesEntry const * currencyEntry = sCurrencyTypesStore.LookupEntry(item->itemid))
            ModifyCurrency(item->itemid, int32(item->count * currencyEntry->GetPrecision()));

        SendNotifyLootItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot);
        currency->is_looted = true;
        --loot->UnlootedCount;

        /// Complete the tracking quest if needed
        AddTrackingQuestIfNeeded(loot->source);
        return;
    }

    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count);
    if (msg == EQUIP_ERR_OK)
    {
        AllowedLooterSet looters = item->GetAllowedLooters();
        std::vector<uint32> l_Bonuses = item->itemBonuses;
        Item* newitem = StoreNewItem(dest, item->itemid, true, item->randomPropertyId, looters, l_Bonuses);

        if (qitem)
        {
            qitem->is_looted = true;
            //freeforall is 1 if everyone's supposed to get the quest item.
            if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
                SendNotifyLootItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot);
            else
                loot->NotifyQuestItemRemoved(qitem->index);
        }
        else
        {
            if (ffaitem)
            {
                //freeforall case, notify only one player of the removal
                ffaitem->is_looted = true;
                SendNotifyLootItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot);
            }
            else
            {
                //not freeforall, notify everyone
                if (conditem)
                    conditem->is_looted = true;
                loot->NotifyItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot, item->PersonalLooter);
            }
        }

        //if only one person is supposed to loot the item, then set it to looted
        if (!item->freeforall)
            item->is_looted = true;

        --loot->UnlootedCount;

        ItemContext l_Context   = ItemContext::None;
        uint32 l_EncounterID    = 0;
        if (Creature* l_Creature = Creature::GetCreature(*this, loot->source))
        {
            if (InstanceScript* l_InstanceScript = l_Creature->GetInstanceScript())
                l_EncounterID = l_InstanceScript->GetEncounterIDForBoss(l_Creature);
        }
        else if (GameObject* l_Gob = GameObject::GetGameObject(*this, loot->source))
        {
            if (InstanceScript* l_InstanceScript = l_Gob->GetInstanceScript())
                l_EncounterID = l_InstanceScript->GetEncounterIDForChest(l_Gob->GetEntry());
        }

        switch (GetMap()->GetDifficultyID())
        {
            case Difficulty::DifficultyRaidLFR:
                l_Context = ItemContext::RaidLfr;
                break;
            case Difficulty::DifficultyRaidNormal:
                l_Context = ItemContext::RaidNormal;
                break;
            case Difficulty::DifficultyRaidHeroic:
                l_Context = ItemContext::RaidHeroic;
                break;
            case Difficulty::DifficultyRaidMythic:
                l_Context = ItemContext::RaidMythic;
                break;
            case Difficulty::DifficultyNormal:
                l_Context = ItemContext::DungeonNormal;
                break;
            case Difficulty::DifficultyHeroic:
                l_Context = ItemContext::DungeonHeroic;
                break;
            case Difficulty::DifficultyMythic:
                l_Context = ItemContext::DungeonMythic;
                break;
            case Difficulty::DifficultyMythicKeystone:
                l_Context = ItemContext::ChallengeMode;
                break;
            default:
                break;
        }

        /// If item is AP item, quest item, don't log
        if (!newitem || !newitem->GetTemplate() || newitem->GetModifier(ItemModifiers::ITEM_MODIFIER_ARTIFACT_KNOWLEDGE_LEVEL) ||
            newitem->GetTemplate()->Bonding == BIND_QUEST_ITEM || newitem->GetTemplate()->Flags2 & uint32(ItemFlagsEX2::DONT_REPORT_LOOT_LOG_TO_PARTY) || l_Context == ItemContext::None)
        {
            l_EncounterID   = 0;
            l_Context       = ItemContext::None;
        }

#ifndef CROSS
        if (const ItemTemplate* proto = sObjectMgr->GetItemTemplate(item->itemid))
            if (proto->Quality > ITEM_QUALITY_EPIC || (proto->Quality == ITEM_QUALITY_EPIC && proto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
                if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                    guild->GetNewsLog().AddNewEvent(GUILD_NEWS_ITEM_LOOTED, time(NULL), GetGUID(), 0, newitem->GetGUIDLow(), newitem);
#endif

        SendNewItem(newitem, uint32(item->count), false, false, true, l_EncounterID, l_Context);

        /// Handle achievement criteria related to loot
        UpdateCriteria(CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
        UpdateCriteria(CRITERIA_TYPE_LOOT_TYPE, item->itemid, item->count, loot->Type, this);
        UpdateCriteria(CRITERIA_TYPE_LOOT_EPIC_ITEM, item->itemid, item->count);

        /// Complete the tracking quest if needed
        AddTrackingQuestIfNeeded(loot->source);
    }
    else
        SendEquipError(msg, NULL, NULL, item->itemid);
}

void Player::AddTrackingQuestIfNeeded(uint64 p_SourceGuid)
{
    uint32 l_TrackingQuest = 0;

    /// If source is a creature
    if (IS_UNIT_GUID(p_SourceGuid))
    {
        Creature* l_CreatureSource = sObjectAccessor->FindCreature(p_SourceGuid);
        if (l_CreatureSource == nullptr)
            return;

        l_TrackingQuest = l_CreatureSource->GetTrackingQuestID();
        if (!l_TrackingQuest)
            return;

        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuest);
        if (IsQuestBitFlaged(l_QuestBit))
            return;

        l_CreatureSource->AddAllowerTrackingQuestLooter(GetGUID());

        //if (l_CreatureSource->GetCreatureTemplate()->RequiredExpansion == Expansion::EXPANSION_LEGION && l_TrackingQuest && !GetMap()->IsDungeon())
            //CompleteLegendaryActivity(LegendaryActivity::RareCreature);
    }

    /// If source is a gameobject
    if (IS_GAMEOBJECT_GUID(p_SourceGuid))
    {
        GameObject const* l_GameObjectSource = sObjectAccessor->FindGameObject(p_SourceGuid);
        if (l_GameObjectSource == nullptr)
            return;

        l_TrackingQuest = l_GameObjectSource->GetGOInfo()->GetTrackingQuestId();

        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuest);
        if (IsQuestBitFlaged(l_QuestBit))
            return;

        //if (l_GameObjectSource->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST &&  l_TrackingQuest && GetMap()->GetEntry()->Expansion() == Expansion::EXPANSION_LEGION && !GetMap()->IsDungeon())
            //CompleteLegendaryActivity(LegendaryActivity::Treasure);
    }

    /// @TODO: Item can have tracking quest ?
    /// If someone as more informations, please tell me :D

    if (l_TrackingQuest == 0)
        return;

    auto l_Quest = sObjectMgr->GetQuestTemplate(l_TrackingQuest);
    if (l_Quest == nullptr)
        return;

    SetQuestStatus(l_Quest->GetQuestId(), QUEST_STATUS_COMPLETE);
    RewardQuest(l_Quest, 0, nullptr, false);
}

bool Player::IsKnowHowFlyIn(uint32 mapid, uint32 zone, uint32 spellId) const
{
    if (isGameMaster())
        return true;

    if (zone == 8443)
        return true;

    // Tempest Keep: Eye
    if (mapid == 550 && spellId == 39432)
        return true;

    /// Pride of Kezan in The Lost Isles
    if (zone == 4720 && spellId == 73427)
        return true;

    /// Allowing fly in Antorus the Burning Throne for Warframes transportation and teleport pods
    if (zone == 8638 && (spellId == 253936 || spellId == 253773))
        return true;

    /// Allowing fly on Helheim for quest Paid in Lifeblood
    if (zone == 7588 && spellId == 192669)
        return true;

    /// Allowing fly on Haustvald for quest The Final Judgment
    if (zone == 7541 && spellId == 209241)
        return true;

    /// Allowing fly on Darkmoon faire for mini game
    if (mapid == 974 && spellId == 170820)
        return true;

    /// Eye of the Storm is always allowed in Throne of the Four Winds
    if (zone == 5638 && spellId == 82724)
        return true;

    /// Wings of Flame is always allowed in Firelands
    if (zone == 5723 && spellId == 98619)
        return true;

    /// Neltharion's Lair - Entrance Run
    if (zone == 7546 && spellId == 209888)
        return true;

    /// Tol Barad
    if (mapid == 732)
        return false;

    /// Tarren Mill
    if (mapid == 1280)
        return false;

    switch (zone)
    {
        case 3455: ///< North Sea
        case 3433: ///< Ghostlands
        case 3430: ///< Eversong Woods
        case 3487: ///< Silvermoon City
        case 6455: ///< Sunstrider Isle
        case 4080: ///< Quel'Danas
        case 3557: ///< Exodar
        case 3524: ///< Azuremist Isle
        case 6456: ///< Ammen Vale
        case 3479: ///< Veiled Sea
        case 3525: ///< Bloodmist Isle
        case 6757: ///< Timeless Isle
        case 6661: ///< Isle of Giants
        case 0:    ///< Unk
            return false;
        default:
            break;
    }

    /// continent checked in SpellMgr::GetSpellAllowedInLocationError at cast and area update
    uint32 v_map = GetVirtualMapForMapAndZone(mapid, zone);
    switch (v_map)
    {
        case 0:    ///< Eastern Kingdoms
        case 1:    ///< Kalimdor
        case 646:  ///< Deepholm
        case 1190: ///< BlastedLands Dark portal
        case 571: ///< Northrend
        case 530: ///< Outland
        case 870: ///< Pandaria
            return HasSpell(34090); ///< Expert Riding
        case 1116: ///< Draenor
            return HasSpell(191645); ///< Draenor Pathfinder
        case 1220: ///< Broken Isles
            return HasSpell(233368); ///< Broken Isles Pathfinder part 2
    }

#ifndef CROSS
    if (mapid == MS::Garrison::GDraenor::Globals::BaseMap || (GetDraenorGarrison() && (mapid == (GetDraenorGarrison()->GetGarrisonSiteLevelEntry() ? GetDraenorGarrison()->GetGarrisonSiteLevelEntry()->MapID : -1) || (mapid == GetDraenorGarrison()->GetShipyardMapId()))))
        return HasSpell(191645);    ///< Draenor Pathfinder
#endif

    return false;
}

void Player::learnSpellHighRank(uint32 spellid)
{
    learnSpell(spellid, false);

    if (uint32 next = sSpellMgr->GetNextSpellInChain(spellid))
        learnSpellHighRank(next);
}

void Player::_LoadSkills(PreparedQueryResult result)
{
    //                                                           0      1      2
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));

    uint32 count = 0;
    uint8 professionCount = 0;
    std::unordered_map<uint32, uint32> loadedSkillValues;
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint16 skill    = fields[0].GetUInt16();
            uint16 value    = fields[1].GetUInt16();
            uint16 max      = fields[2].GetUInt16();

            SkillRaceClassInfoEntry const* rcEntry = GetSkillRaceClassInfo(skill, getRace(), getClass());
            if (!rcEntry)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u has forbidden skill %u for his race/class combination", GetGUIDLow(), skill);
                mSkillStatus.insert(SkillStatusMap::value_type(skill, SkillStatusData(0, SKILL_DELETED)));
                continue;
            }

            // set fixed skill ranges
            switch (GetSkillRangeType(rcEntry))
            {
                case SKILL_RANGE_LANGUAGE:                      // 300..300
                    value = max = 300;
                    break;
                case SKILL_RANGE_MONO:                          // 1..1, grey monolite bar
                    value = max = 1;
                    break;
                case SKILL_RANGE_LEVEL:
                    max = GetMaxSkillValueForLevel();
                default:
                    break;
            }

            if (value == 0)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);
                PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, skill);
                RealmDatabase.Execute(stmt);
                continue;
            }

            uint16 field = count / 2;
            uint8 offset = count & 1;

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, skill);
            uint16 step = 0;

            SkillLineEntry const* skillLine = sSkillLineStore.LookupEntry(rcEntry->SkillID);
            if (skillLine)
            {
                if (skillLine->CategoryID == SKILL_CATEGORY_SECONDARY)
                    step = max / 75;

                if (skillLine->CategoryID == SKILL_CATEGORY_PROFESSION)
                {
                    step = max / 75;

                    if (professionCount < 2)
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + professionCount++, skill);
                }
            }

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, value);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, max);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

            mSkillStatus.insert(SkillStatusMap::value_type(skill, SkillStatusData(count, SKILL_UNCHANGED)));
            loadedSkillValues[skill] = value;

            ++count;

            if (count >= PLAYER_MAX_SKILLS)                      // client limit
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
                break;
            }
        }
        while (result->NextRow());
    }

    // Learn skill rewarded spells after all skills have been loaded to prevent learning a skill from them before its loaded with proper value from DB
    for (auto& skill : loadedSkillValues)
        learnSkillRewardedSpells(skill.first, skill.second);

    if (HasSkill(SKILL_FIST_WEAPONS))
        SetSkill(SKILL_FIST_WEAPONS, 0, GetSkillValue(SKILL_UNARMED), GetMaxSkillValueForLevel());

    // Initialize unknow profession skill, needed since 5.4
    for (uint32 i = 0; i < sSkillLineStore.GetNumRows(); i++)
    {
        SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(i);
        if (!pSkill)
            continue;

        if (pSkill->CategoryID != SKILL_CATEGORY_PROFESSION && pSkill->CategoryID != SKILL_CATEGORY_SECONDARY)
            continue;

        if (HasSkill(i))
            continue;

        uint16 value = 0;
        uint16 max = 75;
        uint16 step = 0;

        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, i);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, value);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, max);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

        ++count;

        if (count >= PLAYER_MAX_SKILLS)                      // client limit
        {
            sLog->outError(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
            break;
        }
    }

    for (; count < PLAYER_MAX_SKILLS; ++count)
    {
        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);
    }
}

InventoryResult Player::CanEquipUniqueItem(Item* item, uint8 eslot, uint32 limit_count) const
{
    ItemTemplate const* itemTemplate = item->GetTemplate();
    if (InventoryResult res = CanEquipUniqueItem(itemTemplate, eslot, limit_count))
        return res;

    for (ItemDynamicFieldGems const& gemData : item->GetGems())
    {
        ItemTemplate const* gem = sObjectMgr->GetItemTemplate(gemData.ItemId);
        if (!gem)
            continue;

        if (InventoryResult res = CanEquipUniqueItem(gem, eslot, !item->IsEquipped() && gem->ItemLimitCategory ? item->GetGemCountWithLimitCategory(gem->ItemLimitCategory) : 1))
            return res;
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanEquipUniqueItem(ItemTemplate const* itemProto, uint8 except_slot, uint32 limit_count) const
{
    // check unique-equipped on item
    if (itemProto->Flags & int32(ItemFlags::UNIQUE_EQUIPPABLE))
    {
        // there is an equip limit on this item
        if (HasItemOrGemWithIdEquipped(itemProto->ItemId, 1, except_slot))
            return EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE;
    }

    // check unique-equipped limit
    if (itemProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(itemProto->ItemLimitCategory);
        if (!limitEntry)
            return EQUIP_ERR_NOT_EQUIPPABLE;

        // NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case

        uint8 l_MaxCount = limitEntry->GetMaxCount(this);

        if (limit_count > l_MaxCount)
            return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS;

        // there is an equip limit on this item
        if (HasItemOrGemWithLimitCategoryEquipped(itemProto->ItemLimitCategory, l_MaxCount - limit_count + 1, except_slot))
            return EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED;
    }

    return EQUIP_ERR_OK;
}

void Player::HandleFall(MovementInfo const& movementInfo)
{
    // calculate total z distance of the fall
    float z_diff = m_lastFallZ - movementInfo.pos.GetPositionZ();
    //sLog->outDebug(LOG_FILTER_GENERAL, "zDiff = %f", z_diff);

    //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
    // 14.57 can be calculated by resolving damageperc formula below to 0
    if (z_diff >= 14.57f && !isDead() && !isGameMaster() &&
        (!HasAuraType(SPELL_AURA_HOVER) || HasAura(212552)) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
        !HasAuraType(SPELL_AURA_FLY) && !IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
    {
        //Safe fall, fall height reduction
        int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);

        // Glyph of Safe Fall
        if (HasAura(58033) && HasAura(1860))
            safe_fall += 10;

        float damageperc = 0.018f*(z_diff-safe_fall)-0.2426f;

        if (damageperc > 0)
        {
            uint32 damage = (uint32)(damageperc * GetMaxHealth()*sWorld->getRate(RATE_DAMAGE_FALL));

            float height = movementInfo.pos.m_positionZ;
            UpdateGroundPositionZ(movementInfo.pos.m_positionX, movementInfo.pos.m_positionY, height);

            if (damage > 0)
            {
                // Gust of Wind
                if (HasAura(43621))
                    damage = GetMaxHealth()/2;

                // Percentage from SPELL_AURA_REDUCE_FALL_DAMAGE_PERCENT
                AuraEffectList const& mReduceFallDamagePct = GetAuraEffectsByType(SPELL_AURA_REDUCE_FALL_DAMAGE_PERCENT);
                for (AuraEffectList::const_iterator i = mReduceFallDamagePct.begin(); i != mReduceFallDamagePct.end(); ++i)
                    AddPct(damage, (*i)->GetAmount());

                //Prevent fall damage from being more than the player maximum health
                if (damage > GetMaxHealth())
                    damage = GetMaxHealth();

                uint64 original_health = GetHealth();
                uint32 final_damage = EnvironmentalDamage(DAMAGE_FALL, damage);


                // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
                if (isAlive() && final_damage < original_health)
                    UpdateCriteria(CRITERIA_TYPE_FALL_WITHOUT_DYING, uint32(z_diff*100));
            }

            //Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
            sLog->outDebug(LOG_FILTER_PLAYER, "FALLDAMAGE z=%f sz=%f pZ=%f FallTime=%d mZ=%f damage=%d SF=%d", movementInfo.pos.GetPositionZ(), height, GetPositionZ(), movementInfo.fallTime, height, damage, safe_fall);
        }
    }

    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LANDING); // No fly zone - Parachute

    /// Handler for Disengage, should give Posthaste just after landing
    /// If in future we have some spells with same mechanic, just need to add switch
    if (getClass() == CLASS_HUNTER && (m_SpellHelper.GetUint32(eSpellHelpers::LastUsedLeapBackSpell) == 56446) && HasAura(109215))
        CastSpell(this, 118922, true);

    m_SpellHelper.GetUint32(eSpellHelpers::LastUsedLeapBackSpell) = 0;
}

bool Player::LearnPvPTalent(uint32 p_TalentID)
{
    PvpTalentEntry const* l_TalentEntry = sPvpTalentStore.LookupEntry(p_TalentID);
    if (!l_TalentEntry)
        return false;

    if (!GetPrestige() && GetHonorLevel() < GetPvPTalentLevelRequirement(l_TalentEntry->m_CollumnIndex, l_TalentEntry->m_TierIndex))
        return false;

    if (l_TalentEntry->m_Class && l_TalentEntry->m_Class != getClass())
        return false;

    if (l_TalentEntry->m_SpecID && l_TalentEntry->m_SpecID != GetActiveSpecializationID())
        return false;

    if (HasPvPTalent(p_TalentID))
        return false;

    if (!IsMaxLevel())
        return false;

    if (GetMap()->IsChallengeMode())
        return false;

    if (uint32 l_TalentToRemove = GetPvPTalentAtTier(l_TalentEntry->m_TierIndex))
    {
        RemovePvPTalent(l_TalentToRemove);
        if (HasAura(134735))
        {
            PvpTalentEntry const* l_TalentEntrytoRemove = sPvpTalentStore.LookupEntry(l_TalentToRemove);
            removeSpell(l_TalentEntrytoRemove->m_SpellID, false, false);
            learnSpell(l_TalentEntry->m_SpellID, false, false, false, 0, true);

            switch (l_TalentEntrytoRemove->m_SpellID)
            {
            case 247483:
                RemoveAura(248643);
                RemoveAura(248648);
                RemoveAura(248646);
                break;
            case 215982:
                removeSpell(215769, false, false);
                break;
            }

            switch (l_TalentEntry->m_SpellID)
            {
            case 247483:
                CastSpell(this, 248643, true);
                break;
            case 215982:
                learnSpell(215769, false, false, true);
                break;
            }
        }
    }

    if (l_TalentEntry->m_OverridesSpellID)
        AddOverrideSpell(l_TalentEntry->m_OverridesSpellID, l_TalentEntry->m_SpellID);

    StorePvPTalent(l_TalentEntry);

    return true;
}

void Player::RemovePvPTalent(uint32 p_TalentID)
{
    PvpTalentEntry const* l_TalentEntry = sPvpTalentStore.LookupEntry(p_TalentID);
    if (!l_TalentEntry)
        return;

    if (GetPvPTalentAtTier(l_TalentEntry->m_TierIndex) != l_TalentEntry->m_ID)
        return;

    if (l_TalentEntry->m_OverridesSpellID)
        RemoveOverrideSpell(l_TalentEntry->m_OverridesSpellID, l_TalentEntry->m_SpellID);

    RemoveInteralPvPTalent(l_TalentEntry->m_TierIndex);
}

void Player::AddKnownCurrency(uint32 itemId)
{
    if (CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(itemId))
        SetFlag64(0, (1LL << (ctEntry->ID-1)));
}

void Player::UpdateFallInformationIfNeed(MovementInfo const& minfo, uint16 opcode)
{
    if (m_lastFallTime >= minfo.fallTime || m_lastFallZ <= minfo.pos.GetPositionZ() || opcode == CMSG_MOVE_FALL_LAND)
        SetFallInformation(minfo.fallTime, minfo.pos.GetPositionZ());
}

void Player::UnsummonPetTemporaryIfAny()
{
    Pet* pet = GetPet();
    if (!pet)
        return;

    if (!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned())
    {
        m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetRealmPetNumber();
        m_oldpetspell = pet->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL);
    }

    RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, false, pet->m_Stampeded);
}

void Player::ResummonPetTemporaryUnSummonedIfAny()
{
    if (!m_temporaryUnsummonedPetNumber)
        return;

    // not resummon in not appropriate state
    if (IsPetNeedBeTemporaryUnsummoned())
        return;

    if (GetPetGUID())
        return;

    Pet*   l_NewPet     = new Pet(this);
    uint64 l_PlayerGUID = GetGUID();
    uint32 l_PetNumber  = m_temporaryUnsummonedPetNumber;

#ifdef CROSS
    uint32 l_RealmID    = GetSession()->GetInterRealmNumber();
#else
    uint32 l_RealmID    = g_RealmID;
#endif

    PreparedStatement* l_PetStatement = PetQueryHolder::GenerateFirstLoadStatement(0, m_temporaryUnsummonedPetNumber, GetRealGUIDLow(), true, PET_SLOT_UNK_SLOT, l_RealmID);
    RealmDatabase.AsyncQuery(l_PetStatement, m_QueryCallbackMgr, [l_NewPet, l_PlayerGUID, l_PetNumber, l_RealmID](PreparedQueryResult p_Result) -> void
    {
        Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);

        if (!p_Result || !l_Player)
        {
            l_NewPet->CleanBeforeGC();
            sGarbageCollector->Add(l_NewPet);
            return;
        }

#ifdef CROSS
        InterRealmClient* l_Client = sInterRealmMgr->GetClientByRealmNumber(l_RealmID);
        if (!l_Client || !l_Client->GetDatabase())
        {
            l_NewPet->CleanBeforeGC();
            sGarbageCollector->Add(l_NewPet);
            return;
        }

        auto l_Database = l_Client->GetDatabase();
#else
        auto l_Database = &CharacterDatabase;
#endif

        PetQueryHolder* l_PetHolder = new PetQueryHolder(p_Result->Fetch()[0].GetUInt32(), l_RealmID, p_Result);
        l_PetHolder->Initialize();

        auto l_QueryHolderResultFuture = l_Database->DelayQueryHolder(l_PetHolder);

        l_Player->GetQueryCallbackMgr()->AddQueryHolderCallback(QueryHolderCallback(l_QueryHolderResultFuture, [l_NewPet, l_PlayerGUID, l_PetNumber](SQLQueryHolder* p_QueryHolder) -> void
        {
            Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
            if (!l_Player || !p_QueryHolder || l_Player != l_NewPet->GetOwner())
            {
                l_NewPet->CleanBeforeGC();
                sGarbageCollector->Add(l_NewPet);
                return;
            }

            l_NewPet->LoadPetFromDB(l_Player, 0, l_PetNumber, true, PET_SLOT_UNK_SLOT, false, (PetQueryHolder*)p_QueryHolder, [p_QueryHolder](Pet* p_Pet, bool p_Result)
            {
                delete p_QueryHolder;

                if (!p_Result)
                {
                    p_Pet->CleanBeforeGC();
                    sGarbageCollector->Add(p_Pet);
                    return;
                }
            });
        }));
    });

    m_temporaryUnsummonedPetNumber = 0;
}

bool Player::canSeeSpellClickOn(Creature const* c) const
{
    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(c->GetEntry());
    if (clickPair.first == clickPair.second)
        return true;

    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
    {
        if (!itr->second.IsFitToRequirements(this, c))
            return false;

        if (!sConditionMgr->IsObjectMeetingSpellClickConditions(c->GetEntry(), itr->second.spellId, const_cast<Player*>(this), const_cast<Creature*>(c)))
            return false;
    }

    return true;
}

void Player::BuildEnchantmentsInfoData(WorldPacket* data)
{
    uint32 slotUsedMask = 0;
    size_t slotUsedMaskPos = data->wpos();
    *data << uint32(slotUsedMask);                          // slotUsedMask < 0x80000

    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i);

        if (!item)
            continue;

        slotUsedMask |= (1 << i);

        *data << uint32(item->GetEntry());                  // item entry

        uint16 enchantmentMask = 0;
        size_t enchantmentMaskPos = data->wpos();
        *data << uint16(enchantmentMask);                   // enchantmentMask < 0x1000

        for (uint32 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
        {
            uint32 enchId = item->GetEnchantmentId(EnchantmentSlot(j));

            if (!enchId)
                continue;

            enchantmentMask |= (1 << j);

            *data << uint16(enchId);                        // enchantmentId?
        }

        data->put<uint16>(enchantmentMaskPos, enchantmentMask);

        *data << uint16(0);                                 // unknown
        data->appendPackGUID(item->GetGuidValue(ITEM_FIELD_CREATOR)); // item creator
        *data << uint32(0);                                 // seed?
    }

    data->put<uint32>(slotUsedMaskPos, slotUsedMask);
}

void Player::SendEquipmentSetList()
{
    /// Clear old equipmentset with local realm guid
    WorldPacket l_Data(SMSG_EQUIPMENT_SET_LIST);
    l_Data << uint32(0);
    GetSession()->SendPacket(&l_Data);

    uint32 l_EquipmentSetCount = 0;

    l_Data.Initialize(SMSG_EQUIPMENT_SET_LIST, 4 * 1024);

    for (EquipmentSets::iterator l_Itr = m_EquipmentSets.begin(); l_Itr != m_EquipmentSets.end(); ++l_Itr)
    {
        if (l_Itr->second.state == EQUIPMENT_SET_DELETED)
            continue;

        ++l_EquipmentSetCount;
    }

    l_Data << uint32(l_EquipmentSetCount);

    for (EquipmentSets::iterator l_Itr = m_EquipmentSets.begin(); l_Itr != m_EquipmentSets.end(); ++l_Itr)
    {
        EquipmentSet const& l_Set = l_Itr->second;

        if (l_Itr->second.state == EQUIPMENT_SET_DELETED)
            continue;

        l_Data << uint32(l_Set.Type);
        l_Data << uint64(l_Set.Guid);
        l_Data << uint32(l_Itr->first);
        l_Data << uint32(l_Set.IgnoreMask);

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            // ignored slots stored in IgnoreMask, client wants "1" as raw GUID, so no HIGHGUID_ITEM
            if (l_Set.IgnoreMask & (1 << i))
                l_Data.appendPackGUID(0);
            else
                l_Data.appendPackGUID(MAKE_NEW_GUID(l_Set.Items[i], 0, HIGHGUID_ITEM));

            l_Data << uint32(0);    ///< AppearanceID - NYI
        }

        l_Data << uint32(0);        ///< EnchantID[0] - NYI
        l_Data << uint32(0);        ///< EnchantID[1] - NYI

        l_Data.WriteBit(l_Set.AssignedSpecIndex != -1);
        l_Data.WriteBits(l_Set.Name.size(), 8);
        l_Data.WriteBits(l_Set.IconName.size(), 9);
        l_Data.FlushBits();

        if (l_Set.AssignedSpecIndex != -1)
            l_Data << int32(l_Set.AssignedSpecIndex);

        l_Data.WriteString(l_Set.Name);
        l_Data.WriteString(l_Set.IconName);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::SetEquipmentSet(uint32 index, EquipmentSet eqset)
{
    if (eqset.Guid != 0)
    {
        bool found = false;

        for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
        {
            if ((itr->second.Guid == eqset.Guid) && (itr->first == index))
            {
                found = true;
                break;
            }
        }

        if (!found)                                          // something wrong...
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to save equipment set " UI64FMTD " (index %u), but that equipment set not found!", GetName(), eqset.Guid, index);
            return;
        }
    }

    EquipmentSet& eqslot = m_EquipmentSets[index];

    EquipmentSetUpdateState old_state = eqslot.state;

    eqslot = eqset;

    if (eqset.Guid == 0)
#ifndef CROSS
        eqslot.Guid = sObjectMgr->GenerateEquipmentSetGuid();
#else /* CROSS */
        eqslot.Guid = InterRealmClient::GetIRClient(this)->GenerateLocalRealmLowGuid(HIGHGUID_EQUIPMENT_SET);
#endif /* CROSS */

    eqslot.state = old_state == EQUIPMENT_SET_NEW ? EQUIPMENT_SET_NEW : EQUIPMENT_SET_CHANGED;
}

void Player::_SaveEquipmentSets(SQLTransaction& trans)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end();)
    {
        uint32 index = itr->first;
        EquipmentSet& eqset = itr->second;
        PreparedStatement* stmt = NULL;
        uint8 j = 0;
        switch (eqset.state)
        {
            case EQUIPMENT_SET_UNCHANGED:
                ++itr;
                break;                                      // nothing do
            case EQUIPMENT_SET_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_EQUIP_SET);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                stmt->setUInt32(j++, eqset.Type);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                stmt->setInt32(j++, eqset.AssignedSpecIndex);
                stmt->setUInt32(j++, GetRealGUID());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j, index);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_EQUIP_SET);
                stmt->setUInt32(j++, GetRealGUIDLow());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j++, index);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                stmt->setUInt32(j++, eqset.Type);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                stmt->setInt32(j++, eqset.AssignedSpecIndex);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_DELETED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_EQUIP_SET);
                stmt->setUInt64(0, eqset.Guid);
                trans->Append(stmt);
                m_EquipmentSets.erase(itr++);
                break;
            default:
                break;
        }
    }
}

#ifdef CROSS
void Player::SaveArenaData()
{
    InterRealmDatabasePool* conn = NULL;
    if (InterRealmClient* irc = GetSession()->GetInterRealmClient())
        conn = irc->GetDatabase();

    if (!conn)
        return;

    SQLTransaction trans = conn->BeginTransaction();

    _SaveArenaData(trans);

    conn->CommitTransaction(trans);
}
#endif

void Player::_SaveArenaData(SQLTransaction& p_Transaction)
{
    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_BRACKET_DATA);
    l_Statement->setUInt32(0, GetRealGUIDLow());
    p_Transaction->Append(l_Statement);

    for (uint8 l_Bracket = 0; l_Bracket < (uint8)BattlegroundBracketType::Max; ++l_Bracket)
    {
        l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_BRACKET_DATA);

        l_Statement->setUInt32(0,  GetRealGUIDLow());
        l_Statement->setUInt8(1,   l_Bracket);
        l_Statement->setUInt32(2,  m_ArenaPersonalRating[l_Bracket]);
        l_Statement->setUInt32(3,  m_BestRatingOfWeek[l_Bracket]);
        l_Statement->setUInt32(4,  m_BestRatingOfPrevWeek[l_Bracket]);
        l_Statement->setUInt32(5,  m_BestRatingOfSeason[l_Bracket]);
        l_Statement->setInt32(6,   m_ArenaMatchMakerRating[l_Bracket]);
        l_Statement->setUInt32(7,  m_DayGames[l_Bracket]);
        l_Statement->setUInt32(8,  m_DayWins[l_Bracket]);
        l_Statement->setUInt32(9,  m_WeekGames[l_Bracket]);
        l_Statement->setUInt32(10, m_WeekWins[l_Bracket]);
        l_Statement->setUInt32(11, m_PrevWeekWins[l_Bracket]);
        l_Statement->setUInt32(12, m_PrevWeekGames[l_Bracket]);
        l_Statement->setUInt32(13, m_SeasonGames[l_Bracket]);
        l_Statement->setUInt32(14, m_SeasonWins[l_Bracket]);

        p_Transaction->Append(l_Statement);
    }
}

void Player::_SaveBGData(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);
    /* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell, lastActiveSpec, lastSpecId */
    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_PLAYER_BGDATA);
    stmt->setUInt32(0,  GetRealGUIDLow());
    stmt->setUInt32(1,  m_bgData.bgInstanceID);
    stmt->setUInt16(2,  m_bgData.bgTeam);
    stmt->setFloat (3,  m_bgData.joinPos.GetPositionX());
    stmt->setFloat (4,  m_bgData.joinPos.GetPositionY());
    stmt->setFloat (5,  m_bgData.joinPos.GetPositionZ());
    stmt->setFloat (6,  m_bgData.joinPos.GetOrientation());
    stmt->setUInt16(7,  m_bgData.joinPos.GetMapId());
    stmt->setUInt16(8,  m_bgData.taxiPath[0]);
    stmt->setUInt16(9,  m_bgData.taxiPath[1]);
    stmt->setUInt16(10, m_bgData.mountSpell);
    stmt->setUInt8 (11, m_bgData.m_LastActiveSpec);
    stmt->setUInt32(12, m_bgData.bgTypeID);
    stmt->setBool  (13,  m_bgData.IsRandom);
    trans->Append(stmt);
}

#ifdef CROSS
void Player::SaveCrossServerArenaData()
{
    if (!GetSession() || !GetSession()->GetInterRealmClient())
        return;

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    for (uint8 l_Bracket = 0; l_Bracket < (uint8)BattlegroundBracketType::Max; ++l_Bracket)
    {
        trans->PAppend
        (
            "REPLACE INTO character_bracket_data (realmId, guid, bracket, rating, bestRatingOfWeek, bestRatingOfPrevWeek, bestRatingOfSeason, matchMakerRating, dayGames, dayWins, weekGames, weekWins, prevWeekWins, prevWeekGames, seasonGames, seasonWins) VALUES "
            "(%u, %u , %u , %u , %u , %u , %u , %u , %u , %u , %u , %u , %u , %u , %u , %u )",
            GetSession()->GetInterRealmClient()->GetRealmId(), GetRealGUIDLow(), l_Bracket, m_ArenaPersonalRating[l_Bracket], m_BestRatingOfWeek[l_Bracket], m_BestRatingOfPrevWeek[l_Bracket], m_BestRatingOfSeason[l_Bracket], m_ArenaMatchMakerRating[l_Bracket], m_DayGames[l_Bracket],
            m_DayWins[l_Bracket], m_WeekGames[l_Bracket], m_WeekWins[l_Bracket], m_PrevWeekWins[l_Bracket], m_PrevWeekGames[l_Bracket], m_SeasonGames[l_Bracket], m_SeasonWins[l_Bracket]
        );
    }

    CharacterDatabase.CommitTransaction(trans);
}
#endif

void Player::DeleteEquipmentSet(uint64 setGuid)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
    {
        if (itr->second.Guid == setGuid)
        {
            if (itr->second.state == EQUIPMENT_SET_NEW)
                m_EquipmentSets.erase(itr);
            else
                itr->second.state = EQUIPMENT_SET_DELETED;
            break;
        }
    }
}

void Player::RemoveAtLoginFlag(AtLoginFlags flags, bool persist /*= false*/)
{
    m_atLoginFlags &= ~flags;

    if (persist)
    {
        PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_REM_AT_LOGIN_FLAG);
        stmt->setUInt16(0, uint16(flags));
        stmt->setUInt32(1, GetRealGUIDLow());
        CharacterDatabase.Execute(stmt);
    }
}

void Player::SendClearCooldown(uint32 p_SpellID, Unit* p_Target, bool p_ClearOnHold)
{
    WorldPacket l_Data(SMSG_CLEAR_COOLDOWN);

    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(p_ClearOnHold = (p_Target == this));
    l_Data.WriteBit(p_Target == GetPet());             ///< IsPetCooldown
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::ModifySpellCooldown(uint32 p_SpellID, int32 p_Delta)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo)
        return;

    //AddSpellCooldown(p_SpellID, 0, p_Delta);
    ReduceSpellCooldown(p_SpellID, p_Delta);
}

void Player::ResetMap()
{
    // this may be called during Map::Update
    // after decrement+unlink, ++m_mapRefIter will continue correctly
    // when the first element of the list is being removed
    // nocheck_prev will return the padding element of the RefManager
    // instead of NULL in the case of prev
    GetMap()->UpdateIteratorBack(this);

    Unit::ResetMap();
    GetMapRef().unlink();
}

void Player::ResetMapForTeleport()
{
    GetMap()->AddLeavingPlayer(GetGUID());
    SetOldMap(GetMap());

    ResetMap();

    SetCurrMap(GetOldMap());
}

void Player::SetMap(Map* map)
{
    if (Map* l_OldMap = GetOldMap())
    {
        uint64 l_PlayerGUID = GetGUID();
        l_OldMap->AddTask([l_OldMap, l_PlayerGUID]() -> void
        {
            l_OldMap->RemoveLeavingPlayer(l_PlayerGUID);
        });

        SetOldMap(nullptr);
    }

    Unit::SetMap(map);
    m_mapRef.link(map, this);
}

void Player::_LoadTalents(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS, "SELECT spell, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
        {
            if (TalentEntry const* talent = sTalentStore.LookupEntry((*result)[0].GetUInt32()))
                AddTalent(talent, (*result)[1].GetUInt8(), false);
        }
        while (result->NextRow());
    }
}

void Player::_LoadPVPTalents(PreparedQueryResult p_Result)
{
    if (p_Result)
    {
        do
        {
            Field* l_Fields = p_Result->Fetch();
            LoadAddPvPTalentFromDB(l_Fields[0].GetUInt32(), l_Fields[1].GetUInt32());
        }
        while (p_Result->NextRow());
    }
}

void Player::_SaveTalents(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    PlayerTalentMap* talents;
    for (uint8 group = 0; group < MAX_SPECIALIZATIONS; ++group)
    {
        talents = GetTalentMap(group);
        for (PlayerTalentMap::iterator itr = talents->begin(); itr != talents->end();)
        {
            if (itr->second == PLAYERSPELL_REMOVED)
            {
                itr = talents->erase(itr);
                continue;
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, itr->first);
            stmt->setUInt8(2, group);
            trans->Append(stmt);
            ++itr;
        }
    }
}

void Player::_SavePvPTalents(SQLTransaction& p_Trans)
{
    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PVP_TALENTS);
    l_Stmt->setUInt32(0, GetGUIDLow());
    p_Trans->Append(l_Stmt);

    std::ostringstream ss;
    ss << "INSERT INTO character_pvp_talent (guid, spell, spec) VALUES ";

    bool l_First = true;

    for (uint32 l_Spec = 0; l_Spec < MAX_SPECIALIZATIONS; ++l_Spec)
    {
        std::vector<uint32> const& l_PvPTalents = _talentMgr->PvPTalents[l_Spec];
        {
            for (auto l_Talent : l_PvPTalents)
            {
                if (!l_Talent)
                    continue;

                if (l_First)
                {
                    l_First = false;
                }
                else
                {
                    ss << ", ";
                }

                ss << "(" <<  GetGUIDLow() << ", " << l_Talent << ", " << l_Spec << ")";
            }

        }
    }
    ss << ";";

    if (!l_First)
        p_Trans->Append(ss.str().c_str());
}

void Player::ActivateTalentGroup(ChrSpecializationsEntry const* spec)
{
    if (GetActiveTalentGroup() == spec->OrderIndex)
        return;

    if (IsNonMeleeSpellCasted(false))
        InterruptNonMeleeSpells(false);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveActions(trans);
    CharacterDatabase.CommitTransaction(trans);

    // TO-DO: We need more research to know what happens with warlock's reagent
    if (Pet* pet = GetPet())
        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT);

    ClearAllReactives();
    UnsummonAllTotems();
    ExitVehicle();
    RemoveAllControlled();
    /*RemoveAllAurasOnDeath();
    if (GetPet())
    GetPet()->RemoveAllAurasOnDeath();*/

    //RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
    //ExitVehicle(); // should be impossible to switch specs from inside a vehicle..

    // Let client clear his current Actions
    SendActionButtons(2);
    // m_actionButtons.clear() is called in the next _LoadActionButtons
    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
    {
        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
        if (!talentInfo)
            continue;

        // unlearn only talents for character class
        // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
        // to prevent unexpected lost normal learned spell skip another class talents
        if (talentInfo->ClassID != getClass())
            continue;

        if (talentInfo->SpellID == 0)
            continue;

        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talentInfo->SpellID);
        if (!spellInfo)
            continue;

        removeSpell(talentInfo->SpellID, true);

        // search for spells that the talent teaches and unlearn them
        for (int l_I = 0; l_I < spellInfo->EffectCount; ++l_I)
        {
            SpellEffectInfo const* effect = &spellInfo->Effects[l_I];

            if (effect && effect->TriggerSpell > 0 && effect->Effect == SPELL_EFFECT_LEARN_SPELL)
                removeSpell(effect->TriggerSpell, true);
        }

        if (talentInfo->OverridesSpellID)
            RemoveOverrideSpell(talentInfo->OverridesSpellID, talentInfo->SpellID);
    }

    // Remove spec specific spells
    RemoveSpecializationSpells();

    for (uint32 l_GlyphID : GetGlyphs(GetActiveTalentGroup()))
    {
        if (GlyphPropertiesEntry const* l_PropEntry = sGlyphPropertiesStore.LookupEntry(l_GlyphID))
            RemoveAurasDueToSpell(l_PropEntry->SpellID);
    }

    for (uint8 l_I = 0; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            _ApplyItemMods(l_Item, l_I, false);
            RemoveItemsSetItem(this, l_Item->GetTemplate());
        }
    }

    if (HasAura(uint32(PvPStatsSpells::PVP_RULES_ENABLED)))
        DeactivatePvPTalents();

    SetActiveTalentGroup(spec->OrderIndex);
    SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, spec->ID);

    if (!GetPrimarySpecialization())
        SetPrimarySpecialization(spec->ID);

    if (HasAura(uint32(PvPStatsSpells::PVP_RULES_ENABLED)))
        ActivatePvPTalents();

    for (uint8 l_I = 0; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            _ApplyItemMods(l_Item, l_I, true);
            AddItemsSetItem(this, l_Item);
        }
    }

    Powers l_Power = GetDisplayPowerForCurrentState();
    if (getPowerType() != l_Power)
        setPowerType(l_Power);

    for (uint8 l_I = POWER_MANA; l_I < MAX_POWERS; ++l_I)
    {
        SetMaxPower(Powers(l_I), GetCreatePowers(Powers(l_I)));
        SetPower(Powers(l_I), 0);
    }

    EquipProperArtifactIfNeeded();

    LearnSpecializationSpells();
    UpdateMasteryPercentage();

    auto l_CanUseMastery = [this]()
    {
        if (ChrSpecializationsEntry const* chrSpec = sChrSpecializationsStore.LookupEntry(GetActiveSpecializationID()))
            return HasSpell(chrSpec->MasterySpellID) || HasSpell(chrSpec->MasterySpellID2);

        return false;
    };

    if (l_CanUseMastery())
    {
        if (uint32 mastery = spec->MasterySpellID)
            learnSpell(mastery, false);

        if (uint32 mastery = spec->MasterySpellID2)
            learnSpell(mastery, false);
    }

    InitTalentForLevel();

    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt8(1, GetActiveTalentGroup());

        uint64 l_PlayerGuid = GetGUID();

        CharacterDatabase.AsyncQuery(stmt, m_QueryCallbackMgr, [l_PlayerGuid](PreparedQueryResult const& p_Result)
        {
            Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGuid);
            if (!l_Player)
                return;

            if (p_Result)
                l_Player->_LoadActions(p_Result);

            l_Player->SendActionButtons(1);
        });
    }

    Powers pw = getPowerType();
    if (pw != POWER_MANA)
        SetPower(POWER_MANA, 0); // Mana must be 0 even if it isn't the active power type.

    SetPower(pw, 0);
    UpdateItemSetAuras(false);
    // update visible transmog
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        if (Item* equippedItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            SetVisibleItemSlot(i, equippedItem);

    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
    {
        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
        if (!talentInfo)
            continue;

        // learn only talents for character class
        if (talentInfo->ClassID != getClass())
            continue;

        if (!talentInfo->SpellID)
            continue;

        // if the talent can be found in the newly activated PlayerTalentMap
        if (HasTalent(talentInfo->Id, GetActiveTalentGroup()))
        {
            int32 l_SpellOnCooldown = 0;
            LearnTalent(talentInfo->Id, &l_SpellOnCooldown, true);      // add the talent to the PlayerSpellMap
            if (talentInfo->OverridesSpellID)
                AddOverrideSpell(talentInfo->OverridesSpellID, talentInfo->SpellID);
        }
    }

    for (uint32 l_GlyphID : GetGlyphs(GetActiveTalentGroup()))
    {
        if (GlyphPropertiesEntry const* l_PropEntry = sGlyphPropertiesStore.LookupEntry(l_GlyphID))
            CastSpell(this, l_PropEntry->SpellID, true);
    }

    SendGlyphs();
}

void Player::ResetTimeSync()
{
    m_timeSyncTimer = 0;
    m_timeSyncClient = 0;
    m_timeSyncServer = getMSTime();
}

void Player::SendTimeSync()
{
    WorldPacket data(SMSG_TIME_SYNC_REQUEST, 4);
    data << uint32(m_movementCounter++);
    GetSession()->SendPacket(&data);

    // Schedule next sync in 10 sec
    m_timeSyncTimer = 10000;
    m_timeSyncServer = getMSTime();
}

void Player::SetReputation(uint32 factionentry, uint32 value)
{
    GetReputationMgr().SetReputation(sFactionStore.LookupEntry(factionentry), value);
}

uint32 Player::GetReputation(uint32 factionentry)
{
    return GetReputationMgr().GetReputation(sFactionStore.LookupEntry(factionentry));
}

std::string Player::GetGuildName()
{
#ifndef CROSS
    return GetGuildId() ? sGuildMgr->GetGuildById(GetGuildId())->GetName() : "";
#else /* CROSS */
    return GetGuild() ? sGuildMgr->GetInterRealmGuild(GetSession()->GetInterRealmNumber(), GetGuildId())->GetName() : "";
#endif /* CROSS */
}

void Player::MountSetFavorite(uint32 p_SpellID, bool p_IsFavorite)
{
    if (m_spells.find(p_SpellID) == m_spells.end())
        return;

    m_spells[p_SpellID]->IsMountFavorite = p_IsFavorite;
    m_spells[p_SpellID]->state = PLAYERSPELL_CHANGED;

    WorldPacket l_Data(SMSG_ACCOUNT_MOUNT_UPDATE, 1 + 4 + 4 + 4 + 1);
    l_Data.WriteBit(false); ///< Is full update
    l_Data.FlushBits();
    l_Data << uint32(1);    ///< One update

    l_Data << uint32(p_SpellID);
    l_Data.WriteBits(p_IsFavorite ? 2 : 0, 2);
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

//////////////////////////////////////////////////////////////////////////
/// Talent
//////////////////////////////////////////////////////////////////////////
uint32 Player::GetTalentResetCost() const
{
    return _talentMgr->ResetTalentsCost;
}

void Player::SetTalentResetCost(uint32 cost)
{
    _talentMgr->ResetTalentsCost = cost;
}

time_t Player::GetTalentResetTime() const
{
    return _talentMgr->ResetTalentsTime;
}

void Player::SetTalentResetTime(time_t time_)
{
    _talentMgr->ResetTalentsTime = time_;
}

uint32 Player::GetPrimarySpecialization() const
{
    return _talentMgr->PrimarySpecialization;
}

void Player::SetPrimarySpecialization(uint32 spec)
{
    _talentMgr->PrimarySpecialization = spec;
}

uint8 Player::GetActiveTalentGroup() const
{
    return _talentMgr->ActiveGroup;
}

void Player::SetActiveTalentGroup(uint8 group)
{
    _talentMgr->ActiveGroup = group;
}

uint32 Player::GetDefaultSpecId() const
{
    if (ChrSpecializationsEntry const* entry = GetDefaultChrSpecializationForClass(getClass()))
        return entry->ID;

    sLog->outAshran("Player::GetDefaultSpecId : DefaultSpecializationForClass is null");
    return 0;
}

uint32 Player::GetActiveSpecializationID() const
{
    return GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);
}

bool Player::ResetTalents(bool noCost)
{
    sScriptMgr->OnPlayerTalentsReset(this, noCost);

    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_TALENTS, true);

    uint32 cost = 0;

    if (!noCost && !sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST))
    {
        cost = GetNextResetTalentsCost();

        if (!HasEnoughMoney(uint64(cost)))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, nullptr, 0, 0);
            return false;
        }
    }

    RemovePet(nullptr, PetSlot::PET_SLOT_ACTUAL_PET_SLOT, true);

    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
    {
        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
        if (!talentInfo)
            continue;

        // unlearn only talents for character class
        // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
        // to prevent unexpected lost normal learned spell skip another class talents
        if (talentInfo->ClassID != getClass())
            continue;

        // skip non-existent talent ranks
        if (talentInfo->SpellID == 0)
            continue;

        RemoveTalent(talentInfo);
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    SQLTransaction accountTrans = LoginDatabase.BeginTransaction();
    _SaveTalents(trans);
    _SaveSpells(trans, accountTrans);
    CharacterDatabase.CommitTransaction(trans);
    LoginDatabase.CommitTransaction(accountTrans);

    if (!noCost)
    {
        ModifyMoney(-(int64)cost, "Player::ResetTalents");
        UpdateCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, cost);
        UpdateCriteria(CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);

        SetTalentResetCost(cost);
        SetTalentResetTime(time(nullptr));
    }

    /* when prev line will dropped use next line
    if (Pet* pet = GetPet())
    {
    if (pet->getPetType() == HUNTER_PET && !pet->GetCreatureTemplate()->IsTameable(CanTameExoticPets()))
    RemovePet(NULL, PET_SAVE_NOT_IN_SLOT, true);
    }
    */

    return true;
}

uint32 Player::GetNextResetTalentsCost() const
{
    // The first time reset costs 1 gold
    if (GetTalentResetCost() < 1 * GOLD)
        return 1 * GOLD;
    // then 5 gold
    else if (GetTalentResetCost() < 5 * GOLD)
        return 5 * GOLD;
    // After that it increases in increments of 5 gold
    else if (GetTalentResetCost() < 10 * GOLD)
        return 10 * GOLD;
    else
    {
        uint64 months = (sWorld->GetGameTime() - GetTalentResetTime()) / MONTH;
        if (months > 0)
        {
            // This cost will be reduced by a rate of 5 gold per month
            int32 new_cost = int32(GetTalentResetCost() - 5 * GOLD*months);
            // to a minimum of 10 gold.
            return (new_cost < 10 * GOLD ? 10 * GOLD : new_cost);
        }
        else
        {
            // After that it increases in increments of 5 gold
            int32 new_cost = GetTalentResetCost() + 5 * GOLD;
            // until it hits a cap of 50 gold.
            if (new_cost > 50 * GOLD)
                new_cost = 50 * GOLD;
            return new_cost;
        }
    }
}

void Player::InitTalentForLevel()
{
    uint8 level = getLevel();
    // talents base at level diff (talents = level - 9 but some can be used already)
    if (level < MIN_SPECIALIZATION_LEVEL)
        ResetTalentSpecialization();

    uint32 talentTiers = CalculateTalentsTiers();
    if (level >= 15)
    {
        for (uint32 t = talentTiers; t < MAX_TALENT_TIERS; ++t)
        {
            for (uint32 c = 0; c < MAX_TALENT_COLUMNS; ++c)
            {
                for (TalentEntry const* talent : GetTalentsByPosition(getClass(), GetActiveSpecializationID(), t, c))
                    RemoveTalent(talent);
            }
        }
    }

    SetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS, talentTiers);

    if (!GetSession()->PlayerLoading())
        SendTalentsInfoData(); // update at client
}

void Player::SendTalentsInfoData()
{
    uint8 l_SpecCount = 0;
    WorldPacket l_Data(SMSG_UPDATE_TALENT_DATA, 4096);

    ByteBuffer l_TalentData;
    for (uint8 l_SpeIT = 0; l_SpeIT < MAX_SPECIALIZATIONS; ++l_SpeIT)
    {
        ChrSpecializationsEntry const* l_Specialization = GetChrSpecializationByIndex(getClass(), l_SpeIT);
        if (!l_Specialization)
            continue;

        l_SpecCount++;
        PlayerTalentMap* l_TalentMap = GetTalentMap(l_SpeIT);

        ByteBuffer l_Talents(400);
        int l_TalentCount = 0;

        for (PlayerTalentMap::const_iterator l_TalentIT = l_TalentMap->begin(); l_TalentIT != l_TalentMap->end(); ++l_TalentIT)
        {
            if (l_TalentIT->second == PLAYERSPELL_REMOVED)
                continue;

            TalentEntry const* l_TalentInfo = sTalentStore.LookupEntry(l_TalentIT->first);
            if (!l_TalentInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player::SendTalentsInfoData: Player '%s' (%u) has unknown talent id: %u",
                    GetName(), GetGUIDLow(), l_TalentIT->first);
                continue;
            }

            if (l_TalentInfo->ClassID != getClass())
                continue;

            SpellInfo const* l_SpellEntry = sSpellMgr->GetSpellInfo(l_TalentInfo->SpellID);
            if (!l_SpellEntry)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player::SendTalentsInfoData: Player '%s' (%u) has unknown talent spell: %u",
                    GetName(), GetGUIDLow(), l_TalentInfo->SpellID);
                continue;
            }

            l_Talents << uint16(uint16(l_TalentIT->first));
            l_TalentCount++;
        }

        ByteBuffer l_PvPTalentBuffer(MAX_PVP_TALENT_SPELLS * sizeof(uint16));
        int l_PvpTalentCount = 0;

        std::vector<uint32> const& l_PvPTalents = *GetPvPTalentMap(l_SpeIT);

        for (uint32 l_I = 0; l_I < l_PvPTalents.size(); ++l_I)
        {
            uint16 l_ID = l_PvPTalents[l_I];

            if (!l_ID)
                continue;

            l_PvPTalentBuffer << uint16(l_ID);
            ++l_PvpTalentCount;
        }

        l_TalentData << uint32(l_Specialization->ID);
        l_TalentData << uint32(l_TalentCount);
        l_TalentData << uint32(l_PvpTalentCount);

        l_TalentData.append(l_Talents);
        l_TalentData.append(l_PvPTalentBuffer);
    }

    l_Data << uint8(GetActiveTalentGroup());
    l_Data << uint32(GetPrimarySpecialization());
    l_Data << uint32(l_SpecCount);
    l_Data.append(l_TalentData);

    GetSession()->SendPacket(&l_Data);
}

TalentLearnResult Player::LearnTalent(uint32 talentId, int32* spellOnCooldown, bool p_Forced /*= false*/)
{
    if (isInCombat())
        return TALENT_FAILED_AFFECTING_COMBAT;

    if (isDead() || (GetMap()->IsBattlegroundOrArena() && !HasAura(BattlegroundSpells::SPELL_ARENA_PREPARATION) && !HasAura(BattlegroundSpells::SPELL_PREPARATION)))
        return TALENT_FAILED_CANT_DO_THAT_RIGHT_NOW;

    if (!GetActiveSpecializationID())
        return TALENT_FAILED_NO_PRIMARY_TREE_SELECTED;

    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
    if (!talentInfo)
        return TALENT_FAILED_UNKNOWN;

    if (talentInfo->SpecID && talentInfo->SpecID != GetActiveSpecializationID())
        return TALENT_FAILED_UNKNOWN;

    // prevent learn talent for different class (cheating)
    if (talentInfo->ClassID != getClass())
        return TALENT_FAILED_UNKNOWN;

    // check if we have enough talent points
    if (talentInfo->TierID >= GetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS))
        return TALENT_FAILED_UNKNOWN;

    // TODO: prevent changing talents that are on cooldown

    // Check if there is a different talent for us to learn in selected slot
    // Example situation:
    // Warrior talent row 2 slot 0
    // Talent.db2 has an entry for each specialization
    // but only 2 out of 3 have SpecID != 0
    // We need to make sure that if player is in one of these defined specs he will not learn the other choice
    TalentEntry const* bestSlotMatch = nullptr;
    for (TalentEntry const* talent : GetTalentsByPosition(getClass(), GetActiveSpecializationID(), talentInfo->TierID, talentInfo->ColumnIndex))
    {
        if (!talent->SpecID)
            bestSlotMatch = talent;
        else if (talent->SpecID == GetActiveSpecializationID())
        {
            bestSlotMatch = talent;
            break;
        }
    }

    if (talentInfo != bestSlotMatch)
        return TALENT_FAILED_UNKNOWN;

    /// Player must be in a rest area to change his talents if he doesn't have "Tome of the Tranquil Mind" aura, never trust client!
    bool l_CanReplaceTalent = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION) || HasAuraType(SPELL_AURA_CAN_CHANGE_TALENT);

    bool l_Found = false;
    for (std::pair<uint32, PlayerSpellState> l_Talent : *GetTalentMap(GetActiveTalentGroup()))
    {
        TalentEntry const* l_TalentEntry = sTalentStore.LookupEntry(l_Talent.first);
        if (!l_TalentEntry)
            continue;

        if (l_TalentEntry->TierID == talentInfo->TierID)
        {
            l_Found = true;
            break;
        }
    }

    if (l_Found == false)
        l_CanReplaceTalent = true;

    // Check if player doesn't have any talent in current tier
    for (uint32 c = 0; c < MAX_TALENT_COLUMNS; ++c)
    {
        for (TalentEntry const* talent : GetTalentsByPosition(getClass(), GetActiveSpecializationID(), talentInfo->TierID, c))
        {
            if (HasTalent(talent->Id, GetActiveTalentGroup()) && !l_CanReplaceTalent && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
                return TALENT_FAILED_REST_AREA;

            if (HasSpellCooldown(talent->SpellID))
            {
                *spellOnCooldown = talent->SpellID;
                return TALENT_FAILED_CANT_REMOVE_TALENT;
            }

            if (Spell const* l_CurrentSpell = GetCurrentSpell(CurrentSpellTypes::CURRENT_GENERIC_SPELL))
                if (l_CurrentSpell->GetSpellInfo()->Id == talent->SpellID)
                    InterruptSpell(CurrentSpellTypes::CURRENT_GENERIC_SPELL);

            if (l_CanReplaceTalent || p_Forced)
            {
                /// Should be able to learn talent even out of rest area if there is no learned talent in the line
                if (HasTalent(talent->Id, GetActiveTalentGroup()))
                    RemoveTalent(talent);

                if (HasSpell(talent->SpellID))
                    removeSpell(talent->SpellID);

                /// Must remove current Beacon of Light when learning talent Beacon of Virtue
                if (talentInfo->OverridesSpellID == 53563)
                {
                    if (Unit* l_PreviousBeaconTarget = Unit::GetUnit(*this, GetBeaconOfLightTarget()))
                        l_PreviousBeaconTarget->RemoveAura(talentInfo->OverridesSpellID);
                }

                continue;
            }
            else
                return TALENT_FAILED_REST_AREA;
        }
    }

    // spell not set in talent.db2
    uint32 spellid = talentInfo->SpellID;
    if (!spellid)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::LearnTalent: Talent.db2 has no spellInfo for talent: %u (spell id = 0)", talentId);
        return TALENT_FAILED_UNKNOWN;
    }

    // already known
    if (HasTalent(talentId, GetActiveTalentGroup()) || HasSpell(spellid))
        return TALENT_FAILED_UNKNOWN;

    if (GetMap()->IsChallengeMode())
        return TALENT_FAILED_CANT_DO_THAT_CHALLENGE_MODE_ACTIVE;

    if (!AddTalent(talentInfo, GetActiveTalentGroup(), true))
        return TALENT_FAILED_UNKNOWN;

    if (spellid == 781 && GetActiveSpecializationID() == SPEC_HUNTER_SURVIVAL)
        learnSpell(spellid, false, false, false, 0, true); ///< Hunter should be able to learn disengage when his spec is survival
    else
        learnSpell(spellid, false);

    sLog->outDebug(LOG_FILTER_GENERAL, "Player::LearnTalent: TalentID: %u Spell: %u Group: %u\n", talentId, spellid, GetActiveTalentGroup());

    return TALENT_LEARN_OK;
}

bool Player::AddTalent(TalentEntry const* talent, uint8 spec, bool learning)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talent->SpellID);
    if (!spellInfo)
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::AddTalent: Spell (ID: %u) does not exist", talent->SpellID);
        return false;
    }

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::AddTalent: Spell (ID: %u) is invalid", talent->SpellID);
        return false;
    }

    if (talent->OverridesSpellID)
        AddOverrideSpell(talent->OverridesSpellID, talent->SpellID);

    PlayerTalentMap::iterator itr = GetTalentMap(spec)->find(talent->Id);
    if (itr != GetTalentMap(spec)->end())
        itr->second = PLAYERSPELL_UNCHANGED;
    else
        (*GetTalentMap(spec))[talent->Id] = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    return true;
}

bool Player::HasTalent(uint32 talentId, uint8 group) const
{
    PlayerTalentMap::const_iterator itr = GetTalentMap(group)->find(talentId);
    return (itr != GetTalentMap(group)->end() && itr->second != PLAYERSPELL_REMOVED);
}

void Player::RemoveTalent(TalentEntry const* p_Talent)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_Talent->SpellID);
    if (!l_SpellInfo)
        return;

    removeSpell(p_Talent->SpellID, true);

    // search for spells that the talent teaches and unlearn them
    for (int l_I = 0; l_I < l_SpellInfo->EffectCount; ++l_I)
    {
        SpellEffectInfo const* l_Effect = &l_SpellInfo->Effects[l_I];

        if (l_Effect && l_Effect->TriggerSpell > 0 && l_Effect->Effect == SPELL_EFFECT_LEARN_SPELL)
            removeSpell(l_Effect->TriggerSpell, true);
    }

    if (p_Talent->OverridesSpellID)
        RemoveOverrideSpell(p_Talent->OverridesSpellID, p_Talent->SpellID);

    // if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
    PlayerTalentMap::iterator l_PlayerTalentIt = GetTalentMap(GetActiveTalentGroup())->find(p_Talent->Id);
    if (l_PlayerTalentIt != GetTalentMap(GetActiveTalentGroup())->end())
        l_PlayerTalentIt->second = PLAYERSPELL_REMOVED;
}

uint32 Player::CalculateTalentsTiers() const
{
    uint32 const* l_RowLevels = nullptr;
    switch (getClass())
    {
        case CLASS_DEATH_KNIGHT:
            l_RowLevels = DKTalentRowLevels;
            break;

        case CLASS_DEMON_HUNTER:
            l_RowLevels = DHTalentRowLevels;
            break;

        default:
            l_RowLevels = DefaultTalentRowLevels;
            break;
    }

    for (uint32 l_I = MAX_TALENT_TIERS; l_I; --l_I)
    {
        if (getLevel() >= l_RowLevels[l_I - 1])
            return l_I;
    }

    return 0;
}

void Player::ResetTalentSpecialization()
{
    /// Reset only talents that have different spells for each spec
    uint32 l_Class = getClass();
    for (uint32 l_TalentTier = 0; l_TalentTier < MAX_TALENT_TIERS; ++l_TalentTier)
    {
        for (uint32 l_TalentColumn = 0; l_TalentColumn < MAX_TALENT_COLUMNS; ++l_TalentColumn)
        {
            if (GetTalentsByPosition(l_Class, GetActiveSpecializationID(), l_TalentTier, l_TalentColumn).size() > 1)
            {
                for (TalentEntry const* l_TalentEntry : GetTalentsByPosition(l_Class, GetActiveSpecializationID(), l_TalentTier, l_TalentColumn))
                    RemoveTalent(l_TalentEntry);
            }
        }
    }

    RemoveSpecializationSpells();

    if (ChrSpecializationsEntry const* l_DefaultSpec = GetDefaultChrSpecializationForClass(getClass()))
    {
        SetPrimarySpecialization(l_DefaultSpec->ID);
        SetActiveTalentGroup(l_DefaultSpec->OrderIndex);
        SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, l_DefaultSpec->ID);
    }
    else
        sLog->outAshran("Player::ResetTalentSpecialization : l_DefaultSpec is null");

    LearnSpecializationSpells();
    EquipProperArtifactIfNeeded();

    SendTalentsInfoData();
    UpdateItemSetAuras(false);
}

void Player::SendDuelCountdown(uint32 p_Coutdown)
{
    WorldPacket data(SMSG_DUEL_COUNTDOWN, 4);
    data << uint32(p_Coutdown);                 ///< seconds
    GetSession()->SendPacket(&data);
}

void Player::AddRefundReference(uint32 p_Iter)
{
    m_refundableItems.insert(p_Iter);
}

void Player::DeleteRefundReference(uint32 p_Iter)
{
    std::set<uint32>::iterator l_Iter = m_refundableItems.find(p_Iter);
    if (l_Iter != m_refundableItems.end())
        m_refundableItems.erase(l_Iter);
}

void Player::SendRefundInfo(Item* p_Item)
{
    /// This function call unset itemFlag::REFUNDABLE if played time is over 2 hours.
    p_Item->UpdatePlayedTime(this);

    if (!p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
        return;

    if (GetGUIDLow() != p_Item->GetRefundRecipient()) ///< Formerly refundable item got traded
    {
        p_Item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* l_ExtendedCost = sItemExtendedCostStore.LookupEntry(p_Item->GetPaidExtendedCost());
    if (!l_ExtendedCost)
        return;

    ObjectGuid l_ItemGUID = p_Item->GetGUID();
    WorldPacket l_Data(SMSG_SET_ITEM_PURCHASE_DATA);

    l_Data.appendPackGUID(l_ItemGUID);

    /// Content
    {
        l_Data << uint64(p_Item->GetPaidMoney());                               ///< Money cost

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
        {
            l_Data << uint32(l_ExtendedCost->RequiredItem[l_I]);
            l_Data << uint32(l_ExtendedCost->RequiredItemCount[l_I]);
        }

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
        {
            /// Second field in db2 is season count except one row
            if (l_I == 1 && l_ExtendedCost->ID != 2999)
            {
                l_Data << uint32(0);
                l_Data << uint32(0);
                continue;
            }

            l_Data << uint32(l_ExtendedCost->RequiredCurrency[l_I]);
            l_Data << uint32(l_ExtendedCost->RequiredCurrencyCount[l_I]);
        }
    }

    l_Data << uint32(0);                                                        ///< Flags
    l_Data << uint32(GetTotalPlayedTime() - p_Item->GetPlayedTime());           ///< Time Left

    GetSession()->SendPacket(&l_Data);
}

Item* Player::AddItem(uint32 p_ItemId, uint32 p_Count, std::list<uint32> p_Bonuses /*= { }*/, bool p_FromShop /*= false*/, uint32 p_EncounterID /*= 0*/, bool p_BonusRoll /*= false*/, bool p_ByMailIfNeeded /*= false*/, ItemContext p_Context /*= ItemContext::None*/)
{
    ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(p_ItemId);
    if (!l_ItemTemplate)
        return nullptr;

    ItemPosCountVec l_Dest;
    InventoryResult l_Message = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, p_ItemId, p_Count);

    if (l_Message != EQUIP_ERR_OK)
    {
        if (p_ByMailIfNeeded)
        {
            for (uint32 l_I = 0; l_I < p_Count; ++l_I)
            {
                SQLTransaction l_Transaction = RealmDatabase.BeginTransaction();
                MailDraft l_Draft(l_ItemTemplate->Name1->Get(GetSession()->GetSessionDbLocaleIndex()), "");

                Item* l_Item = Item::CreateItem(p_ItemId, 1, this);
                if (l_Item)
                {
                    for (auto l_Bonus : p_Bonuses)
                        l_Item->AddItemBonus(l_Bonus);

                    if (!p_FromShop)
                    {
                        std::vector<uint32> l_Bonus;
                        Item::GenerateItemBonus(l_Item->GetEntry(), p_Context, l_Bonus, false, this);
                        l_Item->AddItemBonuses(l_Bonus);
                    }

                    if (p_FromShop)
                        l_Item->ApplyCustomFlags(ItemCustomFlags::FromStore);

                    /// save new item before send
                    l_Item->SaveToDB(l_Transaction);
                    l_Draft.AddItem(l_Item);
                }

                l_Draft.SendMailTo(l_Transaction, this, MailSender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM));
                RealmDatabase.CommitTransaction(l_Transaction);
            }
        }
        return nullptr;
    }

    std::vector<uint32> l_Bonuses { std::begin(p_Bonuses), std::end(p_Bonuses) };

    if (!p_FromShop)
        Item::GenerateItemBonus(p_ItemId, p_Context, l_Bonuses, false, this);

    Item* l_Item = StoreNewItem(l_Dest, p_ItemId, true, Item::GenerateItemRandomPropertyId(p_ItemId), l_Bonuses);
    if (l_Item)
    {
        std::vector<uint32> l_Bonus;

        if (p_FromShop)
            l_Item->ApplyCustomFlags(ItemCustomFlags::FromStore);

        SendNewItem(l_Item, p_Count, true, false,false, p_EncounterID, p_Context, p_BonusRoll);
        return l_Item;
    }

    return nullptr;
}

void Player::SendItemRefundResult(Item* p_Item, ItemExtendedCostEntry const* p_ExtendedCost, uint8 p_Error)
{
    WorldPacket l_Data(Opcodes::SMSG_ITEM_PURCHASE_REFUND_RESULT);
    l_Data.appendPackGUID(p_Item->GetGUID());
    l_Data << uint8(p_Error);
    l_Data.WriteBit(!p_Error);

    if (!p_Error)
    {
        l_Data << uint64(p_Item->GetPaidMoney());

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
        {
            l_Data << uint32(p_ExtendedCost->RequiredItem[l_I]);
            l_Data << uint32(p_ExtendedCost->RequiredItemCount[l_I]);
        }

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
        {
            CurrencyTypesEntry const* l_CurrTemplate = sCurrencyTypesStore.LookupEntry(p_ExtendedCost->RequiredCurrency[l_I]);
            if (l_CurrTemplate != nullptr)
            {
                l_Data << uint32(p_ExtendedCost->RequiredCurrency[l_I]);

                if (l_CurrTemplate->Flags & CurrencyFlags::CURRENCY_FLAG_HIGH_PRECISION)
                    l_Data << uint32(p_ExtendedCost->RequiredCurrencyCount[l_I]);
                else
                    l_Data << uint32(p_ExtendedCost->RequiredCurrencyCount[l_I] / 100);
            }
            else
            {
                l_Data << uint32(0);
                l_Data << uint32(0);
            }
        }
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::RefundItem(Item* p_Item)
{
    if (!p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
    {
        SendItemRefundResult(p_Item, NULL, 10);
        return;
    }

    if (p_Item->IsRefundExpired())    ///< Item refund has expired
    {
        p_Item->SetNotRefundable(this);
        SendItemRefundResult(p_Item, NULL, 10);
        return;
    }

    if (GetGUIDLow() != p_Item->GetRefundRecipient()) ///< Formerly refundable item got traded
    {
        p_Item->SetNotRefundable(this);
        SendItemRefundResult(p_Item, NULL, 10);
        return;
    }

    ItemExtendedCostEntry const* l_ExtendedCost = sItemExtendedCostStore.LookupEntry(p_Item->GetPaidExtendedCost());
    if (!l_ExtendedCost)
        return;

    bool l_StoreError = false;
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
    {
        uint32 l_Count = l_ExtendedCost->RequiredItemCount[l_I];
        uint32 l_ItemID = l_ExtendedCost->RequiredItem[l_I];

        if (l_Count && l_ItemID)
        {
            ItemPosCountVec l_Dest;
            InventoryResult l_InvResult = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemID, l_Count);
            if (l_InvResult != EQUIP_ERR_OK)
            {
                l_StoreError = true;
                break;
            }
         }
    }

    if (l_StoreError)
    {
        SendItemRefundResult(p_Item, l_ExtendedCost, 10);
        return;
    }

    /// Check total cap
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        /// Second field in db2 is season count except one row
        /// @todo check if this is true now
        if (l_I == 1 && l_ExtendedCost->ID != 2999)
            continue;

        uint32 l_CurrencyID = l_ExtendedCost->RequiredCurrency[l_I];
        CurrencyTypesEntry const* l_CurrencyType = sCurrencyTypesStore.LookupEntry(l_CurrencyID);
        if (!l_CurrencyType)
            continue;

        uint32 l_Count = l_ExtendedCost->RequiredCurrencyCount[l_I] / l_CurrencyType->GetPrecision();
        uint32 l_CurrCount = GetCurrency(l_CurrencyID, l_CurrencyType->HasPrecision());

        uint32 l_TotalCap = CalculateCurrencyTotalCap(l_CurrencyID);
        if (l_TotalCap && (l_CurrCount + l_Count > (l_TotalCap / l_CurrencyType->GetPrecision())))
        {
            SendItemRefundResult(p_Item, l_ExtendedCost, 10);
            return;
        }
    }

    SendItemRefundResult(p_Item, l_ExtendedCost, 0);

    uint32 l_Entry       = p_Item->GetEntry();
    uint64 l_MoneyRefund = p_Item->GetPaidMoney();  ///< Item-> will be invalidated in DestroyItem

    /// Save all relevant data to DB to prevent desynchronizing exploits
    SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();

    /// Delete any references to the refund data
    p_Item->SetNotRefundable(this, true, &l_Transaction, false);
    GetSession()->GetCollectionMgr()->RemoveTemporaryAppearance(p_Item);

    /// Destroy item
    if (p_Item->GetEntry() == 138019)
        sLog->outAshran("Mythic Keystone delete [3]");
    DestroyItem(p_Item->GetBagSlot(), p_Item->GetSlot(), true);


    /// Grant back extended cost items ...
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        uint32 l_Count = l_ExtendedCost->RequiredItemCount[l_I];
        uint32 l_ItemID = l_ExtendedCost->RequiredItem[l_I];

        if (l_Count && l_ItemID)
        {
            ItemPosCountVec l_Dest;
            InventoryResult l_InvResult = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemID, l_Count);
            ASSERT(l_InvResult == EQUIP_ERR_OK) ///< Already checked before
            Item* l_Item = StoreNewItem(l_Dest, l_ItemID, true);
            SendNewItem(l_Item, l_Count, true, false, true);
        }
    }

    /// ... and currencies
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        /// Second field in db2 is season count except one row
        if (l_I == 1 && l_ExtendedCost->ID != 2999)
            continue;

        uint32 l_CurrencyID = l_ExtendedCost->RequiredCurrency[l_I];
        uint32 l_Count = l_ExtendedCost->RequiredCurrencyCount[l_I];

        if (l_CurrencyID && l_Count)
            ModifyCurrency(l_CurrencyID, l_Count, false, true, true);
    }

    /// Grant back money
    if (l_MoneyRefund)
        ModifyMoney(l_MoneyRefund, "Player::RefundItem " + std::to_string(l_Entry)); ///< Saved in SaveInventoryAndGoldToDB

    /// Grant back Arena and Honor points ?

    SaveInventoryAndGoldToDB(l_Transaction);

    RealmDatabase.CommitTransaction(l_Transaction);
}

bool Player::HasWinInBracket(BattlegroundBracketType p_BracketType, bool p_Daily) const
{
    return p_Daily ? m_DayWins[(uint8)p_BracketType] : m_WeekWins[(uint8)p_BracketType];
}

void Player::SetRandomWinner(bool p_IsWinner, bool p_DatabaseUpdate)
{
}

void Player::_LoadPvPInfo(PreparedQueryResult p_Result)
{
    if (!IsMaxLevel())
        return;

    if (!p_Result)
    {
        if (!GetHonorLevel())
            GiveHonorLevel();

        return;
    }

    Field* l_Fields = p_Result->Fetch();
    int l_I = 0;

    uint32 l_Honor = l_Fields[l_I++].GetUInt32();
    uint32 l_HonorLevel = std::min(std::max(1u, l_Fields[l_I++].GetUInt32()), (uint32)MAX_HONOR_LEVEL);
    uint32 l_Prestige = std::min(l_Fields[l_I++].GetUInt32(), GetMaxPrestigeLevel());

    SetUInt32Value(PLAYER_FIELD_HONOR_LEVEL, l_HonorLevel);
    if (l_Prestige >= GetMaxPrestigeLevel())
        l_Prestige = GetMaxPrestigeLevel();

    SetUInt32Value(PLAYER_FIELD_PRESTIGE, l_Prestige);
    UpdateRequiredHonor();

    if (l_Honor >= GetHonorRequiredForNextLevel())
        l_Honor = GetHonorRequiredForNextLevel() - 1;

    SetUInt32Value(PLAYER_FIELD_HONOR, l_Honor);
}

uint32 Player::GetAverageItemLevelEquipped() const
{
    int32 l_Sum = 0;
    uint32 l_Count = 0;
    bool l_HasTwoHanded = false;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged, offhand or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        if (i == EQUIPMENT_SLOT_OFFHAND && m_items[i] == nullptr && m_items[EQUIPMENT_SLOT_MAINHAND] && m_items[EQUIPMENT_SLOT_MAINHAND]->GetTemplate()->IsTwoHandedWeapon())
        {
            if (GetActiveSpecializationID() != SpecIndex::SPEC_WARRIOR_FURY)
                l_Sum += m_items[EQUIPMENT_SLOT_MAINHAND]->GetItemLevel(this);
        }

        if (Item* l_Item = m_items[i])
            l_Sum += l_Item->GetItemLevel(this);

        ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}

uint32 Player::GetAverageItemLevelTotal() const
{
    // If player has a 2h ignore offhand if not found (if found fury and count it)
    // If player does not have a 2h check offhand
    int l_EquipItemLevel[EQUIPMENT_SLOT_END];
    bool l_IsLegendary[EQUIPMENT_SLOT_END];
    uint8 l_LegendaryCount = 0;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            l_EquipItemLevel[i] = 0;
            l_IsLegendary[i] = false;
            continue;
        }

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            l_EquipItemLevel[i] = l_Item->GetItemLevel(this);

            /// Legion legendary
            if (l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && l_Item->GetTemplate()->ItemLimitCategory == 357)
            {
                l_IsLegendary[i] = true;
                l_LegendaryCount++;
            }

            continue;
        }

        l_EquipItemLevel[i] = 0;
        l_IsLegendary[i] = false;
    }

    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1], l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1], l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (l_Item->IsSuitableForItemLevelCalulcation(true))
            {
                int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                int l_ThisIlvl = l_Item->GetItemLevel(this);

                if (slot != NULL_SLOT && (l_LegendaryCount < 2 || l_IsLegendary[slot]))
                {
                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);

                    if (!l_IsLegendary[slot] && l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && l_Item->GetTemplate()->ItemLimitCategory == 357)
                    {
                        l_IsLegendary[slot] = true;
                        l_LegendaryCount++;
                    }
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* l_Item = pBag->GetItemByPos(j))
                {
                    if (l_Item->IsSuitableForItemLevelCalulcation(true))
                    {
                        int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                        int l_ThisIlvl = l_Item->GetItemLevel(this);

                        if (slot != NULL_SLOT && (l_LegendaryCount < 2 || l_IsLegendary[slot]))
                        {
                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);

                            if (!l_IsLegendary[slot] && l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && l_Item->GetTemplate()->ItemLimitCategory == 357)
                            {
                                l_IsLegendary[slot] = true;
                                l_LegendaryCount++;
                            }
                        }
                    }
                }
            }
        }
    }
    for (uint8 l_I = BANK_SLOT_ITEM_START; l_I < BANK_SLOT_ITEM_END; l_I++)
    {
        Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I);
        if (l_Item && l_Item->IsSuitableForItemLevelCalulcation(true))
        {
            int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
            int l_ThisIlvl = l_Item->GetItemLevel(this);

            if (slot != NULL_SLOT && (l_LegendaryCount < 2 || l_IsLegendary[slot]))
            {
                if (slot == EQUIPMENT_SLOT_TRINKET1)
                    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                if (slot == EQUIPMENT_SLOT_FINGER1)
                    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);

                if (!l_IsLegendary[slot] && l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && l_Item->GetTemplate()->ItemLimitCategory == 357)
                {
                    l_IsLegendary[slot] = true;
                    l_LegendaryCount++;
                }
            }
        }
    }

    for (uint8 l_I = BANK_SLOT_BAG_START; l_I < BANK_SLOT_BAG_END; l_I++)
    {
        if (Bag* pBag = GetBagByPos(l_I))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* l_Item = GetItemByPos(l_I, j);
                if (l_Item && l_Item->IsSuitableForItemLevelCalulcation(true))
                {
                    int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                    int l_ThisIlvl = l_Item->GetItemLevel(this);

                    if (slot != NULL_SLOT && (l_LegendaryCount < 2 || l_IsLegendary[slot]))
                    {
                        if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                            l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                        if (slot == EQUIPMENT_SLOT_TRINKET1)
                            l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                        if (slot == EQUIPMENT_SLOT_FINGER1)
                            l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                        l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);

                        if (!l_IsLegendary[slot] && l_Item && l_Item->GetQuality() == ItemQualities::ITEM_QUALITY_LEGENDARY && l_Item->GetTemplate()->IsStuff() && l_Item->GetTemplate()->ItemLimitCategory == 357)
                        {
                            l_IsLegendary[slot] = true;
                            l_LegendaryCount++;
                        }
                    }
                }
            }
        }
    }

    int32 l_Sum = 0;
    uint32 l_Count = 0;
    bool l_HasTwoHanded = false;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged, offhand or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY || i == EQUIPMENT_SLOT_OFFHAND)
            continue;

        l_Sum += l_EquipItemLevel[i];
        ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}

uint32 Player::GetAverageItemLevelTotalWithOrWithoutPvPBonus(bool p_PvP) const
{
    // If player has a 2h ignore offhand if not found (if found fury and count it)
    // If player does not have a 2h check offhand
    int l_EquipItemLevel[EQUIPMENT_SLOT_END];

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            l_EquipItemLevel[i] = 0;
            continue;
        }

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            l_EquipItemLevel[i] = l_Item->GetItemLevel(this, !p_PvP, p_PvP);

            if (i == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

            if (i == EQUIPMENT_SLOT_OFFHAND && l_Item->GetTemplate()->Class == ITEM_CLASS_WEAPON)
                l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND]);

            continue;
        }

        l_EquipItemLevel[i] = 0;
    }

    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1], l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1], l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (l_Item->IsSuitableForItemLevelCalulcation(true))
            {
                int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(l_Item->GetItemLevel(this));

                if (slot != NULL_SLOT)
                {
                    if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                        l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* l_Item = pBag->GetItemByPos(j))
                {
                    if (l_Item->IsSuitableForItemLevelCalulcation(true))
                    {
                        int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                        int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(l_Item->GetItemLevel(this));

                        if (slot != NULL_SLOT)
                        {
                            if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                        }
                    }
                }
            }
        }
    }

    uint32 l_Sum = 0;
    uint32 l_Count = 0;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        if (i == EQUIPMENT_SLOT_OFFHAND && !l_EquipItemLevel[i])
            continue;

        l_Sum += l_EquipItemLevel[i];
        ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}

void Player::_LoadInstanceTimeRestrictions(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        _instanceResetTimes.insert(InstanceTimeMap::value_type(fields[0].GetUInt32(), fields[1].GetUInt64()));
    }
    while (result->NextRow());
}

void Player::_LoadCUFProfiles(PreparedQueryResult result)
{
    if (result)
    {
        uint32 count = result->GetRowCount();
        if (count > MAX_CUF_PROFILES)
            count = MAX_CUF_PROFILES;

        m_cufProfiles.resize(count);

        uint32 i = 0;
        do
        {
            Field* fields = result->Fetch();

            CUFProfile& profile = m_cufProfiles[i];

            std::string name = fields[0].GetString();
            uint32 lenght = fields[0].GetStringLength();
            if (lenght > MAX_CUF_PROFILE_NAME_LENGTH)
                continue;

            profile.Name = name;
            profile.l_NameLen = lenght;

            UnpackDBBinary(&profile.data, sizeof(profile.data), fields[1].GetCString(), fields[1].GetStringLength());

            ++i;
        }
        while (i < count && result->NextRow());
    }
    else
        m_cufProfiles.clear();
}

void Player::SendCUFProfiles()
{
    WorldPacket l_Data(SMSG_LOAD_CUF_PROFILES);

    l_Data << uint32(m_cufProfiles.size());

    for (uint32 i = 0; i < m_cufProfiles.size(); ++i)
    {
        CUFProfile& l_Profile = m_cufProfiles[i];
        CUFProfileData& l_ProfileData = l_Profile.data;

        l_Data.WriteBits(l_Profile.l_NameLen, 7);
        l_Data.WriteBit(l_ProfileData.KeepGroupsTogether);
        l_Data.WriteBit(l_ProfileData.DisplayPets);
        l_Data.WriteBit(l_ProfileData.DisplayMainTankAndAssist);
        l_Data.WriteBit(l_ProfileData.DisplayHealPrediction);
        l_Data.WriteBit(l_ProfileData.DisplayAggroHighlight);
        l_Data.WriteBit(l_ProfileData.DisplayOnlyDispellableDebuffs);
        l_Data.WriteBit(l_ProfileData.DisplayPowerBar);
        l_Data.WriteBit(l_ProfileData.DisplayBorder);
        l_Data.WriteBit(l_ProfileData.UseClassColors);
        l_Data.WriteBit(l_ProfileData.HorizontalGroups);
        l_Data.WriteBit(l_ProfileData.DisplayNonBossDebuffs);
        l_Data.WriteBit(l_ProfileData.DynamicPosition);
        l_Data.WriteBit(l_ProfileData.Locked);
        l_Data.WriteBit(l_ProfileData.Shown);
        l_Data.WriteBit(l_ProfileData.AutoActivate2Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate3Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate5Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate10Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate15Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate25Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate40Players);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec1);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec2);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec3);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec4);
        l_Data.WriteBit(l_ProfileData.AutoActivatePvP);
        l_Data.WriteBit(l_ProfileData.AutoActivatePvE);
        l_Data.FlushBits();

        l_Data << uint16(l_ProfileData.FrameHeight);
        l_Data << uint16(l_ProfileData.FrameWidth);
        l_Data << uint8(l_ProfileData.SortBy);
        l_Data << uint8(l_ProfileData.HealthText);
        l_Data << uint8(l_ProfileData.TopPoint);
        l_Data << uint8(l_ProfileData.BottomPoint);
        l_Data << uint8(l_ProfileData.LeftPoint);
        l_Data << uint16(l_ProfileData.TopOffset);
        l_Data << uint16(l_ProfileData.BottomOffset);
        l_Data << uint16(l_ProfileData.LeftOffset);

        if (l_Profile.l_NameLen)
            l_Data.append(l_Profile.Name.c_str(), l_Profile.l_NameLen);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::_SaveInstanceTimeRestrictions(SQLTransaction& trans)
{
    if (_instanceResetTimes.empty())
        return;

    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    trans->Append(stmt);

    for (InstanceTimeMap::const_iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end(); ++itr)
    {
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES);
        stmt->setUInt32(0, GetSession()->GetAccountId());
        stmt->setUInt32(1, itr->first);
        stmt->setUInt64(2, itr->second);
        trans->Append(stmt);
    }
}

bool Player::IsInWhisperWhiteList(uint64 guid)
{
    for (WhisperListContainer::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
    {
        if (*itr == guid)
            return true;
    }
    return false;
}

bool Player::CanSwitch() const
{
    if (getRace() != RACE_WORGEN)
        return false;

    if (isInCombat() || !HasAuraType(SPELL_AURA_ALLOW_WORGEN_TRANSFORM))
        return false;

    return true;
}

void Player::SwitchForm()
{
    if (!CanSwitch())
        return;

    if (IsInWorgenForm())
        SwitchToHumanForm();
    else
        SwitchToWorgenForm();
}

void Player::SendPetTameResult(PetTameResult p_Result)
{
    WorldPacket l_Data(SMSG_PET_TAME_FAILURE, 4);
    l_Data << uint8(p_Result);

    GetSession()->SendPacket(&l_Data);
}

uint8 Player::GetNextVoidStorageFreeSlot() const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i]) // unused item
            return i;

    return VOID_STORAGE_MAX_SLOT;
}

uint8 Player::GetNumOfVoidStorageFreeSlots() const
{
    uint8 count = 0;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i])
            count++;

    return count;
}

uint8 Player::AddVoidStorageItem(const VoidStorageItem& item)
{
    uint8 slot = GetNextVoidStorageFreeSlot();

    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return 255;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemEntry,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.Bonuses, item.CustomFlags, true);
    return slot;
}

void Player::AddVoidStorageItemAtSlot(uint8 slot, const VoidStorageItem& item)
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return;
    }

    if (_voidStorageItems[slot])
    {
        sLog->outError(LOG_FILTER_GENERAL, "Player::AddVoidStorageItemAtSlot - Player (GUID: %u, name: %s) tried to add an item to an used slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName(), _voidStorageItems[slot]->ItemId, _voidStorageItems[slot]->ItemEntry, slot);
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemId,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.Bonuses, item.CustomFlags, true);
}

void Player::DeleteVoidStorageItem(uint8 slot)
{
    if (slot >= VOID_STORAGE_MAX_SLOT || _voidStorageItems[slot]->deleted)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    _voidStorageItems[slot]->change = true;
    _voidStorageItems[slot]->deleted = true;
}

bool Player::SwapVoidStorageItem(uint8 oldSlot, uint8 newSlot)
{
    if (oldSlot >= VOID_STORAGE_MAX_SLOT || newSlot >= VOID_STORAGE_MAX_SLOT || oldSlot == newSlot)
        return false;

    std::swap(_voidStorageItems[newSlot], _voidStorageItems[oldSlot]);

    if (_voidStorageItems[newSlot])
        _voidStorageItems[newSlot]->change = true;

    if (_voidStorageItems[oldSlot])
        _voidStorageItems[oldSlot]->change = true;
    return true;
}

VoidStorageItem* Player::GetVoidStorageItem(uint8 slot) const
{
    if (slot >= VOID_STORAGE_MAX_SLOT || (_voidStorageItems[slot] && _voidStorageItems[slot]->deleted))
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return NULL;
    }

    return _voidStorageItems[slot];
}

VoidStorageItem* Player::GetVoidStorageItem(uint64 id, uint8& slot) const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemId == id && !_voidStorageItems[i]->deleted)
        {
            slot = i;
            return _voidStorageItems[i];
        }
    }

    return NULL;
}

uint32 Player::GetVoidStorageItemsCount(uint32 entry) const
{
    uint32 count = 0;
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemEntry == entry)
        {
            ++count;
        }
    }

    return count;
}

void Player::SendMovementSetCanTransitionBetweenSwimAndFly(bool p_Apply)
{
    WorldPacket l_Data;

    if (p_Apply)
    {
        l_Data.Initialize(SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter
    }
    else
    {
        l_Data.Initialize(SMSG_MOVE_UNSET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter
    }

    SendDirectMessage(&l_Data);
}

void Player::SendMovementSetCollisionHeight(float p_Height)
{
    CreatureDisplayInfoEntry const* l_MountDisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID));

    WorldPacket l_Data(SMSG_MOVE_SET_COLLISION_HEIGHT, 16 + 2 + 4 + 4 + 4 + 4 + 1);
    l_Data.appendPackGUID(GetGUID());                                                    ///< MoverGUID
    l_Data << uint32(m_movementCounter++);                                               ///< SequenceIndex
    l_Data << float(p_Height);                                                           ///< Height
    l_Data << float(GetFloatValue(OBJECT_FIELD_SCALE));                                  ///< Scale
    l_Data << uint32(l_MountDisplayInfo ? l_MountDisplayInfo->ID : 0);                   ///< MountDisplayID
    l_Data << uint32(0);                                                                 ///< ScaleDuration
    l_Data.WriteBits(UPDATE_COLLISION_HEIGHT_MOUNT, 2);                                  ///< Reason
    SendDirectMessage(&l_Data);
}

void Player::SendMovementSetCanDoubleJump(bool p_Apply)
{
    WorldPacket l_Data;

    if (p_Apply)
    {
        l_Data.Initialize(SMSG_MOVE_ENABLE_DOUBLE_JUMP, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter
    }
    else
    {
        l_Data.Initialize(SMSG_MOVE_DISABLE_DOUBLE_JUMP, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(m_movementCounter++);                ///< Movement counter
    }

    SendDirectMessage(&l_Data);
}

float Player::GetCollisionHeight(bool p_Mounted)
{
    if (p_Mounted)
    {
        CreatureDisplayInfoEntry const* l_MountDisplayInfos = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(EUnitFields::UNIT_FIELD_MOUNT_DISPLAY_ID));
        if (!l_MountDisplayInfos)
            return GetCollisionHeight(false);

        CreatureModelDataEntry const* l_CreatureModelData = sCreatureModelDataStore.LookupEntry(l_MountDisplayInfos->ModelID);
        if (!l_CreatureModelData)
            return GetCollisionHeight(false);

        CreatureDisplayInfoEntry const* l_DisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT (l_DisplayInfo);

        CreatureModelDataEntry const* l_ModelData = sCreatureModelDataStore.LookupEntry(l_DisplayInfo->ModelID);
        ASSERT (l_ModelData);

        float l_ScaleMod = GetFloatValue(EObjectFields::OBJECT_FIELD_SCALE); ///< 99% sure about this

        return l_ScaleMod * l_CreatureModelData->MountHeight + l_ModelData->CollisionHeight * 0.5f;
    }
    else
    {
        /// Dismounting case - use basic default model data
        CreatureDisplayInfoEntry const* l_DisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT (l_DisplayInfo);

        CreatureModelDataEntry const* l_ModelData = sCreatureModelDataStore.LookupEntry(l_DisplayInfo->ModelID);
        ASSERT (l_ModelData);

        return l_ModelData->CollisionHeight;
    }
}

void Player::SetMover(Unit* target)
{
    m_mover->m_movedPlayer = NULL;
    m_mover = target;
    m_mover->m_movedPlayer = this;

    if (m_mover)
    {
        WorldPacket data(SMSG_MOVE_SET_ACTIVE_MOVER);
        data.appendPackGUID(target->GetGUID());

        GetSession()->SendPacket(&data);
    }
}

void Player::ShowNeutralPlayerFactionSelectUI()
{
    WorldPacket data(SMSG_SHOW_NEUTRAL_PLAYER_FACTION_SELECT_UI);
    GetSession()->SendPacket(&data);
}

void Player::SetPersonnalXpRate(float p_PersonnalXPRate)
{
    m_PersonnalXpRate = p_PersonnalXPRate;

    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_UPD_XP_RATE);
    l_Statement->setFloat(0, p_PersonnalXPRate);
    l_Statement->setUInt32(1, GetRealGUIDLow());
    RealmDatabase.Execute(l_Statement);
}

void Player::HandleStoreGoldCallback(PreparedQueryResult result)
{
    // Load des golds
    if (result)
    {
        uint64 goldCount = 0;
        do
        {
            Field* fieldGold    = result->Fetch();
            uint64 gold         = uint64(fieldGold[0].GetUInt32()) * GOLD;
            uint32 transaction  = fieldGold[1].GetUInt32();

            if ((GetMoney() + gold) > MAX_MONEY_AMOUNT)
            {
                GetSession()->SendNotification(LANG_GOLD_ERROR1);
                GetSession()->SendNotification(LANG_GOLD_ERROR2);
                break;
            }

            goldCount+= gold;
            ModifyMoney(gold, "Player::HandleStoreGoldCallback");

            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_GOLD);
            stmt->setInt32(0, transaction);
            RealmDatabase.Execute(stmt);
        }
        while(result->NextRow());

        if (goldCount)
            GetSession()->SendNotification(LANG_GOLD_CONFIRM, (goldCount/GOLD));
    }
}

void Player::HandleStoreTitleCallback(PreparedQueryResult p_Result)
{
    // Load titles
    if (p_Result)
    {
        do
        {
            Field* l_TitleField = p_Result->Fetch();
            uint32 l_Title = l_TitleField[0].GetUInt32();
            uint32 l_Transaction = l_TitleField[1].GetUInt32();

            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_TITLE);
            stmt->setInt32(0, l_Transaction);
            RealmDatabase.Execute(stmt);

            CharTitlesEntry const* l_TitleInfo = sCharTitlesStore.LookupEntry(l_Title);
            if (!l_TitleInfo)
                continue;

            SetTitle(l_TitleInfo);
        }
        while (p_Result->NextRow());
    }
}

#ifndef CROSS
void Player::HandleStoreItemCallback(PreparedQueryResult result)
{
    PreparedStatement* stmt;
    if (result)
    {
        uint32 ShopError = 0;
        do
        {
            Field* field = result->Fetch();
            uint32 ShopItemid = field[0].GetUInt32();
            uint32 ShopCount = field[1].GetUInt32();
            uint32 transaction = field[2].GetUInt32();

            uint32 noSpaceForCount = 0;

            // Special item, gold add 200001 - 200006
            /*if (ShopItemid > 200000)
            {
                uint64 po = 0;
                switch (ShopItemid)
                {
                    case 200001: // 500k gold
                        po = 5000000000;
                        break;
                    case 200002: // 200k gold
                        po = 2000000000;
                        break;
                    case 200003: // 50k gold
                        po = 500000000;
                        break;
                    case 200004: // 10k gold
                        po = 100000000;
                        break;
                    case 200005: // 5k gold
                        po = 50000000;
                        break;
                    case 200006: // 1k gold
                        po = 10000000;
                        break;
                    default:
                        po = 0;
                        break;
                }

                if ((GetMoney() + po) > MAX_MONEY_AMOUNT)
                {
                    std::string message = "You have already reach max amount of gold";
                    GetSession()->SendNotification(message.c_str());
                }
                else
                {
                    ModifyMoney(po);

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_ITEM);
                    stmt->setInt32(0, transaction);
                    CharacterDatabase.Execute(stmt);

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_BOUTIQUE_ITEM_LOG);
                    stmt->setInt32(0, transaction);
                    stmt->setInt32(1, GetGUIDLow());
                    stmt->setInt32(2, ShopItemid);
                    stmt->setInt32(3, ShopCount);
                    CharacterDatabase.Execute(stmt);
                }
            }
            else*/
            {
                ItemPosCountVec l_Dest;
                InventoryResult l_Message = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, ShopItemid, ShopCount);

                if (l_Message != EQUIP_ERR_OK)
                {
                    ChatHandler(this).PSendSysMessage("Check if you have free slot in your inventory");
                    continue;
                }

                Item* l_Item = AddItem(ShopItemid, ShopCount, {}, true);
                if (l_Item != nullptr)
                {
                    l_Item->SetState(ItemUpdateState::ITEM_CHANGED, this);
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_ITEM);
                    stmt->setInt32(0, transaction);
                    CharacterDatabase.Execute(stmt);
                }
            }
        } while (result->NextRow());
    }
}

void Player::HandleStoreLevelCallback(PreparedQueryResult result)
{
    PreparedStatement* stmt;

    // Load powerlevels
    if (result)
    {
        Field* fields = result->Fetch();
        uint32 level = fields[0].GetUInt32();

        if (level < getLevel() || level > MAX_LEVEL)
        {
            GetSession()->SendNotification("Tentative de powerlevel vers un niveau inferieur ou vers un niveau plus eleve que le niveau maximum, veuillez contactez le support boutique si ce message apparait.");  // translate me
        }
        else
        {
            GiveLevel(level);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_LEVEL);
            stmt->setInt32(0, GetGUIDLow());
            CharacterDatabase.Execute(stmt);
        }
    }
}

#endif /* not CROSS */
namespace ProfessionBookSpells
{
    enum
    {
        Alchemy        = 156614,
        Blacksmithing  = 169923,
        Enchanting     = 161788,
        Engineering    = 161787,
        Inscription    = 161789,
        JewelCrafting  = 169926,
        LeatherWorking = 169925,
        Tailoring      = 169924,
        FirstAid       = 160329,
        Cooking        = 160360,
        Herbalism      = 158745,
        Mining         = 158754,
        Skinning       = 158756,
        Archaeology    = 158762,
        Fishing        = 160326
    };
}

namespace ProfessionAdditionalSpells
{
    enum
    {
        Prospecting = 31252,
    };
}

void Player::HandleStoreProfessionCallback(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    std::map<uint32, uint32> l_SkillLearningSpells =
    {
        { SkillType::SKILL_ALCHEMY,        ProfessionBookSpells::Alchemy        },
        { SkillType::SKILL_BLACKSMITHING,  ProfessionBookSpells::Blacksmithing  },
        { SkillType::SKILL_ENCHANTING,     ProfessionBookSpells::Enchanting     },
        { SkillType::SKILL_ENGINEERING,    ProfessionBookSpells::Engineering    },
        { SkillType::SKILL_INSCRIPTION,    ProfessionBookSpells::Inscription    },
        { SkillType::SKILL_JEWELCRAFTING,  ProfessionBookSpells::JewelCrafting  },
        { SkillType::SKILL_LEATHERWORKING, ProfessionBookSpells::LeatherWorking },
        { SkillType::SKILL_TAILORING,      ProfessionBookSpells::Tailoring      },
        { SkillType::SKILL_FIRST_AID,      ProfessionBookSpells::FirstAid       },
        { SkillType::SKILL_COOKING,        ProfessionBookSpells::Cooking        },
        { SkillType::SKILL_HERBALISM,      ProfessionBookSpells::Herbalism      },
        { SkillType::SKILL_MINING,         ProfessionBookSpells::Mining         },
        { SkillType::SKILL_SKINNING,       ProfessionBookSpells::Skinning       },
        { SkillType::SKILL_ARCHAEOLOGY,    ProfessionBookSpells::Archaeology    },
        { SkillType::SKILL_FISHING,        ProfessionBookSpells::Fishing        }
    };

    do
    {
        Field* l_Fields     = p_Result->Fetch();
        uint32 l_SkillID    = l_Fields[0].GetUInt32();
        bool   l_Recipe     = l_Fields[1].GetBool();

        auto it = l_SkillLearningSpells.find(l_SkillID);
        if (it == l_SkillLearningSpells.end())
            continue;

        uint32 l_SpellID = it->second;

        if (getLevel() < 90)
            continue;

        if (IsPrimaryProfessionSkill(l_SkillID) && !HasSkill(l_SkillID) && GetFreePrimaryProfessionPoints() == 0)
            continue;

        /// Learn the skill to dreanor rank
        CastSpell(this, l_SpellID, true);

        /// Up skill to 700
        SetSkill(l_SkillID, GetSkillStep(l_SkillID), 700, 700);

        if (l_Recipe)
        {
            const std::list<SkillLineAbilityEntry const*>& l_Abilities = sSpellMgr->GetTradeSpellFromSkill(l_SkillID);
            for (auto l_Abilitie : l_Abilities)
            {
                if (l_Abilitie->spellId > 155748)   ///< last 5.4.7 spellid
                    continue;

                learnSpell(l_Abilitie->spellId, false);
            }
        }

        if (l_SkillID == SkillType::SKILL_JEWELCRAFTING)
            learnSpell(ProfessionAdditionalSpells::Prospecting, false);             ///< Prospecting

        /// We also need to learn it for herbalism
        if (l_SkillID == SkillType::SKILL_HERBALISM)
            learnSpell(l_SpellID, false);

        PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_STORE_PROFESSION);
        l_Statement->setUInt32(0, GetGUIDLow());
        l_Statement->setUInt32(1, l_SkillID);
        CharacterDatabase.Execute(l_Statement);
    }
    while (p_Result->NextRow());
}

void Player::CheckSpellAreaOnQuestStatusChange(uint32 quest_id)
{
    uint32 zone = 0, area = 0;

    SpellAreaForQuestMapBounds saBounds = sSpellMgr->GetSpellAreaForQuestMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                RemoveAurasDueToSpell(itr->second->spellId);
        }
    }

    saBounds = sSpellMgr->GetSpellAreaForQuestEndMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        if (!zone || !area)
            GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                RemoveAurasDueToSpell(itr->second->spellId);
        }
    }
}

#ifndef CROSS
Guild* Player::GetGuild()
#else /* CROSS */
InterRealmGuild* Player::GetGuild()
#endif /* CROSS */
{
    uint32 guildId = GetGuildId();
#ifndef CROSS
    return guildId ? sGuildMgr->GetGuildById(guildId) : 0;
#else /* CROSS */
    return guildId ? sGuildMgr->GetInterRealmGuild(GetSession()->GetInterRealmNumber(), guildId) : nullptr;
#endif /* CROSS */
}

void Player::SetArenaPersonalRating(uint8 p_Slot, uint32 p_Value)
{
    if (p_Slot >= (uint8)BattlegroundBracketType::Max)
        return;

    if (p_Value > 3500)
    {
        ACE_Stack_Trace trace;
        sLog->outError(LOG_FILTER_GENERAL, "Suspiciously high personal rating. Rating: %u, Slot: %u, Player: %u, Trace log: %s", p_Value, p_Slot, GUID_LOPART(GetGUID()), trace.c_str());
    }

    UpdateCriteria(CRITERIA_TYPE_HIGHEST_PERSONAL_RATING, p_Value, Arena::GetTypeBySlot(p_Slot));

    if (p_Slot == uint8(BattlegroundBracketType::Battleground10v10))
        UpdateCriteria(CRITERIA_TYPE_REACH_RATED_BATTLEGROUND_RATING, p_Value);

    m_ArenaPersonalRating[p_Slot] = p_Value;
    if (m_BestRatingOfWeek[p_Slot] < p_Value)
        m_BestRatingOfWeek[p_Slot] = p_Value;
    if (m_BestRatingOfSeason[p_Slot] < p_Value)
        m_BestRatingOfSeason[p_Slot] = p_Value;
}

void Player::FinishWeek()
{
    for (uint8 l_Bracket = 0; l_Bracket < (uint8)BattlegroundBracketType::Max; ++l_Bracket)
    {
        m_BestRatingOfPrevWeek[l_Bracket] = m_BestRatingOfWeek[l_Bracket];
        m_BestRatingOfWeek[l_Bracket]     = 0;
        m_PrevWeekWins[l_Bracket]         = m_WeekWins[l_Bracket];
        m_PrevWeekGames[l_Bracket]        = m_WeekGames[l_Bracket];
        m_WeekGames[l_Bracket]            = 0;
        m_WeekWins[l_Bracket]             = 0;
    }
}

void Player::FinishDay()
{
    for (uint8 l_Bracket = 0; l_Bracket < (uint8)BattlegroundBracketType::Max; ++l_Bracket)
    {
        m_DayGames[l_Bracket] = 0;
        m_DayWins[l_Bracket]  = 0;
    }
}

void Player::SetEmoteState(uint32 anim_id)
{
    HandleEmoteCommand(anim_id);
    m_emote = anim_id;
}

void Player::SendApplyMovementForce(uint64 p_Source, bool p_Apply, Position p_Direction /*= {}*/, float p_Magnitude /*= 0.0f*/, uint8 p_Type /*= 0*/, G3D::Vector3 p_TransportPos /*= G3D::Vector3(0.0f, 0.0f, 0.0f)*/)
{
    if (p_Apply)
    {
        uint32 l_TransportID = GetTransport() ? GetTransport()->GetEntry() : 0;

        WorldPacket l_Data(SMSG_MOVE_APPLY_MOVEMENT_FORCE, 2 + 16 + 4 + 2 + 16 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1);

        l_Data.appendPackGUID(GetGUID());               ///< Mover GUID
        l_Data << uint32(m_movementCounter++);          ///< Sequence Index
        l_Data.appendPackGUID(p_Source);                ///< Movement ForceID
        l_Data << float(p_Direction.GetPositionX());    ///< Direction X
        l_Data << float(p_Direction.GetPositionY());    ///< Direction Y
        l_Data << float(p_Direction.GetPositionZ());    ///< Direction Z
        l_Data.WriteVector3(p_TransportPos);            ///< TransportPosition
        l_Data << uint32(l_TransportID);                ///< Transport ID
        l_Data << float(p_Magnitude);                   ///< Magnitude

        l_Data.WriteBits(p_Type, 2);                    ///< Force type, still one yet
        l_Data.FlushBits();

        SendMessageToSet(&l_Data, true);

        /// Handle if there is a delayed 'removing' event.
        /// It happens on reapplying forced movement.
        if (m_ActiveMovementForces.find(p_Source) != m_ActiveMovementForces.end())
        {
            AddDelayedEvent([this, p_Source]() -> void
            {
                m_ActiveMovementForces.insert(p_Source);
            }, 1 * IN_MILLISECONDS);
        }
        else
        {
            m_ActiveMovementForces.insert(p_Source);
        }
    }
    else
    {
        WorldPacket l_Data(SMSG_MOVE_REMOVE_MOVEMENT_FORCE, (2 * (2 + 16)) + 4);
        l_Data.appendPackGUID(GetGUID());       ///< Mover GUID
        l_Data << uint32(m_movementCounter++);  ///< Sequence Index
        l_Data.appendPackGUID(p_Source);        ///< Movement ForceID

        SendMessageToSet(&l_Data, true);

        /// TODO:
        /// There are at least one CMSG_MOVE_HEARTBEAT and CMSG_MOVE_REMOVE_MOVEMENT_FORCE_ACK after that.
        /// So there is a delay between sending opcode and real removing forced movement (clientside).
        /// Maybe need to sync with CMSG_MOVE_REMOVE_MOVEMENT_FORCE_ACK.
        AddDelayedEvent([this, p_Source]() -> void
        {
            m_ActiveMovementForces.erase(p_Source);
        }, 1 * IN_MILLISECONDS);
    }
}

void Player::RemoveAllMovementForces(uint32 p_Entry /*=0*/)
{
    std::set<uint64> l_ActiveMovementForces;

    if (!p_Entry)
        l_ActiveMovementForces = m_ActiveMovementForces;
    else
    {
        for (std::set<uint64>::iterator l_Itr = m_ActiveMovementForces.begin(); l_Itr != m_ActiveMovementForces.end(); ++l_Itr)
        {
            if (WorldObject* l_Obj = ObjectAccessor::GetWorldObject(*this, *l_Itr))
            {
                if (l_Obj->GetEntry() == p_Entry)
                    l_ActiveMovementForces.insert(l_Obj->GetGUID());
            }
        }
    }

    for (uint64 l_ForceID : l_ActiveMovementForces)
        SendApplyMovementForce(l_ForceID, false, Position());
}

bool Player::HasMovementForce(uint64 p_Source /*= 0*/, bool p_IsEntry /*=false*/)
{
    /// No Guid? Just returns if player has at least one movement force applied
    if (!p_Source)
        return !m_ActiveMovementForces.empty();

    /// Entry?
    if (p_IsEntry)
    {
        if (uint32(p_Source) == p_Source)
        {
            for (std::set<uint64>::iterator l_Itr = m_ActiveMovementForces.begin(); l_Itr != m_ActiveMovementForces.end(); ++l_Itr)
            {
                if (WorldObject* l_Object = ObjectAccessor::GetWorldObject(*this, *l_Itr))
                {
                    if (l_Object->GetEntry() == p_Source)
                        return true;
                }
            }

            return false;
        }
        /// Not a valid entry
        return false;
    }

    /// Guid?
    return m_ActiveMovementForces.find(p_Source) != m_ActiveMovementForces.end();
}

void Player::SendResumeToken(uint32 token)
{
    WorldPacket data(SMSG_RESUME_TOKEN, 5);
    data << uint32(token);
    data.WriteBit(token == m_tokenCounter);
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendRefreshSpellMods()
{
    flag128 l_Mask = 0;
    uint32 l_PctModifierTypeCount;
    uint32 l_FlatModifierTypeCount;
    uint32 l_PctModifiersCount = 0;
    uint32 l_FlatModifiersCount = 0;
    uint32 l_MaskIndex;
    ByteBuffer l_PctBuffer;
    ByteBuffer l_FlatBuffer;

    for (int l_SpellModOp = 0; l_SpellModOp < MAX_SPELLMOD; ++l_SpellModOp)
    {
        if (!m_spellMods[l_SpellModOp].size())
            continue;

        l_PctModifierTypeCount = 0;
        l_FlatModifierTypeCount = 0;
        l_MaskIndex = 0;

        ByteBuffer l_SubFlatBuffer(1024);
        ByteBuffer l_SubPctBuffer(1024);

        for (int l_EffectIndex = 0; l_EffectIndex < 128; ++l_EffectIndex)
        {
            if (l_EffectIndex != 0 && (l_EffectIndex % 32) == 0)
                l_Mask[l_MaskIndex++] = 0;

            l_Mask[l_MaskIndex] = uint32(1) << (l_EffectIndex - (32 * l_MaskIndex));

            float l_PctValue = 1.0f;
            for (SpellModList::iterator l_It = m_spellMods[l_SpellModOp].begin(); l_It != m_spellMods[l_SpellModOp].end(); ++l_It)
                if ((*l_It)->type == SPELLMOD_PCT && (*l_It)->mask & l_Mask)
                    l_PctValue += float((*l_It)->value) / 100.0f;

            if (l_PctValue != 1.0f)
            {
                l_SubPctBuffer << float(l_PctValue);
                l_SubPctBuffer << uint8(l_EffectIndex);

                ++l_PctModifierTypeCount;
            }

            float l_FlatValue = 0.0f;
            for (SpellModList::iterator itr = m_spellMods[l_SpellModOp].begin(); itr != m_spellMods[l_SpellModOp].end(); ++itr)
                if ((*itr)->type == SPELLMOD_FLAT && (*itr)->mask & l_Mask)
                    l_FlatValue += float((*itr)->value);

            if (l_FlatValue)
            {
                l_SubFlatBuffer << float(l_FlatValue);
                l_SubFlatBuffer << uint8(l_EffectIndex);

                ++l_FlatModifierTypeCount;
            }
        }

        if (l_PctModifierTypeCount)
        {
            ++l_PctModifiersCount;

            l_PctBuffer << uint8(l_SpellModOp);
            l_PctBuffer << uint32(l_PctModifierTypeCount);
            l_PctBuffer.append(l_SubPctBuffer);
        }

        if (l_FlatModifierTypeCount)
        {
            ++l_FlatModifiersCount;

            l_FlatBuffer << uint8(l_SpellModOp);
            l_FlatBuffer << uint32(l_FlatModifierTypeCount);
            l_FlatBuffer.append(l_SubFlatBuffer);
        }

    }

    if (l_PctModifiersCount)
    {
        WorldPacket l_Packet(SMSG_SET_PCT_SPELL_MODIFIER, 4 + l_PctBuffer.size());
        l_Packet << uint32(l_PctModifiersCount);
        l_Packet.append(l_PctBuffer);
        SendDirectMessage(&l_Packet);
    }

    if (l_FlatModifiersCount)
    {
        WorldPacket l_Packet(SMSG_SET_FLAT_SPELL_MODIFIER, 4 + l_FlatBuffer.size());
        l_Packet << uint32(l_FlatModifiersCount);
        l_Packet.append(l_FlatBuffer);
        SendDirectMessage(&l_Packet);
    }
}

void Player::PlayScene(uint32 sceneId, WorldObject* spectator)
{
    PlayStandaloneScene(sceneId, 0, *spectator);
}

/// Play standalone scene script on client size
/// @p_ScenePackageID : Scene package ID @ScenePackage.db2
/// @p_PlaybackFlags  : Playback flags (@TODO make some reverse on it)
/// @p_Location       : Scene script start location
/// Return generated Scene instance ID
uint32 Player::PlayStandaloneScene(uint32 p_ScenePackageID, uint32 p_PlaybackFlags, Position p_Location)
{
    SceneScriptPackageEntry const* l_Entry = sSceneScriptPackageStore.LookupEntry(p_ScenePackageID);

    if (!l_Entry)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::PlayStandaloneScene => ScenePackage %u doesn't exist", p_ScenePackageID);
        return -1;
    }

    uint64 l_TransportGUID      = 0;
    uint32 l_SceneInstanceID    = sObjectMgr->GetNewStandaloneSceneInstanceID();

    WorldPacket l_PlayScenePacket(SMSG_PLAY_SCENE, 4 + 4 + 4 + 4 + 2 + 16 + 4 + 4 + 4 + 4);
    l_PlayScenePacket << uint32(0);                 ///< SceneID
    l_PlayScenePacket << uint32(p_PlaybackFlags);
    l_PlayScenePacket << uint32(l_SceneInstanceID);
    l_PlayScenePacket << uint32(p_ScenePackageID);
    l_PlayScenePacket.appendPackGUID(l_TransportGUID);
    l_PlayScenePacket << float(p_Location.m_positionX);
    l_PlayScenePacket << float(p_Location.m_positionY);
    l_PlayScenePacket << float(p_Location.m_positionZ);
    l_PlayScenePacket << float(p_Location.m_orientation);

    SendDirectMessage(&l_PlayScenePacket);
    m_RunningScenes.insert({l_SceneInstanceID, RunningScenePackage(p_ScenePackageID)});

    return l_SceneInstanceID;
}

/// Cancel a client-side played standalone scene
/// @p_SceneInstanceID : Scene instance ID
void Player::CancelStandaloneScene(uint32 p_SceneInstanceID)
{
    WorldPacket l_Data(SMSG_CANCEL_SCENE, 4);
    l_Data << uint32(p_SceneInstanceID);
    SendDirectMessage(&l_Data);
}

/// Start a spell scene
/// @p_SpellID      : Spell ID
/// @p_MiscValue    : Effect misc value
/// @p_Apply        : Start or cancel scene
/// @p_Location     : Scene play offset
void Player::SendSpellScene(uint32 p_SpellID, uint32 p_MiscValue, bool p_Apply, Position* p_Location)
{
    SpellScene const* l_SpellScene = sSpellMgr->GetSpellScene(p_MiscValue);
    if (!l_SpellScene)
        return;

    if (p_Apply)
    {
        uint64 l_TransportGUID = 0;
        uint32 l_NewInstanceID = sObjectMgr->GetNewStandaloneSceneInstanceID();

        WorldPacket l_PlayScenePacket(SMSG_PLAY_SCENE, 4 + 4 + 4 + 4 + 2 + 16 + 4 + 4 + 4 + 4);
        l_PlayScenePacket << uint32(p_MiscValue);                 ///< SceneID
        l_PlayScenePacket << uint32(l_SpellScene->PlaybackFlags);
        l_PlayScenePacket << uint32(l_NewInstanceID);
        l_PlayScenePacket << uint32(l_SpellScene->SceneScriptPackageID);
        l_PlayScenePacket.appendPackGUID(l_TransportGUID);
        l_PlayScenePacket << float(p_Location->m_positionX);
        l_PlayScenePacket << float(p_Location->m_positionY);
        l_PlayScenePacket << float(p_Location->m_positionZ);
        l_PlayScenePacket << float(p_Location->m_orientation);

        SendDirectMessage(&l_PlayScenePacket);
        m_RunningScenes.insert({ l_NewInstanceID, RunningScenePackage(p_MiscValue, p_SpellID) });

        /// Link aura effect
        m_sceneInstanceID[l_NewInstanceID] = p_MiscValue;
        m_sceneStatus[p_MiscValue] = SCENE_LAUNCH;
    }
    else
    {
        uint32 l_InstanceID = 0;
        for (auto l_Current : m_sceneInstanceID)
        {
            if (l_Current.second == p_MiscValue)  ///< no break. get last.
                l_InstanceID = l_Current.first;
        }

        if (!l_InstanceID || m_RunningScenes.find(l_InstanceID) == m_RunningScenes.end())    ///< As we have script with finishing scene it now could be 0.
            return;

        CancelStandaloneScene(l_InstanceID);
    }
}

/// When the scene is complete
/// @p_InstanceID : Scene instance ID
void Player::SceneCompleted(uint32 p_InstanceID)
{
    auto l_It = m_sceneInstanceID.find(p_InstanceID);
    if (l_It == m_sceneInstanceID.end())
        return;

    /// Trigger some events at complete scene.
    TrigerScene(p_InstanceID, "complete");

    m_sceneStatus[l_It->second] = SCENE_COMPLETE;
    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);

    AuraEffectList const& l_PeriodicAuras = GetAuraEffectsByType(SPELL_AURA_ACTIVATE_SCENE);
    for (AuraEffectList::const_iterator l_AuraIT = l_PeriodicAuras.begin(); l_AuraIT != l_PeriodicAuras.end(); ++l_AuraIT)
    {
        if ((*l_AuraIT)->GetMiscValue() == l_It->second)
        {
            RemoveAurasDueToSpell((*l_AuraIT)->GetId());
            break;
        }
    }
}

/// Trigger event in scene
/// @p_InstanceID   : Scene instance ID
/// @p_Type         : Trigger type
void Player::TrigerScene(uint32 p_InstanceID, std::string const& p_Type)
{
    auto l_It = m_sceneInstanceID.find(p_InstanceID);
    if (l_It == m_sceneInstanceID.end())
    {
        //sLog->outDebug(LOG_FILTER_PLAYER, " >> TrigerScene can't find instance type: %s instance %u", p_Type.c_str(), p_InstanceID);

        /// Fallback on legacy system
        sScriptMgr->OnSceneTriggerEvent(this, p_InstanceID, p_Type);
        return;
    }

    const SpellScene *l_SpellScene = sSpellMgr->GetSpellScene(l_It->second);
    if (!l_SpellScene)
    {
        sLog->outDebug(LOG_FILTER_PLAYER, " >> TrigerScene can't find SpellScene instance type: %s instance %u Misc %u", p_Type.c_str(), p_InstanceID, l_It->second);
        return;
    }

    m_sceneStatus[l_It->second] = SCENE_TRIGER;

    if (sScriptMgr->OnSceneTrigger(this, l_SpellScene, p_Type))
        return;

    if (p_Type == "Visual" || p_Type == "Clear")
    {
        if (l_SpellScene->TrigerSpell)
        {
            if (p_Type == "Visual" && !HasAura(l_SpellScene->TrigerSpell))
                CastSpell(this, l_SpellScene->TrigerSpell, true);
            else if (p_Type == "Clear" && HasAura(l_SpellScene->TrigerSpell))
                RemoveAurasDueToSpell(l_SpellScene->TrigerSpell);
        }
        else
            sLog->outDebug(LOG_FILTER_PLAYER, " >> TrigerScene unhandle type: %s SceneScriptPackageID %u", p_Type.c_str(), l_SpellScene->SceneScriptPackageID);
    }
    else
    {
        bool l_Proc = false;
        if (l_SpellScene->TrigerSpell)
        {
            l_Proc = true;
            CastSpell(this, l_SpellScene->TrigerSpell, true);
        }

        if (l_SpellScene->MonsterCredit)
        {
            l_Proc = true;
            KilledMonsterCredit(l_SpellScene->MonsterCredit);
        }

        if (!l_Proc)
        {
            sScriptMgr->OnSceneTriggerEvent(this, p_InstanceID, p_Type);
            sLog->outDebug(LOG_FILTER_PLAYER, " >> TrigerScene unhandle type: %s SceneScriptPackageID %u", p_Type.c_str(), l_SpellScene->SceneScriptPackageID);
        }
    }
}

uint32 Player::GetSceneInstanceIDByPackage(uint32 p_ScenePackageID) const
{
    for (auto l_Itr = m_RunningScenes.rbegin(); l_Itr != m_RunningScenes.rend(); ++l_Itr)
    {
        if (l_Itr->second.m_PackageID == p_ScenePackageID)
            return l_Itr->first;
    }

    return 0;
}

uint32 Player::GetMiscIDBySceneInstanceID(uint32 p_SceneInstanceID) const
{
    for (auto l_Itr = m_RunningScenes.rbegin(); l_Itr != m_RunningScenes.rend(); ++l_Itr)
    {
        if (l_Itr->first == p_SceneInstanceID)
            return l_Itr->second.m_PackageID;
    }

    return 0;
}

uint32 Player::GetAuraIDByScenceInstance(uint32 p_SceneInstanceID)
{
    for (auto l_Itr = m_RunningScenes.rbegin(); l_Itr != m_RunningScenes.rend(); ++l_Itr)
    {
        if (l_Itr->first == p_SceneInstanceID)
            return l_Itr->second.m_SpellID;
    }

    return 0;
}

void Player::RemoveAuraIDBySceneInstance(uint32 p_SceneInstanceID)
{
    if (uint32 l_SpellID = GetAuraIDByScenceInstance(p_SceneInstanceID))
        RemoveAurasDueToSpell(l_SpellID);

    std::map<uint32, RunningScenePackage>::iterator l_Itr = m_RunningScenes.find(p_SceneInstanceID);
    if (l_Itr != m_RunningScenes.end())
        m_RunningScenes.erase(l_Itr);
}

/// Has battle pet training
bool Player::HasBattlePetTraining()
{
    return HasSpell(119467);
}

/// Get battle pet trap level
uint32 Player::GetBattlePetTrapLevel()
{
    /// Pro Pet Crew
    if (HasAchieved(6581))
        return 3;     ///< Pristine Pet Trap

    /// Going to Need More Traps
    if (HasAchieved(6556))
        return 2;      ///< Strong Pet Trap

    return 1; ///< Pet trap
}

/// Compute the unlocked pet battle slot
uint32 Player::GetUnlockedPetBattleSlot()
{
    /// Just a Pup
    if (HasAchieved(6566))
        return 3;

    /// Newbie
    if (HasAchieved(7433))
        return 2;

    /// battle pet training
    if (HasBattlePetTraining())
        return 1;

    return 0;
}

/// Summon current pet if any active
void Player::UnsummonCurrentBattlePetIfAny(bool p_Unvolontary)
{
    if (!m_BattlePetSummon)
        return;

    if (!p_Unvolontary)
        m_LastSummonedBattlePet = 0;

    Creature * l_Pet = GetSummonedBattlePet();

    if (l_Pet)
    {
        l_Pet->DespawnOrUnsummon();
        l_Pet->AddObjectToRemoveList();
    }

    m_BattlePetSummon = 0;

    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID, 0);
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL, 0);
}

/// Summon new pet
void Player::SummonBattlePet(uint64 p_JournalID)
{
    if (!IsInWorld())
        return;

    std::vector<BattlePet::Ptr>::iterator l_It = std::find_if(m_BattlePets->begin(), m_BattlePets->end(), [p_JournalID](BattlePet::Ptr & p_Ptr)
    {
        if (p_Ptr && p_Ptr->JournalID == p_JournalID)
            return true;

        return false;
    });

    if (l_It == m_BattlePets->end())
        return;

    BattlePet::Ptr l_BattlePet = (*l_It);

    if (l_BattlePet->Health <= 0)
    {
        UnsummonCurrentBattlePetIfAny(false);
        return;
    }

    BattlePetSpeciesEntry const* l_SpeciesInfo      = sBattlePetSpeciesStore.LookupEntry(l_BattlePet->Species);
    SummonPropertiesEntry const* l_SummonProperties = sSummonPropertiesStore.LookupEntry(3221);

    if (!l_SpeciesInfo || !l_SummonProperties)
        return;

    uint32 l_Team   = GetTeam();
    uint32 l_Phase  = GetPhaseMask();

    WorldLocation l_Position;
    GetClosePoint(l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, DEFAULT_WORLD_OBJECT_SIZE);

    TempSummon* l_CurrentPet = new Minion(l_SummonProperties, this, false);

    if (!l_CurrentPet->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), GetMap(), l_Phase, l_SpeciesInfo->CreatureID, 0, l_Team, l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, GetOrientation()))
    {
        l_CurrentPet->CleanBeforeGC();
        sGarbageCollector->Add(l_CurrentPet);
        l_CurrentPet = nullptr;
        return;
    }

    l_CurrentPet->SetHomePosition(l_Position);
    l_CurrentPet->SetTempSummonType(TEMPSUMMON_MANUAL_DESPAWN);
    l_CurrentPet->InitStats(0, this);
    l_CurrentPet->SetOwnerGUID(GetGUID());

    m_LastSummonedBattlePet = GUID_LOPART(l_BattlePet->JournalID);

    SetGuidValue(UNIT_FIELD_CRITTER,                                l_CurrentPet->GetGUID());
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL,                l_BattlePet->Level);
    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID,             l_BattlePet->JournalID);
    SetUInt32Value(PLAYER_FIELD_CURRENT_BATTLE_PET_BREED_QUALITY,   l_BattlePet->Breed);

    l_CurrentPet->SetGuidValue(UNIT_FIELD_BATTLE_PET_COMPANION_GUID,    l_BattlePet->JournalID);
    l_CurrentPet->SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL,      l_BattlePet->Level);

    if (!l_BattlePet->Name.empty())
    {
        l_CurrentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, l_BattlePet->NameTimeStamp);
        l_CurrentPet->SetName(l_BattlePet->Name);
    }
    else
        l_CurrentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, 0);

    l_CurrentPet->SetUInt32Value(UNIT_FIELD_SHAPESHIFT_FORM, !l_BattlePet->Name.empty());
    l_CurrentPet->SetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL, l_SpeciesInfo->SummonSpellID);

    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    l_CurrentPet->RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_PETBATTLE);

    GetMap()->AddToMap(l_CurrentPet->ToCreature());

    l_CurrentPet->InitSummon();
    l_CurrentPet->GetMotionMaster()->MoveFollow(this, PET_FOLLOW_DIST, (3 * M_PI) / 2);
    l_CurrentPet->SetSpeed(MOVE_WALK, GetSpeedRate(MOVE_WALK), true);
    l_CurrentPet->SetSpeed(MOVE_RUN, GetSpeedRate(MOVE_RUN), true);

    m_BattlePetSummon = l_CurrentPet->GetGUID();

    /// Glyph of shadowy friend
    if (l_CurrentPet->GetOwner())
    {
        Player* l_Owner = l_CurrentPet->GetOwner()->ToPlayer();
        if (l_Owner && l_Owner->getClass() == CLASS_PRIEST && l_Owner->GetActiveSpecializationID() == SPEC_PRIEST_SHADOW && l_Owner->HasAura(126745))
        {
            if (l_Owner->HasAura(107903))
                l_CurrentPet->CastSpell(l_CurrentPet, 107903, true);
            if (l_Owner->HasAura(107904))
                l_CurrentPet->CastSpell(l_CurrentPet, 107904, true);
        }
    }
}

/// Get current summoned battle pet
Creature* Player::GetSummonedBattlePet()
{
    Unit * l_Pet = sObjectAccessor->FindUnit(m_BattlePetSummon);

    return l_Pet ? l_Pet->ToCreature() : NULL;
}

void Player::RecastCombatAllySpellIfNeeded()
{
    if (!GetMap() || GetMap()->GetId() != 1220)
        return;

    std::vector<MS::Garrison::GarrisonMission> l_ActiveMissions = GetGarrison()->GetMissions(MS::Garrison::GarrisonType::Type::GarrisonBrokenIsles);
    for (MS::Garrison::GarrisonMission l_Mission : l_ActiveMissions)
    {
        GarrMissionEntry const* l_MissionEntry = sGarrMissionStore.LookupEntry(l_Mission.MissionID);
        if (!l_MissionEntry || !(l_MissionEntry->Flags & MS::Garrison::Mission::Flags::IsZoneSupport))
            continue;

        std::vector<MS::Garrison::GarrisonFollower> l_Followers = GetGarrison()->GetFollowers(MS::Garrison::GarrisonType::Type::GarrisonBrokenIsles);
        for (MS::Garrison::GarrisonFollower l_Follower : l_Followers)
        {
            if (l_Follower.CurrentMissionID != l_Mission.MissionID)
                continue;

            CastSpell(this, l_Follower.ZoneSupportSpellID, true);
        }
    }
}

/// Summon last summoned battle pet
void Player::SummonLastSummonedBattlePet()
{
    SummonBattlePet(MAKE_NEW_GUID(m_LastSummonedBattlePet, 0, HIGHGUID_BATTLE_PET));
}

/// Get pet battles
std::vector<std::shared_ptr<BattlePet>> Player::GetBattlePets()
{
    return *m_BattlePets;
}

/// Get pet battles
std::shared_ptr<BattlePet> Player::GetBattlePet(uint64 p_JournalID)
{
    std::vector<BattlePet::Ptr>::iterator l_It = std::find_if(m_BattlePets->begin(), m_BattlePets->end(), [p_JournalID](BattlePet::Ptr & p_Ptr)
    {
        if (p_Ptr && p_Ptr->JournalID == p_JournalID)
            return true;

        return false;
    });

    if (l_It == m_BattlePets->end())
        return BattlePet::Ptr();

    return (*l_It);
}

/// Get pet battle combat team
std::shared_ptr<BattlePet> * Player::GetBattlePetCombatTeam()
{
    return m_BattlePetCombatTeam;
}

/// Reload pet battles
void Player::ReloadPetBattles()
{
    SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();

    for (std::vector<BattlePet::Ptr>::iterator l_It = m_BattlePets->begin(); l_It != m_BattlePets->end(); ++l_It)
    {
        BattlePet::Ptr l_Pet = (*l_It);
        l_Pet->Save(l_Transaction);
    }

    uint64 l_ThisGUID = GetGUID();
    MS::Utilities::CallBackPtr l_CallBack = std::make_shared<MS::Utilities::Callback>([l_ThisGUID](bool p_Success) -> void ///< p_Success is unused
    {
        if (Player* l_This = HashMapHolder<Player>::Find(l_ThisGUID))
        {
            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_PETBATTLE_ACCOUNT);
            stmt->setUInt32(0, l_This->GetSession()->GetAccountId());
            l_This->_petBattleJournalCallback = LoginDatabase.AsyncQuery(stmt);
        }
    });

    LoginDatabase.CommitTransaction(l_Transaction, m_QueryCallbackMgr, l_CallBack);
}

/// PetBattleCountBattleSpecies
void Player::PetBattleCountBattleSpecies()
{
    PetBattle * l_Battle = sPetBattleSystem->GetBattle(_petBattleId);

    if (!l_Battle)
        return;

    uint32 l_ThisTeamID = l_Battle->Teams[PETBATTLE_TEAM_1]->PlayerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

    std::for_each(m_BattlePets->begin(), m_BattlePets->end(), [l_Battle, l_ThisTeamID](BattlePet::Ptr & p_PetBattle)
    {
        if (!p_PetBattle)
            return;

        if (l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount.find(p_PetBattle->Species) == l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount.end())
            l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount[p_PetBattle->Species] = 0;

        l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount[p_PetBattle->Species]++;
    });
}

/// Update battle pet combat team
void Player::UpdateBattlePetCombatTeam()
{
    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    uint32 l_UnlockedSlotCount = GetUnlockedPetBattleSlot();

    std::for_each(m_BattlePets->begin(), m_BattlePets->end(), [this, l_UnlockedSlotCount](BattlePet::Ptr & p_BattlePet)
    {
        if (!p_BattlePet)
            return;

        if (p_BattlePet->Slot >= 0 && p_BattlePet->Slot < (int32)l_UnlockedSlotCount)
            m_BattlePetCombatTeam[p_BattlePet->Slot] = p_BattlePet;
    });
}

//////////////////////////////////////////////////////////////////////////
/// Calc Monk Melee Attacks
/// 7.0.3 todo, the override is deprecated
enum ExpelHarmSpells
{
    SPELL_MONK_STANCE_OF_THE_FIERCE_TIGER = 103985,
    SPELL_MONK_2H_STAFF_OVERRIDE = 108561,
    SPELL_MONK_EXPEL_HARM_DAMAGE = 115129,
    SPELL_MONK_2H_POLEARM_OVERRIDE = 115697,
    SPELL_MONK_MANA_MEDITATION = 121278
};

//////////////////////////////////////////////////////////////////////////
/// ToyBox
void Player::_LoadToyBox(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();
        uint32 l_ItemID = l_Fields[0].GetUInt32();
        bool l_IsFavorite = l_Fields[1].GetBool();

        if (!GetToyEntryFromItemId(l_ItemID))
            continue;

        if (!HasToy(l_ItemID))
        {
            PlayerToy l_PlayerToy = PlayerToy(l_ItemID, l_IsFavorite);
            m_PlayerToys.insert(std::make_pair(l_ItemID, l_PlayerToy));
        }
    }
    while (p_Result->NextRow());

    uint32 l_Count = 0;
    for (PlayerToys::iterator l_Toy = m_PlayerToys.begin(); l_Toy != m_PlayerToys.end(); ++l_Toy)
    {
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_TOYS, l_Count, l_Toy->second.m_ItemID);
        ++l_Count;
    }
}

void Player::SendToyBox()
{
    uint32 l_ToyCount = m_PlayerToys.size();

    WorldPacket l_Data(SMSG_ACCOUNT_TOYS_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);      // IsFullUpdate

    l_Data << uint32(l_ToyCount);
    l_Data << uint32(l_ToyCount);

    for (auto l_Toy : m_PlayerToys)
        l_Data << uint32(l_Toy.second.m_ItemID);

    for (auto l_Toy : m_PlayerToys)
        l_Data.WriteBit(l_Toy.second.m_IsFavorite);

    SendDirectMessage(&l_Data);
}

void Player::AddNewToyToBox(uint32 p_ItemID)
{
    /// Save toys to database only for live realms
    if (sWorld->CanBeSaveInLoginDatabase())
    {
        PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_TOYS);
        l_Statement->setUInt32(0, GetSession()->GetAccountId());
        l_Statement->setUInt32(1, p_ItemID);
        l_Statement->setBool(2, false);
        LoginDatabase.Execute(l_Statement);
    }

    if (!HasToy(p_ItemID))
    {
        UpdateCriteria(CRITERIA_TYPE_OWN_TOY_COUNT, 1, 0, 0, nullptr);

        PlayerToy l_PlayerToy = PlayerToy(p_ItemID, false);
        m_PlayerToys.insert(std::make_pair(p_ItemID, l_PlayerToy));

        uint32 l_ToySize = m_PlayerToys.size();
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_TOYS, l_ToySize, p_ItemID);
    }
}

void Player::SetFavoriteToy(bool p_Apply, uint32 p_ItemID)
{
    PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_UPD_TOY_FAVORITE);
    l_Statement->setBool(0, p_Apply);
    l_Statement->setUInt32(1, GetSession()->GetAccountId());
    l_Statement->setUInt32(2, p_ItemID);
    LoginDatabase.Execute(l_Statement);

    WorldPacket l_Data(SMSG_ACCOUNT_TOYS_UPDATE);
    l_Data.WriteBit(false);     // IsFullUpdate

    l_Data << uint32(1);
    l_Data << uint32(1);
    l_Data << uint32(p_ItemID);
    l_Data.WriteBit(p_Apply);   // IsFavorite

    SendDirectMessage(&l_Data);

    if (PlayerToy* l_PlayerToy = GetToy(p_ItemID))
        l_PlayerToy->m_IsFavorite = p_Apply;
}
//////////////////////////////////////////////////////////////////////////

void Player::_LoadBossLooted(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    m_BossLooted.clear();

    do
    {
        uint8 l_Index           = 0;
        Field* l_Fields         = p_Result->Fetch();

        uint32 l_BossEntry      = l_Fields[l_Index++].GetUInt32();
        uint32 l_DisplayID      = l_Fields[l_Index++].GetUInt32();
        uint32 l_DifficultyID   = l_Fields[l_Index++].GetUInt32();

        uint64 l_Value = l_BossEntry | ((uint64)l_DisplayID << 32);

        if (m_BossLooted.find(std::make_pair(l_Value, l_DifficultyID)) != m_BossLooted.end())
            continue;

        m_BossLooted.insert(std::make_pair(l_Value, l_DifficultyID));
    }
    while (p_Result->NextRow());
}

bool Player::BossAlreadyLooted(WorldObject* p_WorldObject, bool p_CheckDiff /*= true*/, Difficulty excludingDiff /*= DifficultyNone*/) const
{
    if (p_WorldObject == nullptr)
        return false;

    auto l_Difficulty = p_WorldObject->GetMap()->GetDifficultyID();

    /// Doesn't apply in normal & heroic dungeons, only mythics.
    if (l_Difficulty == Difficulty::DifficultyNormal || l_Difficulty == Difficulty::DifficultyHeroic)
        return false;

    uint32 l_Entry = p_WorldObject->GetEntry();
    uint32 l_Display = 0;

    if (Unit* l_Unit = p_WorldObject->ToUnit())
        l_Display = l_Unit->GetNativeDisplayId();
    else if (GameObject* l_GameObject = p_WorldObject->ToGameObject())
        l_Display = l_GameObject->GetDisplayId();
    else
        return false;

    uint64 l_Value = l_Entry | ((uint64)l_Display << 32);

    /// Check if boss has been killed in a specific difficulty
    if (p_CheckDiff)
    {
        if (m_BossLooted.find(std::make_pair(l_Value, l_Difficulty)) == m_BossLooted.end())
            return false;
        else
            return true;
    }
    /// Otherwise, check if boss has been already killed, no matter on which difficulty
    else
    {
        for (auto const& l_Iter : m_BossLooted)
        {
            if (excludingDiff != DifficultyNone && excludingDiff == l_Iter.second)
                continue;

            if (l_Iter.first == l_Value)
                return true;
        }

        return false;
    }
}

void Player::AddBossLooted(WorldObject* p_WorldObject)
{
    if (p_WorldObject == nullptr)
        return;

    auto l_Difficulty = p_WorldObject->GetMap()->GetDifficultyID();

    /// Doesn't apply in normal & heroic dungeons, only mythics.
    if (l_Difficulty == Difficulty::DifficultyNormal || l_Difficulty == Difficulty::DifficultyHeroic)
        return;

    uint32 l_Entry   = p_WorldObject->GetEntry();
    uint32 l_Display = 0;

    if (Unit* l_Unit = p_WorldObject->ToUnit())
        l_Display = l_Unit->GetNativeDisplayId();
    else if (GameObject* l_GameObject = p_WorldObject->ToGameObject())
        l_Display = l_GameObject->GetDisplayId();
    else
        return;

    uint64 l_Value = l_Entry | ((uint64)l_Display << 32);

    if (m_BossLooted.find(std::make_pair(l_Value, l_Difficulty)) != m_BossLooted.end())
        return;

    m_BossLooted.insert(std::make_pair(l_Value, l_Difficulty));

    uint8 l_Index = 0;
    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_BOSS_LOOTED);
    l_Statement->setUInt32(l_Index++, GetRealGUIDLow());
    l_Statement->setUInt32(l_Index++, l_Entry);
    l_Statement->setUInt32(l_Index++, l_Display);
    l_Statement->setUInt32(l_Index++, l_Difficulty);
    RealmDatabase.Execute(l_Statement);
}

bool Player::HasUnlockedReagentBank()
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS_EX, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED);
}

void Player::UnlockReagentBank()
{
    SetFlag(PLAYER_FIELD_PLAYER_FLAGS_EX, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED);
}

uint32 Player::GetFreeReagentBankSlot() const
{
    for (uint8 l_I = REAGENT_BANK_SLOT_BAG_START; l_I < REAGENT_BANK_SLOT_BAG_END; ++l_I)
    {
        if (!GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            return l_I;
    }

    return REAGENT_BANK_SLOT_BAG_END;
}

MS::Garrison::Manager * Player::GetGarrison() const
{
    return m_Garrison;
}

MS::Garrison::GDraenor::GarrisonDraenor* Player::GetDraenorGarrison() const
{
    return m_Garrison ? m_Garrison->GetDraenorGarrison() : nullptr;
}

MS::Garrison::GBrokenIsles::GarrisonBrokenIsles* Player::GetBrokenIslesGarrison() const
{
    return m_Garrison ? m_Garrison->GetBrokenIslesGarrison() : nullptr;
}

void Player::CreateGarrison(MS::Garrison::GarrisonType::Type p_Type)
{
    m_Garrison->Create(p_Type);
}

bool Player::IsInDraenorGarrison() const
{
    if (!GetDraenorGarrison() || !GetDraenorGarrison()->GetGarrisonSiteLevelEntry())
        return false;

    if (GetMapId() == GetDraenorGarrison()->GetGarrisonSiteLevelEntry()->MapID)
        return true;

    return false;
}

bool Player::IsInBrokenIslesGarrison() const
{
    if (!GetBrokenIslesGarrison() || !GetBrokenIslesGarrison()->GetGarrisonSiteLevelEntry())
        return false;

    if (GetMapId() == GetBrokenIslesGarrison()->GetGarrisonSiteLevelEntry()->MapID)
        return true;

    return false;
}


bool Player::IsInShipyard() const
{
    return GetShipyardMapID() == GetMapId(); ///< Comparison of integers of different signs: 'int32' (aka 'int') and 'uint32' (aka 'unsigned int')
}

bool Player::IsInAnyGarrison() const
{
    return IsInDraenorGarrison() || IsInBrokenIslesGarrison();
}

int32 Player::GetGarrisonMapID() const
{
    if (!GetDraenorGarrison())
        return -1;

    return GetDraenorGarrison()->GetGarrisonSiteLevelEntry()->MapID;
}

int32 Player::GetShipyardMapID() const
{
    if (!GetDraenorGarrison())
        return -1;

    return GetDraenorGarrison()->GetShipyardMapId();
}

void Player::DeleteGarrison(MS::Garrison::GarrisonType::Type p_Type)
{
    if (!m_Garrison)
        return;

    SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();

    if (p_Type == MS::Garrison::GarrisonType::GarrisonBrokenIsles)
    {
        MS::Garrison::GBrokenIsles::GarrisonBrokenIsles::DeleteFromDB(GetGUID(), l_Transaction);
        CharacterDatabase.CommitTransaction(l_Transaction);
    }
    else if (p_Type == MS::Garrison::GarrisonType::GarrisonDraenor)
    {
        if (IsInDraenorGarrison())
        {
            if (GetTeamId() == TEAM_ALLIANCE)
                TeleportTo(0, -8866.55f, 671.93f, 97.90f, 5.31f);
            else if (GetTeamId() == TEAM_HORDE)
                TeleportTo(1, 1577.30f, -4453.64f, 15.68f, 1.84f);
        }

        MS::Garrison::GDraenor::GarrisonDraenor::DeleteFromDB(GetGUID(), l_Transaction);
        CharacterDatabase.CommitTransaction(l_Transaction);
    }
}

uint32 Player::GetPlotInstanceID() const
{
    if (GetDraenorGarrison() == nullptr)
        return 0;

    return GetDraenorGarrison()->GetPlot(m_positionX, m_positionY, m_positionZ).PlotInstanceID;
}

Stats Player::GetPrimaryStat() const
{
    int8 magicNumber = -1;
    if (ChrSpecializationsEntry const* spec = sChrSpecializationsStore.LookupEntry(GetActiveSpecializationID()))
        magicNumber = spec->MainStat;
    else if (ChrClassesEntry const* playerClass = sChrClassesStore.LookupEntry(getClass()))
        magicNumber = playerClass->MainStat;

    // WTF is Blizzard doing ????
    switch (magicNumber)
    {
        case 0:
        case 1:
            return STAT_INTELLECT;
        case 2:
        case 3:
            return STAT_AGILITY;
        case 4:
        case 5:
        default:
            return STAT_STRENGTH;
    }
}

/*
 *          WARNING !!!!!!
 *
 *
 *
 *  Never use _ApplyItemBonuses for rescaling, use those the functions below, unless you know how it works and trust me you dont
 *
 */

void Player::RescaleAllItemsIfNeeded()
{
    if (!isAlive())
        return;

    float l_HealthPct = GetHealthPct();

    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            if (m_items[i]->IsEquipped())
            {
                _ApplyItemMods(m_items[i], m_items[i]->GetSlot(), false);
                _ApplyItemMods(m_items[i], m_items[i]->GetSlot(), true);
            }
        }
    }

    /// Recalculate Armor Specialization Amounts
    AuraEffectList l_AuraModTotalStat = GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
    for (AuraEffect* l_AuraEffect : l_AuraModTotalStat)
        l_AuraEffect->RecalculateAmount();

    int32 l_Health = std::max(1, int32(l_HealthPct * (float)GetMaxHealth() / 100.0f));
    SetHealth(l_Health);

    UpdateItemLevel();
}

void Player::CutOffItemLevel(bool p_RescaleItems)
{
    Map* l_Map = GetMap();
    if (!l_Map)
        return;

    uint32 l_StartsWith = 0, l_MinLevel = 0, l_MaxLevel = 0;

    if (l_Map->IsBattlegroundOrArena())
    {
        l_StartsWith = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_CUTOFF);
        l_MinLevel = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_MIN);
        l_MaxLevel = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_MAX);
    }

    UpdateItemLevelCutOff(l_StartsWith, l_MinLevel, l_MaxLevel, p_RescaleItems);
}

bool Player::UpdateItemLevelCutOff(uint32 p_StartsWith, uint32 p_MinLevel, uint32 p_MaxLevel, bool p_RescaleItems)
{
    if ((!p_MaxLevel && p_MinLevel > p_MaxLevel) || p_StartsWith > p_MaxLevel)
        return false;

    SetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL_CUTOFF, p_StartsWith);
    SetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL, p_MinLevel);
    SetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL, p_MaxLevel);

    if (p_RescaleItems)
        RescaleAllItemsIfNeeded();

    return true;
}

/// Set current interaction status
/// NOTE : This will fire all pending callback
/// @p_GUID   : Interacted GUID
/// @p_Status : New interaction status
void Player::SetInteractionStatus(uint64 p_GUID, InteractionStatus::Type p_Status)
{
    /// @TODO temp disable
    return;
    m_InteractionStatusMutex.lock();

    if (m_InteractionStatus.find(p_GUID) == m_InteractionStatus.end())
        m_InteractionStatus[p_GUID] = std::queue<InteractionStatus::Type>();

    auto & l_Queue = m_InteractionStatus[p_GUID];
    InteractionStatus::Type l_Old = InteractionStatus::None;

    if (!l_Queue.empty() && p_Status == InteractionStatus::None)
    {
        l_Old = l_Queue.front();
        l_Queue.pop();
    }

    l_Queue.push(p_Status);

    std::vector<Player::InteractionStatusCallback> l_Callbacks = m_InteractionStatusCallbacks[p_GUID];
    m_InteractionStatusCallbacks[p_GUID].clear();

    m_InteractionStatusMutex.unlock();

    for (const auto& l_Callback : l_Callbacks)
    {
        if (!l_Callback(this, p_GUID, l_Old, p_Status))
            AddInteractionStatusChangeCallback(p_GUID, l_Callback);
    }
}

/// Get current interaction status
Player::InteractionStatusMap Player::GetInteractionStatus()
{
    std::lock_guard<std::mutex> l_LockGuard(m_InteractionStatusMutex);
    return m_InteractionStatus;
}

/// Register a "fire once" callback for interaction status change
/// @p_GUID     : Interacted GUID
/// @p_Callback : Callback method
void Player::AddInteractionStatusChangeCallback(uint64 p_GUID, const Player::InteractionStatusCallback& p_Callback)
{
    /// @TODO temp disable
    return;
    ///m_InteractionStatusMutex.lock();
    ///m_InteractionStatusCallbacks[p_GUID].push_back(p_Callback);
    ///m_InteractionStatusMutex.unlock();
}

void Player::SetInPvPCombat(bool set)
{
    if (m_pvpCombat == set)
        return;

    m_pvpCombat = set;

    if (m_pvpCombat)
        OnEnterPvPCombat();
}

void Player::OnEnterPvPCombat()
{
    RescaleAllItemsIfNeeded();
    if (!HasAura(uint32(PvPStatsSpells::PVP_RULES_ENABLED)))
        CastSpell(this, uint32(PvPStatsSpells::PVP_RULES_ENABLED), true);
}

void Player::UpdatePvP(uint32 diff)
{
    if (!m_PvPCombatTimer || !IsInPvPCombat())
        return;

    if (m_PvPCombatTimer <= diff)
    {
        SetInPvPCombat(false);
        OnLeavePvPCombat();
        m_PvPCombatTimer = 0;
    }
    else
        m_PvPCombatTimer -= diff;
}

void Player::OnLeavePvPCombat()
{
    RescaleAllItemsIfNeeded();
    if (!IsInBattleground() && !IsInDuel())
        RemoveAurasDueToSpell(uint32(PvPStatsSpells::PVP_RULES_ENABLED));
}

/// Get pet battle combat team size
uint32 Player::GetBattlePetCombatSize()
{
    uint32 l_Count = 0;

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        if (m_BattlePetCombatTeam[l_CurrentPetSlot])
            l_Count++;

    return l_Count;
}

/// Load pet battle async callback
bool Player::_LoadPetBattles(PreparedQueryResult&& p_Result)
{
    m_BattlePets->clear();

    uint64 l_PlayerGUID = GetGUID();
    MS::Utilities::CallBackPtr l_CallBack = std::make_shared<MS::Utilities::Callback>([l_PlayerGUID](bool p_Success) -> void
    {
        if (Player* l_Player = HashMapHolder<Player>::Find(l_PlayerGUID))
            l_Player->ReloadPetBattles();
    });

    if (!p_Result)
    {
        bool l_Add = false;

        SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();

        for (uint32 l_I = 0; l_I < m_OldPetBattleSpellToMerge.size(); l_I++)
        {
            BattlePet l_BattlePet;
            l_BattlePet.Slot            = PETBATTLE_NULL_SLOT;
            l_BattlePet.NameTimeStamp   = 0;
            l_BattlePet.Species         = m_OldPetBattleSpellToMerge[l_I].second;
            l_BattlePet.DisplayModelID  = 0;
            l_BattlePet.Flags           = 0;

            if (BattlePetTemplate const* l_Template = sObjectMgr->GetBattlePetTemplate(m_OldPetBattleSpellToMerge[l_I].second))
            {
                l_BattlePet.Breed   = l_Template->Breed;
                l_BattlePet.Quality = l_Template->Quality;
                l_BattlePet.Level   = l_Template->Level;
            }
            else
            {
                l_BattlePet.Breed   = 3;
                l_BattlePet.Quality = BATTLEPET_QUALITY_COMMON;
                l_BattlePet.Level   = 1;
            }

            /// Calculate XP for level
            l_BattlePet.XP = 0;

            if (l_BattlePet.Level > 1 && l_BattlePet.Level < 100)
                l_BattlePet.XP = g_BattlePetXPStore.LookupEntry(l_BattlePet.Level - 1)->xp * g_BattlePetXPStore.LookupEntry(l_BattlePet.Level - 1)->wins;

            /// Calculate stats
            l_BattlePet.UpdateStats();
            l_BattlePet.Health = l_BattlePet.InfoMaxHealth;
            l_BattlePet.AddToPlayer(this, l_Transaction);

            l_Add = true;
        }

        m_OldPetBattleSpellToMerge.clear();

        if (l_Add)
        {
            LoginDatabase.CommitTransaction(l_Transaction, m_QueryCallbackMgr, l_CallBack);
            return true;
        }
    }

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    m_BattlePets->resize(p_Result ? p_Result->GetRowCount() : 0);
    uint32 l_UnlockedSlotCount = GetUnlockedPetBattleSlot();

    if (l_UnlockedSlotCount > 0)
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HAS_BATTLE_PET_TRAINING);

    std::vector<uint32> l_AlreadyKnownPet;

    if (p_Result && p_Result->GetRowCount())
    {
        size_t l_PetID = 0;

        do
        {
            if (l_PetID > m_BattlePets->size())
                continue;

            (*m_BattlePets)[l_PetID] = BattlePet::Ptr(new BattlePet());
            (*m_BattlePets)[l_PetID]->Load(p_Result->Fetch());

            if ((*m_BattlePets)[l_PetID]->Slot >= 0 && (*m_BattlePets)[l_PetID]->Slot < (int32)l_UnlockedSlotCount)
                m_BattlePetCombatTeam[(*m_BattlePets)[l_PetID]->Slot] = (*m_BattlePets)[l_PetID];

            l_AlreadyKnownPet.push_back((*m_BattlePets)[l_PetID]->Species);

            BattlePetSpeciesEntry const* l_SpeciesEntry = sBattlePetSpeciesStore.LookupEntry((*m_BattlePets)[l_PetID]->Species);
            if (l_SpeciesEntry != nullptr && !HasSpell(l_SpeciesEntry->SummonSpellID))
                addSpell(l_SpeciesEntry->SummonSpellID, true, true, false, false, false, false, false);

            ++l_PetID;
        } while (p_Result->NextRow());
    }

    bool l_OldPetAdded = false;
    SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();
    for (uint32 l_I = 0; l_I < m_OldPetBattleSpellToMerge.size(); l_I++)
    {
        if (std::find(l_AlreadyKnownPet.begin(), l_AlreadyKnownPet.end(), m_OldPetBattleSpellToMerge[l_I].second) != l_AlreadyKnownPet.end())
            continue;

        l_OldPetAdded = true;

        BattlePet l_BattlePet;
        l_BattlePet.Slot            = PETBATTLE_NULL_SLOT;
        l_BattlePet.NameTimeStamp   = 0;
        l_BattlePet.Species         = m_OldPetBattleSpellToMerge[l_I].second;
        l_BattlePet.DisplayModelID  = 0;
        l_BattlePet.Flags           = 0;

        if (BattlePetTemplate const* temp = sObjectMgr->GetBattlePetTemplate(m_OldPetBattleSpellToMerge[l_I].second))
        {
            l_BattlePet.Breed   = temp->Breed;
            l_BattlePet.Quality = temp->Quality;
            l_BattlePet.Level   = temp->Level;
        }
        else
        {
            l_BattlePet.Breed   = 3;
            l_BattlePet.Quality = BATTLEPET_QUALITY_COMMON;
            l_BattlePet.Level   = 1;
        }

        /// Calculate XP for level
        l_BattlePet.XP = 0;

        if (l_BattlePet.Level > 1 && l_BattlePet.Level < 100)
            l_BattlePet.XP = g_BattlePetXPStore.LookupEntry(l_BattlePet.Level - 1)->xp * g_BattlePetXPStore.LookupEntry(l_BattlePet.Level - 1)->wins;

        /// Calculate stats
        l_BattlePet.UpdateStats();
        l_BattlePet.Health = l_BattlePet.InfoMaxHealth;

        l_BattlePet.AddToPlayer(this, l_Transaction);
    }

    m_OldPetBattleSpellToMerge.clear();

    if (l_OldPetAdded)
    {
        LoginDatabase.CommitTransaction(l_Transaction, m_QueryCallbackMgr, l_CallBack);
        return true;
    }

    GetSession()->SendBattlePetJournal();

    /// HACK:
    /// Fix if players have pets before the achievement fix
    /// CheckAllAchievementCriteria is not called at login now

    m_achievementMgr->UpdateCriteria(CriteriaTypes::CRITERIA_TYPE_OWN_PET, 0, 0, 0, nullptr, this);
    m_achievementMgr->UpdateCriteria(CriteriaTypes::CRITERIA_TYPE_OWN_BATTLE_PET, 0, 1, 0, nullptr, this); ///< miscvalue2=1 is login case mark

    return true;
}

//////////////////////////////////////////////////////////////////////////
/// SpellCharges
void Player::SendSpellCharges()
{
    WorldPacket l_Data(SMSG_SEND_SPELL_CHARGES, 4 + m_CategoryCharges.size() * 9);

    size_t l_CountPos = l_Data.wpos();
    l_Data << uint32(0);

    uint32 l_Count = 0;
    Clock::time_point l_Now = Clock::now();
    for (auto l_CategoryCharge : m_CategoryCharges)
    {
        if (!l_CategoryCharge.second.empty())
        {
            std::chrono::milliseconds l_CooldownDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_CategoryCharge.second.front().RechargeEnd - l_Now);
            if (l_CooldownDuration.count() <= 0)
                continue;

            l_Data << uint32(l_CategoryCharge.first);
            l_Data << uint32(l_CooldownDuration.count());
            l_Data << float(1.0f);    ///< Mod rate
            l_Data << uint8(l_CategoryCharge.second.size());

            ++l_Count;
        }
    }

    l_Data.put(l_CountPos, l_Count);

    SendDirectMessage(&l_Data);
}

void Player::SendSpellCharge(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    WorldPacket l_Data(SMSG_SEND_SPELL_CHARGES, 4 + 1 * 13);

    l_Data << uint32(1);

    Clock::time_point l_Now = Clock::now();
    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end())
    {
        if (!l_Itr->second.empty())
        {
            std::chrono::milliseconds l_CooldownDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd - l_Now);
            if (l_CooldownDuration.count() > 0)
            {
                l_Data << uint32(l_Itr->first);
                l_Data << uint32(l_CooldownDuration.count());
                l_Data << float(1.0f);    ///< Mod rate
                l_Data << uint8(l_Itr->second.size());
            }
        }
    }
    SendDirectMessage(&l_Data);
}

void Player::SendSetSpellCharges(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    if (!p_ChargeCategoryEntry)
        return;

    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end())
    {
        uint32 l_ConsumedCharges = l_Itr->second.size();
        bool   l_IsPet = false;

        uint32 l_RecoveryTime = GetChargeRecoveryTime(p_ChargeCategoryEntry);
        if (!l_Itr->second.empty())
        {
            Clock::time_point l_Now = Clock::now();
            std::chrono::milliseconds l_CooldownDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd - l_Now);
            if (l_CooldownDuration.count() > 0)
                l_RecoveryTime = l_CooldownDuration.count();
        }

        WorldPacket l_Data(SMSG_SET_SPELL_CHARGES);
        l_Data << uint32(p_ChargeCategoryEntry->Id);
        l_Data << uint32(l_RecoveryTime);
        l_Data << uint8(l_ConsumedCharges);
        l_Data << float(1.0f);  ///< Mod rate
        l_Data.WriteBit(l_IsPet);
        l_Data.FlushBits();

        SendDirectMessage(&l_Data);
    }
}

void Player::UpdateCharges()
{
    Clock::time_point l_Now = Clock::now();

    for (auto& l_CategoryCharge : m_CategoryCharges)
    {
        std::deque<ChargeEntry>& l_ChargeRefreshTimes = l_CategoryCharge.second;

        while (!l_ChargeRefreshTimes.empty() && l_ChargeRefreshTimes.front().RechargeEnd <= l_Now)
        {
            l_ChargeRefreshTimes.pop_front();

            SpellCategoryEntry const* l_CategoryEntry = sSpellCategoryStore.LookupEntry(l_CategoryCharge.first);
            if (l_CategoryEntry != nullptr)
            {
                /// Call Script on modify charges
                sScriptMgr->OnModifyCharges(this, l_CategoryCharge.first);

                SendSetSpellCharges(l_CategoryEntry);
            }
        }
    }
}

void Player::UpdateCharge(SpellCategoryEntry const* p_ChargeCategoryEntry, bool p_Packet /*= true*/)
{
    Clock::time_point l_Now = Clock::now();

    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];

    while (!l_Charges.empty() && l_Charges.front().RechargeEnd <= l_Now)
    {
        l_Charges.pop_front();
        /// Call Script on modify charges
        sScriptMgr->OnModifyCharges(this, p_ChargeCategoryEntry->Id);
    }

    if (p_Packet)
        SendSetSpellCharges(p_ChargeCategoryEntry);
}

bool Player::ConsumeCharge(SpellCategoryEntry const* p_ChargeCategoryEntry, uint32 p_SpellID /*= 0*/)
{
    if (!p_ChargeCategoryEntry)
        return false;

    int32 l_ChargeRecovery = GetChargeRecoveryTime(p_ChargeCategoryEntry);
    if (l_ChargeRecovery > 0 && GetMaxCharges(p_ChargeCategoryEntry) > 0)
    {
        Clock::time_point l_RecoveryStart;
        std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];

        if (l_Charges.empty())
            l_RecoveryStart = Clock::now();
        else
            l_RecoveryStart = l_Charges.back().RechargeEnd;

        l_Charges.emplace_back(l_RecoveryStart, std::chrono::milliseconds(l_ChargeRecovery));

        /// Call Script on modify charges
        sScriptMgr->OnModifyCharges(this, p_ChargeCategoryEntry->Id);

        if (int32 l_ForcedCooldown = GetTotalAuraModifier(AuraType::SPELL_AURA_MOD_COOLDOWN) * 1000)
        {
            WorldPacket l_Data(SMSG_SPELL_COOLDOWN, 4 + 18 + 4);

            l_Data.appendPackGUID(GetGUID());
            l_Data << uint8(CooldownFlags::CooldownFlagNone);
            l_Data << uint32(1);
            l_Data << uint32(p_SpellID);
            l_Data << uint32(l_ChargeRecovery);
            l_Data << float(1.0f);

            GetSession()->SendPacket(&l_Data);
        }

        return true;
    }

    return false;
}

void Player::ConsumeAllCharges(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    uint32 l_ConsumeCount = 0;
    while (HasCharge(p_ChargeCategoryEntry) && l_ConsumeCount < 0xFF)
    {
        ConsumeCharge(p_ChargeCategoryEntry);
        l_ConsumeCount++;
    }

    SendSetSpellCharges(p_ChargeCategoryEntry);
}

void Player::ReduceChargeCooldown(SpellCategoryEntry const* p_ChargeCategoryEntry, uint64 p_Reductiontime, bool p_Packet /*= true*/)
{
    if (!p_ChargeCategoryEntry)
        return;

    Clock::time_point l_Now = Clock::now();

    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];
    for (ChargeEntry& l_Entry : l_Charges)
    {
        l_Entry.RechargeStart -= std::chrono::milliseconds(p_Reductiontime);
        l_Entry.RechargeEnd -= std::chrono::milliseconds(p_Reductiontime);
    }

    UpdateCharge(p_ChargeCategoryEntry, p_Packet);
}

void Player::RestoreCharge(SpellCategoryEntry const* p_ChargeCategoryEntry, bool p_KeepCurrCD /*= false*/)
{
    if (!p_ChargeCategoryEntry)
        return;

    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end() && !l_Itr->second.empty())
    {
        l_Itr->second.pop_back();

        uint32 l_RecoveryTime = GetChargeRecoveryTime(p_ChargeCategoryEntry);

        if (p_KeepCurrCD)
        {
            if (!l_Itr->second.empty())
                l_RecoveryTime = uint32(std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd - Clock::now()).count());
        }
        else
        {
            if (!l_Itr->second.empty())
            {
                auto l_WaitedTime = std::chrono::milliseconds(l_RecoveryTime) - std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd - Clock::now());
                l_Itr->second.front().RechargeEnd -= l_WaitedTime;
            }
        }

        uint32 l_ConsumedCharges = l_Itr->second.size();

        bool l_IsPet = false;

        WorldPacket l_Data(SMSG_SET_SPELL_CHARGES);
        l_Data << uint32(p_ChargeCategoryEntry->Id);
        l_Data << uint32(l_RecoveryTime);
        l_Data << uint8(l_ConsumedCharges);
        l_Data.WriteBit(l_IsPet);
        l_Data.FlushBits();

        if (l_IsPet)
        {
            l_Data << uint32(0);    ///< unk
            l_Data << uint32(0);    ///< unk
        }

        SendDirectMessage(&l_Data);
    }
}

void Player::ResetAllCharges()
{
    m_CategoryCharges.clear();

    WorldPacket l_Data(SMSG_CLEAR_ALL_SPELL_CHARGES);
    l_Data.WriteBit(false); ///< IsPet
    l_Data.FlushBits();
    SendDirectMessage(&l_Data);
}

bool Player::HasCharge(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return true;

    // Check if the spell is currently using charges (untalented warlock Dark Soul)
    int32 l_MaxCharges = GetMaxCharges(p_ChargeCategoryEntry);
    if (l_MaxCharges <= 0)
        return true;

    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    return l_Itr == m_CategoryCharges.end() || int32(l_Itr->second.size()) < l_MaxCharges;
}

uint32 Player::GetConsumedCharges(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];

    return l_Charges.size();
}

uint32 Player::GetMaxCharges(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return 0;

    uint32 l_MaxCharge = p_ChargeCategoryEntry->MaxCharges;

    l_MaxCharge += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MAX_CHARGES, p_ChargeCategoryEntry->Id);

    return l_MaxCharge;
}

int32 Player::GetChargeRecoveryTime(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return 0;

    float l_RecoveryTime = p_ChargeCategoryEntry->ChargeRecoveryTime;

    l_RecoveryTime += float(GetTotalAuraModifierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MOD, p_ChargeCategoryEntry->Id));
    l_RecoveryTime *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MULTIPLIER, p_ChargeCategoryEntry->Id);

    if (HasAuraType(SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE))
        l_RecoveryTime *= GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED);

    if (HasAuraTypeWithMiscvalue(SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE_REGEN, p_ChargeCategoryEntry->Id))
        l_RecoveryTime *= GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);

    if (int32 l_CooldownMod = GetTotalAuraModifier(AuraType::SPELL_AURA_MOD_COOLDOWN))
        l_RecoveryTime += l_CooldownMod * TimeConstants::IN_MILLISECONDS;

    l_RecoveryTime *= GetFloatValue(EUnitFields::UNIT_FIELD_MOD_TIME_RATE);
    l_RecoveryTime *= GetTotalChargeRecoveryRateForCategory(p_ChargeCategoryEntry->Id);

    return int32(std::floor(l_RecoveryTime));
}

void Player::ModSpellCharge(uint32 p_SpellID, int32 p_Num)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo || !p_Num)
        return;

    SpellCategoryEntry const* l_ChargeCategory = l_SpellInfo->ChargeCategoryEntry;
    if (!l_ChargeCategory)
        return;

    uint64 l_RemainingCooldownOnCharge = 0;
    auto l_Itr = m_CategoryCharges.find(l_ChargeCategory->Id);
    if (l_Itr != m_CategoryCharges.end() && !l_Itr->second.empty())
    {
        ACE_UINT64 l_CurrTime = 0;
        ACE_OS::gettimeofday().msec(l_CurrTime);
        l_RemainingCooldownOnCharge = std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd.time_since_epoch()).count() - l_CurrTime;
    }
    else
        return;

    if (p_Num > 0)
    {
        for (uint32 l_Itr = 0; l_Itr < p_Num; ++l_Itr)
            RestoreCharge(l_ChargeCategory);
        l_Itr = m_CategoryCharges.find(l_ChargeCategory->Id);
        if (l_Itr != m_CategoryCharges.end() && !l_Itr->second.empty())
        {
            auto l_CooldownReduction = std::chrono::milliseconds(GetChargeRecoveryTime(l_ChargeCategory) - l_RemainingCooldownOnCharge);
            for (auto l_ThirdItr = l_Itr->second.begin(); l_ThirdItr != l_Itr->second.end(); ++l_ThirdItr)
            {
                (*l_ThirdItr).RechargeStart += l_CooldownReduction;
                (*l_ThirdItr).RechargeEnd += l_CooldownReduction;
            }
        }
    }
    else
    {
        for (int32 l_Itr = 0; l_Itr > p_Num; --l_Itr)
            ConsumeCharge(l_ChargeCategory, p_SpellID);
    }

    UpdateCharge(l_ChargeCategory);
    SendSpellCharge(l_ChargeCategory);
}

void Player::ModSpellChargeCooldown(uint32 p_SpellID, int32 p_Delta)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_SpellID);
    if (!l_SpellInfo || !p_Delta)
        return;

    SpellCategoryEntry const* l_ChargeCategory = l_SpellInfo->ChargeCategoryEntry;
    if (!l_ChargeCategory)
        return;

    Clock::time_point l_Now = Clock::now();

    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[l_ChargeCategory->Id];
    for (ChargeEntry& l_Entry : l_Charges)
    {
        l_Entry.RechargeStart += std::chrono::milliseconds(p_Delta);
        l_Entry.RechargeEnd -= std::chrono::milliseconds(p_Delta);
    }

    UpdateCharge(l_ChargeCategory);
    SendSpellCharge(l_ChargeCategory);
}
//////////////////////////////////////////////////////////////////////////

void Player::ApplyOnBagsItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }

    for (uint32 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Bag* l_Bag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            for (uint32 l_J = 0; l_J < l_Bag->GetBagSize(); ++l_J)
            {
                if (Item* l_Item = GetItemByPos(l_I, l_J))
                {
                    if (!p_Function(this, l_Item, l_I, l_J))
                        return;
                }
            }
        }
    }
}

void Player::ApplyOnBankItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = BANK_SLOT_ITEM_START; l_I < BANK_SLOT_ITEM_END; l_I++)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }

    for (uint32 l_I = BANK_SLOT_BAG_START; l_I < BANK_SLOT_BAG_END; ++l_I)
    {
        if (Bag* l_Bag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            for (uint32 l_J = 0; l_J < l_Bag->GetBagSize(); ++l_J)
            {
                if (Item* l_Item = GetItemByPos(l_I, l_J))
                {
                    if (!p_Function(this, l_Item, l_I, l_J))
                        return;
                }
            }
        }
    }
}

void Player::ApplyOnReagentBankItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = REAGENT_BANK_SLOT_BAG_START; l_I < REAGENT_BANK_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }
}

void Player::_LoadDailyLootsCooldowns(PreparedQueryResult&& p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Field = p_Result->Fetch();
        uint32 l_ID = l_Field[0].GetUInt32();

        if (!m_DailyLootsCooldowns.count(l_ID))
            m_DailyLootsCooldowns.insert(l_ID);
    }
    while (p_Result->NextRow());
}

void Player::ResetDailyLoots()
{
    m_DailyLootsCooldowns.clear();
}

void Player::AddDailyLootCooldown(uint32 p_Entry)
{
    /// If not, already in database
    if (!m_DailyLootsCooldowns.count(p_Entry))
    {
        m_DailyLootsCooldowns.insert(p_Entry);

        PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_DAILY_LOOT_COOLDOWNS);
        l_Statement->setUInt32(0, GetRealGUIDLow());
        l_Statement->setUInt32(1, p_Entry);
        RealmDatabase.Execute(l_Statement);
    }
}

bool Player::AddHeirloom(HeirloomEntry const* p_HeirloomEntry, uint8 p_UpgradeLevel, bool p_UseShopGroupRealmMask)
{
    if (HasHeirloom(p_HeirloomEntry))
        return false;

    uint32 l_Index = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size();
    p_UpgradeLevel = std::min(p_UpgradeLevel, (uint8)p_HeirloomEntry->Source);
    uint32 l_HeirloomFlags = (1 << p_UpgradeLevel) - 1;

    SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, l_Index, p_HeirloomEntry->ItemID);
    SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, l_Index, l_HeirloomFlags);

    UpdateCriteria(CRITERIA_TYPE_OWN_HEIRLOOMS, l_Index + 1);

    if (!sWorld->CanBeSaveInLoginDatabase())
        return true;

#ifndef CROSS
    uint32 l_GroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_GROUP_MASK);
#else /* CROSS */
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());

    uint32 l_GroupRealmMask = l_Config->groupRealmMask;
#endif /* CROSS */
    if (p_UseShopGroupRealmMask)
        l_GroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_SHOP_GROUP_MASK);

    PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_INS_HEIRLOOM);
    l_Statement->setUInt32(0, GetSession()->GetAccountId());
    l_Statement->setUInt32(1, p_HeirloomEntry->ID);
    l_Statement->setUInt32(2, l_HeirloomFlags);
    l_Statement->setUInt32(3, l_GroupRealmMask);
    l_Statement->setUInt32(4, l_GroupRealmMask);
    LoginDatabase.Execute(l_Statement);

    return true;
}

bool Player::HasHeirloom(uint32 p_ItemID) const
{
    HeirloomEntry const* l_Heirloom = GetHeirloomEntryByItemID(p_ItemID);
    return HasHeirloom(l_Heirloom);
}

bool Player::HasHeirloom(HeirloomEntry const* p_HeirloomEntry) const
{
    if (!p_HeirloomEntry)
        return false;

    std::vector<uint32> const& l_Heirlooms = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS);

    for (uint32 l_I = 0; l_I < l_Heirlooms.size(); ++l_I)
        if (l_Heirlooms[l_I] == p_HeirloomEntry->ItemID)
            return true;

    return false;
}

void Player::_LoadHeirloomCollection(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

#ifndef CROSS
    uint32 l_AllowedGroupRealmMask = sWorld->getIntConfig(CONFIG_ACCOUNT_BIND_ALLOWED_GROUP_MASK);
#else /* CROSS */
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());
    uint32 l_AllowedGroupRealmMask = l_Config->allowedGroupRealmMask;
#endif /* CROSS */

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint32 l_HeirloomID     = l_Fields[0].GetUInt32();
        uint32 l_HeirloomFlags  = l_Fields[1].GetUInt32();
        uint32 l_GroupRealmMask = l_Fields[2].GetUInt32();

        if ((l_GroupRealmMask & l_AllowedGroupRealmMask) == 0)
            continue;

        HeirloomEntry const* l_HeirloomEntry = sHeirloomStore.LookupEntry(l_HeirloomID);

        if (!l_HeirloomEntry)
            continue;

        if (HasHeirloom(l_HeirloomEntry))
            continue;

        l_HeirloomFlags = std::min(l_HeirloomFlags, (uint32)(1 << (l_HeirloomEntry->Source + 1)) - 1);

        uint32 l_Index = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size();
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, l_Index, l_HeirloomEntry->ItemID);
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, l_Index, l_HeirloomFlags);
    }
    while (p_Result->NextRow());

    UpdateCriteria(CRITERIA_TYPE_OWN_HEIRLOOMS, GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size());
}

void Player::_LoadArtifacts(PreparedQueryResult p_Result, PreparedQueryResult p_PowersResult)
{
    if (!p_Result)
        return;

    std::map<uint32, std::unordered_map<uint32, MS::Artifact::ArtifactPowerRanks>> l_Powers;

    if (p_PowersResult)
    {
        do
        {
            uint32 l_Index = 0;
            Field* l_Fields = p_PowersResult->Fetch();

            uint32 l_ID = l_Fields[l_Index++].GetUInt32();
            uint32 l_Power = l_Fields[l_Index++].GetUInt32();

            ArtifactPowerEntry const* l_ArtifactPower = sArtifactPowerStore.LookupEntry(l_Power);
            if (!l_ArtifactPower)
                continue;

            uint32 l_PurchasedRank = l_Fields[l_Index++].GetUInt32();
            uint32 l_RankWithBonus = (l_ArtifactPower->Flags & MS::Artifact::ArtifactPowerFlags::IsStart || l_ArtifactPower->MaxPurchasableRank == 0) ? 1 : l_PurchasedRank;

            auto l_Iter = l_Powers.find(l_ID);

            if (l_Iter == l_Powers.end())
                l_Iter = l_Powers.insert({ l_ID, std::unordered_map<uint32, MS::Artifact::ArtifactPowerRanks>()}).first;

            std::unordered_map<uint32, MS::Artifact::ArtifactPowerRanks>& l_Powers = l_Iter->second;
            l_Powers.insert({ l_Power, MS::Artifact::ArtifactPowerRanks(l_PurchasedRank, l_RankWithBonus) });
        }
        while (p_PowersResult->NextRow());
    }

    do
    {
        MS::Artifact::Manager* l_Artifact;

        Field* l_Fields = p_Result->Fetch();

        uint32 l_Index = 0;

        uint32 l_ID            = l_Fields[l_Index++].GetInt32();
        uint64 l_ArtifactPower = l_Fields[l_Index++].GetUInt64();
        uint32 l_AppearanceId  = l_Fields[l_Index++].GetUInt32();
        uint8 l_Tier           = l_Fields[l_Index++].GetUInt8();

        l_Artifact = MS::Artifact::Manager::GenerateNew(l_ID);

        if (!l_Artifact)
            continue;

        l_Artifact->SetOwner(this);
        auto l_Iter = l_Powers.find(l_ID);
        std::unordered_map<uint32, MS::Artifact::ArtifactPowerRanks>* l_TargetPowers = l_Iter != l_Powers.end() ? l_TargetPowers = &l_Iter->second : nullptr;

        m_ArtifactMgrHolder[l_ID] = l_Artifact;
        l_Artifact->LoadFromDB(l_ArtifactPower, l_AppearanceId, l_Tier, l_TargetPowers);

        /// Delay UpdateCriteria because of 'GetSession()->IsPlayerLoading' condition
        auto l_TraitsCount = l_Artifact->GetLevel();
        AddDelayedEvent([this, l_TraitsCount]() -> void
        {
            UpdateCriteria(CriteriaTypes::CRITERIA_TYPE_ARTIFACT_TRAITS_UNLOCKED, l_TraitsCount);
        }, 1);
    }
    while (p_Result->NextRow());
}

uint32 Player::GetHeirloomUpgradeLevel(HeirloomEntry const* p_HeirloomEntry) const
{
    if (!p_HeirloomEntry)
        return 0;

    std::vector<uint32> const& l_Heirlooms = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS);

    for (uint32 l_I = 0; l_I < l_Heirlooms.size(); ++l_I)
    {
        if (l_Heirlooms[l_I] == p_HeirloomEntry->ItemID)
        {
            for (int l_X = p_HeirloomEntry->Source + 1; l_X != 0; --l_X)
                if (GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS)[l_I] & (1 << (l_X - 1)))
                    return l_X;
            return 0;
        }
    }

    return 0;
}

bool Player::CanUpgradeHeirloomWith(HeirloomEntry const* p_HeirloomEntry, uint32 p_ItemId) const
{
    if (!p_HeirloomEntry)
        return false;

    if (!HasHeirloom(p_HeirloomEntry))
        return false;

    uint32 l_CurrentUpgradeLevel = GetHeirloomUpgradeLevel(p_HeirloomEntry);
    if (l_CurrentUpgradeLevel >= MAX_HEIRLOOM_UPGRADE_LEVEL)
        return false;

    if (!p_HeirloomEntry->UpgradeIemBonusID[l_CurrentUpgradeLevel])
        return false;

    if (p_HeirloomEntry->UpgradableByItemID[l_CurrentUpgradeLevel] != p_ItemId)
        return false;

    return HasItemCount(p_ItemId);
}

void Player::SetQuestBit(uint32 p_BitIndex, bool p_Completed)
{
    if (!p_BitIndex)
        return;

    uint32 l_FlagValue  = 1 <<  ((p_BitIndex - 1) % 32);
    uint32 l_FieldIndex = (p_BitIndex - 1) / 32;

    if (p_Completed)
        SetFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
    else
        RemoveFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
}

bool Player::IsQuestBitFlaged(uint32 p_BitIndex) const
{
    if (!p_BitIndex)
        return false;

    uint32 l_FlagValue  = 1 << ((p_BitIndex - 1) % 32);
    uint32 l_FieldIndex = (p_BitIndex - 1) / 32;

    return HasFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
}

void Player::ClearQuestBits(std::vector<uint32> const& p_QuestBits)
{
    for (auto l_Bit : p_QuestBits)
        SetQuestBit(l_Bit, false);
}

Difficulty Player::GetDifficultyID(MapEntry const* p_MapEntry) const
{
    if (p_MapEntry->IsScenario())
        return Difficulty::DifficultyNScenario;

    if (!p_MapEntry->IsRaid())
    {
        /// Headless Horseman, we still have to use the old map, needs to force it to Normal mode
        if (p_MapEntry->MapID == 189)
            return Difficulty::DifficultyNormal;

        return m_dungeonDifficulty;
    }

    MapDifficultyEntry const* l_DefaultDifficulty = GetDefaultMapDifficulty(p_MapEntry->MapID);
    if (!l_DefaultDifficulty)
        return m_LegacyRaidDifficulty;

    DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(l_DefaultDifficulty->DifficultyID);
    if (!l_Difficulty || l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY)
        return m_LegacyRaidDifficulty;

    return m_raidDifficulty;
}

Difficulty Player::CheckLoadedDungeonDifficultyID(Difficulty difficulty)
{
    /// Difficulty MythicKeystone should be enabled by server only during mythic+ dungeons
    if (difficulty == Difficulty::DifficultyMythicKeystone)
        difficulty = Difficulty::DifficultyMythic;

    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(difficulty);
    if (!l_DifficultyEntry)
        return DifficultyNormal;

    if (l_DifficultyEntry->InstanceType != MAP_INSTANCE)
        return DifficultyNormal;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT))
        return DifficultyNormal;

    return difficulty;
}

Difficulty Player::CheckLoadedRaidDifficultyID(Difficulty p_Difficulty)
{
    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(p_Difficulty);
    if (!l_DifficultyEntry)
        return DifficultyRaidNormal;

    if (l_DifficultyEntry->InstanceType != MAP_RAID)
        return DifficultyRaidNormal;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || (l_DifficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return DifficultyRaidNormal;

    return p_Difficulty;
}

Difficulty Player::CheckLoadedLegacyRaidDifficultyID(Difficulty p_Difficulty)
{
    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(p_Difficulty);
    if (!l_DifficultyEntry)
        return Difficulty10N;

    if (l_DifficultyEntry->InstanceType != MAP_RAID)
        return Difficulty10N;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || !(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return Difficulty10N;

    return p_Difficulty;
}

void Player::ApplyWargameItemModifications()
{
    bool l_InWargame       = GetBattleground() && GetBattleground()->IsWargame();
    bool l_TournamentRules = GetBattleground() && GetBattleground()->UseTournamentRules();

    for (uint8 l_I = 0; l_I < EQUIPMENT_SLOT_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            bool l_UpdateItemMods = false;

            if (l_InWargame)
            {
                if (l_Item->GetTemplate()->Flags3 & int32(ItemFlagsEX2::PVP_TOURNAMENT_GEAR))
                {
                    if (l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                    {
                        l_Item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                        l_UpdateItemMods = true;
                    }
                }
                else if (l_TournamentRules && !l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                {
                    l_Item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                    l_UpdateItemMods = true;
                }
            }
            else
            {
                if (l_Item->GetTemplate()->Flags3 & int32(ItemFlagsEX2::PVP_TOURNAMENT_GEAR))
                {
                    if (!l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                    {
                        l_Item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                        l_UpdateItemMods = true;
                    }
                }
                else if (l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                {
                    l_Item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                    l_UpdateItemMods = true;
                }
            }

            if (l_UpdateItemMods)
            {
                _ApplyItemMods(l_Item, l_I, false);
                _ApplyItemMods(l_Item, l_I, true);
            }
        }
    }
}

void Player::DeleteInvalidSpells()
{
    PlayerSpellMap l_SpellMap = GetSpellMap();
    for (PlayerSpellMap::const_iterator l_Iterator = l_SpellMap.begin(); l_Iterator != l_SpellMap.end(); ++l_Iterator)
    {
        if (sObjectMgr->IsInvalidSpell(l_Iterator->first))
            removeSpell(l_Iterator->first, false, false);
    }
}

void Player::_LoadWorldStates(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();
        CharacterWorldState l_WorldState;
        l_WorldState.Value   = l_Fields[1].GetUInt64();
        l_WorldState.Changed = false;

        m_CharacterWorldStates.insert(std::make_pair(l_Fields[0].GetUInt32(), l_WorldState));
    }
    while (p_Result->NextRow());
}

void Player::_SaveCharacterWorldStates(SQLTransaction& p_Transaction)
{
    for (auto l_Iterator : m_CharacterWorldStates)
    {
        CharacterWorldState& l_WorldState = l_Iterator.second;
        if (!l_WorldState.Changed)
            continue;

        PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_REP_WORLD_STATES);
        l_Statement->setUInt32(0, GetRealGUIDLow());
        l_Statement->setUInt32(1, l_Iterator.first);
        l_Statement->setUInt64(2, l_WorldState.Value);

        p_Transaction->Append(l_Statement);
    }
}

void Player::_SavePvpInfo(SQLTransaction& p_Transaction)
{
    if (!IsMaxLevel())
        return;

    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_DEL_PVP_INFO);
    l_Statement->setUInt32(0, GetRealGUIDLow());
    p_Transaction->Append(l_Statement);

    uint8 l_I = 0;

    l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_PVP_INFO);
    l_Statement->setUInt32(l_I++, GetRealGUIDLow());
    l_Statement->setUInt32(l_I++, GetHonor());
    l_Statement->setUInt32(l_I++, GetHonorLevel());
    l_Statement->setUInt32(l_I++, GetPrestige());

    p_Transaction->Append(l_Statement);
}

void Player::SendCustomMessage(std::string const& p_Opcode)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|" << " " << "|";
    ChatHandler(this).SendSysMessage(l_Message.str().c_str(), true);
}

void Player::SendCustomMessage(std::string const& p_Opcode, std::ostringstream const& p_Message)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|" << p_Message.str() << "|";
    ChatHandler(this).SendSysMessage(l_Message.str().c_str(), true);
}

void Player::SendCustomMessage(std::string const& p_Opcode, std::vector<std::string> const& p_Data)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|";

    if (!p_Data.empty())
    {
        for (auto const& l_Elem : p_Data)
            l_Message << l_Elem << "|";
    }
    else
        l_Message << " " << "|";

    ChatHandler(this).SendSysMessage(l_Message.str().c_str(), true);
}

uint32 Player::GetBagsFreeSlots() const
{
    uint32 l_FreeBagSlots = 0;

    for (uint8 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; l_I++)
    {
        if (Bag * l_Bag = GetBagByPos(l_I))
            l_FreeBagSlots += l_Bag->GetFreeSlots();
    }

    for (uint8 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (!GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            ++l_FreeBagSlots;
    }

    return l_FreeBagSlots;
}

uint32 Player::GetGeneralFreeBagSlots() const
{
    uint32 l_FreeBagSlots = 0;

    for (uint8 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; l_I++)
    {
        if (Bag * l_Bag = GetBagByPos(l_I))
        {
            if (l_Bag->GetTemplate()->SubClass == ITEM_SUBCLASS_CONTAINER)
            {
                l_FreeBagSlots += l_Bag->GetFreeSlots();
            }
        }
    }

    for (uint8 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (!GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            ++l_FreeBagSlots;
    }

    return l_FreeBagSlots;
}

void Player::HandleWarlockWodPvpBonus()
{
    if (getClass() != CLASS_WARLOCK || getLevel() != 100)
        return;

    uint32 l_SpellBonusId = 0;
    uint32 l_TriggerSpell = 0;

    /// Check what's specialization bonus we need
    if (GetActiveSpecializationID() == SPEC_WARLOCK_AFFLICTION)
    {
        l_SpellBonusId = 171377;
        l_TriggerSpell = 171378;
    }
    else if (GetActiveSpecializationID() == SPEC_WARLOCK_DESTRUCTION)
    {
        l_SpellBonusId = 171383;
        l_TriggerSpell = 188168;
    }

    if (HasAura(l_SpellBonusId) && !HasSpellCooldown(l_TriggerSpell))
    {
        CastSpell(this, l_TriggerSpell, true);
        AddSpellCooldown(l_TriggerSpell, 0, 15 * IN_MILLISECONDS);
    }
}

Creature* Player::GetHati()
{
    enum eDatas
    {
        Hati = 100324
    };

    for (std::set<Unit*>::iterator l_Itr = m_Controlled.begin(); l_Itr != m_Controlled.end(); ++l_Itr)
    {
        if ((*l_Itr)->GetEntry() == eDatas::Hati)
            return (*l_Itr)->ToCreature();
    }
    return nullptr;
}

#ifdef CROSS
void Player::RemovePlayer()
{
    sAnticheatMgr->HandlePlayerLogout(this);
    sRecruitAFriendMgr->AddEvent(eRecruitAFriendMgrEvents::EventPlayerLogout, GetRealGUID(), GetName());

    if (InBattleground())
    {
        if (Battleground* bg = GetBattleground())
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
    }
    else if (InBattlegroundQueue())
    {
        for (int i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        {
            MS::Battlegrounds::BattlegroundType::Type l_BgQueueTypeId = GetBattlegroundQueueTypeId(i);

            if (l_BgQueueTypeId != MS::Battlegrounds::BattlegroundType::None)
            {
                RemoveBattlegroundQueueId(l_BgQueueTypeId);
                sBattlegroundMgr->RemovePlayer(GetGUID(), true, l_BgQueueTypeId);
            }
        }
    }

    /// Make sure every invitation are removed to avoid future bug (they should be already removed ...)
    sBattlegroundMgr->GetInvitationsMgr().ClearPlayerInvitation(GetGUID());

    WorldSession* pSession = GetSession();

    uint64 realguid = GetRealGUID();
    uint64 newguid = GetGUID();

    CleanupsBeforeDelete();

    if (GroupPtr l_Group = GetGroup())
        l_Group->UnlinkPlayer(this);

    if (GroupPtr l_Group = GetOriginalGroup())
        l_Group->UnlinkPlayer(this);

    if (pSession)
    {
        if (InterRealmClient* client = pSession->GetInterRealmClient())
            pSession->GetInterRealmClient()->RemovePlayer(GetRealGUID());

        pSession->SetInterRealmClient(NULL);
        pSession->setInInterRealmBG(false);
        pSession->SetIRClosing(true);
        pSession->SetDummySession();
    }

    if (IsInGrid())
        RemoveFromGrid();

    sObjectAccessor->RemoveObject(this);
    RemoveFromObjectUpdate();

    ResetMap();
}

InterRealmDatabasePool* Player::GetRealmDatabase()
{
    return GetSession()->GetInterRealmClient()->GetDatabase();
}

#endif /* CROSS */

uint32 Player::GetRandomWeaponFromPrimaryBag(ItemTemplate const* p_Transmogrified) const
{
    std::vector<uint32> l_AllItemsInPrimaryBag;

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        if (Item* l_FoundItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (ItemTemplate const* l_FoundItemTemplate = l_FoundItem->GetTemplate())
            {
                if (l_FoundItemTemplate->Class != ITEM_CLASS_WEAPON && l_FoundItemTemplate->Class != ITEM_CLASS_ARMOR)
                    continue;

                if (!Item::CanTransmogrifyIntoRandomWeapon(l_FoundItemTemplate, p_Transmogrified))
                    continue;

                if (l_FoundItemTemplate->ItemId != 0)
                    l_AllItemsInPrimaryBag.push_back(l_FoundItemTemplate->ItemId);
            }
        }
    }

    /// If we have just one item, we should take it
    if (uint32(l_AllItemsInPrimaryBag.size()) == 1)
        return l_AllItemsInPrimaryBag[0];

    /// Select random weapon id from primary bag if we have many items
    if (uint32(l_AllItemsInPrimaryBag.size()) > 1)
        return l_AllItemsInPrimaryBag[urand(0, uint32(l_AllItemsInPrimaryBag.size() - 1))];

    return 0;
}

#ifdef CROSS
void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    if (Battleground* bg = GetBattleground())
    {
        bg->RemovePlayerAtLeave(GetGUID(), true, false);

        // call after remove to be sure that player resurrected for correct cast
        if (bg->isBattleground() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                //lets check if player was teleported from BG and schedule delayed Deserter spell cast
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                CastSpell(this, MS::Battlegrounds::Spells::DeserterBuff, true);
            }
        }

        if (bg->IsRated() && bg->isArena() && (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN))
        {
            int32 l_LooserChange = 0;
            int32 l_LooserMMRChange = 0;

            if (PlayerData const* l_Data = bg->GetPlayerData(GetObjectGuid()))
            {
                uint32 l_LooserTeam = l_Data->TeamID;
                uint32 l_WinnerTeam = bg->GetOtherTeam(l_LooserTeam);
                uint32 l_LooserMMR  = bg->GetArenaMatchmakerRating(l_LooserTeam, uint8(bg->GetBattlegroundBracketType()));
                uint32 l_WinnerMMR  = bg->GetArenaMatchmakerRating(l_WinnerTeam, uint8(bg->GetBattlegroundBracketType()));

                /// Needed for rating gain calculations for the winner team, and for scoreboard data
                /// will be cleared at the end of the battleground anyway
                if (GroupPtr l_Group = GetGroup())
                    bg->SetBgRaid(l_LooserTeam, l_Group);

                bg->LooserRatingChanges(l_LooserMMR, l_WinnerMMR, l_LooserChange, l_LooserMMRChange, uint8(bg->GetBattlegroundBracketType()), l_WinnerTeam, GetObjectGuid());

                bg->SetArenaMatchmakerRating(l_LooserTeam, l_LooserMMR + l_LooserMMRChange);
                bg->SetArenaTeamRatingChangeForTeam(l_LooserTeam, l_LooserChange);
            }

            if (InterRealmClient* l_Client = GetSession()->GetInterRealmClient())
                l_Client->SendBattlegroundLeaveQueue(GetObjectGuid(), l_LooserChange, l_LooserMMRChange, uint8(bg->GetBattlegroundBracketType()), false);
        }

        bg->RemoveFromInterRealm(GetGUID());
    }
}
#endif /* CROSS */

uint32 Player::GetZoneId(bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
        *(const_cast<uint32*>(&m_LastZoneId)) = WorldObject::GetZoneId();

    return m_LastZoneId;
}

uint32 Player::GetAreaId(bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
        *(const_cast<uint32*>(&m_LastAreaId)) = WorldObject::GetAreaId();

    return m_LastAreaId;
}

void Player::GetZoneAndAreaId(uint32& p_ZoneId, uint32& p_AreaId, bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
    {
        WorldObject::GetZoneAndAreaId(p_ZoneId, p_AreaId);
        *(const_cast<uint32*>(&m_LastZoneId)) = p_ZoneId;
        *(const_cast<uint32*>(&m_LastAreaId)) = p_AreaId;
        return;
    }

    p_ZoneId = m_LastZoneId;
    p_AreaId = m_LastAreaId;
}

void Player::GiveHonor(uint32 p_Honor)
{
    if (GetHonorLevel() >= MAX_HONOR_LEVEL)
        return;

    uint32 l_RequiredRemainingHonor = GetHonorRequiredForNextLevel() - GetHonor();

    while (l_RequiredRemainingHonor <= p_Honor)
    {
        p_Honor -= l_RequiredRemainingHonor;

        if (GiveHonorLevel() == MAX_HONOR_LEVEL)
            return;

        l_RequiredRemainingHonor = GetHonorRequiredForNextLevel() - GetHonor();
    }

    SetUInt32Value(PLAYER_FIELD_HONOR, GetHonor() + p_Honor);
}

uint32 Player::GiveHonorLevel()
{
    uint32 l_HonorLevel = GetHonorLevel();

    enum eItems
    {
        Item_Grand_Marshals_Medal_Of_Valor = 138992,
        Item_High_Warlords_Medal_Of_Valor  = 138996
    };

    if (l_HonorLevel >= MAX_HONOR_LEVEL)
        return l_HonorLevel;

    SetHonorLevel(l_HonorLevel + 1);

    if (GetHonorLevel() == 50 && GetPrestige() == 1)
    {
        if (!HasItemCount(eItems::Item_Grand_Marshals_Medal_Of_Valor, 1, true, false) || !HasItemCount(eItems::Item_High_Warlords_Medal_Of_Valor, 1, true, false))
        {
            if (GetTeamId() == TEAM_ALLIANCE)
                AddItem(eItems::Item_Grand_Marshals_Medal_Of_Valor, 1);
            else if (GetTeamId() == TEAM_HORDE)
                AddItem(eItems::Item_High_Warlords_Medal_Of_Valor, 1);
        }
    }

    if (GetHonorLevel() != 50)
    {
        if (uint32 l_PackReward = GetHonorReward(GetHonorLevel(), 0)) ///< In the db2 the rewards are only set to Prestige 0 while they are also given out at Prestige 1+
            GiveRewardPack(l_PackReward);
    }
    else
    {
        if (uint32 l_PackReward = GetHonorReward(GetHonorLevel(), GetPrestige()))
            GiveRewardPack(l_PackReward);
    }

    UpdateCriteria(CRITERIA_TYPE_HONOR_LEVEL_REACHED, l_HonorLevel);

    return l_HonorLevel;
}

uint32 Player::GetHonorReward(uint8 p_Level, uint8 p_Prestige) const
{
    for (uint32 l_ID = 0; l_ID < sPvpRewardStore.GetNumRows(); ++l_ID)
    {
        PvpRewardEntry const* l_Reward = sPvpRewardStore.LookupEntry(l_ID);
        if (!l_Reward)
            continue;

        if (l_Reward->HonorLevel == p_Level && l_Reward->PrestigeLevel == p_Prestige)
            return l_Reward->RewardPackID;
    }

    return 0;
}

void Player::SetHonorLevel(uint32 p_Level)
{
    if (p_Level == GetHonorLevel())
        return;

    if (p_Level > MAX_HONOR_LEVEL)
        return;

    if (getLevel() < 110)
        return;

    SetUInt32Value(PLAYER_FIELD_HONOR_LEVEL, p_Level);
    SetUInt32Value(PLAYER_FIELD_HONOR, 0);
    UpdateRequiredHonor();
}

uint32 Player::GetHonorLevel() const
{
    return GetUInt32Value(PLAYER_FIELD_HONOR_LEVEL);
}

uint32 Player::GetHonorRequiredForNextLevel() const
{
    return GetUInt32Value(PLAYER_FIELD_HONOR_NEXT_LEVEL);
}

uint32 Player::GetHonor() const
{
    return GetUInt32Value(PLAYER_FIELD_HONOR);
}

void Player::UpdateRequiredHonor()
{
    HonorLevelTableEntry const* l_Entry = g_HonorLevelTable.LookupEntry(GetHonorLevel() + 1);
    uint32 l_RequiredHonor = l_Entry ? l_Entry->m_RequiredHonor[std::min((uint32)MAX_HONOR_PRESTIGE_LEVEL, GetPrestige())] : 0;
    SetUInt32Value(PLAYER_FIELD_HONOR_NEXT_LEVEL, l_RequiredHonor);
}

bool Player::CanPrestige() const
{
    if (GetPrestige() >= GetMaxPrestigeLevel())
        return false;

    if (GetHonorLevel() < MAX_HONOR_LEVEL)
        return false;

    return true;
}

void Player::Prestige(bool p_CheckIfCan)
{
    if (p_CheckIfCan && !CanPrestige())
        return;

    if (GetPrestige() >= GetMaxPrestigeLevel())
        return;

    if (getLevel() < 110)
        return;

    SendTalentsInfoData();

    SetUInt32Value(PLAYER_FIELD_PRESTIGE, GetPrestige() + 1);
    SetHonorLevel(1);

    UpdateCriteria(CRITERIA_TYPE_PRESTIGE_REACHED, GetPrestige());

    SaveToDB();
}

uint32 Player::GetPrestige() const
{
    return GetUInt32Value(PLAYER_FIELD_PRESTIGE);
}

void Player::GiveRewardPack(uint32 p_Id)
{
    RewardPackEntry const* l_Entry = sRewardPackStore.LookupEntry(p_Id);
    if (!l_Entry)
        return;

    if (int32 l_Money = l_Entry->MoneyReward)
        ModifyMoney(l_Money, "Player::GiveRewardPack " + std::to_string(p_Id));

    if (uint16 l_Title = l_Entry->TitleID)
        SetTitle(sCharTitlesStore.LookupEntry(l_Title));

    for (uint32 l_Id = 0; l_Id < sRewardPackXCurrencyTypeStore.GetNumRows(); ++l_Id)
    {
        RewardPackXCurrencyTypeEntry const* l_CurrencyEntry = sRewardPackXCurrencyTypeStore.LookupEntry(l_Id);
        if (!l_CurrencyEntry)
            continue;

        if (l_CurrencyEntry->m_RewardPackID == p_Id)
            ModifyCurrency(l_CurrencyEntry->m_CurrencyID, l_CurrencyEntry->m_Count);
    }

    for (uint32 l_Id = 0; l_Id < sRewardPackXItemStore.GetNumRows(); ++l_Id)
    {
        RewardPackXItemEntry const* l_ItemEntry = sRewardPackXItemStore.LookupEntry(l_Id);
        if (!l_ItemEntry)
            continue;

        if (l_ItemEntry->RewardPackID == p_Id)
            AddItem(l_ItemEntry->ItemID, l_ItemEntry->Amount, {}, false, 0, false, true);
    }
}

Powers Player::GetDisplayPowerForCurrentState() const
{
    ShapeshiftForm form = GetShapeshiftForm();
    switch (form)
    {
        case FORM_TIGER_STANCE:
        case FORM_OX_STANCE:
        case FORM_GHOUL:
        case FORM_CAT_FORM:
            return POWER_ENERGY;
        case FORM_BEAR_FORM:
            return POWER_RAGE;
        case FORM_CRANE_STANCE:
        case FORM_SERPENT_STANCE:
            return POWER_MANA;
        default:
            break;
    }

    switch (GetActiveSpecializationID())
    {
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_SHAMAN_ELEMENTAL:
            return POWER_MAELSTROM;
        case SPEC_DRUID_BALANCE:
            return POWER_LUNAR_POWER;
        case SPEC_DEMON_HUNTER_HAVOC:
            return POWER_FURY;
        case SPEC_DEMON_HUNTER_VENGEANCE:
            return POWER_PAIN;
        case SPEC_PRIEST_SHADOW:
            return POWER_INSANITY;
        case SPEC_MONK_MISTWEAVER:
            return POWER_MANA;
        default:
            break;
    }

    ChrClassesEntry const* l_ClassEntry = sChrClassesStore.LookupEntry(getClass());
    if (l_ClassEntry && l_ClassEntry->DisplayPower < MAX_POWERS)
        return Powers(l_ClassEntry->DisplayPower);

    return POWER_MANA;
}

MS::Artifact::Manager * Player::GetArtifactHolder(uint32 p_ArtifactID)
{
    auto l_Iter = m_ArtifactMgrHolder.find(p_ArtifactID);
    return l_Iter != m_ArtifactMgrHolder.end() ? l_Iter->second : nullptr;
}

MS::Artifact::Manager const* Player::GetArtifactHolder(uint32 p_ArtifactID) const
{
    auto l_Iter = m_ArtifactMgrHolder.find(p_ArtifactID);
    return l_Iter != m_ArtifactMgrHolder.end() ? l_Iter->second : nullptr;
}

MS::Artifact::Manager* Player::GetOrGenerateNewArtifactHolder(uint32 p_ArtifactID)
{
    MS::Artifact::Manager* l_Artifact = GetArtifactHolder(p_ArtifactID);

    if (l_Artifact)
     return l_Artifact;

    l_Artifact = MS::Artifact::Manager::GenerateNew(p_ArtifactID);

    if (!l_Artifact)
        return nullptr;

    l_Artifact->SetOwner(this);
    m_ArtifactMgrHolder.insert({ p_ArtifactID, l_Artifact });

    return l_Artifact;
}

bool Player::HasPvPTalent(uint32 p_ID) const
{
    std::vector<uint32>& l_Talents = _talentMgr->PvPTalents[GetActiveTalentGroup()];
    return std::find(l_Talents.begin(), l_Talents.end(), p_ID) != l_Talents.end();
}

uint32 Player::GetPvPTalentAtTier(uint32 p_TierIndex) const
{
    return _talentMgr->PvPTalents[GetActiveTalentGroup()][p_TierIndex];
}

void Player::StorePvPTalent(PvpTalentEntry const* p_TalentEntry)
{
    _talentMgr->PvPTalents[GetActiveTalentGroup()][p_TalentEntry->m_TierIndex] = p_TalentEntry->m_ID;
}

void Player::RemoveInteralPvPTalent(uint32 p_TierIndex)
{
    _talentMgr->PvPTalents[GetActiveTalentGroup()][p_TierIndex] = 0;
}

void Player::LoadAddPvPTalentFromDB(uint32 p_Talent, uint8 p_Spec)
{
    PvpTalentEntry const* l_Entry = sPvpTalentStore.LookupEntry(p_Talent);
    if (!l_Entry)
        return;

    if (p_Spec >= MAX_SPECIALIZATIONS)
        return;

    if (GetHonorLevel() < GetPvPTalentLevelRequirement(l_Entry->m_CollumnIndex, l_Entry->m_TierIndex) && GetPrestige() == 0)
        return;

    if (uint32 l_Spec = l_Entry->m_SpecID)
    {
        if (ChrSpecializationsEntry const* l_SpecEntry = sChrSpecializationsStore.LookupEntry(l_Spec))
        {
            if (l_SpecEntry->OrderIndex != p_Spec)
                return;
        }
    }

    if (l_Entry->m_OverridesSpellID)
        AddOverrideSpell(l_Entry->m_OverridesSpellID, l_Entry->m_SpellID);

    _talentMgr->PvPTalents[p_Spec][l_Entry->m_TierIndex] = p_Talent;
}

void Player::RemoveAllPvpTalents()
{
    for (uint32 l_Index = 0; l_Index < MAX_SPECIALIZATIONS; ++l_Index)
        memset(&(_talentMgr->PvPTalents[l_Index][0]), 0, _talentMgr->PvPTalents[l_Index].size() * sizeof(uint32));
}

void Player::ActivatePvPTalents()
{
    std::vector<uint32>& l_PvPTalents = _talentMgr->PvPTalents[GetActiveTalentGroup()];

    for (auto l_Talent : l_PvPTalents)
    {
        if (!l_Talent)
            continue;

        PvpTalentEntry const* l_TalentEntry = sPvpTalentStore.LookupEntry(l_Talent);
        if (!l_TalentEntry)
            continue;

        learnSpell(l_TalentEntry->m_SpellID, false, false, true);

        switch (l_TalentEntry->m_SpellID)
        {
        case 247483:
            CastSpell(this, 248643, true);
            break;
        case 215982:
            learnSpell(215769, false, false, true);
            break;
        }
    }
}

void Player::DeactivatePvPTalents()
{
    std::vector<uint32>& l_PvPTalents = _talentMgr->PvPTalents[GetActiveTalentGroup()];

    for (auto l_Talent : l_PvPTalents)
    {
        if (!l_Talent)
            continue;

        PvpTalentEntry const* l_TalentEntry = sPvpTalentStore.LookupEntry(l_Talent);
        if (!l_TalentEntry)
            continue;

        if (!HasSpell(l_TalentEntry->m_SpellID))
            continue;

        removeSpell(l_TalentEntry->m_SpellID, false, false);

        switch (l_TalentEntry->m_SpellID)
        {
        case 247483:
            RemoveAura(248643);
            RemoveAura(248648);
            RemoveAura(248646);
            break;
        case 215982:
            removeSpell(215769, false, false);
            break;
        }
    }
}

void Player::SummonLastSummonedPet()
{
    if (uint32 l_Entry = GetActiveSummonOnDeath())
    {
        SetActiveSummonOnDeath(0);
        uint32 l_SpellID = sSpellMgr->GetSummoningSpellForEntry(l_Entry);
        CastSpell(this, l_SpellID, true);
    }
}

MS::Artifact::Manager* Player::GetCurrentlyEquippedArtifact()
{
    Item* l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);

    if (!l_CurrentItem || !l_CurrentItem->GetTemplate()->ArtifactID)
        l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

    if (!l_CurrentItem)
        return nullptr;

    uint32 l_ArtifactID = l_CurrentItem->GetTemplate()->ArtifactID;
    return l_ArtifactID ? GetArtifactHolder(l_ArtifactID) : nullptr;
}

MS::Artifact::Manager const* Player::GetCurrentlyEquippedArtifact() const
{
    Item* l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);

    if (!l_CurrentItem || !l_CurrentItem->GetTemplate()->ArtifactID)
        l_CurrentItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

    if (!l_CurrentItem)
        return nullptr;

    uint32 l_ArtifactID = l_CurrentItem->GetTemplate()->ArtifactID;
    return l_ArtifactID ? GetArtifactHolder(l_ArtifactID) : nullptr;
}

uint8 Player::GetRankOfArtifactPowerId(uint32 p_ArtifactPowerId) const
{
    if (MS::Artifact::Manager const* l_Manager = GetCurrentlyEquippedArtifact())
    {
        if (l_Manager->HasPower(p_ArtifactPowerId))
        {
            auto power = l_Manager->GetPowerReference(p_ArtifactPowerId);
            if (!power->first)
                return 0;

            if (IsInBattleground() && !MS::Artifact::Manager::IsArtifactNonPurshaseableTraitPowerId(p_ArtifactPowerId))
                return power->second.PurchasedRank;
            else
                return power->second.CurrentRankWithBonus;
        }
    }

    return 0;
}

PvPStatsSpells Player::SelectPvpStatsSpell(int32 p_AlternateSpec /*=SPEC_NONE*/)
{
    return PvPStatsSpells::SPEC_STAT_TEMPLATE_ALL_SPECS;
}

bool Player::IsInBattleground() const
{
    return m_IsInBattleground;
}

void Player::SetInBattleground(bool p_Apply)
{
    m_IsInBattleground = p_Apply;
}

bool Player::IsInBattlegroundProcess() const
{
    return m_IsInBattlegroundProcess;
}

void Player::SetInBattlegroundProcess(bool p_Apply)
{
    m_IsInBattlegroundProcess = p_Apply;
}

bool Player::IsInBattlegroundLeaving() const
{
    return m_IsInBattlegroundLeaving;
}

void Player::SetInBattlegroundLeaving(bool p_Apply)
{
    m_IsInBattlegroundLeaving = p_Apply;
}

bool Player::IsInDuel() const
{
    return m_IsInDuel;
}

void Player::SetInDuel(bool p_Apply)
{
    m_IsInDuel = p_Apply;
}

void Player::GenerateFactionConversionQuery(SQLTransaction& p_Transaction, uint32 p_Guid, uint32 p_Team, char const* p_KnowTitlesStr /*= nullptr*/, bool p_ItemsOnly /*= false*/)
{
    if (!p_ItemsOnly)
    {
        // Achievement conversion
        for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Achievements.begin(); l_Iterator != sObjectMgr->FactionChange_Achievements.end(); ++l_Iterator)
        {
            uint32 l_AchievementAlliance = l_Iterator->first;
            uint32 l_AchievementHorde = l_Iterator->second;

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT);
            l_Statement->setUInt16(0, uint16(p_Team == BG_TEAM_ALLIANCE ? l_AchievementAlliance : l_AchievementHorde));
            l_Statement->setUInt32(1, p_Guid);
            p_Transaction->Append(l_Statement);

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACHIEVEMENT);
            l_Statement->setUInt16(0, uint16(p_Team == BG_TEAM_ALLIANCE ? l_AchievementAlliance : l_AchievementHorde));
            l_Statement->setUInt16(1, uint16(p_Team == BG_TEAM_ALLIANCE ? l_AchievementHorde : l_AchievementAlliance));
            l_Statement->setUInt32(2, p_Guid);
            p_Transaction->Append(l_Statement);
        }

        // Spell conversion
        for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Spells.begin(); l_Iterator != sObjectMgr->FactionChange_Spells.end(); ++l_Iterator)
        {
            uint32 l_SpellAlliance = l_Iterator->first;
            uint32 l_SpellHorde = l_Iterator->second;

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
            l_Statement->setUInt32(0, (p_Team == BG_TEAM_ALLIANCE ? l_SpellAlliance : l_SpellHorde));
            l_Statement->setUInt32(1, p_Guid);
            p_Transaction->Append(l_Statement);

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_SPELL_FACTION_CHANGE);
            l_Statement->setUInt32(0, (p_Team == BG_TEAM_ALLIANCE ? l_SpellAlliance : l_SpellHorde));
            l_Statement->setUInt32(1, (p_Team == BG_TEAM_ALLIANCE ? l_SpellHorde : l_SpellAlliance));
            l_Statement->setUInt32(2, p_Guid);
            p_Transaction->Append(l_Statement);
        }

        // Reputation conversion
        for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Reputation.begin(); l_Iterator != sObjectMgr->FactionChange_Reputation.end(); ++l_Iterator)
        {
            uint32 reputation_alliance = l_Iterator->first;
            uint32 reputation_horde = l_Iterator->second;

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REP_BY_FACTION);
            l_Statement->setUInt32(0, uint16(p_Team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
            l_Statement->setUInt32(1, p_Guid);
            p_Transaction->Append(l_Statement);

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_REP_FACTION_CHANGE);
            l_Statement->setUInt16(0, uint16(p_Team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
            l_Statement->setUInt16(1, uint16(p_Team == BG_TEAM_ALLIANCE ? reputation_horde : reputation_alliance));
            l_Statement->setUInt32(2, p_Guid);
            p_Transaction->Append(l_Statement);
        }

        // Title conversion
        if (p_Transaction)
        {
            const uint32 l_KnowTitleCount = KNOWN_TITLES_SIZE;
            uint32 l_KnownTitles[l_KnowTitleCount];
            Tokenizer l_Tokens(p_KnowTitlesStr, ' ', l_KnowTitleCount);

            if (l_Tokens.size() != l_KnowTitleCount)
                return;

            for (uint32 l_Index = 0; l_Index < l_KnowTitleCount; ++l_Index)
                l_KnownTitles[l_Index] = atol(l_Tokens[l_Index]);

            for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Titles.begin(); l_Iterator != sObjectMgr->FactionChange_Titles.end(); ++l_Iterator)
            {
                uint32 l_TitleAlliance = l_Iterator->first;
                uint32 l_TitleHorde = l_Iterator->second;

                CharTitlesEntry const* l_AllianceTitle = sCharTitlesStore.LookupEntry(l_TitleAlliance);
                CharTitlesEntry const* l_HordeTitle = sCharTitlesStore.LookupEntry(l_TitleHorde);

                // new team
                if (p_Team == BG_TEAM_ALLIANCE)
                {
                    uint32 l_BitIndex = l_HordeTitle->MaskID;
                    uint32 l_Index = l_BitIndex / 32;
                    uint32 l_OldFlag = 1 << (l_BitIndex % 32);
                    uint32 l_NewFlag = 1 << (l_AllianceTitle->MaskID % 32);

                    if (l_KnownTitles[l_Index] & l_OldFlag)
                    {
                        l_KnownTitles[l_Index] &= ~l_OldFlag;
                        // use index of the new title
                        l_KnownTitles[l_AllianceTitle->MaskID / 32] |= l_NewFlag;
                    }
                }
                else
                {
                    uint32 l_BitIndex = l_AllianceTitle->MaskID;
                    uint32 l_Index = l_BitIndex / 32;
                    uint32 l_OldFlag = 1 << (l_BitIndex % 32);
                    uint32 l_NewFlag = 1 << (l_HordeTitle->MaskID % 32);

                    if (l_KnownTitles[l_Index] & l_OldFlag)
                    {
                        l_KnownTitles[l_Index] &= ~l_OldFlag;
                        // use index of the new title
                        l_KnownTitles[l_HordeTitle->MaskID / 32] |= l_NewFlag;
                    }
                }

                std::ostringstream l_OstreamString;
                for (uint32 l_Index = 0; l_Index < l_KnowTitleCount; ++l_Index)
                    l_OstreamString << l_KnownTitles[l_Index] << ' ';

                PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TITLES_FACTION_CHANGE);
                l_Statement->setString(0, l_OstreamString.str().c_str());
                l_Statement->setUInt32(1, p_Guid);
                p_Transaction->Append(l_Statement);

                // unset any currently chosen title
                l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_RES_CHAR_TITLES_FACTION_CHANGE);
                l_Statement->setUInt32(0, p_Guid);
                p_Transaction->Append(l_Statement);
            }
        }
    }

    // Item conversion
    for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Items.begin(); l_Iterator != sObjectMgr->FactionChange_Items.end(); ++l_Iterator)
    {
        uint32 l_ItemAlliance = l_Iterator->first;
        uint32 l_ItemHorde = l_Iterator->second;

        PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE);
        l_Statement->setUInt32(0, (p_Team == BG_TEAM_ALLIANCE ? l_ItemAlliance : l_ItemHorde));
        l_Statement->setUInt32(1, (p_Team == BG_TEAM_ALLIANCE ? l_ItemHorde : l_ItemAlliance));
        l_Statement->setUInt32(2, p_Guid);
        p_Transaction->Append(l_Statement);
    }
}

void Player::AddPersonalInstanceLockout(uint32 p_MapId, uint32 p_Difficulty, uint32 p_EncounterMask)
{
    auto l_Key = std::make_pair(p_MapId, p_Difficulty);
    auto l_Itr = m_PersonInstanceLockout.find(l_Key);

    if (l_Itr == m_PersonInstanceLockout.end())
        m_PersonInstanceLockout[l_Key] = p_EncounterMask;
    else
        l_Itr->second |= p_EncounterMask;
}

void Player::_LoadPersonalInstanceLockouts(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();
        AddPersonalInstanceLockout(l_Fields[0].GetUInt32(), l_Fields[1].GetUInt32(), l_Fields[2].GetUInt32());
    }
    while (p_Result->NextRow());
}

void Player::_SavePersonalInstanceLockouts(SQLTransaction& p_Transaction)
{
    PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PERSONAL_INSTANCE_LOCKOUTS);
    l_Statement->setUInt32(0, GetGUIDLow());
    p_Transaction->Append(l_Statement);

    for (auto l_Itr : m_PersonInstanceLockout)
    {
        l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_INS_PERSONAL_INSTANCE_LOCKOUT);
        l_Statement->setUInt32(0, GetGUIDLow());
        l_Statement->setUInt32(1, l_Itr.first.first);
        l_Statement->setUInt32(2, l_Itr.first.second);
        l_Statement->setUInt32(3, l_Itr.second);
        p_Transaction->Append(l_Statement);
    }
}

void Player::SendSysMessage(char const* p_Message)
{
    ChatHandler(this).SendSysMessage(p_Message);
}

void Player::AddCosmetic(eCosmetics p_Cosmetic, uint32 p_Id)
{
    PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_INS_COSMETIC);
    l_Statement->setUInt32(0, GetSession()->GetAccountId());
    l_Statement->setUInt8(1, p_Cosmetic);
    l_Statement->setUInt32(2, p_Id);
    LoginDatabase.Execute(l_Statement);

    /// Flask of appearances item
    if (!GetItemByEntry(ITEM_COSMETIC))
        AddItem(ITEM_COSMETIC, 1);

    m_Cosmetics[p_Cosmetic].insert(p_Id);
}

void Player::_LoadCosmetics(PreparedQueryResult&& p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Field = p_Result->Fetch();
        eCosmetics l_Type = static_cast<eCosmetics>(l_Field[0].GetUInt8());
        if (l_Type > eCosmetics::MaxCosmetic)
        {
            sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown cosmetic type %u `account_cosmetic`, skipping.", GetGUIDLow(), l_Type);
            continue;
        }

        uint32 l_Id = l_Field[1].GetUInt32();

        CosmeticEntry const* l_CosmeticEntry = sObjectMgr->GetCosmeticByEntry(l_Type, l_Id);
        if (l_CosmeticEntry && l_CosmeticEntry->Expansion <= Expansion::EXPANSION_LEGION)
            m_Cosmetics[l_Type].insert(l_Id);

    }
    while (p_Result->NextRow());
}

bool Player::HasCosmetic(eCosmetics p_Cosmetic, uint32 p_Id) const
{
    return m_Cosmetics[p_Cosmetic].find(p_Id) != m_Cosmetics[p_Cosmetic].end();
}

std::vector<uint32> Player::GetCosmetics(eCosmetics p_Cosmetic) const
{
    std::vector<uint32> l_Cosmetics;
    for (uint32 l_Cosmetic : m_Cosmetics[p_Cosmetic])
        l_Cosmetics.push_back(l_Cosmetic);

    return l_Cosmetics;
}

void Player::UpdateActiveCosmetic(eCosmetics p_Cosmetic, uint32 p_Id)
{
    switch (m_ActiveCosmetic.first)
    {
        case eCosmetics::CosmeticAura:
            RemoveAura(m_ActiveCosmetic.second);
            break;
        case eCosmetics::CosmeticMorph:
            if (m_CosmeticEnabled)
                DeMorph();
            break;
        case eCosmetics::CosmeticMount:
        default:
            break;
    }

    m_ActiveCosmetic.first = p_Cosmetic;
    m_ActiveCosmetic.second = p_Id;

    if (p_Id == 0 || !m_CosmeticEnabled)
        return;

    switch (p_Cosmetic)
    {
        case eCosmetics::CosmeticAura:
        {
            Aura* l_Aura = AddAura(p_Id, this);
            if (!l_Aura)
                break;

            l_Aura->SetDuration(-1);
            l_Aura->SetMaxDuration(-1);
            break;
        }
        case eCosmetics::CosmeticMorph:
        {
            SetDisplayId(p_Id);
            break;
        }
        case eCosmetics::CosmeticMount:
        default:
            break;
    }
}

void Player::EnableCosmetic(bool p_Apply /*=true*/)
{
    if (HasAuraType(AuraType::SPELL_AURA_MOD_SHAPESHIFT))
    {
        m_CosmeticEnabled = false;
        return;
    }

    m_CosmeticEnabled = p_Apply;
    UpdateActiveCosmetic(m_ActiveCosmetic.first, m_ActiveCosmetic.second);
}

void Player::SetArenaMatchMakerRating(uint8 slot, uint32 value)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    if (value > 3500)
    {
        ACE_Stack_Trace trace;
        sLog->outError(LOG_FILTER_GENERAL, "Suspiciously high match maker rating. Rating: %u, Slot: %u, Player: %u, Trace log: %s", value, slot, GUID_LOPART(GetGUID()), trace.c_str());
    }

    m_ArenaMatchMakerRating[slot] = value;
}

void Player::IncrementWeekGames(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_WeekGames[slot];
}

void Player::IncrementWeekWins(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_WeekWins[slot];
}

void Player::IncrementDayWins(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_DayWins[slot];
}

void Player::IncrementDayGames(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_DayGames[slot];
}

void Player::IncrementSeasonGames(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_SeasonGames[slot];
}

void Player::IncrementSeasonWins(uint8 slot)
{
    if (slot >= (uint8)BattlegroundBracketType::Max)
        return;

    ++m_SeasonWins[slot];

    sScriptMgr->OnPlayerBracketWin(this, static_cast<BattlegroundBracketType>(slot));
}

static const float k_LegendaryBaseChance = 0.0095f;

bool Player::CompleteLegendaryActivity(LegendaryActivity p_Activity, uint32 p_EncounterID /*= 0*/, bool p_Relinquished /*= false*/, InventoryType p_InventoryType /*= InventoryType::INVTYPE_NON_EQUIP*/)
{
    if (getLevel() < 100)
        return false;

    m_LegendaryPoints += g_LegendaryActivityPoints[(uint8)p_Activity];

    auto legendaryDropChance = 0.f;
    switch (p_Activity)
    {
        case LegendaryActivity::NormalDungeon:
        case LegendaryActivity::RelinquishedToken:
            legendaryDropChance = 0.15f;
            break;
        case LegendaryActivity::HeroicDungeon:
            legendaryDropChance = 0.3f;
            break;
        case LegendaryActivity::MythicDungeon:
            legendaryDropChance = 0.5f;
            break;
        case LegendaryActivity::MythicPlusChest:
        case LegendaryActivity::LfrRaidBoss:
        case LegendaryActivity::LootBox:
            legendaryDropChance = 0.6f;
            break;
        case LegendaryActivity::MythicPlusWeeklyChest:
            legendaryDropChance = 5.0f;
            break;
        case LegendaryActivity::NormalRaidBoss:
            legendaryDropChance = 0.8f;
            break;
        case LegendaryActivity::Emissary:
            legendaryDropChance = 0.4f;
            break;
        case LegendaryActivity::HeroicRaidBoss:
            legendaryDropChance = 1.f;
            break;
        case LegendaryActivity::MythicRaidBoss:
            legendaryDropChance = 1.2f;
            break;
        default:
            break;
    }

    auto calcChance = [&]() -> float
    {
        auto result = 0.5f;
        auto countDecrement = 0.f;

        if (!m_LegendaryCount) // increase chance if haven't any legendary
            result += 5.f;

        if (m_LegendaryCount <= 3)
            countDecrement = m_LegendaryCount / 10;
        else if (m_LegendaryCount > 3)
            countDecrement = 0.3f;

        // Add legendary points as bad luck protection
        result += m_LegendaryPoints * (k_LegendaryBaseChance);

        if (countDecrement) // decr by legendary count
            result -= result * countDecrement;

        return result;
    };

    legendaryDropChance += calcChance();

    if (sWorld->getBoolConfig(CONFIG_ENABLE_LEGION_LEGENDARIES) && ((roll_chance_f(legendaryDropChance) && (GetCharacterWorldStateValue(CharacterWorldStates::LastLegendaryItemEarnedTimestamp) + DAY) < time(nullptr)) || p_Activity == LegendaryActivity::RecruitAFriend))
    {
        /// OMFG, you've got a legendary!
        ItemTemplate const* l_LegendaryItem = sObjectMgr->GetItemLegendary(GetLootSpecId() ? GetLootSpecId() : GetActiveSpecializationID(), this, p_Relinquished, p_InventoryType);
        if (!l_LegendaryItem)
            return false;

        /// Last updated - 26365
        /// Newly added legendaries now have a base Ilvl of 970
        auto l_Item = AddItem(l_LegendaryItem->ItemId, 1, {}, false, p_EncounterID, false, true);
        SendDisplayToast(l_LegendaryItem->ItemId, 1, 0, DisplayToastMethod::DISPLAY_TOAST_METHOD_LEGENDARY_LOOTED, ToastTypes::TOAST_TYPE_NEW_ITEM, false, false, l_Item ? l_Item->GetAllItemBonuses() : std::vector<uint32>());

#ifndef CROSS
        if (Guild* l_Guild = GetGuild())
        {
            if (l_Item)
                l_Guild->GetNewsLog().AddNewEvent(GUILD_NEWS_ITEM_LOOTED, time(nullptr), GetGUID(), 0, l_Item->GetGUIDLow(), l_Item);
        }
#endif
        sLog->outAshran("Player %u looted %u legendary item map %u x: %f  y: %f z: %f points: %u count: %u", GetGUIDLow(), l_LegendaryItem->ItemId, GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), m_LegendaryPoints, m_LegendaryCount);

        if (p_Activity != LegendaryActivity::RecruitAFriend)
        {
            sRecruitAFriendMgr->AddEvent(eRecruitAFriendMgrEvents::EventLootLegendary, GetRealGUID());
            m_LegendaryPoints = 0;
            SetCharacterWorldState(CharacterWorldStates::LastLegendaryItemEarnedTimestamp, time(nullptr));
        }

        m_LegendaryCount++;

        SaveToDB();

        return true;
    }

    return false;
}

void Player::_LoadLegendaries(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    Field* l_Fields = p_Result->Fetch();

    m_LegendaryPoints = l_Fields[0].GetUInt32();
    m_LegendaryCount  = l_Fields[1].GetUInt32();

    if (m_LegendaryCount == 0)
        m_LegendaryCount = GetLegendaryCounts();
}

void Player::_SaveLegendaries(SQLTransaction& p_Transaction)
{
    PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_REP_LEGENDARIES);
    l_Statement->setUInt32(0, GetGUIDLow());
    l_Statement->setUInt32(1, m_LegendaryPoints);
    l_Statement->setUInt32(2, m_LegendaryCount);
    p_Transaction->Append(l_Statement);
}

void Player::_SaveNomiRecipes(SQLTransaction& p_Transaction)
{
    for (uint32 l_ItemID : m_SpellHelper.GetUint64Set()[eSpellHelpers::NomiRecipes])
    {
        PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_REP_NOMI_RECIPES);
        l_Statement->setUInt32(0, GetGUIDLow());
        l_Statement->setUInt32(1, l_ItemID);
        p_Transaction->Append(l_Statement);
    }
}

std::map<uint64, uint32> const& Player::GetSpellFromItems() const
{
    return m_SpellsFromItem;
}

bool Player::CanLootItem(ItemTemplate const* p_Proto) const
{
    if (!p_Proto)
        return false;

    /// Mythic Keystone
    if (p_Proto->ItemId == 138019)
    {
        /// Mythic Keystone can looting one for week
        if (HasItemCount(138019))
            return false;

        /// Player will get his next key from the weekly class hall chest
        if (sChallengeMgr->HasRecordThisWeek(GetGUID()))
            return false;
    }

    if (p_Proto->AllowableClass)
    {
        if (!(p_Proto->AllowableClass & getClassMask()))
            return false;
    }

    if (p_Proto->AllowableRace)
    {
        if (!(p_Proto->AllowableRace & getRaceMask()))
            return false;
    }

    return true;
}

std::pair<uint32, uint32> Player::GetObliterumAshesAmount(Item* p_Item)
{
    ItemTemplate const* l_ItemTemplate = p_Item->GetTemplate();
    if (!l_ItemTemplate)
        return {0, 0};

    constexpr uint32 l_RegularGearDescriptionID = 13312;
    constexpr uint32 l_EliteGearDescriptionID = 13314;

    if (l_ItemTemplate->ItemNameDescriptionID == l_RegularGearDescriptionID)
    {
        /// "Combattant" items give 1 Echoes of Battle, as well as all Relics
        if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_RARE || l_ItemTemplate->IsArtifactRelic())
            return { 1, 1 };
        /// "Gladiator" items give 15 Echoes of Battle
        else if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_EPIC)
            return { 15, 15 };
        else
            return { 0, 0 };
    }
    /// 15 Echoes of Domination
    else if (l_ItemTemplate->ItemNameDescriptionID == l_EliteGearDescriptionID)
        return { 15, 15 };

    if (p_Item->IsStuffItem())
    {
        uint32 l_Ilevel = p_Item->GetItemLevel(this);
        if (l_ItemTemplate->Class == ITEM_CLASS_GEM)
        {
            return { 1, 2 };
        }
        else
        {
            if (l_Ilevel >= 715 && l_Ilevel < 805)
                return{ 2,3 };
            else if (l_Ilevel >= 805 && l_Ilevel < 850)
            {
                switch (l_ItemTemplate->InventoryType)
                {
                    case InventoryType::INVTYPE_TRINKET:
                        return {115, 170};
                    case InventoryType::INVTYPE_FINGER:
                        return {49, 71};
                    case InventoryType::INVTYPE_NECK:
                        return {144, 208};
                    default:
                    {
                        return {18, 26};
                    }
                }
            }
            else if (l_Ilevel >= 850)
                return {162, 234};
        }
        return {0, 0};
    }
    else if (l_ItemTemplate->Class == ItemClass::ITEM_CLASS_CONSUMABLE)
    {
        switch (l_ItemTemplate->SubClass)
        {
        case ItemSubclassConsumable::ITEM_SUBCLASS_ELIXIR:
        case ItemSubclassConsumable::ITEM_SUBCLASS_POTION:
            return {1, 2};
        case ItemSubclassConsumable::ITEM_SUBCLASS_FLASK:
            return {5, 10};
        default:
            return {0, 0};
        }
    }
    else if (p_Item->GetEntry() == 131743)
    {
        return { 1, 2 };
    }

    return {0, 0};
}

static const std::map<uint32, uint32> g_PricePerPiece =
{{
    { 820,  10 },
    { 825,  20 },
    { 830,  25 },
    { 835,  30 },
    { 840,  35 },
    { 845,  40 },
    { 850,  45 },
    { 855,  50 },
    { 860,  55 },
    { 865,  60 },
    { 870,  70 },
    { 875,  80 },
    { 880,  85 },
    { 885,  90 },
    { 890,  95 },
    { 895, 100 },
    { 900, 105 }
}};

uint32 Player::ComputeSellPrice() const
{
    /// Base price based on the character level
    uint32 l_Price = getLevel() * 2;

    /// Then based on the avg ilvl in bag
    uint32 l_CurrentIlvlInBag = GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel);
    uint32 l_BasePricePerIlvl = 10;

    for (auto l_Itr : g_PricePerPiece)
    {
        if (l_CurrentIlvlInBag > l_Itr.first)
        {
            l_BasePricePerIlvl = l_Itr.second;
            continue;
        }

        l_BasePricePerIlvl = l_CurrentIlvlInBag * l_Itr.second / l_Itr.first;
        break;
    }

    /// We assume a char always have at least a item for each equipment slot (otherwise, what's the point to sell it anyway?)
    l_Price += l_BasePricePerIlvl * 15;

    /// Increase the price for each legendary item the character own
    l_Price += GetLegendaryCounts() * 150;

    return l_Price;
}

void Player::SendTempSummonUITimer(Unit* p_TempSummon, uint32 p_CustomDuration)
{
    time_t l_Time = getMSTime();
    std::map<uint64, uint64>& l_Slots = m_SpellHelper.GetUint64Map()[eSpellHelpers::TempSummonUITimer];

    int8 l_Slot = -1;
    int l_SubTimer = 0;
    for (uint8 l_I = 0; l_I < 5; l_I++)
    {
        if (l_Slots.find(l_I) == l_Slots.end() && l_Slot == -1)
        {
            l_Slot = static_cast<int8>(l_I);
            break;
        }
        else
        {
            l_SubTimer = l_Slots[l_I] - l_Time;
            if (l_SubTimer < 0)
            {
                l_Slots.erase(l_I);
                l_Slot = static_cast<int8>(l_I);
                break;
            }
        }
    }

    if (l_Slot == -1)
        return;

    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(sSpellMgr->GetSummoningSpellForEntry(p_TempSummon->GetEntry()));
    if (!l_SpellInfo)
        return;

    uint32 l_MSDuration = p_CustomDuration ? p_CustomDuration : l_SpellInfo->GetMaxDuration();

    ///< Getting duration from created spell for some NPCs
    switch (p_TempSummon->GetEntry())
    {
        case 100868: ///< Invoke Chi-Ji, the Red Crane
        case 43499: ///< Consecration
            if (p_TempSummon->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL) != 0)
                if (SpellInfo const* l_DurationSpellInfo = sSpellMgr->GetSpellInfo(p_TempSummon->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL)))
                    l_MSDuration = l_DurationSpellInfo->GetMaxDuration();
            break;
    }

    l_Slots[l_Slot] = l_Time + l_MSDuration;

    WorldPacket data(SMSG_TEMPSUMMON_UI_TIMER, 4 + 16 + 2 + 4 + 4);
    data << uint8(l_Slot);
    data.appendPackGUID(p_TempSummon->GetGUID());
    data << uint32(l_MSDuration);
    data << uint32(p_TempSummon->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL));
    data << float(1.0f); ///< TimeMod
    data.WriteBit(1);    ///< CanDismiss
    data.FlushBits();
    SendDirectMessage(&data);
}

void Player::GetSortedGroupMembers(std::list<Player*>& p_PlayerList, std::function<bool(Player*)> p_Check, uint32 p_Count, std::list<std::function<bool(Player*)>> p_Orders) const
{
    GroupPtr const l_Group = GetGroup();
    if (!l_Group)
        return;

    std::list<Player*> l_GroupPlayers;
    l_Group->GetMemberSlots().foreach([&](Group::MemberSlotPtr l_GroupMember) -> void
    {
        Player* l_Player = sObjectAccessor->GetPlayer(*this, l_GroupMember->guid);
        if (!l_Player)
            return;

        if (p_Check(l_Player))
            l_GroupPlayers.push_back(l_Player);
    });

    std::list<std::list<Player*>> l_PlayerPools;
    for (auto l_Order : p_Orders)
    {
        std::list<Player*> l_Pool;
        for (auto l_Itr = l_GroupPlayers.begin(); l_Itr != l_GroupPlayers.end();)
        {
            if (l_Order(*l_Itr))
            {
                l_Pool.push_back(*l_Itr);
                l_Itr = l_GroupPlayers.erase(l_Itr);
            }
            else
                ++l_Itr;
        }
        l_PlayerPools.push_back(l_Pool);
    }

    std::list<Player*> l_LastPool;
    for (Player* l_Player : l_GroupPlayers)
        l_LastPool.push_back(l_Player);

    l_PlayerPools.push_back(l_LastPool);

    uint32 l_Count = 0;
    for (auto l_Pool : l_PlayerPools)
    {
        std::list<Player*> l_Randomlist;
        uint32 l_Pool_size = l_Pool.size();

        while (l_Pool_size > 0)
        {
            auto itr = l_Pool.begin();
            std::advance(itr, urand(0, l_Pool_size - 1));
            l_Randomlist.push_back(*itr);
            l_Pool.erase(itr);
            --l_Pool_size;
        }

        for (Player* l_Player : l_Randomlist)
        {
            p_PlayerList.push_back(l_Player);
            ++l_Count;
            if (l_Count >= p_Count)
                return;
        }
    }

    return;
}

void Player::UpdateCooldowns(float p_OldModTimeRate, float p_NewModTimeRate, bool p_OnlyHasteAffectedSpells /*= false*/)
{
    /// Usefull when called by Player::UpdateRating in case of Haste changes
    if (G3D::fuzzyEq(p_OldModTimeRate, p_NewModTimeRate))
        return;

    std::set<uint32> l_AffectedSpells;
    AuraEffectList const& l_ListAuraCooldownByHaste = GetAuraEffectsByType(SPELL_AURA_MOD_COOLDOWN_BY_HASTE);

    for (auto const& l_SpellCooldown : GetSpellCooldowns())
    {
        if (!p_OnlyHasteAffectedSpells)
            l_AffectedSpells.insert(l_SpellCooldown.first);
        else if (!l_ListAuraCooldownByHaste.empty())
        {
            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellCooldown.first);
            for (AuraEffect* l_AuraEffect : l_ListAuraCooldownByHaste)
            {
                if (l_AuraEffect->IsAffectingSpell(l_SpellInfo))
                    l_AffectedSpells.insert(l_SpellCooldown.first);
            }
        }
    }

    uint32 l_Cooldown = 0;

    float l_Mod = p_NewModTimeRate / p_OldModTimeRate;

    for (uint32 l_AffectedSpell : l_AffectedSpells)
    {
        l_Cooldown = GetSpellCooldownDelay(l_AffectedSpell);

        // Don't send CD packets to the client, it will do all visuals itself.
        RemoveSpellCooldown(l_AffectedSpell, false);

        AddSpellCooldown(l_AffectedSpell, 0, static_cast<float>(l_Cooldown) * l_Mod);
        SendModifyCooldownRecoveryRate(l_AffectedSpell, l_Mod, 1.0f);
    }

    Clock::time_point l_Now = Clock::now();

    for (auto& l_CategoryCharge : m_CategoryCharges)
    {
        std::deque<ChargeEntry>& l_ChargeRefreshTimes = l_CategoryCharge.second;

        SpellCategoryEntry const* l_CategoryEntry = sSpellCategoryStore.LookupEntry(l_CategoryCharge.first);
        if (!l_CategoryEntry)
            continue;

        if (p_OnlyHasteAffectedSpells && !HasAuraTypeWithMiscvalue(AuraType::SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE_REGEN, l_CategoryEntry->Id))
            continue;

        Clock::time_point l_LastChargeEnd;
        uint32 l_Index = 0;
        for (ChargeEntry& l_Charge : l_ChargeRefreshTimes)
        {
            /// Don't update recovered charges that aren't yet removed from container
            if (l_Charge.RechargeEnd.time_since_epoch() <= l_Now.time_since_epoch())
                continue;

            std::chrono::milliseconds l_LeftChargeDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_Charge.RechargeEnd - (l_Index ? l_Charge.RechargeStart : l_Now));
            if (l_Index)
            {
                l_Charge.RechargeStart = l_LastChargeEnd;
                l_Charge.RechargeEnd = l_Charge.RechargeStart;
            }
            else
                l_Charge.RechargeEnd -= l_LeftChargeDuration;

            uint32 l_DurationAsInteger = l_LeftChargeDuration.count();
            l_DurationAsInteger = static_cast<float>(l_DurationAsInteger) * l_Mod;
            l_LeftChargeDuration = std::chrono::milliseconds(l_DurationAsInteger);

            l_Charge.RechargeEnd += l_LeftChargeDuration;
            l_LastChargeEnd = l_Charge.RechargeEnd;

            l_Index++;
        }

        if (l_Mod > 1.0f)
        {
            SendModifyChargeRecoveryRate(l_CategoryEntry->Id, 1.0f, 1.0f);
            SendModifyChargeRecoveryRate(l_CategoryEntry->Id, l_Mod, 1.0f);
        }
        else
        {
            SendModifyChargeRecoveryRate(l_CategoryEntry->Id, l_Mod, 1.0f);
            SendModifyChargeRecoveryRate(l_CategoryEntry->Id, 1.0f, 1.0f);
        }

        SendModifyChargeRecoveryRate(l_CategoryEntry->Id, l_Mod, 1.0f);
    }
}

void Player::_LoadNomiRecipes(PreparedQueryResult p_Result)
{
    if (p_Result)
    {
        ACE_UINT64 l_CurTime = 0;
        ACE_OS::gettimeofday().msec(l_CurTime);

        do
        {
            Field* l_Fields = p_Result->Fetch();
            uint32 l_RecipeItemID = l_Fields[0].GetUInt32();

            m_SpellHelper.GetUint64Set()[eSpellHelpers::NomiRecipes].insert(l_RecipeItemID);
        } while (p_Result->NextRow());
    }
}

void Player::_LoadPlayerChoiceResponseRewarded(PreparedQueryResult p_Result)
{
    if (p_Result)
    {
        do
        {
            Field* l_Fields     = p_Result->Fetch();
            uint32 l_ChoiceId   = l_Fields[0].GetUInt32();
            uint32 l_ResponseId = l_Fields[1].GetUInt32();

            m_PlayerChoiceResponseRewarded.insert(MAKE_PAIR64(l_ChoiceId, l_ResponseId));
        } while (p_Result->NextRow());
    }
}

void Player::_LoadChestTimedLockout(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint32 l_ChestDBGuid       = l_Fields[0].GetUInt32();
        uint32 l_ExpireLockoutTime = l_Fields[1].GetUInt32();

        m_ChestTimedLockout[l_ChestDBGuid] = l_ExpireLockoutTime;

    } while (p_Result->NextRow());
}

void Player::_LoadObjectLockout(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint32 l_DBGuid     = l_Fields[0].GetUInt32();
        uint32 l_QuestId    = l_Fields[1].GetUInt32();
        bool l_Invisible    = l_Fields[2].GetBool();

        ObjectLockout l_ObjectLockout = { l_QuestId, l_Invisible };
        m_ObjectLockout[l_DBGuid] = l_ObjectLockout;

    } while (p_Result->NextRow());
}

void Player::AddObjectInLockoutList(uint32 p_DbGuid, uint32 p_QuestId, bool p_SetInvisible)
{
    /// Prevent adding to the list the 0 Guid, which means every GoB not spawned in DB would be invisible
    if (p_DbGuid == 0)
        return;

    if (!IsQuestRewarded(p_QuestId) || (IsQuestRewarded(p_QuestId) && MS::WorldQuest::Template::GetTemplate(p_QuestId)))
    {
        ObjectLockout l_ObjectLockout = { p_QuestId, p_SetInvisible };
        m_ObjectLockout[p_DbGuid] = l_ObjectLockout;

        if (p_SetInvisible)
            UpdateObjectVisibility();
    }
}

void Player::RemoveObjectsFromLockoutListByQuest(uint32 p_QuestId, bool p_IncludeDB)
{
    bool l_QueryExecuted = false;
    bool l_NeedUpdate = false;

    for (std::unordered_map<uint32, ObjectLockout>::iterator l_Itr = m_ObjectLockout.begin(); l_Itr != m_ObjectLockout.end();)
    {
        if (l_Itr->second.QuestId == p_QuestId)
        {
            if (p_IncludeDB && !l_QueryExecuted)
            {
                PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OBJECT_LOCKOUT);
                l_Stmt->setUInt64(0, GetRealGUIDLow());
                l_Stmt->setUInt32(1, l_Itr->second.QuestId);
                CharacterDatabase.Execute(l_Stmt);

                l_QueryExecuted = true;
            }

            if (l_Itr->second.Invisible)
                l_NeedUpdate = true;

            l_Itr = m_ObjectLockout.erase(l_Itr);
            continue;
        }
        else
            ++l_Itr;
    }

    if (l_NeedUpdate)
        UpdateObjectVisibility();
}

bool Player::IsObjectInvisibleForPlayer(WorldObject const* p_Object) const
{
    Creature const* l_Creature = p_Object->ToCreature();
    GameObject const* l_Gob = p_Object->ToGameObject();
    if ((!l_Creature && !l_Gob) || (l_Creature && l_Creature->isSummon())
        || (l_Gob && !l_Gob->isSpawnedByDefault()))
        return false;

    uint32 l_DbGuid = l_Creature ? l_Creature->GetDBTableGUIDLow() : l_Gob->GetDBTableGUIDLow();

    return m_ObjectLockout.find(l_DbGuid) != m_ObjectLockout.end() && m_ObjectLockout.at(l_DbGuid).Invisible;
}

bool Player::HasTimingForPhase(uint32 p_PhaseId)
{
    std::unordered_map<uint32, uint32>::iterator l_Phase = m_PhaseTimings.find(p_PhaseId);
    if (l_Phase == m_PhaseTimings.end())
        return false;
    else
    {
        if (l_Phase->second != 0)
            return true;
    }

    return false;
}

void Player::SetTimingForPhase(uint32 p_PhaseId, uint32 p_Time)
{
    std::unordered_map<uint32, uint32>::iterator l_Phase = m_PhaseTimings.find(p_PhaseId);
    if (l_Phase != m_PhaseTimings.end())
    {
        l_Phase->second = p_Time;
    }
    else
    {
        m_PhaseTimings[p_PhaseId] = p_Time;
    }
}

void Player::UpdatePhaseTimings(uint32 p_Time)
{
    if (p_Time && !m_PhaseTimings.empty())
    {
        bool l_NeedVisibilityUpdate = false;

        for (std::unordered_map<uint32, uint32>::iterator l_Itr = m_PhaseTimings.begin(); l_Itr != m_PhaseTimings.end();)
        {
            if (l_Itr->second <= p_Time)
            {
                l_Itr = m_PhaseTimings.erase(l_Itr);
                l_NeedVisibilityUpdate = true;
                continue;
            }
            else
            {
                l_Itr->second -= p_Time;
                ++l_Itr;
            }
        }

        if (l_NeedVisibilityUpdate)
            GetPhaseMgr().NotifyStoresReloaded();
    }
}

void Player::_LoadPvpRewardSeason(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint8  l_Bracket = l_Fields[0].GetUInt8();
        uint32 l_Rating  = l_Fields[1].GetUInt32();

        PvpSeasonReward const* l_Reward = sObjectMgr->GetPvpReward(l_Bracket, l_Rating);
        if (!l_Reward)
            continue;

        if (AchievementEntry const* l_Achievement = sAchievementStore.LookupEntry(l_Reward->AchievementId))
            m_achievementMgr->CompletedAchievement(l_Achievement, this);

        if (CharTitlesEntry const* l_Title = sCharTitlesStore.LookupEntry(l_Reward->TitleId))
            SetTitle(l_Title);

        if (l_Reward->ItemId)
            AddItem(l_Reward->ItemId, 1, {}, false, 0, false, true);

        AddDelayedEvent([this]() -> void
        {
            uint32 l_Guid = GetGUIDLow();

            MS::Utilities::CallBackPtr l_OnSaveCallBack = std::make_shared<MS::Utilities::Callback>([l_Guid](bool p_Success) -> void
            {
                if (!p_Success)
                    return;

                PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PVP_SEASON_REWARD_RANKING_REWARDED);
                l_Stmt->setUInt32(0, l_Guid);
                CharacterDatabase.Execute(l_Stmt);
            });

            SaveToDB(false, false, l_OnSaveCallBack);
        },2000);

    } while (p_Result->NextRow());
}

bool Player::CanSelectQuestPackageItem(QuestPackageItemEntry const* questPackageItem) const
{
    ItemTemplate const* rewardProto = sObjectMgr->GetItemTemplate(questPackageItem->ItemID);
    if (!rewardProto)
        return false;

    if ((rewardProto->Flags2 & static_cast<uint32>(ItemFlagsEX::ALLIANCE) && GetTeam() != Team::ALLIANCE) ||
        (rewardProto->Flags2 & static_cast<uint32>(ItemFlagsEX::HORDE) && GetTeam() != Team::HORDE))
        return false;

    switch (static_cast<PackageItemRewardType>(questPackageItem->FilterType))
    {
        case PackageItemRewardType::SpecializationReward:
            return rewardProto->IsUsableBySpecialization(GetActiveSpecializationID(), getLevel());
        case PackageItemRewardType::ClassReward:
            return !rewardProto->ItemSpecClassMask || (rewardProto->ItemSpecClassMask & getClassMask()) != 0;
        case PackageItemRewardType::NoRequire:
            return true;
        default:
            break;
    }

    return false;
}

void Player::RewardQuestPackage(uint32 p_QuestPackageID, uint32 p_OnlyItemID /*= 0*/)
{
    bool l_HasFilteredQuestPackageReward = false;
    if (std::vector<QuestPackageItemEntry const*> const* l_QuestPackageItems = GetQuestPackageItems(p_QuestPackageID))
    {
        for (QuestPackageItemEntry const* l_QuestPackageItem : *l_QuestPackageItems)
        {
            if (p_OnlyItemID && l_QuestPackageItem->ItemID != p_OnlyItemID)
                continue;

            if (CanSelectQuestPackageItem(l_QuestPackageItem))
            {
                l_HasFilteredQuestPackageReward = true;
                ItemPosCountVec l_Dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_QuestPackageItem->ItemID, l_QuestPackageItem->ItemCount) == EQUIP_ERR_OK)
                {
                    Item* l_Item = StoreNewItem(l_Dest, l_QuestPackageItem->ItemID, true, Item::GenerateItemRandomPropertyId(l_QuestPackageItem->ItemID));
                    SendNewItem(l_Item, l_QuestPackageItem->ItemCount, true, false);
                }
            }
        }
    }

    if (!l_HasFilteredQuestPackageReward)
    {
        if (std::vector<QuestPackageItemEntry const*> const* l_QuestPackageItems = GetQuestPackageItems(p_QuestPackageID))
        {
            for (QuestPackageItemEntry const* l_QuestPackageItem : *l_QuestPackageItems)
            {
                if (p_OnlyItemID && l_QuestPackageItem->ItemID != p_OnlyItemID)
                    continue;

                ItemPosCountVec l_Dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_QuestPackageItem->ItemID, l_QuestPackageItem->ItemCount) == EQUIP_ERR_OK)
                {
                    Item* l_Item = StoreNewItem(l_Dest, l_QuestPackageItem->ItemID, true, Item::GenerateItemRandomPropertyId(l_QuestPackageItem->ItemID));
                    SendNewItem(l_Item, l_QuestPackageItem->ItemCount, true, false);
                }
            }
        }
    }
}

bool Player::SendPlayerChoice(uint64 p_Sender, int32 p_ChoiceID)
{
    PlayerChoice const* l_PlayerChoice = sObjectMgr->GetPlayerChoice(p_ChoiceID);
    if (!l_PlayerChoice)
        return false;

    LocaleConstant l_Locale = GetSession()->GetSessionDbLocaleIndex();
    PlayerChoiceLocale const* l_PlayerChoiceLocale = l_Locale != DEFAULT_LOCALE ? sObjectMgr->GetPlayerChoiceLocale(p_ChoiceID) : nullptr;

    PlayerTalkClass->GetInteractionData().Reset();
    PlayerTalkClass->GetInteractionData().SourceGuid = p_Sender;
    PlayerTalkClass->GetInteractionData().PlayerChoiceId = uint32(p_ChoiceID);

    WorldPackets::Quest::DisplayPlayerChoice l_DisplayPlayerChoice;
    l_DisplayPlayerChoice.SenderGUID = p_Sender;
    l_DisplayPlayerChoice.ChoiceID = p_ChoiceID;
    l_DisplayPlayerChoice.Question = l_PlayerChoice->Question;
    l_DisplayPlayerChoice.UiTextureKitID = l_PlayerChoice->UiTextureKitID;
    if (l_PlayerChoiceLocale)
        ObjectMgr::GetLocaleString(l_PlayerChoiceLocale->Question, l_Locale, l_DisplayPlayerChoice.Question);

    std::vector<PlayerChoiceResponse const*> l_Responses;
    uint32 l_Count = 0;
    for (PlayerChoiceResponse const& l_Response : l_PlayerChoice->Responses)
    {
        if (m_PlayerChoiceResponseRewarded.find(MAKE_PAIR64(p_ChoiceID, l_Response.ResponseID)) != m_PlayerChoiceResponseRewarded.end())
            continue;

        if (!sConditionMgr->IsObjectMeetingNotGroupedConditions(CONDITION_SOURCE_TYPE_PLAYERCHOICE_RESPONSE, l_Response.ResponseID, this))
            continue;

        l_Responses.push_back(&l_Response);
        l_Count++;

        if (l_Count >= 3)
            break;
    }

    if (l_Count == 0)
        return false;

    l_DisplayPlayerChoice.Responses.resize(l_Responses.size());
    l_DisplayPlayerChoice.CloseChoiceFrame = false;

    for (std::size_t i = 0; i < l_Responses.size(); ++i)
    {
        PlayerChoiceResponse const& l_PlayerChoiceResponseTemplate = *l_Responses[i];
        WorldPackets::Quest::PlayerChoiceResponse& l_PlayerChoiceResponse = l_DisplayPlayerChoice.Responses[i];
        l_PlayerChoiceResponse.ResponseID = l_PlayerChoiceResponseTemplate.ResponseID;
        l_PlayerChoiceResponse.ChoiceArtFileID = l_PlayerChoiceResponseTemplate.ChoiceArtFileID;
        l_PlayerChoiceResponse.Answer = l_PlayerChoiceResponseTemplate.Answer;
        l_PlayerChoiceResponse.Header = l_PlayerChoiceResponseTemplate.Header;
        l_PlayerChoiceResponse.Description = l_PlayerChoiceResponseTemplate.Description;
        l_PlayerChoiceResponse.Confirmation = l_PlayerChoiceResponseTemplate.Confirmation;
        if (l_PlayerChoiceLocale)
        {
            auto l_Itr = l_PlayerChoiceLocale->Responses.find(l_PlayerChoiceResponseTemplate.ResponseID);
            if (l_Itr != l_PlayerChoiceLocale->Responses.end())
            {
                if (PlayerChoiceResponseLocale const* l_PlayerChoiceResponseLocale = &(l_Itr->second))
                {
                    ObjectMgr::GetLocaleString(l_PlayerChoiceResponseLocale->Answer, l_Locale, l_PlayerChoiceResponse.Answer);
                    ObjectMgr::GetLocaleString(l_PlayerChoiceResponseLocale->Header, l_Locale, l_PlayerChoiceResponse.Header);
                    ObjectMgr::GetLocaleString(l_PlayerChoiceResponseLocale->Description, l_Locale, l_PlayerChoiceResponse.Description);
                    ObjectMgr::GetLocaleString(l_PlayerChoiceResponseLocale->Confirmation, l_Locale, l_PlayerChoiceResponse.Confirmation);
                }
            }
        }

        if (l_PlayerChoiceResponseTemplate.Reward)
        {
            l_PlayerChoiceResponse.Reward.emplace();
            l_PlayerChoiceResponse.Reward->TitleID = l_PlayerChoiceResponseTemplate.Reward->TitleID;
            l_PlayerChoiceResponse.Reward->PackageID = l_PlayerChoiceResponseTemplate.Reward->PackageID;
            l_PlayerChoiceResponse.Reward->SkillLineID = l_PlayerChoiceResponseTemplate.Reward->SkillLineID;
            l_PlayerChoiceResponse.Reward->SkillPointCount = l_PlayerChoiceResponseTemplate.Reward->SkillPointCount;
            l_PlayerChoiceResponse.Reward->ArenaPointCount = l_PlayerChoiceResponseTemplate.Reward->ArenaPointCount;
            l_PlayerChoiceResponse.Reward->HonorPointCount = l_PlayerChoiceResponseTemplate.Reward->HonorPointCount;
            l_PlayerChoiceResponse.Reward->Money = l_PlayerChoiceResponseTemplate.Reward->Money;
            l_PlayerChoiceResponse.Reward->Xp = l_PlayerChoiceResponseTemplate.Reward->Xp;

            for (PlayerChoiceResponseRewardItem const& l_Item : l_PlayerChoiceResponseTemplate.Reward->Items)
            {
                l_PlayerChoiceResponse.Reward->Items.emplace_back();
                WorldPackets::Quest::PlayerChoiceResponseRewardEntry& l_RewardEntry = l_PlayerChoiceResponse.Reward->Items.back();
                l_RewardEntry.Item.ItemID = l_Item.Id;
                l_RewardEntry.Quantity = l_Item.Quantity;
                if (!l_Item.BonusListIDs.empty())
                {
                    l_RewardEntry.Item.ItemBonus.emplace();
                    l_RewardEntry.Item.ItemBonus->BonusListIDs = l_Item.BonusListIDs;
                }
            }

            for (PlayerChoiceResponseRewardEntry const& l_Currency : l_PlayerChoiceResponseTemplate.Reward->Currency)
            {
                l_PlayerChoiceResponse.Reward->Items.emplace_back();
                WorldPackets::Quest::PlayerChoiceResponseRewardEntry& l_RewardEntry = l_PlayerChoiceResponse.Reward->Items.back();
                l_RewardEntry.Item.ItemID = l_Currency.Id;
                l_RewardEntry.Quantity = l_Currency.Quantity;
            }

            for (PlayerChoiceResponseRewardEntry const& l_Faction : l_PlayerChoiceResponseTemplate.Reward->Faction)
            {
                l_PlayerChoiceResponse.Reward->Items.emplace_back();
                WorldPackets::Quest::PlayerChoiceResponseRewardEntry& l_RewardEntry = l_PlayerChoiceResponse.Reward->Items.back();
                l_RewardEntry.Item.ItemID = l_Faction.Id;
                l_RewardEntry.Quantity = l_Faction.Quantity;
            }
        }
    }

    SendDirectMessage(l_DisplayPlayerChoice.Write());

    return true;
}

void Player::SetPlayerChoiceResponseRewarded(int32 p_ChoiceID, int32 p_ResponseID)
{
    m_PlayerChoiceResponseRewarded.insert(MAKE_PAIR64(p_ChoiceID, p_ResponseID));
    PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYERCHOICE_RESPONSE_REWARDED);
    l_Statement->setUInt64(0, GetGUIDLow());
    l_Statement->setUInt32(1, p_ChoiceID);
    l_Statement->setUInt32(2, p_ResponseID);
    CharacterDatabase.AsyncQuery(l_Statement);
}

void Player::SetInventorySlotCount(uint8 slots)
{
    ASSERT(slots <= (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));
    SetByteValue(PLAYER_FIELD_NUM_BACKPACK_SLOTS, PLAYER_FIELD_NUM_BACKPACK_SLOTS_OFFSET_NUM_BACKPACK_SLOTS, slots);
}

bool Player::CanReceiveLiveChangelog() const
{
    return !GetSession()->HasReceivedChangelog();
}

void Player::SetChangelogReceived()
{
    GetSession()->SetChangelogReceived();
}

void Player::SendUpdateCelestialBody(uint32 p_CelestialBodyID)
{
    m_CelestialBodyID = p_CelestialBodyID;

    WorldPacket l_Data(Opcodes::SMSG_UPDATE_CELESTIAL_BODY, 1);

    l_Data << m_CelestialBodyID;

    GetSession()->SendPacket(&l_Data);
}

void Player::AddMapTask(eTaskType p_TaskType, std::function<void()> p_Task)
{
    if (p_TaskType == eTaskType::TaskSwitchToPhasedMap && HasTaskRegistered(eTaskType::TaskTeleport))
        return;

    m_RegisteredTaskCounters[p_TaskType]++;
    m_RegisteredTasks.add(TaskInfo(p_TaskType, p_Task));
}

bool Player::HasTaskRegistered(eTaskType p_TaskType)
{
    return m_RegisteredTaskCounters[p_TaskType] != 0;
}

void Player::UpdateTasks()
{
    if (m_TaskInProgress || m_RegisteredTasks.empty())
        return;

    m_TaskInProgress = true;

    TaskInfo l_TaskInfo;
    m_RegisteredTasks.next(l_TaskInfo);

    m_RegisteredTaskCounters[l_TaskInfo.Type]--;
    l_TaskInfo.Task();
}

void Player::SetPhaseMask(uint32 p_NewPhaseMask, bool p_Update)
{
    SetPhaseMaskWithSummons(p_NewPhaseMask, p_Update);
}

void Player::SetZonePhaseMask(uint32 p_NewPhaseMask, bool p_Update)
{
    m_ZonesPhaseMask[GetZoneId()] = p_NewPhaseMask;
    SetPhaseMask(p_NewPhaseMask, p_Update);
}

uint32 Player::GetZonePhaseMask(uint32 p_Zone) const
{
    if (p_Zone == 0)
        p_Zone = GetZoneId();

    auto l_Itr = m_ZonesPhaseMask.find(p_Zone);
    if (l_Itr == m_ZonesPhaseMask.end())
        return 0;

    return l_Itr->second;
}

uint32 Player::GetLastProcAttemptTime(uint32 p_SpellId) const
{
    auto l_Itr = m_LastProcTimes.find(p_SpellId);
    if (l_Itr != m_LastProcTimes.end())
        return l_Itr->second.LastProcAttemptTime;
    return 0;
}

uint32 Player::GetLastProcSuccessTime(uint32 p_SpellId) const
{
    auto l_Itr = m_LastProcTimes.find(p_SpellId);
    if (l_Itr != m_LastProcTimes.end())
        return l_Itr->second.LastProcSuccessTime;
    return 0;
}

void Player::SetLastProcAttemptTime(uint32 p_SpellId, uint32 p_LastProcAttemptTime)
{
    m_LastProcTimes[p_SpellId].LastProcAttemptTime = p_LastProcAttemptTime;
}

void Player::SetLastProcSuccessTime(uint32 p_SpellId, uint32 p_LastProcSuccessTime)
{
    m_LastProcTimes[p_SpellId].LastProcSuccessTime = p_LastProcSuccessTime;
}

void Player::UpdateAreaQuestTasks(uint32 newAreaId, uint32 oldAreaId)
{
    std::list<uint32> questAdd;

    if (std::set<Quest const*> const* qInfo = sObjectMgr->GetQuestTask(newAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            if (FindQuestSlot(quest->GetQuestId()) < MAX_QUEST_LOG_SIZE)
            {
                questAdd.push_back(quest->GetQuestId());
                continue;
            }

            if (QuestV2CliTaskEntry const* questTask = sQuestV2CliTaskStore.LookupEntry(quest->GetQuestId()))
            {
                if (DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this))
                    continue;

                if (questTask->PlayerConditionID && !EvalPlayerCondition(questTask->PlayerConditionID).first)
                    continue;

                if (!sConditionMgr->IsObjectMeetingNotGroupedConditions(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, quest->GetQuestId(), this))
                    continue;

                if (questTask->FiltMinSkillId && GetSkillValue(questTask->FiltMinSkillId) < questTask->FiltMinSkillValue)
                    continue;

                if (questTask->FiltMinLevel < (MAX_LEVEL + 1) && getLevel() < questTask->FiltMinLevel)
                    continue;

                if (questTask->FiltMaxLevel < (MAX_LEVEL + 1) && getLevel() > questTask->FiltMaxLevel)
                    continue;

                bool needQuest = false;
                bool canStart = true;
                for (uint8 slot = 0; slot < 3; ++slot)
                    if (questTask->FiltCompletedQuest[slot])
                        needQuest = true;

                if (needQuest)
                    for (uint8 slot = 0; slot < 3; ++slot)
                        if (questTask->FiltCompletedQuest[slot] && GetQuestStatus(questTask->FiltCompletedQuest[slot]) != QUEST_STATUS_REWARDED)
                            canStart = false;

                if (needQuest && !canStart)
                    continue;

                if (CanAddQuest(quest, true) && !IsQuestRewarded(quest->GetQuestId()))
                {
                    AddQuest(quest, NULL);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
            else
            {
                if (CanAddQuest(quest, true))
                {
                    AddQuest(quest, NULL);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
        }
    }

    if (std::set<Quest const*> const* qInfo = sObjectMgr->GetQuestTask(oldAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            bool questRemove = true;

            for (uint32 questId : questAdd)
                if (questId == quest->GetQuestId())
                    questRemove = false;

            if (!questRemove)
                continue;

            for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
            {
                uint32 logQuest = GetQuestSlotQuestId(slot);
                if (logQuest == quest->GetQuestId())
                {
                    SetQuestSlot(slot, 0);
                    TakeQuestSourceItem(logQuest, false);
                }
            }
        }
    }

    questAdd.clear();
}

uint32 Player::GetSpecializationRole() const
{
    if (auto plrSpec = sChrSpecializationsStore.LookupEntry(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID)))
        return plrSpec->Role;
    return ROLE_DEFAULT;
}

bool Player::isInTankSpec() const
{
    return GetSpecializationRole() == ROLE_TANK;
}